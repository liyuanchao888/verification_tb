//=======================================================================
// COPYRIGHT (C) 2020 SYNOPSYS INC.
// This software and the associated documentation are confidential and
// proprietary to Synopsys, Inc. Your use or disclosure of this software
// is subject to the terms and conditions of a written license agreement
// between you, or your company, and Synopsys, Inc. In the event of
// publications, the following notice is applicable:
//
// ALL RIGHTS RESERVED
//
// The entire notice above must be reproduced on all authorized copies.
//
//-----------------------------------------------------------------------

`ifndef GUARD_SVT_CHI_SYSTEM_VIRTUAL_SEQUENCE_COLLECTION_SV
`define GUARD_SVT_CHI_SYSTEM_VIRTUAL_SEQUENCE_COLLECTION_SV
       
`ifndef DESIGNWARE_INCDIR
  `include "svt_event_util.svi"
`endif


typedef class svt_chi_system_rn_coherent_transaction_base_virtual_sequence;
typedef class svt_chi_system_cacheline_initialization_virtual_sequence;
typedef class svt_chi_system_cacheline_invalidation_virtual_sequence;

`define _SVT_CHI_SYSTEM_SEQUENCE_GET_OVERRIDE(typ,str) \
`ifdef SVT_UVM_TECHNOLOGY \
  status = uvm_config_db#(typ)::get(null, get_full_name(), "``str", ``str ); \
`elsif SVT_OVM_TECHNOLOGY \
  status = m_sequencer.get_config_int({get_type_name(), ".``str"}, ``str); \
`endif 

`define _SVT_CHI_SYSTEM_SEQUENCE_GET_OVERRIDE_W_DISPLAY(typ,str) \
    `_SVT_CHI_SYSTEM_SEQUENCE_GET_OVERRIDE(typ,str) \
    if(status) \
      `svt_debug("pre_body",$sformatf("set by config override ``str = %0d",``str));

//============================================================================================================
// Sequence grouping definitions-- starts here
//============================================================================================================  
//-------------------------------------------------------------------------------------------------------------
// Base sequences
//-------------------------------------------------------------------------------------------------------------
/** 
 * @grouphdr sequences CHI_SYS_BASE CHI System level base virtual sequence
 * Base sequence for all CHI system virtual sequences
 */
//-------------------------------------------------------------------------------------------------------------
// Single node sequences  
//-------------------------------------------------------------------------------------------------------------
/**
 * @grouphdr sequences CHI_SINGLE_RN_BASE System level single RN initiating xact virtual base sequence
 * Base sequence for transaction specific single node virtual sequences
 */
  
/**
 * @grouphdr sequences CHI_SINGLE_RN_RD_TYPE System level single RN initiating RD type xact virtual sequences
 * Read type transaction specific single node virtual sequences
 */

`ifdef SVT_CHI_ISSUE_B_ENABLE
/**
 * @grouphdr sequences CHI_B_SINGLE_RN_RD_TYPE System level single RN initiating RD type xact virtual sequences
 * CHI-B Read type transaction specific single node virtual sequences
 */

/**
 * @grouphdr sequences CHI_B_SINGLE_RN_CMO_TYPE System level single RN initiating CMO type xact virtual sequences
 * CHI-B CMO type transaction specific single node virtual sequences
 */

/**
 * @grouphdr sequences CHI_SINGLE_RN_ATOMICSTORE_TYPE System level single RN initiating Atomic Store type xact virtual sequences
 * CHI-B AtomicStore type transaction specific single node virtual sequence
 */

/**
 * @grouphdr sequences CHI_SINGLE_RN_ATOMICLOAD_TYPE System level single RN initiating Atomic Load type xact virtual sequences
 * CHI-B AtomicLoad type transaction specific single node virtual sequence
 */

/**
 * @grouphdr sequences CHI_SINGLE_RN_ATOMICSWAP_TYPE System level single RN initiating Atomic Swap type xact virtual sequences
 * CHI-B AtomicSwap type transaction specific single node virtual sequence
 */

/**
 * @grouphdr sequences CHI_SINGLE_RN_ATOMICCOMPARE_TYPE System level single RN initiating Atomic Compare type xact virtual sequences
 * CHI-B AtomicCompare type transaction specific single node virtual sequence
 */
`endif

/**
 * @grouphdr sequences CHI_SINGLE_RN_WR_TYPE System level single RN initiating WR type xact virtual sequences
 * Write type transaction specific single node virtual sequences
 */
  
/**
 * @grouphdr sequences CHI_SINGLE_RN_CPBK_TYPE System level single RN initiating CPBK type xact virtual sequences
 * CopyBack type transaction specific single node virtual sequences
 */
  
/**
 * @grouphdr sequences CHI_SINGLE_RN_CMO_TYPE System level single RN initiating CMO type xact virtual sequences
 * CMO type transaction specific single node virtual sequences
 */
  
/**
 * @grouphdr sequences CHI_SINGLE_RN_DVM_TYPE System level single RN initiating DVM type xact virtual sequences
 * DVM type transaction specific single node virtual sequences
 */
  
/**
 * @grouphdr sequences CHI_SINGLE_RN_BARRIER_TYPE System level single RN initiating BARRIER type xact virtual sequences
 * BARRIER type transaction specific single node virtual sequences
 */
  
/**
 * @grouphdr sequences CHI_SINGLE_RN_ORDERED_NONCOHERENT_TYPE System level single RN initiating Ordered non-coherent xact virtual sequences
 * Ordered Non-Coherent transaction specific single node virtual sequences
 */

`ifdef SVT_CHI_ISSUE_E_ENABLE
/**
 * @grouphdr sequences CHI_E_SINGLE_RN_STASH_TYPE System level single RN initiating stash type xact virtual sequences
 * CHI_E Stash type transaction specific single node virtual sequences
 */
`endif
 
/**
 * @grouphdr sequences CHI_SYS_SINGLE_RN System level single RN initiating node virtual sequences
 * transaction specific single node virtual sequences
 * @groupref CHI_SINGLE_RN_BASE
 * @groupref CHI_SINGLE_RN_RD_TYPE
`ifdef SVT_CHI_ISSUE_B_ENABLE
 * @groupref CHI_B_SINGLE_RN_RD_TYPE
 * @groupref CHI_B_SINGLE_RN_CMO_TYPE
 * @groupref CHI_SINGLE_RN_ATOMICSTORE_TYPE
 * @groupref CHI_SINGLE_RN_ATOMICLOAD_TYPE
 * @groupref CHI_SINGLE_RN_ATOMICSWAP_TYPE
 * @groupref CHI_SINGLE_RN_ATOMICCOMPARE_TYPE
`endif
 * @groupref CHI_SINGLE_RN_WR_TYPE
 * @groupref CHI_SINGLE_RN_CPBK_TYPE
 * @groupref CHI_SINGLE_RN_CMO_TYPE
 * @groupref CHI_SINGLE_RN_DVM_TYPE
 * @groupref CHI_SINGLE_RN_BARRIER_TYPE
 * @groupref CHI_SINGLE_RN_ORDERED_NONCOHERENT_TYPE
`ifdef SVT_CHI_ISSUE_E_ENABLE
 * @groupref CHI_E_SINGLE_RN_STASH_TYPE
`endif
 */
//-------------------------------------------------------------------------------------------------------------
// Multi node sequences  
//-------------------------------------------------------------------------------------------------------------
/** @cond PRIVATE */
/**
 * @grouphdr sequences CHI_SYS_MULTI_RN System level multi RN initiating node virtual sequences
 * Virtual sequences with multiple RNs initiating the transactions
 */  
/** @endcond */
//-------------------------------------------------------------------------------------------------------------
// Flow control sequences  
//-------------------------------------------------------------------------------------------------------------  
/**
 * @grouphdr sequences CHI_FLOW_CTRL_RD_TYPE System level flow control RD type xact virtual sequences
 * Read type transaction specific flow control feature virtual sequences
 */

`ifdef SVT_CHI_ISSUE_B_ENABLE
/**
 * @grouphdr sequences CHI_FLOW_CTRL_PREFETCHTGT_TYPE System level flow control PREFETCHTGT type xact virtual sequences
 * PREFETCHTGT type transaction specific flow control feature virtual sequences
 */
 `endif

/**
 * @grouphdr sequences CHI_FLOW_CTRL_WR_TYPE System level flow control WR type xact virtual sequences
 * Write type transaction specific flow control feature virtual sequences
 */
  
/**
 * @grouphdr sequences CHI_FLOW_CTRL_CPBK_TYPE System level flow control CPBK type xact virtual sequences
 * CopyBack type transaction specific flow control feature virtual sequences
 */
  
/**
 * @grouphdr sequences CHI_FLOW_CTRL_CMO_TYPE System level flow control CMO type xact virtual sequences
 * CMO type transaction specific flow control feature virtual sequences
 */

/**
 * @grouphdr sequences CHI_SYS_FLOW_CTRL CHI System level flow control virtual sequences
 * Flow control feature virtual sequences
 * @groupref CHI_FLOW_CTRL_RD_TYPE
 * @groupref CHI_FLOW_CTRL_WR_TYPE
 * @groupref CHI_FLOW_CTRL_CPBK_TYPE
 * @groupref CHI_FLOW_CTRL_CMO_TYPE 
`ifdef SVT_CHI_ISSUE_B_ENABLE
 * @groupref CHI_FLOW_CTRL_PREFETCHTGT_TYPE 
 `endif
 */

//-------------------------------------------------------------------------------------------------------------
// Outstanding transactions sequences  
//-------------------------------------------------------------------------------------------------------------  
/**
 * @grouphdr sequences CHI_OUTSTANDING_RD_TYPE System level flow control RD type xact virtual sequences
 * Read type transaction specific flow control feature virtual sequences
 */

/**
 * @grouphdr sequences CHI_OUTSTANDING_WR_TYPE System level flow control WR type xact virtual sequences
 * Write type transaction specific flow control feature virtual sequences
 */
  
`ifdef SVT_CHI_ISSUE_B_ENABLE
/**
 * @grouphdr sequences CHI_OUTSTANDING_ATOMIC_TYPE System level flow control Atomic type xact virtual sequences
 * Atomic type transaction specific flow control feature virtual sequences
 */
`endif 

/**
 * @grouphdr sequences CHI_OUTSTANDING_CPBK_TYPE System level flow control CPBK type xact virtual sequences
 * CopyBack type transaction specific flow control feature virtual sequences
 */
  
/**
 * @grouphdr sequences CHI_OUTSTANDING_CMO_TYPE System level flow control CMO type xact virtual sequences
 * CMO type transaction specific flow control feature virtual sequences
 */
/**
 * @grouphdr sequences CHI_SYS_OUTSTANDING System level oustanding transactions virtual sequences
 * Outstanding transactions feature virtual sequences
 * @groupref CHI_OUTSTANDING_RD_TYPE
 * @groupref CHI_OUTSTANDING_WR_TYPE
 * @groupref CHI_OUTSTANDING_CPBK_TYPE
 * @groupref CHI_OUTSTANDING_CMO_TYPE 
`ifdef SVT_CHI_ISSUE_B_ENABLE
 * @groupref CHI_OUTSTANDING_ATOMIC_TYPE
`endif
 */
//-------------------------------------------------------------------------------------------------------------  
// Hazard Scenario sequences  
//-------------------------------------------------------------------------------------------------------------  
/**
 * @grouphdr sequences CHI_SYS_HAZARD System level Hazard scenario virtual sequences
 * Hazard feature virtual sequences
 */
//-------------------------------------------------------------------------------------------------------------  
// Exclusive Sequence  
//-------------------------------------------------------------------------------------------------------------  
/**
 * @grouphdr sequences CHI_EXCLUSIVE_ACCESS
 */
//-------------------------------------------------------------------------------------------------------------  
//============================================================================================================
// Sequence grouping definitions-- ends here  
//============================================================================================================

  
// =============================================================================
/**
 * @groupname CHI_SYS_BASE
 * This sequence creates a reporter reference. <br>
 * This sequence setups up configuraion awareness related infrastructure
 * to the derived sequences. <br>
 * - Refer to svt_chi_system_configuration::participating_rn_nodes, 
 *   svt_chi_system_configuration::participating_sn_nodes for details.
 * .
 * This sequence also provides the following attributes which can be
 * controlled through config DB:
 * - sequence_length: Length of the sequence
 * - silent: Control the messages from sequences
 * .
 * 
 */
class svt_chi_system_base_virtual_sequence extends svt_sequence;

  `svt_xvm_object_utils(svt_chi_system_base_virtual_sequence)
  `svt_xvm_declare_p_sequencer(svt_chi_system_virtual_sequencer)

  /** Handles to get system configuration */
  svt_configuration base_cfg; 
  svt_chi_system_configuration sys_cfg;

  /** Flags used to represent the cache state of a given RN */
  bit rn0_is_valid, rn0_is_unique,rn0_is_clean;
  bit rn1_is_valid, rn1_is_unique,rn1_is_clean;

  /** Flag used to represent the cache state of a given RN is updated or not */
  bit update_cache_status;

  /** Represents the Active Participating RN's node from which the cache initialization is performed. */ 
  int unsigned cache_line_init_rn_f_node_index;

  /** Represents the RN node indices which are used by the sequence 
   *  to initiate the transactions.
   *  initiating_rn_node_idx_0,initiating_rn_node_idx_1 can be programmed by the user
   *  using config_db, otherwise it picks random node indices by default.
   */
  int unsigned initiating_rn_node_idx_0 ,initiating_rn_node_idx_1;

  /** Represents the HN node indices which are used by the sequence to which the 
   *  transactions are targeted.
   *  target_hn_node_idx_0,target_hn_node_idx_1 can be programmed by the user
   *  using config_db, otherwise it picks random node indices by default.
   */
  int unsigned target_hn_node_idx_0,target_hn_node_idx_1;

  /** Represents the length of the sequence. */
  int unsigned sequence_length = 10;

  /** This bit silent is used typically to suppress is_supported message */
  bit silent;

  /** Status field for capturing config DB get status for sequence_length */
  bit sequence_length_status;

  /** Status field for capturing config DB get status for silent */  
  bit silent_status;

  /** 
   * - Represents the maximum number of outstanding transactions at a given HN.
   * - The given value is applicable for each of the HN's in the system.
   * - Applicable for the oustanding transaction feature virtual sequences.
   * - This can be controlled through config DB.
   * - Default value is governed by macro \`SVT_CHI_MAX_NUM_OUTSTANDING_XACT (`SVT_CHI_MAX_NUM_OUTSTANDING_XACT).
   * - This will only be considered when max_num_outstanding_*_xacts_at_hn are not set
   * .
   */
  int unsigned max_num_outstanding_xacts_at_hn = `SVT_CHI_MAX_NUM_OUTSTANDING_XACT;
 
  /** 
   * - Represents the maximum number of outstanding read transactions at a given HN.
   * - The given value is applicable for each of the HN's in the system.
   * - Applicable for the oustanding transaction feature virtual sequences.
   * - This can be controlled through config DB.
   * - Default value is 0.
   * - Must be set only when there are separate num_outstanding_*_xact counts defined for each xact_type in the HN.
   * .
   */
  int unsigned max_num_outstanding_read_xacts_at_hn = 0;
  
  /** 
   * - Represents the maximum number of outstanding Write transactions at a given HN.
   * - The given value is applicable for each of the HN's in the system.
   * - Applicable for the oustanding transaction feature virtual sequences.
   * - This can be controlled through config DB.
   * - Default value is 0.
   * - Must be set only when there are separate num_outstanding_*_xact counts defined for each xact_type in the HN.
   * .
   */
  int unsigned max_num_outstanding_write_xacts_at_hn = 0;
  
  /** 
   * - Represents the maximum number of outstanding Atomic transactions at a given HN.
   * - The given value is applicable for each of the HN's in the system.
   * - Applicable for the oustanding transaction feature virtual sequences.
   * - This can be controlled through config DB.
   * - Default value is 0.
   * - Must be set only when there are separate num_outstanding_*_xact counts defined for each xact_type in the HN.
   * .
   */
  int unsigned max_num_outstanding_atomic_xacts_at_hn = 0;

  /** 
   * - Represents the maximum number of outstanding CMO transactions at a given HN.
   * - The given value is applicable for each of the HN's in the system.
   * - Applicable for the oustanding transaction feature virtual sequences.
   * - This can be controlled through config DB.
   * - Must be set only when there are separate num_outstanding_*_xact counts defined for each xact_type in the HN.
   * - Default value is 0.
   * .
   */
  int unsigned max_num_outstanding_cmo_xacts_at_hn = 0;
  
  /** 
   * - Represents the maximum number of outstanding Control transactions at a given HN.
   * - The given value is applicable for each of the HN's in the system.
   * - Applicable for the oustanding transaction feature virtual sequences.
   * - This can be controlled through config DB.
   * - Default value is 0.
   * - Must be set only when there are separate num_outstanding_*_xact counts defined for each xact_type in the HN.
   * .
   */
  int unsigned max_num_outstanding_control_xacts_at_hn = 0;

  /** Status field for capturing config DB get status for max_num_outstanding_xacts_at_hn */  
  bit max_num_outstanding_xacts_at_hn_status;

  /** Status field for capturing config DB get status for max_num_outstanding_read_xacts_at_hn */  
  bit max_num_outstanding_read_xacts_at_hn_status;

  /** Status field for capturing config DB get status for max_num_outstanding_write_xacts_at_hn */  
  bit max_num_outstanding_write_xacts_at_hn_status;

  /** Status field for capturing config DB get status for max_num_outstanding_atomic_xacts_at_hn */  
  bit max_num_outstanding_atomic_xacts_at_hn_status;

  /** Status field for capturing config DB get status for max_num_outstanding_cmo_xacts_at_hn */  
  bit max_num_outstanding_cmo_xacts_at_hn_status;

  /** Status field for capturing config DB get status for max_num_outstanding_control_xacts_at_hn */  
  bit max_num_outstanding_control_xacts_at_hn_status;

  bit outstanding_xact_count_reached = 0;
  
  bit use_seq_flag_to_resume_response_for_outstanding_xact = 0;

  bit resume_response_for_outstanding_xact = 0;

  /** @cond PRIVATE */
  /** Min addr and Max addr */
  rand bit [`SVT_CHI_MAX_ADDR_WIDTH-1:0] min_addr;
  rand bit [`SVT_CHI_MAX_ADDR_WIDTH-1:0] max_addr;

  /** initiating_rn_f_node_index_* used for the cases of RN-Fs, similarly 
   *  initiating_rn_i_node_index_* variables for RN-Is and 
   *  initiating_rn_node_index_* variables for any RN.
   *  All these variables are used for randomly picking up appropriate RN 
   *  indices from active participating arrays from which the transaction 
   *  will be initiated.
   *  These node indices are used by sequences to initiate the transactions.
   */
  rand int unsigned initiating_rn_f_node_index_0;
  rand int unsigned initiating_rn_f_node_index_1;  
  rand int unsigned initiating_rn_f_node_index_2;
  rand int unsigned initiating_rn_i_node_index_0;  
  rand int unsigned initiating_rn_i_node_index_1;  
  rand int unsigned initiating_rn_d_node_index_0;  
  rand int unsigned initiating_rn_d_node_index_1;  
  rand int unsigned initiating_rn_node_index_0;
  rand int unsigned initiating_rn_node_index_1;

  /** Represents the Active Participating RN's node from which the cache 
   *  initialization is performed.
   */ 
  rand int unsigned cache_line_init_rn_f_node_index_0;
  rand int unsigned cache_line_init_rn_f_node_index_1;

  /** Represents the HN-F node to which the transaction will be sent */ 
  rand int unsigned target_hn_f_node_index_0;
  rand int unsigned target_hn_f_node_index_1;
  
  /** Represents the Targeted HN node index. */ 
  rand int unsigned target_hn_node_index_0;
  rand int unsigned target_hn_node_index_1;

  /** Fields used to track randomization of node_index fields */
  rand bit valid_initiating_rn_f_node_index_0;
  rand bit valid_initiating_rn_f_node_index_1;
  rand bit valid_initiating_rn_f_node_index_2;
  rand bit valid_initiating_rn_i_node_index_0;
  rand bit valid_initiating_rn_i_node_index_1;
  rand bit valid_initiating_rn_d_node_index_0;
  rand bit valid_initiating_rn_d_node_index_1;

  /** Fields used to track randomization of node_index fields */
  rand bit valid_initiating_rn_node_index_0;
  rand bit valid_initiating_rn_node_index_1;  

  /** To display contents of Active Participating RN's nodes info. */
  string str_node_info;

  /** Array of RN's that are participating and active **/
  int active_participating_rn_nodes[int];

  /** Array of RN-F's that are participating and active **/
  int active_participating_rn_f_nodes[int];

  /** Array of RN-I's that are participating and active **/
  int active_participating_rn_i_nodes[int];

  /** Array of RN-D's that are participating and active **/
  int active_participating_rn_d_nodes[int];
  
  /** Array of SN's that are participating and active **/
  int active_participating_sn_nodes[int];
  
  /** Array of SN-F's that are participating and active **/
  int active_participating_sn_f_nodes[int];
  
  /** Array of HN-F nodes */
  int hn_f_nodes[int];

  /** Array of HN-I nodes */
  int hn_i_nodes[int];
  
  /** Sets the failure severity of is_supported functionality of the sequence */
  `SVT_XVM(severity) is_supported_failure_severity = `SVT_XVM_UC(INFO);

  /** Represents the Active Participating RN's node from which the sequence
   *  will be initiated.initiating_rn_node_index_0_from_config_db can be programmed by the user 
   *  from the test using config DB or it takes random value by default.
   */
  int unsigned initiating_rn_node_index_0_from_config_db;

  /** Represents the Active Participating RN's node from which the sequence
   *  will be initiated.initiating_rn_node_index_1_from_config_db can be programmed by the user 
   *  from the test using config DB or it takes random value by default.
   */
  int unsigned initiating_rn_node_index_1_from_config_db;

  /** Represents the HN's node index to which the transactions
   *  are targeted.target_hn_node_index_0_from_config_db can be programmed by the user 
   *  from the test using config DB or it takes random value by default.
   */
  int unsigned target_hn_node_index_0_from_config_db;

  /** Represents the HN's node index to which the transactions
   *  are targeted.target_hn_node_index_1_from_config_db can be programmed by the user 
   *  from the test using config DB or it takes random value by default.
   */
  int unsigned target_hn_node_index_1_from_config_db;

  /** Status flags for capturing config DB get status for initiating_rn_node_index_0_from_config_db
   *  and initiating_rn_node_index_1_from_config_db 
   */
  bit initiating_rn_node_index_0_status,initiating_rn_node_index_1_status;

  /** Status flags for capturing config DB get status for target_hn_node_index_0_from_config_db
   *  and target_hn_node_index_1_from_config_db 
   */
  bit target_hn_node_index_0_status,target_hn_node_index_1_status;

  /** Status field for capturing config DB get status for is_supported_failure_severity */
  bit is_supported_failure_severity_status;
  
  /** This bit indicates whether the arrays related to various types of nodes
   *  are populated or not. 
   *  This is used by the sequence for maitaining the infrastructure, and should
   *  not be programmed by user.
   */
  bit is_node_info_arrays_setup = 0;

  /** Randomize the first initiatiating Active Participating RN-F node **/
  constraint initiating_rn_f_node_index_0_c {
    if(active_participating_rn_f_nodes.size())
    {
     initiating_rn_f_node_index_0 inside {active_participating_rn_f_nodes};
     valid_initiating_rn_f_node_index_0 == 1;
    }
    else
    {
     valid_initiating_rn_f_node_index_0 == 0;
    }                     
  }

  /** Randomize the second initiating Active Participating RN-F Nodes */
  constraint initiating_rn_f_node_index_1_c {
    if((active_participating_rn_f_nodes.size() >= 2)) 
      {
       initiating_rn_f_node_index_1 inside {active_participating_rn_f_nodes};
       initiating_rn_f_node_index_1 != initiating_rn_f_node_index_0;
       valid_initiating_rn_f_node_index_1 == 1;
      }
    else
      {
       valid_initiating_rn_f_node_index_1 == 0;
      }                     
  }

  /** Randomize the initiating_rn_f_node_index_2 */
  constraint initiating_rn_f_node_index_2_c {
    if((active_participating_rn_f_nodes.size() >= 3))
      {
       initiating_rn_f_node_index_2 inside {active_participating_rn_f_nodes};
       initiating_rn_f_node_index_2 != initiating_rn_f_node_index_0;
       initiating_rn_f_node_index_2 != initiating_rn_f_node_index_1;
       valid_initiating_rn_f_node_index_2 == 1;
      }
      else
      {
       valid_initiating_rn_f_node_index_2 == 0;
      }
  }
  
  /** Randomize the first initiatiating Active Participating RN-I node **/
  constraint initiating_rn_i_node_index_0_c {
    if(active_participating_rn_i_nodes.size())
    {
     initiating_rn_i_node_index_0 inside {active_participating_rn_i_nodes};
     valid_initiating_rn_i_node_index_0 == 1;
    }
    else
    {
     valid_initiating_rn_i_node_index_0 == 0;
    }                     
  }

  /** Randomize the second initiating Active Participating RN-I Nodes */
  constraint initiating_rn_i_node_index_1_c {
    if((active_participating_rn_i_nodes.size() >= 2)) 
      {
       initiating_rn_i_node_index_1 inside {active_participating_rn_i_nodes};
       initiating_rn_i_node_index_1 != initiating_rn_i_node_index_0;
       valid_initiating_rn_i_node_index_1 == 1;
      }
    else
      {
       valid_initiating_rn_i_node_index_1 == 0;
      }                     
  }

  /** Randomize the first initiatiating Active Participating RN-D node **/
  constraint initiating_rn_d_node_index_0_c {
    if(active_participating_rn_d_nodes.size())
    {
     initiating_rn_d_node_index_0 inside {active_participating_rn_d_nodes};
     valid_initiating_rn_d_node_index_0 == 1;
    }
    else
    {
     valid_initiating_rn_d_node_index_0 == 0;
    }                     
  }

  /** Randomize the second initiating Active Participating RN-D Nodes */
  constraint initiating_rn_d_node_index_1_c {
    if((active_participating_rn_d_nodes.size() >= 2)) 
      {
       initiating_rn_d_node_index_1 inside {active_participating_rn_d_nodes};
       initiating_rn_d_node_index_1 != initiating_rn_d_node_index_0;
       valid_initiating_rn_d_node_index_1 == 1;
      }
    else
      {
       valid_initiating_rn_d_node_index_1 == 0;
      }                     
  }

  /** Randomize the initiating first Active Participating RN Nodes */
  constraint initiating_rn_node_index_0_c {
    if(active_participating_rn_nodes.size()) {
      initiating_rn_node_index_0 inside {active_participating_rn_nodes};
      valid_initiating_rn_node_index_0 == 1;
    }
    else
    {
      valid_initiating_rn_node_index_0 == 0;
    }
  }

  /** Randomize the initiating second Active Participating RN Nodes */
  constraint initiating_rn_node_index_1_c {
    if(active_participating_rn_nodes.size() >= 2) {
      initiating_rn_node_index_1 inside {active_participating_rn_nodes};
      initiating_rn_node_index_1 != initiating_rn_node_index_0;
      valid_initiating_rn_node_index_1 == 1;
    }
    else
    {
      valid_initiating_rn_node_index_1 == 0;
    }
  }

  /** Randomize the cache_line_init_rn_f_node_index_0 **/
  constraint cache_line_init_rn_f_node_index_0_c {
    if(active_participating_rn_f_nodes.size() >= 3) {
     cache_line_init_rn_f_node_index_0 inside {active_participating_rn_f_nodes};
     cache_line_init_rn_f_node_index_0 != initiating_rn_node_index_0;
     cache_line_init_rn_f_node_index_0 != initiating_rn_node_index_1;
    }
  }

  /** Randomize the cache_line_init_rn_f_node_index_1 **/
  constraint cache_line_init_rn_f_node_index_1_c {
    if(active_participating_rn_f_nodes.size() >= 3) {
     cache_line_init_rn_f_node_index_1 inside {active_participating_rn_f_nodes};
     cache_line_init_rn_f_node_index_1 != initiating_rn_f_node_index_0;
     cache_line_init_rn_f_node_index_1 != initiating_rn_f_node_index_1;
    }
  }

  /** Randomize the target_hn_node_index_0 */
  constraint target_hn_node_index_0_c {
    if(hn_f_nodes.size()>=1) {
      target_hn_node_index_0 inside {hn_f_nodes};
    }
  }

  /** Randomize the target_hn_node_index_1 */
  constraint target_hn_node_index_1_c {
    if(hn_f_nodes.size()>=2) {
      target_hn_node_index_1 inside {hn_f_nodes};
      target_hn_node_index_1 != target_hn_node_index_0;
    }
  }

  /** Randomize the target_hn_f_node_index_0 */
  constraint target_hn_f_node_index_0_c {
    if(hn_f_nodes.size()>=1) { 
      target_hn_f_node_index_0 inside {hn_f_nodes};
    }
  }

  /** Randomize the target_hn_f_node_index_1 */
  constraint target_hn_f_node_index_1_c  {
    if(hn_f_nodes.size()>=2) 
    {
     target_hn_f_node_index_1 inside {hn_f_nodes};
     target_hn_f_node_index_1 != target_hn_f_node_index_0;
    }
  }
  /** @endcond */

  /** Randomize max_addr */
  constraint max_addr_c {
   max_addr == `SVT_CHI_MAX_ADDR_WIDTH'h7FF_FFFF_FFFF; 
  }

  // -----------------------------------------------------------------------------
  virtual task body();
    initiating_rn_node_index_0_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(), "initiating_rn_node_idx_0", initiating_rn_node_index_0_from_config_db);
    initiating_rn_node_index_1_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(), "initiating_rn_node_idx_1", initiating_rn_node_index_1_from_config_db);
    target_hn_node_index_0_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(), "target_hn_node_idx_0", target_hn_node_index_0_from_config_db);
    target_hn_node_index_1_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(), "target_hn_node_idx_1", target_hn_node_index_1_from_config_db);
  endtask: body
  
  /** Setups the participating arrays */
  //--------------------------------------------------------------------
  function void setup_node_info_arrays();

    `svt_xvm_debug("setup_node_info_arrays","Entered ...")    
    void'(get_sys_cfg());

    if (!is_node_info_arrays_setup) begin
      sys_cfg.get_active_participating_node_indices("RN",active_participating_rn_nodes);
      sys_cfg.get_active_participating_node_indices("RN-F",active_participating_rn_f_nodes);
      sys_cfg.get_active_participating_node_indices("RN-I",active_participating_rn_i_nodes);
      sys_cfg.get_active_participating_node_indices("RN-D",active_participating_rn_d_nodes);
      sys_cfg.get_active_participating_node_indices("SN",active_participating_sn_nodes);
      sys_cfg.get_active_participating_node_indices("SN-F",active_participating_sn_f_nodes);

      sys_cfg.get_hn_node_indices_of_hn_type("HN-F",hn_f_nodes);
      sys_cfg.get_hn_node_indices_of_hn_type("HN-I",hn_i_nodes);

      is_node_info_arrays_setup = 1;
    end // if (!is_node_info_arrays_setup)

    `svt_xvm_debug("setup_node_info_arrays","Exiting ...")        
  endfunction // setup_node_info_arrays
  
//--------------------------------------------------------------------
  /** Indicates whether the argument val is present in the input associative array, also returns the matched index */
  function bit is_value_found_in_int_assoc_array(input int int_type_assoc_array[int], input int unsigned val, output int matched_array_idx);
    int loop_idx;
    is_value_found_in_int_assoc_array = 0;
    matched_array_idx = -1;
    // User has programmed node_index.
    // So ignore select_rn_d_node, select_rn_i_node and select_rn_f_node settings.
    if (int_type_assoc_array.first(loop_idx)) begin
      do begin
        if (int_type_assoc_array[loop_idx] == val) begin
          is_value_found_in_int_assoc_array = 1;
          matched_array_idx = loop_idx;
          break;
        end
      end  while (int_type_assoc_array.next(loop_idx));
    end
  endfunction // is_value_found_in_int_assoc_array

//--------------------------------------------------------------------
  function bit update_rn_cache_status(int node_index, bit[`SVT_CHI_MAX_TAGGED_ADDR_WIDTH-1:0] addr, input int in_is_unique, input int in_is_clean);
    int status =0;
    `SVT_XVM(component)           my_component;
    svt_axi_cache                 my_cache;
  
    my_component = p_sequencer.rn_virt_seqr[node_index].rn_xact_seqr.get_parent();
    status = svt_config_object_db#(svt_axi_cache)::get(my_component,"",{my_component.get_name(),"_cache"}, my_cache);
  
    update_rn_cache_status = my_cache.update_status(addr,in_is_unique,in_is_clean);
    if(!update_rn_cache_status) begin
      //`svt_xvm_error("body",$psprintf("Backdoor update for moving the cachestate to shared state failed for address - %h  %s node='h%d", addr, my_component.get_name(),node_index));
    end
    else begin
      `svt_xvm_debug("body",$psprintf("Backdoor update for moving the cachestate to valid state is successful for address - %h", addr));
    end
    `svt_debug("update_rn_cache_status", $psprintf("node_index - %d, addr - %h, update_rn_cache_status - %b, in_is_clean - %b, in_is_clean - %b", node_index, addr, update_rn_cache_status, in_is_unique, in_is_clean));
    return update_rn_cache_status;      
    
  endfunction // update_rn_cache_status

//--------------------------------------------------------------------
  function bit get_rn_cache_status(int node_index, bit[`SVT_CHI_MAX_TAGGED_ADDR_WIDTH-1:0] addr, output bit is_unique, output bit is_clean);
    int status =0;
    `SVT_XVM(component)           my_component;
    svt_axi_cache                 my_cache;
  
    my_component = p_sequencer.rn_virt_seqr[node_index].rn_xact_seqr.get_parent();
    status = svt_config_object_db#(svt_axi_cache)::get(my_component,"",{my_component.get_name(),"_cache"}, my_cache);
  
    get_rn_cache_status = my_cache.get_status(addr,is_unique,is_clean);
    `svt_debug("get_rn_cache_status", $psprintf("node_index - %d, addr - %h, get_rn_cache_status - %b, is_unique - %b, is_clean - %b", node_index, addr, get_rn_cache_status, is_unique, is_clean));
    
  endfunction // get_rn_cache_status

//--------------------------------------------------------------------
  /** Pre-Randomizing the participating RN_F and SN_F */  
  function void pre_randomize();
    `svt_xvm_debug("svt_chi_system_base_virtual_sequence::pre_randomize()","Entered ...")      
    super.pre_randomize();
    setup_node_info_arrays();
    `svt_xvm_debug("svt_chi_system_base_virtual_sequence::pre_randomize()","Exiting ...")    
  endfunction: pre_randomize

//--------------------------------------------------------------------
  virtual task pre_start();
    string is_supported_failure_severity_str = "";
    `svt_xvm_debug("svt_chi_system_base_virtual_sequence::pre_start()","Entered ...")      
    super.pre_start();
    setup_node_info_arrays();
`ifdef SVT_UVM_TECHNOLOGY
    sequence_length_status = uvm_config_db#(int unsigned)::get(null, get_full_name(), "sequence_length", sequence_length);
    silent_status = uvm_config_db#(int unsigned)::get(null, get_full_name(), "silent", silent);
    is_supported_failure_severity_status = uvm_config_db#(uvm_severity)::get(null, get_full_name(), "is_supported_failure_severity", is_supported_failure_severity);
`elsif SVT_OVM_TECHNOLOGY
    sequence_length_status = m_sequencer.get_config_int({get_type_name(), ".sequence_length"}, sequence_length);
    silent_status = m_sequencer.get_config_int({get_type_name(), ".silent"}, silent);
`endif    
    `svt_xvm_debug("body", $sformatf("sequence_length is %0d as a result of %0s.", sequence_length, sequence_length_status ? "config DB" : "default value"));
    `svt_xvm_debug("body", $sformatf("silent is %0d as a result of %0s.", silent, silent_status ? "config DB" : "default value"));

    case (is_supported_failure_severity) 
      `SVT_XVM_UC(INFO): begin
        is_supported_failure_severity_str = "INFO";
      end
      `SVT_XVM_UC(WARNING): begin
        is_supported_failure_severity_str = "WARNING";        
      end
      `SVT_XVM_UC(ERROR): begin
        is_supported_failure_severity_str = "ERROR";        
      end
      `SVT_XVM_UC(FATAL): begin
        is_supported_failure_severity_str = "FATAL";        
      end
    endcase // case (is_supported_failure_severity)

    
    `svt_xvm_debug("body", $sformatf("is_supported_failure_severity is %0s as a result of %0s.", is_supported_failure_severity_str, is_supported_failure_severity_status ? "config DB" : "default value"));
    
    `svt_xvm_debug("svt_chi_system_base_virtual_sequence::pre_start()","Exiting ...")    
  endtask // pre_start
  
//--------------------------------------------------------------------  
  /** Function returns svt_chi_system_configuration handle */
  virtual function svt_chi_system_configuration get_sys_cfg();
    /** Getting svt_chi_system_configuration object handle */ 
    p_sequencer.get_cfg(base_cfg);
    if (!$cast(sys_cfg, base_cfg)) begin
      `svt_xvm_fatal("body", "Unable to $cast the configuration to a svt_chi_system_configuration class");
    end
    else  begin
      return sys_cfg;
    end
  endfunction : get_sys_cfg

  //--------------------------------------------------------------------
  virtual function bit is_target_hn_idx_valid_for_curr_cfg();
    int   rn_idx;
    is_target_hn_idx_valid_for_curr_cfg = 1;
    foreach (active_participating_rn_nodes[idx]) begin
      if (sys_cfg.rn_cfg[active_participating_rn_nodes[idx]].random_tgt_id_enable) begin
        is_target_hn_idx_valid_for_curr_cfg =  0;
        rn_idx = idx;
        break;
      end
    end
    if (is_target_hn_idx_valid_for_curr_cfg == 0) begin
      `svt_xvm_note("is_target_hn_idx_valid_for_curr_cfg", $sformatf("random_tgt_id_enable is set to 1 for rn[%0d], returning is_target_hn_idx_valid_for_curr_cfg as 0", rn_idx));
    end
    else begin
      `svt_xvm_debug("is_target_hn_idx_valid_for_curr_cfg", "returning is_target_hn_idx_valid_for_curr_cfg as 1");
    end
  endfunction // is_target_hn_idx_valid_for_curr_cfg
  
  //-------------------------------------------------------------------- 
  virtual function void issue_is_supported_failure(string fail_msg);
    case (is_supported_failure_severity) 
      `SVT_XVM_UC(INFO): begin
        if (silent) begin
          `svt_xvm_debug("is_supported", fail_msg);
        end
        else begin
          `svt_xvm_note("is_supported", fail_msg);
        end          
      end
      `SVT_XVM_UC(WARNING): begin
        `svt_xvm_warning("is_supported", fail_msg);
      end
      `SVT_XVM_UC(ERROR): begin
        `svt_xvm_error("is_supported", fail_msg);
      end
      `SVT_XVM_UC(FATAL): begin
        `svt_xvm_fatal("is_supported", fail_msg);
      end
    endcase // case (is_supported_failure_severity)
  endfunction // issue_is_supported_failure
  
  //-------------------------------------------------------------------- 
  extern function new(string name="svt_chi_system_base_virtual_sequence");
endclass: svt_chi_system_base_virtual_sequence


  
// =============================================================================
/** @cond PRIVATE */
/**
 * This sequence allows unconstrained random traffic for all ports
 */
class svt_chi_system_random_virtual_sequence extends svt_chi_system_base_virtual_sequence;

  `svt_xvm_object_utils(svt_chi_system_random_virtual_sequence)

  function new(string name="svt_chi_system_random_virtual_sequence");
    super.new(name);
  endfunction

  virtual task body();
    // just extended so that UVM doesn't complain about a missing body implementation
  endtask: body
endclass
/** @endcond */


// =============================================================================
/**
 * This sequence allows to initiate transactions to achieve hazard sceanrios.
 * This sequence cannot be used directly, however, the derived sequences need to be used.
 */
class svt_chi_system_protocol_flow_ctrl_xact_hazard_virtual_sequence extends svt_chi_system_base_virtual_sequence;

  `svt_xvm_object_utils(svt_chi_system_protocol_flow_ctrl_xact_hazard_virtual_sequence)

  /* A semaphore to control access to the xact_type sequence */
  protected semaphore xact_hazard_sema_0 = new(1);
  protected semaphore xact_hazard_sema_1 = new(1);

  /** Used to check chi_spec_revision is set ISSUE_E or later. */
  bit require_issue_e_chi_spec_revision = 0;

  /** To display contents of Active Participating RN-F's node info. */
  string str_rn_f_node;

  /** To display Active Participating RN-F's node info whicha re selected randomly. */
  string str_initiating_rn_node_indices;

  bit is_valid = 0;

  /** Represents the Active Participating RN's node from which the initialization is performed. */ 
  protected int unsigned cache_initializing_rn_node_index;
  protected bit perform_initialization_from_rn_used_for_hazard = 0;

  extern function bit get_cache_status(int node_index, bit[`SVT_CHI_MAX_TAGGED_ADDR_WIDTH-1:0] addr, output bit is_unique, output bit is_clean);

  function new(string name="svt_chi_system_protocol_flow_ctrl_xact_hazard_virtual_sequence");
    super.new(name);
  endfunction

  virtual task body();
    super.body();
    `svt_xvm_debug("body", "Entering ...")

  endtask: body

  /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting Request Nodes = 2
   *  #- minimum supporting Home Nodes = 1
   */
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    
    /** local variables */
    int num_supporting_rn_f_nodes;
    int num_hn_f_nodes;   
    int array_idx;
    bit is_rn_idx_0_participating, is_rn_idx_1_participating;
    string str_is_supported_info_prefix = "";
    string str_is_supported_info = "";
    string str_is_supported_info_suffix = "Modify configurations through svt_chi_node_configuration::chi_spec_revision\n";
    string str_idx0_info = "";
    string str_idx1_info = "";    

    /** Supporting RN-F Nodes required */
    int required_num_supporting_rn_f_nodes = 2;
    int required_num_hn_nodes = 1;
    
    `svt_xvm_debug("is_supported",$sformatf("Entering ..."));

    /** By default is_supported is 0 */
    is_supported = 0;

    /** Check for minimum required HN nodes */
    num_hn_f_nodes = hn_f_nodes.size();

    /** Check requirment of number of HN nodes needed */  
    if (num_hn_f_nodes < required_num_hn_nodes) begin
      issue_is_supported_failure($sformatf("This sequence requires minimum %0d HN-F nodes to be present in the system. Number of HN-F nodes are %0d. Program number of HN nodes using svt_chi_system_configuration::num_hn. Program the HN interface type using svt_chi_system_configuration::chi_addr_cfg.hn_interface_type[].", required_num_hn_nodes, num_hn_f_nodes));             
      return 0;      
    end
    /** Check for minimum required RN-F nodes.
     *  Also check whether the selected RN-F nodes are part of participating arrays or not.
     */ 
    num_supporting_rn_f_nodes = active_participating_rn_f_nodes.size();

    /** Check the requirements of RN-F nodes */  
    if (num_supporting_rn_f_nodes) begin
      /** Display the contents of Active Participating RN-F Nodes */
      foreach (active_participating_rn_f_nodes[j]) begin
        str_rn_f_node = {str_rn_f_node, $sformatf(" %0d", active_participating_rn_f_nodes[j])};
      end 
      `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_f_nodes are %0s", str_rn_f_node));
    end

    str_is_supported_info_prefix = $sformatf("Number of Supporting RN-F Node(s)  - Minimum Required : %0d Current : %0d", required_num_supporting_rn_f_nodes, num_supporting_rn_f_nodes);
    
    if ((initiating_rn_node_index_0_status==0)&&(valid_initiating_rn_f_node_index_0==0)) begin
        str_idx0_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN-Fs that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)";
    end
    else begin
      is_rn_idx_0_participating = is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_node_idx_0, array_idx);
      if (!is_rn_idx_0_participating) begin
        str_idx0_info = $sformatf("initiating_rn_node_idx_0 %0d is not valid for this sequence. The RN-F corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)", initiating_rn_node_idx_0, initiating_rn_node_idx_0);
      end
    end

    if ((initiating_rn_node_index_1_status==0)&&(valid_initiating_rn_f_node_index_1==0)) begin
      str_idx1_info = "Valid initiating_rn_node_idx_1 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN-Fs that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)";
    end 
    else begin
      is_rn_idx_1_participating = is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_node_idx_1, array_idx);
      if (!is_rn_idx_1_participating) begin
        str_idx1_info = $sformatf("initiating_rn_node_idx_1 %0d is not valid for this sequence. The RN-F corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)", initiating_rn_node_idx_1, initiating_rn_node_idx_1);
      end
    end  

    if (is_rn_idx_0_participating && is_rn_idx_1_participating) begin
      is_supported = 1;
    end
    
    if (!is_supported) begin
      str_is_supported_info = $sformatf("%0s%0s",str_idx0_info, str_idx1_info);
      issue_is_supported_failure($sformatf("This sequence cannot be run based on the current system configuration.\n\
                                            %0s \n\
                                            %0s \n\
                                            Modify configurations through \n\
                                            svt_chi_system_configuration::num_rn,\n\
                                            svt_chi_node_configuration::is_active,\n\
                                            svt_chi_system_configuration::participating_request_nodes\n\
                                            ", str_is_supported_info_prefix, str_is_supported_info));
    end      

    /** Checking the Spec revision **/
    if(require_issue_e_chi_spec_revision) begin
      if(is_supported) begin
        str_is_supported_info_prefix = "This sequence cannot be run based on the current configuration.\n";
        str_is_supported_info = "";

        if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision < svt_chi_node_configuration::ISSUE_E) begin
          is_supported = 0;
          str_is_supported_info = $sformatf("svt_chi_node_configuration::chi_spec_revision is not set to svt_chi_node_configuration::ISSUE_E or later for initiating requester node %0d. Writeevictorevict can only be issued from RN when svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_E or later ", initiating_rn_node_idx_0);
        end else begin
          is_supported = 1;
        end  

        if (!is_supported) begin
          string str_complete_is_supported_info = {str_is_supported_info_prefix, str_is_supported_info, str_is_supported_info_suffix};
          issue_is_supported_failure(str_complete_is_supported_info);
        end
      end
    end  
  endfunction : is_supported

endclass//svt_chi_system_protocol_flow_ctrl_xact_hazard_virtual_sequence

function bit svt_chi_system_protocol_flow_ctrl_xact_hazard_virtual_sequence::get_cache_status(int node_index, bit[`SVT_CHI_MAX_TAGGED_ADDR_WIDTH-1:0] addr, output bit is_unique, output bit is_clean);
  int status =0;
  `SVT_XVM(component)           my_component;
  svt_axi_cache                 my_cache;

  my_component = p_sequencer.rn_virt_seqr[node_index].rn_xact_seqr.get_parent();
  status = svt_config_object_db#(svt_axi_cache)::get(my_component,"",{my_component.get_name(),"_cache"}, my_cache);

  get_cache_status = my_cache.get_status(addr,is_unique,is_clean);
  `svt_debug("get_cache_status", $psprintf("node_index - %d, addr - %h, get_cache_status - %b, is_unique - %b, is_clean - %b", node_index, addr, get_cache_status, is_unique, is_clean));
  
endfunction // get_cache_status

`protected
(fQ/;dV@B)W:f,]XgZ&)3&dT,J>18V<9W8N#<:XU:5P?d[R;66>W.)7BWL(D^L&A
F0-5WQ]cbGU+U#B4d_3]00G8e08CLA9VQQ8DCU&+Z8ZR@)^V=)(EOEURBdOK/:WI
UEQTK?2J@.R=JI#6]6MP6<0)MNP4#JfHKF0L3I9-5NX5:(KJB+.f1\6CABA:9#_]
[KV7-.J2K<JPL\<f/9QP/1a=KU0-W6#cPL\E2>+ZKJ4#^b,0JK-D=_O8;aRV)0HS
bc:0Y6?YKN&P)$
`endprotected


// =============================================================================
/** 
 *  This is the base sequence for:
 *  - #svt_chi_system_single_node_rn_coherent_transaction_base_virtual_sequence
 *  - #svt_chi_system_coherent_virtual_sequence
 *  .
 *  
 */  
class svt_chi_system_rn_coherent_transaction_base_virtual_sequence extends svt_chi_system_base_virtual_sequence;

  /** An array of RN-F nodes in the system. Contents are same as that of active_participating_rn_f_nodes */
  int   rn_f_nodes[$];
  /** An array of RN-D nodes in the system. Contents are same as that of active_participating_rn_d_nodes */
  int   rn_d_nodes[$];
  /** An array of RN-I nodes in the system. Contents are same as that of active_participating_rn_i_nodes */
  int   rn_i_nodes[$];
  
  /* A semaphore to control access to the cacheline initialization sequence */
  static semaphore cacheline_init_sema = new(1);

  `svt_xvm_object_utils(svt_chi_system_rn_coherent_transaction_base_virtual_sequence)

  extern virtual task body();

  /** Utility to print caches of all masters */
  extern function void print_caches();
  
  /** Gets cache status of the given address in the master specified by node_index */
  extern function bit get_cache_status(int node_index, bit[`SVT_CHI_MAX_TAGGED_ADDR_WIDTH-1:0] addr, output bit is_unique, output bit is_clean);

  /** Populates rn_f_nodes, rn_d_nodes & rn_i_nodes arrays using system configuration */
  extern function void pre_randomize();
  
  extern function new(string name="svt_chi_system_rn_coherent_transaction_base_virtual_sequence");
  
endclass // svt_chi_system_rn_coherent_transaction_base_virtual_sequence

function svt_chi_system_rn_coherent_transaction_base_virtual_sequence::new(string name="svt_chi_system_rn_coherent_transaction_base_virtual_sequence");
  super.new(name);
endfunction // new

task svt_chi_system_rn_coherent_transaction_base_virtual_sequence::body();
endtask: body


function void svt_chi_system_rn_coherent_transaction_base_virtual_sequence::print_caches();
  int status  = 0;
  
  `SVT_XVM(component)               my_component;
  svt_axi_cache                     my_cache;
  if (sys_cfg != null) begin
    foreach (sys_cfg.rn_cfg[i]) begin
      if (sys_cfg.rn_cfg[i] != null) begin
        if(sys_cfg.rn_cfg[i].is_active &&
           (sys_cfg.rn_cfg[i].chi_interface_type == svt_chi_node_configuration::RN_F)) begin

          if (p_sequencer.rn_virt_seqr[i].rn_xact_seqr != null) begin
            my_component = p_sequencer.rn_virt_seqr[i].rn_xact_seqr.get_parent();
            status = svt_config_object_db#(svt_axi_cache)::get(my_component,"",{my_component.get_name(),"_cache"}, my_cache);
          end

          if (my_cache != null) begin
            `svt_xvm_debug("print_cache",$sformatf("Contents of RN[%0d] cache:\n%0s",i, my_cache.sprint()));
          end
        end // if (sys_cfg.rn_cfg[i].is_active &&...
      end // if (sys_cfg.rn_cfg[i] != null)
    end // foreach (sys_cfg.rn_cfg[i])
  end // if (sys_cfg != null)
  
  
endfunction // print_caches


function bit svt_chi_system_rn_coherent_transaction_base_virtual_sequence::get_cache_status(int node_index, bit[`SVT_CHI_MAX_TAGGED_ADDR_WIDTH-1:0] addr, output bit is_unique, output bit is_clean);
  int status =0;
  `SVT_XVM(component)           my_component;
  svt_axi_cache                 my_cache;

  my_component = p_sequencer.rn_virt_seqr[node_index].rn_xact_seqr.get_parent();
  status = svt_config_object_db#(svt_axi_cache)::get(my_component,"",{my_component.get_name(),"_cache"}, my_cache);

  get_cache_status = my_cache.get_status(addr,is_unique,is_clean);
  `svt_debug("get_cache_status", $psprintf("node_index - %d, addr - %h, get_cache_status - %b, is_unique - %b, is_clean - %b", node_index, addr, get_cache_status, is_unique, is_clean));
  
endfunction // get_cache_status

/** Populates rn_f_nodes, rn_d_nodes & rn_i_nodes arrays using system configuration */
function void svt_chi_system_rn_coherent_transaction_base_virtual_sequence::pre_randomize();
  svt_configuration base_cfg;
  super.pre_randomize();
  
  if(sys_cfg == null) begin
    p_sequencer.get_cfg(base_cfg);
    if (!$cast(sys_cfg, base_cfg)) begin
      `svt_xvm_fatal("body", "Unable to $cast the configuration to a svt_chi_system_configuration class");
    end
  end

  // Make sure that the the rn_*_nodes arrays are nothing but active_participating_rn_*_nodes
  // This is needed for backward compatibility
  // rn_f_nodes = sys_cfg.rn_cfg.find_index with (item.chi_interface_type == svt_chi_node_configuration::RN_F && item.is_active == 1) ;
  // rn_d_nodes = sys_cfg.rn_cfg.find_index with (item.chi_interface_type == svt_chi_node_configuration::RN_D && item.is_active == 1) ;
  // rn_i_nodes = sys_cfg.rn_cfg.find_index with (item.chi_interface_type == svt_chi_node_configuration::RN_I && item.is_active == 1) ;
`protected
B-aP0c9eK<6OCKY?V7f7ACD;UIeED.YScH=RTdaT\=dT-C_LS6\d-)XXM+gV6:B1
OM/#bfRI?&QO,$
`endprotected
  
  foreach (active_participating_rn_f_nodes[rn_f_idx]) begin
    rn_f_nodes.push_back(active_participating_rn_f_nodes[rn_f_idx]);
  end
  foreach (active_participating_rn_i_nodes[rn_i_idx]) begin
    rn_i_nodes.push_back(active_participating_rn_i_nodes[rn_i_idx]);
  end  
  foreach (active_participating_rn_d_nodes[rn_d_idx]) begin
    rn_d_nodes.push_back(active_participating_rn_d_nodes[rn_d_idx]);
  end
  
endfunction // pre_randomize

// =============================================================================
/** 
 * This sequence initializes the cache line of all masters.
 * - The rn_xact for which cache is to be initialized must be input to this sequence. 
 * - The sequence checks if the cache line is already one of the spec permitted states for the rn_xact type. If legal, nothing is done by this sequence. If not legal, then the next steps are performed. 
 * - invalidate_all_cachelines: send makeunique from initiating RN-F; send invalidate xact (writeback if current state is dirty, evict if current state is clean)
 * - get_random_initial_cachestate: get the random legal initial cacheline state for the xact type. Based on this, the next steps are performed. 
 *   - If get_random_initial_cachestate returns 'Invalid' state: send readshared from the peer RN-Fs.). 
 *   - If get_random_initial_cachestate returns a Unique state: send makeunique from initiating RN-F. 
 *   - If get_random_initial_cachestate returns a Shared state: send makeunique from initiating RN-F; send readshared from the peer RN-Fs; If the initiating rn-f cacheline state is not valid,
 *     send makeunique from initiating RN-F. If bypass_silent_cache_line_state_transition is set to 0: update status of cacheline silently to shared. 
 *   .
 * - If clean cache line is required for the coherent xact, send writeclean xact from the initiating RN-F. 
 * .
 */

class svt_chi_system_cacheline_initialization_virtual_sequence extends svt_chi_system_rn_coherent_transaction_base_virtual_sequence; 

  /** The transaction corresponding to which cache line initialization needs to be done */
  svt_chi_rn_transaction rn_xact;
`ifdef SVT_CHI_ISSUE_B_ENABLE
  /** Queue used to capture the transactions used for Cache initialization.*/
  static svt_chi_rn_transaction cacheline_ini_xacts[$];
`endif

  /** The address which needs to be initialized. */
  local bit[`SVT_CHI_MAX_TAGGED_ADDR_WIDTH-1:0] init_addr;

  /** The snoop attribute which needs to be initialized. */
  local bit                              init_snp_attr_is_snoopable;

  /** The snoop attribute which needs to be initialized. */
  local svt_chi_common_transaction::snp_attr_snp_domain_type_enum                              init_snp_attr_snp_domain_type;

  /** The memory attribute which needs to be initialized. */
  local bit                              init_mem_attr_allocate_hint;

  /** The NS attribute which needs to be initialized. */
  local bit                              init_is_non_secure_access;

  /** The byte_enable attribute which needs to be initialized */
  bit [(`SVT_CHI_MAX_BE_WIDTH-1):0] init_directed_byte_enable;

   /** The allocate_in_cache attribute which needs to be initialized for CleanUnique*/
  bit  init_allocate_in_cache;

  /** node_index of master_xact */
  local int                              node_index;
  
  /** Force cache line initialization even if the initial cachestate is a valid one for
   *  current transaction type
   */
  bit                                    force_cache_initialization = 1;

 `ifdef SVT_CHI_ISSUE_B_ENABLE
  /** Poison **/
  bit                                    program_poison_to_zero_cache_initialization = 1;
 `endif 


`ifdef SVT_CHI_ISSUE_B_ENABLE
 /** Data value written to the memory through initialisation.
  *  Applicable for ATOMICCOMPARE transaction only.
  */
  bit [`SVT_CHI_MAX_DATA_WIDTH-1:0] mem_data_after_intialisation = 64'h0;

  /** @cond PRIVATE */
  /** This can be useful to verify SLC invisible cache mode for CHI-B */
  bit perform_cacheinit_for_non_coherent_xacts = 0;
  /** @endcond */
  
`endif

  
  /** When set to 1: 
   *  - The SD state randomization will be avoided in get_random_initial_cachestate()
   *  - writeclean_full, readshared xacts will be avoided from the cache initialization sequence 
   *  .
   */
  bit bypass_cacheinit_sd_wrclean_rdshared = 0;

  /** When set to 1:
   *  - In addition to transactions sent from the initiating RN-F node to initialize its cache,
   *  transactions are initiated, randomly, from the other RN-Fs in the system to ensure that they are in random cache states.
   *  .
   *  When set to 0:
   *  - Only transactions required to initialize the cache of the initiating RN-F node are sent. The cache state of the other RN-Fs remains unchanged.
   *  .
   */
  bit send_init_xacts_from_other_rn_f_nodes = 1;

  /** Base sequence used internaly to initialize cache */
  svt_chi_rn_coherent_transaction_base_sequence basic_makeunique,basic_readshared, basic_cleaninvalid, basic_readnotshareddirty, basic_writeback, basic_cleanunique;

  /** A sequence that generates WRITEBACK for a full cacheline */
  svt_chi_rn_coherent_transaction_base_sequence basic_writeclean;

  /** Flag to indicate if other initial cache state is considered */
  local bit   is_other_initial_cache_state_enabled;

  /** Flag to indicate if partial_cache_states_enable is considered */
  local bit is_partial_cache_line_states_enabled;

  /** Flag to indicate if the cache line is in partial dirty state */
  local bit   is_partial_dirty_line;

  /** Flag to indicate if line in empty state */
  local bit is_line_empty;

  /** Flag to indicate if the cache line state is transitioned silently */
  bit bypass_silent_cache_line_state_transition;
  
  `svt_xvm_object_utils(svt_chi_system_cacheline_initialization_virtual_sequence)

  function new(string name = "svt_chi_system_cacheline_initialization_virtual_sequence");
    super.new(name);
  endfunction

  /**
   * Check the current cache state corresponding to init_addr. If the initial cache state not a
   * valid state for initiating coherent transaction or if force_cache_initialization flag is set
   * initialize the cache in system.
   * 
   * For cache initialization get a random valid initial cache state for the coherent transaction.
   * 
   */
  virtual task body();
    `SVT_XVM(object) base_obj;
    bit is_valid, is_unique, is_clean;
    bit rand_is_valid, rand_is_unique, rand_is_clean, rand_is_empty, rand_is_partial_dirty;
    bit cachestate_is_valid;
    svt_axi_cache my_cache;
    bit config_db_status;
    bit cache_status;
    `SVT_XVM(component)           my_component;
    /** Node index of RN-F node, whose cache lines need to be initialized */
    int   node_index_of_rn_f_to_be_initialized;
    bit send_init_xacts_from_other_rn_f_nodes_status;
    // Populates master_xacts from parent
    super.body();

    send_init_xacts_from_other_rn_f_nodes_status = uvm_config_db#(int unsigned)::get(null, get_full_name(), "send_init_xacts_from_other_rn_f_nodes", send_init_xacts_from_other_rn_f_nodes);
    `svt_xvm_debug("body", $sformatf("send_init_xacts_from_other_rn_f_nodes is set to %0b", send_init_xacts_from_other_rn_f_nodes))  
    `svt_note("body", $sformatf("Starting cache initialization for xact: %0s",`SVT_CHI_PRINT_PREFIX(rn_xact))); 
    if(bypass_cacheinit_sd_wrclean_rdshared == 1) begin
      bit _is_error; 
      `ifndef SVT_CHI_ISSUE_B_ENABLE 
        `svt_xvm_error("body", "bypass_cacheinit_sd_wrclean_rdshared must be set to 1 only if the macro SVT_CHI_ISSUE_B_ENABLE or  SVT_CHI_ISSUE_C_ENABLE is defined");  
      `endif 
    end 
    if (rn_xact == null) begin
      `svt_xvm_fatal("cacheline_initialization","rn_xact is null. Cannot proceed. Please provide a valid RN transaction to the rn_xact property of this sequence");
    end
    else begin
      node_index   = sys_cfg.get_rn_index(rn_xact.cfg.node_id);
      init_addr = rn_xact.get_aligned_addr_to_cache_line_size(1);
      `ifdef SVT_CHI_ISSUE_B_ENABLE
      if(rn_xact.xact_type == svt_chi_transaction::PREFETCHTGT) begin 
        //no need to execute cache init sequence. so exiting. 
        `svt_xvm_debug("body", $sformatf("For transaction %s, the xact_type is %s. No need to perform cache initialization. So bypassing the cache initialization sequence..", `SVT_CHI_PRINT_PREFIX(rn_xact), rn_xact.xact_type.name())); 
        return; 
      end
      else if(rn_xact.hn_node_idx inside {rn_xact.cfg.hn_i_node_indices}) begin
        `svt_xvm_debug("body", $sformatf("For transaction %s, the mem_attr_mem_type is set to %s. Can't perform cache initialization. So bypassing the cache initialization sequence..", `SVT_CHI_PRINT_PREFIX(rn_xact), rn_xact.mem_attr_mem_type.name())); 
        return; 
      end
      if((perform_cacheinit_for_non_coherent_xacts == 1) &&
         ((rn_xact.xact_type == svt_chi_transaction::READNOSNP) ||
`ifdef SVT_CHI_ISSUE_E_ENABLE
          (rn_xact.xact_type == svt_chi_transaction::WRITENOSNPZERO) ||
          (rn_xact.xact_type == svt_chi_transaction::WRITENOSNPFULL_CLEANSHARED) ||
          (rn_xact.xact_type == svt_chi_transaction::WRITENOSNPFULL_CLEANINVALID) ||
          (rn_xact.xact_type == svt_chi_transaction::WRITENOSNPPTL_CLEANINVALID) ||
          (rn_xact.xact_type == svt_chi_transaction::WRITENOSNPPTL_CLEANSHARED) ||
          (rn_xact.xact_type == svt_chi_transaction::WRITENOSNPFULL_CLEANSHAREDPERSISTSEP) ||          
          (rn_xact.xact_type == svt_chi_transaction::WRITENOSNPPTL_CLEANSHAREDPERSISTSEP) ||          
`endif
          (rn_xact.xact_type == svt_chi_transaction::WRITENOSNPFULL) ||
          (rn_xact.xact_type == svt_chi_transaction::WRITENOSNPPTL))
        )
        begin
          init_snp_attr_is_snoopable = 1;
          init_snp_attr_snp_domain_type = rn_xact.snp_attr_snp_domain_type;
          init_mem_attr_allocate_hint = rn_xact.mem_attr_allocate_hint;
        end
      else
      `endif        
        begin
        init_snp_attr_is_snoopable = rn_xact.snp_attr_is_snoopable;
        init_snp_attr_snp_domain_type = rn_xact.snp_attr_snp_domain_type;
        init_mem_attr_allocate_hint = rn_xact.mem_attr_allocate_hint;
        end 
      
      init_is_non_secure_access = rn_xact.is_non_secure_access;
    end

   `svt_xvm_debug("body", $psprintf("Node ID - %0d, Interface type - %0s :: Received transaction of type - %0s,  init_addr - %0h, init_snp_attr_is_snoopable - %0d, init_mem_attr_allocate_hint - %0d, init_is_non_secure_access - %0d",node_index, sys_cfg.rn_cfg[node_index].chi_interface_type.name(), rn_xact.xact_type.name(), init_addr, init_snp_attr_is_snoopable, init_mem_attr_allocate_hint, init_is_non_secure_access));

    if (sys_cfg.rn_cfg[node_index].chi_interface_type == svt_chi_node_configuration::RN_F) begin
      node_index_of_rn_f_to_be_initialized = node_index;
    end
    else begin
      // As RN-I/RN-D doesn't have cache, it's required to initialize the the peer RN-Fs cache lines
      // from one of the peer RN-F node.
      // Randomly pick up one of the peer RN-F
      node_index_of_rn_f_to_be_initialized = rn_f_nodes[$urandom_range((rn_f_nodes.size() -1),0)];
      `svt_xvm_debug("body",$sformatf("Initializing the Cache lines of snoopable RN_F nodes to valid states from RN-F node with index %0d", node_index_of_rn_f_to_be_initialized));      
    end
    
    my_component = p_sequencer.rn_virt_seqr[node_index_of_rn_f_to_be_initialized].rn_xact_seqr.get_parent();
    config_db_status = svt_config_object_db#(svt_axi_cache)::get(my_component,"",{my_component.get_name(),"_cache"}, my_cache);
    
    //Check the cache line state corresponding to init_addr
    is_valid = get_cache_status(node_index_of_rn_f_to_be_initialized, init_addr, is_unique, is_clean);
    `svt_xvm_debug("body", $psprintf("Initial cache state :: xact_type - %s, is_valid - %b, is_unique - %b, is_clean - %b",rn_xact.xact_type.name(), is_valid, is_unique, is_clean));

    // Check if other initial cache states come into picture as per V5
    if (sys_cfg.chi_version == svt_chi_system_configuration::VERSION_5_0) begin
      is_other_initial_cache_state_enabled = sys_cfg.rn_cfg[node_index_of_rn_f_to_be_initialized].other_initial_cache_state_enable;
      `svt_xvm_debug("body", $psprintf("Initial cache state :: xact_type - %s. svt_chi_node_configuration::other_initial_cache_state_enable is set to %0d for rn[%0d]",rn_xact.xact_type.name(),is_other_initial_cache_state_enabled, node_index_of_rn_f_to_be_initialized));
    end

    //Check if partial cache states [UCE, UDP] are enabled
    is_partial_cache_line_states_enabled = sys_cfg.rn_cfg[node_index_of_rn_f_to_be_initialized].partial_cache_line_states_enable;
    `svt_xvm_debug("body", $psprintf("Initial cache state :: xact_type - %s. svt_chi_node_configuration::partial_cache_line_states_enable is set to %0d for rn[%0d]",rn_xact.xact_type.name(),is_partial_cache_line_states_enabled, node_index_of_rn_f_to_be_initialized));

    // Check if the cache line is in partial dirty state
    is_partial_dirty_line = my_cache.is_partial_dirty_line(init_addr);

    //check if the cache line is empty
    is_line_empty = my_cache.is_line_empty(init_addr);
    
    //Check if the cache state is a valid one for initiating the coherent transactions
    cachestate_is_valid = check_init_cachestate_is_valid(rn_xact.xact_type, is_valid, is_unique, is_clean);
      `svt_xvm_debug("body", $psprintf(" check_init_cachestate_is_valid(%0d) for :: xact_type - %s is_valid - %b, is_unique - %b, is_clean - %b",cachestate_is_valid,rn_xact.xact_type.name(),is_valid, is_unique, is_clean));
    if((cachestate_is_valid == 0) || (force_cache_initialization == 1)) begin
      {rand_is_valid, rand_is_unique, rand_is_clean} = get_random_initial_cachestate(rn_xact.xact_type);
      rand_is_empty = get_random_initial_empty_cachestate(rn_xact.xact_type,rand_is_valid, rand_is_unique, rand_is_clean);
      rand_is_partial_dirty = get_random_initial_partial_dirty_cachestate(rn_xact.xact_type,rand_is_valid, rand_is_unique, rand_is_clean); 
      
      `svt_xvm_debug("rand cache state desired body",{`SVT_CHI_PRINT_PREFIX(rn_xact), $psprintf("Random cache line state for initiating node :: xact_type - %s rand_is_valid - %b, rand_is_unique - %b, rand_is_clean - %b rand_is_empty - %b rand_is_partial_dirty: %0b",rn_xact.xact_type.name(),rand_is_valid, rand_is_unique, rand_is_clean,rand_is_empty, rand_is_partial_dirty)});
      //Invaildate all cache line in all RN-F
      invalidate_all_cachelines(node_index_of_rn_f_to_be_initialized, init_addr);
      if(bypass_cacheinit_sd_wrclean_rdshared == 0) begin
        //---------------------------------------------------------------------------------------------------
        //If the desired initial cache state is Invalid.
        //Send ReadShared from some RN-F node's, except the initiating node. Cache line will be
        //in invalid state in RN-F node from which ReadShared was not initiated and in random state
        //in RN-F node which initiated ReadShared. 
        if(rand_is_valid == 0) begin
          if(send_init_xacts_from_other_rn_f_nodes)
            send_rand_readshared_xact(node_index_of_rn_f_to_be_initialized);
        end
        // if desired initial cache state is UCE
        else if(/*is_partial_cache_line_states_enabled ==1 &&*/ rand_is_valid ==1 && rand_is_unique ==1 && rand_is_clean ==1 && rand_is_empty ==1) begin
          init_allocate_in_cache = 1'b0;
          init_directed_byte_enable =`SVT_CHI_MAX_BE_WIDTH'b0;
          send_cleanunqiue_xact(node_index_of_rn_f_to_be_initialized,init_addr);
        end
        //if desired state is UDP
        else if(/*is_partial_cache_line_states_enabled ==1 &&*/ rand_is_valid ==1 && rand_is_unique ==1 && rand_is_clean ==0 && rand_is_partial_dirty ==1) begin
          init_allocate_in_cache = 1'b1;
          init_directed_byte_enable =`SVT_CHI_MAX_BE_WIDTH'b1;
          send_cleanunqiue_xact(node_index_of_rn_f_to_be_initialized,init_addr);
        end
        //If the desired initial cache state is UD, UC, SC or SD
        else begin
          //TO get cache state to UD
          if (rand_is_unique) begin
            //Send MakeUnique from initiating RN-F, this will result in cache state to be in UD
            send_makeunique_xact(node_index_of_rn_f_to_be_initialized, init_addr);
          end
          else begin
            // If the desired state is shared, then then do a silent 
            // cache line state transition. It is legal to silently transition
            // from unique to shared. See section 6.1.3 of specification.
            bit _is_unique = 0;
            send_makeunique_xact(node_index_of_rn_f_to_be_initialized, init_addr);
            // Get the line in other nodes
            if(send_init_xacts_from_other_rn_f_nodes)
              send_rand_readshared_xact(node_index_of_rn_f_to_be_initialized);
            is_valid = get_cache_status(node_index_of_rn_f_to_be_initialized, init_addr, is_unique, is_clean);
            `svt_xvm_debug("body", $psprintf("Initial cache state :: xact_type - %s, is_valid - %b, is_unique - %b, is_clean - %b",rn_xact.xact_type.name(), is_valid, is_unique, is_clean)); 
            
            // After sending rand readshared transactions, the lines could
            // get invalidated; if so write something into the cache
            // The line could also move from dirty to clean state.
            // If the transaction requires the line to be in dirty state, send
            // a MAKEUNIQUE
            if (!is_valid || (is_valid && !rand_is_clean && is_clean))  begin
              send_makeunique_xact(node_index_of_rn_f_to_be_initialized, init_addr);
            end
            
            `svt_xvm_debug("body", $psprintf("Value of bypass_silent_cache_line_state_transition is %b in svt_chi_system_cacheline_initialization_virtual_sequence", bypass_silent_cache_line_state_transition));
            // Silently transition of cache line from unique to shared is not required for
            // WriteBackPtl,WriteCleanPtl transactions because desired initial cache state is 
            // in Unique/Invalid.
            if(!bypass_silent_cache_line_state_transition) begin
              // Make sure that the cacheline is shared.
              cache_status = my_cache.update_status(init_addr,_is_unique,-1);
              if(!cache_status) begin
                //`svt_xvm_error("body",$psprintf("Backdoor update for moving the cachestate to shared state failed for address - %h", init_addr));
              end
              else begin
                `svt_xvm_debug("body",$psprintf("Backdoor update for moving the cachestate to shared state is successful for address - %h", init_addr));
              end
            end
          end // else: !if(rand_is_unique)
          
          //At this point the Cache state is either UD, SC, SD.
          // If this requires a clean cache-line send a WRITECLEAN
          is_valid = get_cache_status(node_index_of_rn_f_to_be_initialized, init_addr, is_unique, is_clean);
          `svt_xvm_debug("body", $psprintf("Initial cache state :: xact_type - %s, is_valid - %b, is_unique - %b, is_clean - %b",rn_xact.xact_type.name(), is_valid, is_unique, is_clean));
          if (is_valid && !is_clean && rand_is_clean)begin
            send_writeclean_xact(node_index_of_rn_f_to_be_initialized,init_addr);
          end
          //---------------------------------------------------------------------------------------------------
        end // else: !if(rand_is_valid == 0)
      end 
`ifdef SVT_CHI_ISSUE_B_ENABLE       
      else begin //bypass_cacheinit_sd_wrclean_rdshared == 1
        if(rand_is_valid == 0) begin //I
          if(send_init_xacts_from_other_rn_f_nodes)
            send_rand_readnotshareddirty_xact(node_index_of_rn_f_to_be_initialized);
        end
        else if(/*is_partial_cache_line_states_enabled ==1 &&*/ rand_is_valid ==1 && rand_is_unique ==1 && rand_is_clean ==1 && rand_is_empty ==1) begin //UCE
          init_allocate_in_cache = 1'b0;
          init_directed_byte_enable =`SVT_CHI_MAX_BE_WIDTH'b0;
          send_cleanunqiue_xact(node_index_of_rn_f_to_be_initialized,init_addr);
        end
        else if(/*is_partial_cache_line_states_enabled ==1 &&*/ rand_is_valid ==1 && rand_is_unique ==1 && rand_is_clean ==0 && rand_is_partial_dirty ==1) begin //UDP
          init_allocate_in_cache = 1'b1;
          init_directed_byte_enable =`SVT_CHI_MAX_BE_WIDTH'b1;
          send_cleanunqiue_xact(node_index_of_rn_f_to_be_initialized,init_addr);
        end
        else if(rand_is_unique && !rand_is_clean) begin //UD
          send_makeunique_xact(node_index_of_rn_f_to_be_initialized, init_addr); 
        end 
        else if(rand_is_unique && rand_is_clean) begin //UC 
          send_makeunique_xact(node_index_of_rn_f_to_be_initialized, init_addr);
          send_writeback_xact(node_index_of_rn_f_to_be_initialized, init_addr); 
          send_readnotshareddirty_xact(node_index_of_rn_f_to_be_initialized, init_addr);
        end 
        else if(!rand_is_unique && rand_is_clean) begin //SC 
          send_makeunique_xact(node_index_of_rn_f_to_be_initialized, init_addr);
          send_writeback_xact(node_index_of_rn_f_to_be_initialized, init_addr); 
          send_readnotshareddirty_xact(node_index_of_rn_f_to_be_initialized, init_addr);
          if(send_init_xacts_from_other_rn_f_nodes)
            send_rand_readnotshareddirty_xact(node_index_of_rn_f_to_be_initialized);
        end 
        else if(!rand_is_unique && !rand_is_clean) begin //SD 
          `svt_xvm_error("body",$psprintf("SD is not a valid initial state when bypass_cacheinit_sd_wrclean_rdshared is set to 1. Please fix the function get_random_initial_cachestate"));
        end 
      end 
`endif       
    end // if ((cachestate_is_valid == 0) || (force_cache_initialization == 1))
    `svt_debug("Body", "Exiting body of svt_chi_system_cacheline_initialization_virtual_sequence");
    `svt_debug("body", $sformatf("Cache initialization done, will be sending actual transaction now : Xact %0s",`SVT_CHI_PRINT_PREFIX(rn_xact)));
  endtask: body

  /** Sends makeunique transaction on the specified node for the specified address */
  task send_makeunique_xact(int target_node_index, bit[`SVT_CHI_MAX_ADDR_WIDTH-1:0] addr);
    `svt_xvm_debug("send_makeunique_xact",$psprintf("target_node_index - %d, addr - %h ",target_node_index, addr));
    `svt_xvm_create_on(basic_makeunique, p_sequencer.rn_virt_seqr[target_node_index].rn_xact_seqr)
    basic_makeunique.disable_all_weights();
    basic_makeunique.makeunique_wt = 1;
    basic_makeunique.directed_addr_mailbox.put(init_addr);
    basic_makeunique.directed_snp_attr_is_snoopable_mailbox.put(init_snp_attr_is_snoopable);
    basic_makeunique.directed_mem_attr_allocate_hint_mailbox.put(init_mem_attr_allocate_hint);
    basic_makeunique.directed_is_non_secure_access_mailbox.put(init_is_non_secure_access);
    basic_makeunique.use_seq_p_crd_return_on_retry_ack = 1;
    `ifndef SVT_CHI_ISSUE_B_ENABLE
      basic_makeunique.directed_snp_attr_snp_domain_type_mailbox.put(init_snp_attr_snp_domain_type);
    `endif
    void'(basic_makeunique.randomize with {use_directed_addr == 1;sequence_length==1;seq_p_crd_return_on_retry_ack==0;});
    `ifdef SVT_CHI_ISSUE_B_ENABLE
      /** Poison **/
      if(`SVT_CHI_POISON_INTERNAL_WIDTH_ENABLE == 1 && 
          sys_cfg.rn_cfg[target_node_index].poison_enable == 1
        )begin
        basic_makeunique.program_poison_to_zero_cache_initialization = 1;
      end 
    `endif
    basic_makeunique.start(p_sequencer.rn_virt_seqr[target_node_index].rn_xact_seqr);
    // Wait for MakeUnique transactions to finish
    basic_makeunique.wait_for_active_xacts_to_end();

`ifdef SVT_CHI_ISSUE_B_ENABLE
    /** Capturing the transactions used for Cache initialization into a queue cacheline_ini_xacts.*/
    cacheline_ini_xacts.push_back(basic_makeunique.local_rn_xact);
`endif
    `svt_xvm_debug("send_makeunique_xact","After wait_for_active_xacts_to_end");
  endtask
//-------------------------------------------------------------------------------------
task send_cleanunqiue_xact(int target_node_index,bit[`SVT_CHI_MAX_ADDR_WIDTH-1:0] addr); 
	//Send cleanunique from RN-F, which is the initiator of transaction
	`svt_xvm_debug("send_cleanunqiue_xact",$psprintf("target_node_index - %d, addr - %h", target_node_index, addr));
	`svt_xvm_create_on(basic_cleanunique,  p_sequencer.rn_virt_seqr[target_node_index].rn_xact_seqr)
	basic_cleanunique.disable_all_weights();
	basic_cleanunique.cleanunique_wt = 1;
  basic_cleanunique.use_directed_byte_enable = 1;
  basic_cleanunique.use_directed_allocate_in_cache = 1;
	basic_cleanunique.directed_addr_mailbox.put(init_addr);
	basic_cleanunique.directed_snp_attr_is_snoopable_mailbox.put(init_snp_attr_is_snoopable);
  basic_cleanunique.directed_mem_attr_allocate_hint_mailbox.put(init_mem_attr_allocate_hint);
	basic_cleanunique.directed_is_non_secure_access_mailbox.put(init_is_non_secure_access);
	basic_cleanunique.directed_byte_enable_mailbox.put(init_directed_byte_enable);
  basic_cleanunique.directed_allocate_in_cache_mailbox.put(init_allocate_in_cache);
  `ifndef SVT_CHI_ISSUE_B_ENABLE
      basic_cleanunique.directed_snp_attr_snp_domain_type_mailbox.put(init_snp_attr_snp_domain_type);
    `endif
	basic_cleanunique.use_seq_p_crd_return_on_retry_ack = 1;
	void'(basic_cleanunique.randomize with {use_directed_addr == 1; sequence_length==1;seq_p_crd_return_on_retry_ack==0;});
  `ifdef SVT_CHI_ISSUE_B_ENABLE
      /** Poison **/
      if(`SVT_CHI_POISON_INTERNAL_WIDTH_ENABLE == 1 && 
          sys_cfg.rn_cfg[target_node_index].poison_enable == 1
        )begin
        basic_cleanunique.program_poison_to_zero_cache_initialization = 1;
      end 
    `endif
	basic_cleanunique.start( p_sequencer.rn_virt_seqr[target_node_index].rn_xact_seqr);
  `svt_debug("send_cleanunqiue_xact","Waiting for CleanUnique to end");
	basic_cleanunique.wait_for_active_xacts_to_end();
  `svt_debug("send_cleanunqiue_xact","CleanUnique Ended");
  `ifdef SVT_CHI_ISSUE_B_ENABLE
    /** Capturing the transactions used for Cache initialization into a queue cacheline_ini_xacts.*/
    cacheline_ini_xacts.push_back(basic_cleanunique.local_rn_xact);
  `endif
endtask // send_rand_cleanunique_xact
//----------------------------------------------------------------------------------------
  /** sends a writeclean transaction on the specified node with the specified address */
  task send_writeclean_xact(int target_node_index, bit[`SVT_CHI_MAX_ADDR_WIDTH-1:0] addr);
    `svt_xvm_debug("send_writeclean_xact",$psprintf("target_node_index - %d, addr - %h", target_node_index, addr));
    `svt_xvm_create_on(basic_writeclean, p_sequencer.rn_virt_seqr[target_node_index].rn_xact_seqr)
    basic_writeclean.disable_all_weights();
    basic_writeclean.writecleanfull_wt = 1;
    basic_writeclean.directed_addr_mailbox.put(addr);
    basic_writeclean.directed_snp_attr_is_snoopable_mailbox.put(init_snp_attr_is_snoopable);
    basic_writeclean.directed_mem_attr_allocate_hint_mailbox.put(init_mem_attr_allocate_hint);
    basic_writeclean.directed_is_non_secure_access_mailbox.put(init_is_non_secure_access);
    basic_writeclean.use_seq_p_crd_return_on_retry_ack = 1;
    `ifndef SVT_CHI_ISSUE_B_ENABLE
      basic_writeclean.directed_snp_attr_snp_domain_type_mailbox.put(init_snp_attr_snp_domain_type);
    `endif
    void'(basic_writeclean.randomize with {use_directed_addr == 1;sequence_length==1;seq_p_crd_return_on_retry_ack==0;});
    `ifdef SVT_CHI_ISSUE_B_ENABLE
      /** Poison **/
      if(`SVT_CHI_POISON_INTERNAL_WIDTH_ENABLE == 1 && 
          sys_cfg.rn_cfg[target_node_index].poison_enable == 1
        )begin
         basic_writeclean.program_poison_to_zero_cache_initialization = 1;
      end 
    `endif      
    basic_writeclean.start(p_sequencer.rn_virt_seqr[target_node_index].rn_xact_seqr);
    basic_writeclean.wait_for_active_xacts_to_end();
    `svt_xvm_debug("send_writeclean_xact","After wait_for_active_xacts_to_end");
  endtask

  /** sends a writeback transaction on the specified node with the specified address */
  task send_writeback_xact(int target_node_index, bit[`SVT_CHI_MAX_ADDR_WIDTH-1:0] addr);
    `svt_xvm_debug("send_writeback_xact",$psprintf("target_node_index - %d, addr - %h", target_node_index, addr));
    `svt_xvm_create_on(basic_writeback, p_sequencer.rn_virt_seqr[target_node_index].rn_xact_seqr)
    basic_writeback.disable_all_weights();
    basic_writeback.writebackfull_wt = 1;
    basic_writeback.directed_addr_mailbox.put(addr);
    basic_writeback.directed_snp_attr_is_snoopable_mailbox.put(init_snp_attr_is_snoopable);
    basic_writeback.directed_mem_attr_allocate_hint_mailbox.put(init_mem_attr_allocate_hint);
    basic_writeback.directed_is_non_secure_access_mailbox.put(init_is_non_secure_access);
    basic_writeback.use_seq_p_crd_return_on_retry_ack = 1;
    `ifndef SVT_CHI_ISSUE_B_ENABLE
      basic_writeback.directed_snp_attr_snp_domain_type_mailbox.put(init_snp_attr_snp_domain_type);
    `endif
    void'(basic_writeback.randomize with {use_directed_addr == 1;sequence_length==1;seq_p_crd_return_on_retry_ack==0;});
    `ifdef SVT_CHI_ISSUE_B_ENABLE
    /** Poison **/
    if(`SVT_CHI_POISON_INTERNAL_WIDTH_ENABLE == 1 && 
        sys_cfg.rn_cfg[target_node_index].poison_enable == 1
      )begin
      basic_writeback.program_poison_to_zero_cache_initialization = 1;
    end      
    `endif
    basic_writeback.start(p_sequencer.rn_virt_seqr[target_node_index].rn_xact_seqr);
    basic_writeback.wait_for_active_xacts_to_end();
    `svt_xvm_debug("send_writeback_xact","After wait_for_active_xacts_to_end");
  endtask

`ifdef SVT_CHI_ISSUE_B_ENABLE  
  /** sends a readnotshareddirty transaction on the specified node with the specified address */
  task send_readnotshareddirty_xact(int target_node_index, bit[`SVT_CHI_MAX_ADDR_WIDTH-1:0] addr);
    if(sys_cfg.rn_cfg[target_node_index].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) begin 
      `svt_xvm_error("send_readnotshareddirty_xact", $psprintf("cannot generate readnotshareddirty from RN[%0d], as this node is configured as ISSUE_A compliant.", target_node_index));
      return; 
    end 
    `svt_xvm_debug("send_readnotshareddirty_xact",$psprintf("target_node_index - %d, addr - %h", target_node_index, addr));
    `svt_xvm_create_on(basic_readnotshareddirty, p_sequencer.rn_virt_seqr[target_node_index].rn_xact_seqr)
    basic_readnotshareddirty.disable_all_weights();
    basic_readnotshareddirty.readnotshareddirty_wt = 1;
    basic_readnotshareddirty.directed_addr_mailbox.put(addr);
    basic_readnotshareddirty.directed_snp_attr_is_snoopable_mailbox.put(init_snp_attr_is_snoopable);
    basic_readnotshareddirty.directed_mem_attr_allocate_hint_mailbox.put(init_mem_attr_allocate_hint);
    basic_readnotshareddirty.directed_is_non_secure_access_mailbox.put(init_is_non_secure_access);
    basic_readnotshareddirty.use_seq_p_crd_return_on_retry_ack = 1;
    void'(basic_readnotshareddirty.randomize with {use_directed_addr == 1;sequence_length==1;seq_p_crd_return_on_retry_ack==0;});
    basic_readnotshareddirty.start(p_sequencer.rn_virt_seqr[target_node_index].rn_xact_seqr);
    basic_readnotshareddirty.wait_for_active_xacts_to_end();
    `svt_xvm_debug("send_readnotshareddirty_xact","After wait_for_active_xacts_to_end");
  endtask
`endif  

  /** Sends READSHARED transaction from random RN-F node in the system other than target_node_index.
   *  This will result from cache line in Invalid state(if called after invalidate_all_cachelines()) and
   *  other cache line in random state.
   */
  task send_rand_readshared_xact(int ref_rn_f_node_index = node_index);
    /** An array of RN-F nodes in the system */
    int   _rn_f_nodes[$];
    int   _num_rnf_node;
    int   _rand_node_index;
    
    //Get  a list of all the RN-F node in system
    _rn_f_nodes = sys_cfg.rn_cfg.find_index with (item.chi_interface_type == svt_chi_node_configuration::RN_F && item.is_active == 1) ;
    _num_rnf_node = _rn_f_nodes.size();
    
    //Send ReadShared from RN-F, in random order 
    for(int index = 0; index < _num_rnf_node; index++) 
      begin
        //Pick a random RN-F node
        _rand_node_index = $urandom_range((_rn_f_nodes.size() -1),0);

        if(_rn_f_nodes[_rand_node_index] != ref_rn_f_node_index) begin
          // Randomly send ReadShared from _rn_f_nodes[_rand_node_index].(75% probability ReadShared will be send)
          if($urandom_range(3,0) != 3) begin
            `svt_xvm_debug("send_rand_readshared_xact",$psprintf("ReadShared tranasction being sent from RN-F[%0d]",_rn_f_nodes[_rand_node_index]));
            `svt_xvm_create_on(basic_readshared,  p_sequencer.rn_virt_seqr[_rn_f_nodes[_rand_node_index]].rn_xact_seqr)
            basic_readshared.disable_all_weights();
            basic_readshared.readshared_wt = 1;
            basic_readshared.directed_addr_mailbox.put(init_addr);
            basic_readshared.directed_snp_attr_is_snoopable_mailbox.put(init_snp_attr_is_snoopable);
            basic_readshared.directed_mem_attr_allocate_hint_mailbox.put(init_mem_attr_allocate_hint);
            basic_readshared.directed_is_non_secure_access_mailbox.put(init_is_non_secure_access);
            basic_readshared.use_seq_p_crd_return_on_retry_ack = 1;
            `ifndef SVT_CHI_ISSUE_B_ENABLE
              basic_readshared.directed_snp_attr_snp_domain_type_mailbox.put(init_snp_attr_snp_domain_type);
            `endif
            void'(basic_readshared.randomize with {use_directed_addr == 1;sequence_length==1;seq_p_crd_return_on_retry_ack==0;});
            `ifdef SVT_CHI_ISSUE_B_ENABLE
              /** Poison **/
              if(`SVT_CHI_POISON_INTERNAL_WIDTH_ENABLE == 1 && 
                  sys_cfg.rn_cfg[node_index].poison_enable == 1
                )begin
                 basic_readshared.program_poison_to_zero_cache_initialization = 1;
              end 
            `endif  
            basic_readshared.start( p_sequencer.rn_virt_seqr[_rn_f_nodes[_rand_node_index]].rn_xact_seqr);
            basic_readshared.wait_for_active_xacts_to_end();
            `svt_xvm_debug("send_rand_readshared_xact",$psprintf("Cachestate after ReadShared tranasction sent from RN-F[%0d]",_rn_f_nodes[_rand_node_index]));
          end
          else begin
            `svt_xvm_debug("send_rand_readshared_xact",$psprintf("ReadShared tranasction is not sent from RN-F[%0d]",_rn_f_nodes[_rand_node_index]));
          end // else: !if($urandom_range(3,0) != 3)
        end // if (_rn_f_nodes[_rand_node_index] != node_index)
        //Removed the node for the queue for generating ReadShared
        _rn_f_nodes.delete(_rand_node_index);
      end // for (int index = 0; index < _num_rnf_node; index++)


    `svt_xvm_debug("send_rand_readshared_xact","Cachestate of all RN-F at end of send_rand_readshared_xact()");
    print_caches();
  endtask // send_rand_readshared_xact

`ifdef SVT_CHI_ISSUE_B_ENABLE  
  /** Sends READNOTSHAREDDIRTY transaction from random RN-F node in the system other than target_node_index.
   */
  task send_rand_readnotshareddirty_xact(int ref_rn_f_node_index = node_index);
    /** An array of RN-F nodes in the system */
    int   _rn_f_nodes[$];
    int   _num_rnf_node;
    int   _rand_node_index;
    
    //Get  a list of all the RN-F node in system
    _rn_f_nodes = sys_cfg.rn_cfg.find_index with (item.chi_interface_type == svt_chi_node_configuration::RN_F && item.is_active == 1) ;
    _num_rnf_node = _rn_f_nodes.size();
    
    //Send readnotshareddirty from RN-F, in random order 
    for(int index = 0; index < _num_rnf_node; index++) 
      begin
        //Pick a random RN-F node
        _rand_node_index = $urandom_range((_rn_f_nodes.size() -1),0);

        if(_rn_f_nodes[_rand_node_index] != ref_rn_f_node_index) begin
          // Randomly send readnotshareddirty from _rn_f_nodes[_rand_node_index].(75% probability readnotshareddirty will be send)
          if($urandom_range(3,0) != 3) begin
            if(sys_cfg.rn_cfg[_rn_f_nodes[_rand_node_index]].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) begin 
              `svt_xvm_error("send_readnotshareddirty_xact", $psprintf("cannot generate readnotshareddirty from RN[%0d], as this node is configured as ISSUE_A compliant.", _rn_f_nodes[_rand_node_index]));
              return; 
            end 
            `svt_xvm_debug("send_rand_readnotshareddirty_xact",$psprintf("readnotshareddirty tranasction being sent from RN-F[%0d]",_rn_f_nodes[_rand_node_index]));
            `svt_xvm_create_on(basic_readnotshareddirty,  p_sequencer.rn_virt_seqr[_rn_f_nodes[_rand_node_index]].rn_xact_seqr)
            basic_readnotshareddirty.disable_all_weights();
            basic_readnotshareddirty.readnotshareddirty_wt = 1;
            basic_readnotshareddirty.directed_addr_mailbox.put(init_addr);
            basic_readnotshareddirty.directed_snp_attr_is_snoopable_mailbox.put(init_snp_attr_is_snoopable);
            basic_readnotshareddirty.directed_mem_attr_allocate_hint_mailbox.put(init_mem_attr_allocate_hint);
            basic_readnotshareddirty.directed_is_non_secure_access_mailbox.put(init_is_non_secure_access);
            basic_readnotshareddirty.use_seq_p_crd_return_on_retry_ack = 1;
            void'(basic_readnotshareddirty.randomize with {use_directed_addr == 1;sequence_length==1;seq_p_crd_return_on_retry_ack==0;});
            /** Poison **/
            if(`SVT_CHI_POISON_INTERNAL_WIDTH_ENABLE == 1 && 
                sys_cfg.rn_cfg[node_index].poison_enable == 1
              )begin
              basic_readnotshareddirty.program_poison_to_zero_cache_initialization = 1;
            end             
            basic_readnotshareddirty.start( p_sequencer.rn_virt_seqr[_rn_f_nodes[_rand_node_index]].rn_xact_seqr);
            basic_readnotshareddirty.wait_for_active_xacts_to_end();
            `svt_xvm_debug("send_rand_readnotshareddirty_xact",$psprintf("Cachestate after readnotshareddirty tranasction sent from RN-F[%0d]",_rn_f_nodes[_rand_node_index]));
          end
          else begin
            `svt_xvm_debug("send_rand_readnotshareddirty_xact",$psprintf("readnotshareddirty tranasction is not sent from RN-F[%0d]",_rn_f_nodes[_rand_node_index]));
          end // else: !if($urandom_range(3,0) != 3)
        end // if (_rn_f_nodes[_rand_node_index] != node_index)
  `ifdef SVT_CHI_ISSUE_B_ENABLE        
        // Initialize the Initiating RN to Valid state even if only one active RN_F 
        // is present in the system for Atomic type transactions.
        else if((_rn_f_nodes.size() ==1 ) && ((rn_xact.xact_type == svt_chi_common_transaction::ATOMICSTORE_ADD)||
           (rn_xact.xact_type == svt_chi_common_transaction::ATOMICSTORE_CLR)||         
           (rn_xact.xact_type == svt_chi_common_transaction::ATOMICSTORE_EOR)||         
           (rn_xact.xact_type == svt_chi_common_transaction::ATOMICSTORE_SET)||         
           (rn_xact.xact_type == svt_chi_common_transaction::ATOMICSTORE_SMAX)||         
           (rn_xact.xact_type == svt_chi_common_transaction::ATOMICSTORE_SMIN)||         
           (rn_xact.xact_type == svt_chi_common_transaction::ATOMICSTORE_UMAX)||         
           (rn_xact.xact_type == svt_chi_common_transaction::ATOMICSTORE_UMIN)||         
           (rn_xact.xact_type == svt_chi_common_transaction::ATOMICLOAD_ADD)||         
           (rn_xact.xact_type == svt_chi_common_transaction::ATOMICLOAD_CLR)||         
           (rn_xact.xact_type == svt_chi_common_transaction::ATOMICLOAD_EOR)||         
           (rn_xact.xact_type == svt_chi_common_transaction::ATOMICLOAD_SET)||         
           (rn_xact.xact_type == svt_chi_common_transaction::ATOMICLOAD_SMAX)||         
           (rn_xact.xact_type == svt_chi_common_transaction::ATOMICLOAD_SMIN)||         
           (rn_xact.xact_type == svt_chi_common_transaction::ATOMICLOAD_UMAX)||         
           (rn_xact.xact_type == svt_chi_common_transaction::ATOMICLOAD_UMIN)||         
           (rn_xact.xact_type == svt_chi_common_transaction::ATOMICSWAP)||         
           (rn_xact.xact_type == svt_chi_common_transaction::ATOMICCOMPARE)     
          ))begin
              _rand_node_index = 0;
              if(sys_cfg.rn_cfg[_rn_f_nodes[_rand_node_index]].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) begin 
                `svt_xvm_error("send_readnotshareddirty_xact", $psprintf("cannot generate readnotshareddirty from RN[%0d], as this node is configured as ISSUE_A compliant.", _rn_f_nodes[_rand_node_index]));
                return; 
              end 
              `svt_xvm_debug("send_rand_readnotshareddirty_xact",$psprintf("readnotshareddirty tranasction being sent from RN-F[%0d]",_rn_f_nodes[0]));
              `svt_xvm_create_on(basic_readnotshareddirty,  p_sequencer.rn_virt_seqr[_rn_f_nodes[_rand_node_index]].rn_xact_seqr)
              basic_readnotshareddirty.disable_all_weights();
              basic_readnotshareddirty.readnotshareddirty_wt = 1;
              basic_readnotshareddirty.directed_addr_mailbox.put(init_addr);
              basic_readnotshareddirty.directed_snp_attr_is_snoopable_mailbox.put(init_snp_attr_is_snoopable);
              basic_readnotshareddirty.directed_mem_attr_allocate_hint_mailbox.put(init_mem_attr_allocate_hint);
              basic_readnotshareddirty.directed_is_non_secure_access_mailbox.put(init_is_non_secure_access);
              basic_readnotshareddirty.use_seq_p_crd_return_on_retry_ack = 1;
              void'(basic_readnotshareddirty.randomize with {use_directed_addr == 1;sequence_length==1;seq_p_crd_return_on_retry_ack==0;});
              basic_readnotshareddirty.start( p_sequencer.rn_virt_seqr[_rn_f_nodes[_rand_node_index]].rn_xact_seqr);
              basic_readnotshareddirty.wait_for_active_xacts_to_end();
              `svt_xvm_debug("send_rand_readnotshareddirty_xact",$psprintf("Atomic Store operattion transaction %s is programmed and readnotshareddirty tranasction sent from RN-F[%0d] as part cache state initialisation when only One RN_F is present in the system",rn_xact.xact_type.name(),_rn_f_nodes[_rand_node_index]));
        end  
  `endif

        //Removed the node for the queue for generating readnotshareddirty
        _rn_f_nodes.delete(_rand_node_index);
      end // for (int index = 0; index < _num_rnf_node; index++)


    `svt_xvm_debug("send_rand_readnotshareddirty_xact","Cachestate of all RN-F at end of send_rand_readnotshareddirty_xact()");
    print_caches();
  endtask // send_rand_readnotshareddirty_xact
`endif
  //Invalidate cache line in all the RN-F node's
  task invalidate_all_cachelines(int target_node_index, bit[`SVT_CHI_MAX_ADDR_WIDTH-1:0] addr);
    `svt_xvm_debug("invalidate_all_cachelines",$psprintf("Invalidate all cache line corresponding to addr = %h", addr));
    send_makeunique_xact(target_node_index, addr);
    send_invalidate_xact(target_node_index, addr); 
  endtask // invalidate_all_cachelines

  /** Sends a sequence that invalidates a cache line on the specified node for the specified address */
  task send_invalidate_xact(int target_node_index, bit[`SVT_CHI_MAX_ADDR_WIDTH-1:0] addr);
      svt_chi_system_cacheline_invalidation_virtual_sequence cacheline_invalidation;
    `svt_xvm_debug("send_invalidate_xact",$psprintf("target_node_index - %d, addr -%h", target_node_index, addr));
    `svt_xvm_create(cacheline_invalidation)
    cacheline_invalidation.invalidate_node = target_node_index;
    cacheline_invalidation.invalidate_addr = addr;
    cacheline_invalidation.init_snp_attr_is_snoopable = init_snp_attr_is_snoopable;
    cacheline_invalidation.init_snp_attr_snp_domain_type = init_snp_attr_snp_domain_type;
    cacheline_invalidation.init_mem_attr_allocate_hint = init_mem_attr_allocate_hint;
    cacheline_invalidation.init_is_non_secure_access = init_is_non_secure_access;
    `ifdef SVT_CHI_ISSUE_B_ENABLE
      /** Poison **/
      if(`SVT_CHI_POISON_INTERNAL_WIDTH_ENABLE == 1 && 
          sys_cfg.rn_cfg[target_node_index].poison_enable == 1
        )begin
        cacheline_invalidation.program_poison_to_zero_cache_initialization = 1;
      end 
    `endif
    cacheline_invalidation.start(p_sequencer);
  endtask

  /** Check if the cache line state in initiating node is valid state for specified transaction */
  function bit check_init_cachestate_is_valid(svt_chi_common_transaction::xact_type_enum xact_type, bit is_valid, bit is_unique, bit is_clean);
    case (xact_type)
`ifdef SVT_CHI_ISSUE_E_ENABLE
      // UC and SC are valid states
      svt_chi_common_transaction::WRITEEVICTOREVICT: 
        begin
          if(is_clean == 1) check_init_cachestate_is_valid = 1;
        end
      svt_chi_common_transaction::MAKEREADUNIQUE: begin
        // SC and SD are valid states
        if(is_valid && !is_unique) begin     
          check_init_cachestate_is_valid = 1;
        end
      end
      svt_chi_common_transaction::READPREFERUNIQUE: 
        // I is valid state
        begin
          if((!is_valid) 
            ) begin
            check_init_cachestate_is_valid = 1;
          end
        end      
`endif
      svt_chi_common_transaction::READNOSNP,
      svt_chi_common_transaction::WRITENOSNPPTL, 
`ifdef SVT_CHI_ISSUE_E_ENABLE
      svt_chi_common_transaction::WRITENOSNPZERO,
      svt_chi_common_transaction::WRITENOSNPFULL_CLEANSHARED,
      svt_chi_common_transaction::WRITENOSNPFULL_CLEANINVALID,
      svt_chi_common_transaction::WRITENOSNPPTL_CLEANSHARED,
      svt_chi_common_transaction::WRITENOSNPPTL_CLEANINVALID,
      svt_chi_common_transaction::WRITENOSNPFULL_CLEANSHAREDPERSISTSEP,
      svt_chi_common_transaction::WRITENOSNPPTL_CLEANSHAREDPERSISTSEP,
`endif
      svt_chi_common_transaction::WRITENOSNPFULL: 
      // This transaction is never cached and so need to go out always
        begin
`ifdef SVT_CHI_ISSUE_B_ENABLE
          if ((perform_cacheinit_for_non_coherent_xacts == 1) || (is_valid == 0))
`else
          if(is_valid == 0)
`endif
            check_init_cachestate_is_valid = 1;
        end
      svt_chi_common_transaction::READONCE,
      svt_chi_common_transaction::READCLEAN,
      svt_chi_common_transaction::READSHARED       :
      // Valid initial state: I, UCE
      // Other Initial states that are valid: UC, SC  
        begin 
          if(((!is_valid) ||
              (is_other_initial_cache_state_enabled && is_valid && is_clean) ||
              (is_partial_cache_line_states_enabled && is_valid && is_clean && is_unique && is_line_empty)
             )
            ) begin
            check_init_cachestate_is_valid = 1;
          end
        end
      `ifdef SVT_CHI_ISSUE_B_ENABLE
      svt_chi_common_transaction::READONCECLEANINVALID,
      svt_chi_common_transaction::READONCEMAKEINVALID:
      // Valid initial state: I, UCE
        begin 
          if(!is_valid ||
             (is_partial_cache_line_states_enabled && is_valid && is_clean && is_unique && is_line_empty)
            ) begin
            check_init_cachestate_is_valid = 1;
          end
        end
      `endif
      svt_chi_common_transaction::READUNIQUE       : 
      // I, SC and SD are valid states
      // Other Initial states that are valid: UC, UCE, UD, UDP
        begin
          if(((!is_valid) ||
              (is_valid && !is_unique) ||
              (is_other_initial_cache_state_enabled && is_valid && is_unique)
             )
            ) begin
            check_init_cachestate_is_valid = 1;
          end
        end
      svt_chi_common_transaction::CLEANUNIQUE      : 
      // SC and SD are valid states
      // As per V5: I is also valid state.
      // Other Initial states that are valid: UC, UD
        begin
          if(((is_valid && !is_unique) ||
              (!is_valid && (sys_cfg.chi_version == svt_chi_system_configuration::VERSION_5_0)) ||
              (is_other_initial_cache_state_enabled && is_valid && 
               is_unique && (is_clean || (!is_partial_dirty_line))
              )
             )
            ) begin     
            check_init_cachestate_is_valid = 1;
          end
        end
      svt_chi_common_transaction::MAKEUNIQUE       :
      // I, SC and SD are valid states
      // Other Initial states that are valid: UC
        begin 
          if(((!is_valid) ||
              (is_valid && !is_unique) ||
              (is_other_initial_cache_state_enabled && is_unique && is_clean)
             )
            ) begin
            check_init_cachestate_is_valid = 1;
          end
        end
      `ifdef SVT_CHI_ISSUE_E_ENABLE
      svt_chi_common_transaction::WRITEBACKFULL_CLEANSHARED,
      svt_chi_common_transaction::WRITEBACKFULL_CLEANSHAREDPERSISTSEP,
      svt_chi_common_transaction::WRITEBACKFULL_CLEANINVALID,
      `endif
      svt_chi_common_transaction::WRITEBACKFULL    : 
        begin
          if(is_clean == 0) check_init_cachestate_is_valid = 1;
        end
      svt_chi_common_transaction::WRITEBACKPTL     : 
        begin
          if(is_partial_cache_line_states_enabled ==1)begin
            if(is_unique ==1 && is_clean ==0 && is_partial_dirty_line ==1)
              check_init_cachestate_is_valid =1;
          end
          else begin
            if(is_unique == 1 && is_clean == 0) check_init_cachestate_is_valid = 1;
          end
        end
      svt_chi_common_transaction::WRITEEVICTFULL   : 
        begin
          if((is_unique == 1) && (is_clean == 1)) check_init_cachestate_is_valid = 1;
        end
      `ifdef SVT_CHI_ISSUE_E_ENABLE
      svt_chi_common_transaction::WRITECLEANFULL_CLEANSHARED,svt_chi_common_transaction::WRITECLEANFULL_CLEANSHAREDPERSISTSEP,
      `endif
      svt_chi_common_transaction::WRITECLEANFULL   : 
        begin
          if(is_clean == 0) check_init_cachestate_is_valid = 1;
        end
      svt_chi_common_transaction::WRITECLEANPTL    : 
        begin
          if(is_unique == 1 && is_clean == 0) check_init_cachestate_is_valid = 1;
        end
      svt_chi_common_transaction::EVICT            : 
        begin
          if(is_clean == 1) check_init_cachestate_is_valid = 1;
        end
      `ifdef SVT_CHI_ISSUE_B_ENABLE
      svt_chi_common_transaction::WRITEUNIQUEFULLSTASH,
      svt_chi_common_transaction::WRITEUNIQUEPTLSTASH,
      svt_chi_common_transaction::STASHONCEUNIQUE,
      svt_chi_common_transaction::STASHONCESHARED,
      `endif
`ifdef SVT_CHI_ISSUE_E_ENABLE
      svt_chi_common_transaction::WRITEUNIQUEZERO,
      svt_chi_common_transaction::WRITEUNIQUEFULL_CLEANSHARED,
      svt_chi_common_transaction::WRITEUNIQUEFULL_CLEANSHAREDPERSISTSEP,
      svt_chi_common_transaction::WRITEUNIQUEPTL_CLEANSHARED,
      svt_chi_common_transaction::WRITEUNIQUEPTL_CLEANSHAREDPERSISTSEP,
      svt_chi_common_transaction::STASHONCESEPUNIQUE,
      svt_chi_common_transaction::STASHONCESEPSHARED,
`endif
      svt_chi_common_transaction::WRITEUNIQUEFULL, 
      svt_chi_common_transaction::WRITEUNIQUEPTL   : 
        begin 
          if(is_valid == 0) check_init_cachestate_is_valid = 1;
        end
      `ifdef SVT_CHI_ISSUE_B_ENABLE
      svt_chi_common_transaction::CLEANSHAREDPERSIST,
      `endif
      `ifdef SVT_CHI_ISSUE_D_ENABLE
      svt_chi_common_transaction::CLEANSHAREDPERSISTSEP,
      `endif
      svt_chi_common_transaction::CLEANSHARED      :
      // I, UC and SC are valid states
      // Other Initial states that are valid: UC, SC        
        begin 
          if((is_valid == 0) || (is_clean == 1)) check_init_cachestate_is_valid = 1;
        end
      svt_chi_common_transaction::CLEANINVALID,
      svt_chi_common_transaction::MAKEINVALID      : 
      // Only I is valid state
      // Other Initial states that are valid: UC, SC
        begin
          if(((!is_valid) ||
              (is_other_initial_cache_state_enabled && is_valid && is_clean)
             )
            ) begin
            check_init_cachestate_is_valid = 1;
          end
        end
      svt_chi_common_transaction::EOBARRIER        : begin check_init_cachestate_is_valid = 1; end
      svt_chi_common_transaction::ECBARRIER        : begin check_init_cachestate_is_valid = 1; end
      svt_chi_common_transaction::DVMOP            : begin check_init_cachestate_is_valid = 1; end
      svt_chi_common_transaction::PCRDRETURN       : begin check_init_cachestate_is_valid = 1; end
      svt_chi_common_transaction::REQLINKFLIT      : begin check_init_cachestate_is_valid = 1; end
`ifdef SVT_CHI_ISSUE_B_ENABLE
      svt_chi_common_transaction::ATOMICSTORE_ADD,
      svt_chi_common_transaction::ATOMICSTORE_CLR,
      svt_chi_common_transaction::ATOMICSTORE_EOR,
      svt_chi_common_transaction::ATOMICSTORE_SET,
      svt_chi_common_transaction::ATOMICSTORE_SMAX,
      svt_chi_common_transaction::ATOMICSTORE_SMIN,
      svt_chi_common_transaction::ATOMICSTORE_UMAX,
      svt_chi_common_transaction::ATOMICSTORE_UMIN,
      svt_chi_common_transaction::ATOMICLOAD_ADD,
      svt_chi_common_transaction::ATOMICLOAD_CLR,
      svt_chi_common_transaction::ATOMICLOAD_EOR,
      svt_chi_common_transaction::ATOMICLOAD_SET,
      svt_chi_common_transaction::ATOMICLOAD_SMAX,
      svt_chi_common_transaction::ATOMICLOAD_SMIN,
      svt_chi_common_transaction::ATOMICLOAD_UMAX,
      svt_chi_common_transaction::ATOMICLOAD_UMIN,
      svt_chi_common_transaction::ATOMICSWAP,
      svt_chi_common_transaction::ATOMICCOMPARE :
        begin
          // I, UC, UCE, UD, SC and SD are valid states
          if(is_other_initial_cache_state_enabled)begin
            check_init_cachestate_is_valid = 1;
          end
          // I, UCE, SC and SD are valid states
          if((!is_valid) || (is_valid && !is_unique && is_clean) || (is_valid && !is_unique && !is_clean) || (is_partial_cache_line_states_enabled && is_valid && is_clean && is_unique && is_line_empty)) begin
            check_init_cachestate_is_valid = 1;
          end
          else begin
            check_init_cachestate_is_valid = 0;
          end
        end

      svt_chi_common_transaction::READSPEC         : 
      // I, UC, UCE, UD, UDP SC and SD are valid states
        begin
          check_init_cachestate_is_valid = 1;
        end
      svt_chi_common_transaction::READNOTSHAREDDIRTY : 
      // I, and UCE are valid states
        begin
          if((!is_valid ||
             (is_partial_cache_line_states_enabled && is_valid && is_clean && is_unique && is_line_empty)
             ) 
            ) begin
            check_init_cachestate_is_valid = 1;
          end
        end      
`endif
      default : begin `svt_xvm_error("check_if_cacheline_state_valid","Invalid xact_type"); end
      
    endcase // case (xact.xact_type)
  endfunction // check_init_cachestate_is_valid
  

  /* Get a random initial cache state for transaction (if multiple iniital cache state are possible)*/
  //output bit [2] - is_valid, (0 - Invalid, 1 - cacheline is present in cache)
  //output bit [1] - is_unique (1 - Unique , 0 - Shared)
  //output bit [0] - is_clean  (1 - Clean , 0 - Dirty)
  function bit[2:0] get_random_initial_cachestate(svt_chi_common_transaction::xact_type_enum xact_type);
    bit [2:0]  rand_cs_selector;
    
    case(xact_type)
`ifdef SVT_CHI_ISSUE_E_ENABLE    
      svt_chi_common_transaction::WRITEEVICTOREVICT: 
        begin  
          //Possible initial cache state - UC , SC
          rand_cs_selector = $urandom_range(1,0);
          if(rand_cs_selector == 0 )  //CS - UC
            get_random_initial_cachestate = 3'b111;
          else //CS - SC
            get_random_initial_cachestate = 3'b101;
        end           
      svt_chi_common_transaction::MAKEREADUNIQUE: begin
        //Possible initial cache state - SC, SD
        rand_cs_selector = $urandom_range(1,0);
        if(rand_cs_selector == 0) //CS - SC
          get_random_initial_cachestate = 3'b101;
        else //CS - SD
          get_random_initial_cachestate = 3'b100;
       end
       
       svt_chi_common_transaction::READPREFERUNIQUE:
        begin
          // Only I is valid state
          rand_cs_selector = 0;
          case (rand_cs_selector) 
            0: begin
              // I
              get_random_initial_cachestate = 3'b000;
            end
          endcase // case (rand_cs_selector)
        end

`endif       
      svt_chi_common_transaction::READNOSNP,
      svt_chi_common_transaction::WRITENOSNPFULL,
`ifdef SVT_CHI_ISSUE_E_ENABLE
      svt_chi_common_transaction::WRITENOSNPZERO,
      svt_chi_common_transaction::WRITENOSNPFULL_CLEANSHARED,
      svt_chi_common_transaction::WRITENOSNPFULL_CLEANINVALID,
      svt_chi_common_transaction::WRITENOSNPPTL_CLEANSHARED,
      svt_chi_common_transaction::WRITENOSNPPTL_CLEANINVALID,
      svt_chi_common_transaction::WRITENOSNPFULL_CLEANSHAREDPERSISTSEP,
      svt_chi_common_transaction::WRITENOSNPPTL_CLEANSHAREDPERSISTSEP,
`endif
      svt_chi_common_transaction::WRITENOSNPPTL: begin
`ifdef SVT_CHI_ISSUE_B_ENABLE
        if (perform_cacheinit_for_non_coherent_xacts) begin
          bit is_valid_state;
          if ($value$plusargs("INIT_STATE_FOR_NON_COH_XACT=%0d", rand_cs_selector))begin
            rand_cs_selector = (rand_cs_selector%5);
          end
          else 
            rand_cs_selector = $urandom_range(4,0);

          case (rand_cs_selector) 
            0: begin
              // I
              get_random_initial_cachestate = 3'b000;
            end
            1: begin
              // SC
              get_random_initial_cachestate = 3'b101;
            end
            2: begin
              // SD
              get_random_initial_cachestate = 3'b100;
            end
            3: begin
              // UC/UCE
              get_random_initial_cachestate = 3'b111;
            end
            4: begin
              // UD/UDP
              get_random_initial_cachestate = 3'b110;
            end
          endcase     
        end // if (perform_cacheinit_for_non_coherent_xacts)
`else
        get_random_initial_cachestate = 3'b000;
`endif
      end       
      svt_chi_common_transaction::READONCE,
      svt_chi_common_transaction::READCLEAN,
      svt_chi_common_transaction::READSHARED      : begin        
        // I,UCE is valid.
        if(is_partial_cache_line_states_enabled ==1) begin
          //I and UCE are valid states
          rand_cs_selector = $urandom_range(1,0);
          case (rand_cs_selector) 
            0: begin
              // I
              get_random_initial_cachestate = 3'b000;
            end
            1: begin
              // UC-E will be assigned further through get_random_initial_empty_cacheline method
              get_random_initial_cachestate = 3'b111;
            end
          endcase
        end
        else begin
          get_random_initial_cachestate = 3'b000;           
        end
      end        
      svt_chi_common_transaction::READUNIQUE      :
        begin
          if (is_other_initial_cache_state_enabled) begin
            // I, SC and SD are valid states
            // Other Initial states that are valid: UC, UCE, UD, UDP
            rand_cs_selector = $urandom_range(4,0);
            case (rand_cs_selector) 
              0: begin
                // I
                get_random_initial_cachestate = 3'b000;
              end
              1: begin
                // SC
                get_random_initial_cachestate = 3'b101;
              end
              2: begin
                // SD
                get_random_initial_cachestate = 3'b100;
              end
              3: begin
                // UC/UCE
                get_random_initial_cachestate = 3'b111;
              end
              4: begin
                // UD/UDP
                get_random_initial_cachestate = 3'b110;
              end
            endcase 
          end
          else begin
            if(bypass_cacheinit_sd_wrclean_rdshared == 0) begin 
              //Possible initial cache state - I, SC, SD
              rand_cs_selector = $urandom_range(2,0);
              if(rand_cs_selector == 0 )  //CS - I 
                get_random_initial_cachestate = 3'b000;
              else if(rand_cs_selector == 1) //CS - SC
                get_random_initial_cachestate = 3'b101;
              else //CS - SD
                get_random_initial_cachestate = 3'b100;
            end     
            else begin 
              //Possible initial cache state - I, SC
              rand_cs_selector = $urandom_range(1,0);
              if(rand_cs_selector == 0 )  //CS - I 
                get_random_initial_cachestate = 3'b000;
              else //CS - SC
                get_random_initial_cachestate = 3'b101;
            end    
          end // else: !if(is_other_initial_cache_state_enabled)
        end      
      svt_chi_common_transaction::CLEANUNIQUE     : 
        begin
          if (is_other_initial_cache_state_enabled) begin
            // SC and SD are valid states
            // As per V5: I is also valid state.
            // Other Initial states that are valid: UC, UD
            rand_cs_selector = $urandom_range(4,0);
            case (rand_cs_selector) 
              0: begin
                // I
                get_random_initial_cachestate = 3'b000;
              end
              1: begin
                // SC
                get_random_initial_cachestate = 3'b101;
              end
              2: begin
                // SD
                get_random_initial_cachestate = 3'b100;
              end
              3: begin
                // UC
                get_random_initial_cachestate = 3'b111;
              end
              4: begin
                // UD
                get_random_initial_cachestate = 3'b110;
              end
            endcase     
          end
          else if (sys_cfg.chi_version == svt_chi_system_configuration::VERSION_5_0) begin
            if(bypass_cacheinit_sd_wrclean_rdshared == 0) begin 
              // SC and SD are valid states
              // As per V5: I is also valid state.
              rand_cs_selector = $urandom_range(2,0);
              case (rand_cs_selector) 
                0: begin
                  // I
                  get_random_initial_cachestate = 3'b000;
                end
                1: begin
                  // SC
                  get_random_initial_cachestate = 3'b101;
                end
                2: begin
                  // SD
                  get_random_initial_cachestate = 3'b100;
                end       
              endcase // case (rand_cs_selector)
            end 
            else begin 
              // SC and SD are valid states
              // As per V5: I is also valid state.
              rand_cs_selector = $urandom_range(1,0);
              case (rand_cs_selector) 
                0: begin
                  // I
                  get_random_initial_cachestate = 3'b000;
                end
                1: begin
                  // SC
                  get_random_initial_cachestate = 3'b101;
                end
              endcase // case (rand_cs_selector)
            end 
          end
          else begin
            //Possible initial cache state - SC, SD
            rand_cs_selector = $urandom_range(1,0);
            if(rand_cs_selector == 0) //CS - SC
              get_random_initial_cachestate = 3'b101;
            else //CS - SD
              get_random_initial_cachestate = 3'b100;
          end // else: !if(sys_cfg.chi_version == svt_chi_system_configuration::VERSION_5_0)
        end     
      svt_chi_common_transaction::MAKEUNIQUE      : 
        begin
          if (is_other_initial_cache_state_enabled) begin
            // I, SC and SD are valid states
            // Other Initial states that are valid: UC
            rand_cs_selector = $urandom_range(3,0);
            case (rand_cs_selector) 
              0: begin
                // I
                get_random_initial_cachestate = 3'b000;
              end
              1: begin
                // SC
                get_random_initial_cachestate = 3'b101;
              end
              2: begin
                // SD
                get_random_initial_cachestate = 3'b100;
              end
              3: begin
                // UC
                get_random_initial_cachestate = 3'b111;
              end
            endcase     
          end  
          else begin
            if(bypass_cacheinit_sd_wrclean_rdshared == 0) begin 
              //Possible initial cache state - I, SC, SD
              rand_cs_selector = $urandom_range(2,0);
              if(rand_cs_selector == 0 )  //CS - I 
                get_random_initial_cachestate = 3'b000;
              else if(rand_cs_selector == 1) //CS - SC
                get_random_initial_cachestate = 3'b101;
              else //CS - SD
                get_random_initial_cachestate = 3'b100;
            end 
            else begin 
              //Possible initial cache state - I, SC
              rand_cs_selector = $urandom_range(1,0);
              if(rand_cs_selector == 0 )  //CS - I 
                get_random_initial_cachestate = 3'b000;
              else if(rand_cs_selector == 1) //CS - SC
                get_random_initial_cachestate = 3'b101;
            end 
          end // else: !if(is_other_initial_cache_state_enabled)
        end
      `ifdef SVT_CHI_ISSUE_E_ENABLE
      svt_chi_common_transaction::WRITEBACKFULL_CLEANSHARED, 
      svt_chi_common_transaction::WRITEBACKFULL_CLEANSHAREDPERSISTSEP, 
      svt_chi_common_transaction::WRITEBACKFULL_CLEANINVALID,
      `endif
      svt_chi_common_transaction::WRITEBACKFULL   : 
        begin
          if(bypass_cacheinit_sd_wrclean_rdshared == 0) begin 
            //Possible initial cache state - UD, SD
            rand_cs_selector = $urandom_range(1,0);
            if(rand_cs_selector == 0 )  //CS - UD 
              get_random_initial_cachestate = 3'b110;
            else //CS - SD
              get_random_initial_cachestate = 3'b100;
          end 
          else begin 
            //Possible initial cache state - UD
            get_random_initial_cachestate = 3'b110;
          end 
        end
      // The only valid cache line state that
      // is valid as per table 6.2 of CHI 5.0 spec is UDP; 
      // as UDP state is not modelled, and table 6.4 indicates
      // that UDP can transition to UD if full cache line is dirty,
      // UD can be considered as valid initial state.
      //But if partial_cache_line_states are enabled then valid initial state for WriteBackPtl
      //should be UDP.
      svt_chi_common_transaction::WRITEBACKPTL:begin
        //valid state: UDP - is_partial_dirty flag will be assigned from the method:get_random_initial_partial_dirty_cachestate
        if(is_partial_cache_line_states_enabled ==1)begin
          get_random_initial_cachestate = 3'b110;
        end
        else //Possible initial cache state CS - UD
          get_random_initial_cachestate = 3'b110;
      end
      svt_chi_common_transaction::WRITECLEANPTL    : 
        begin  
          //Possible initial cache state CS - UD
          get_random_initial_cachestate = 3'b110;
        end    
      svt_chi_common_transaction::WRITEEVICTFULL  : 
        begin
          //Possible initial cache state - UC
          get_random_initial_cachestate = 3'b111;
        end 
      `ifdef SVT_CHI_ISSUE_E_ENABLE
      svt_chi_common_transaction::WRITECLEANFULL_CLEANSHARED,svt_chi_common_transaction::WRITECLEANFULL_CLEANSHAREDPERSISTSEP,
      `endif
      svt_chi_common_transaction::WRITECLEANFULL  : 
        begin  
          if(bypass_cacheinit_sd_wrclean_rdshared == 0) begin 
            //Possible initial cache state - UD, SD
            rand_cs_selector = $urandom_range(1,0);
            if(rand_cs_selector == 0 )  //CS - UD 
              get_random_initial_cachestate = 3'b110;
            else //CS - SD
              get_random_initial_cachestate = 3'b100;
          end 
          else begin 
            //Possible initial cache state - UD
            get_random_initial_cachestate = 3'b110;
          end 
        end  
      svt_chi_common_transaction::EVICT           : 
        begin  
          //Possible initial cache state - UC , SC
          rand_cs_selector = $urandom_range(1,0);
          if(rand_cs_selector == 0 )  //CS - UC
            get_random_initial_cachestate = 3'b111;
          else //CS - SC
            get_random_initial_cachestate = 3'b101;
        end           
`ifdef SVT_CHI_ISSUE_E_ENABLE
      svt_chi_common_transaction::WRITEUNIQUEZERO,
      svt_chi_common_transaction::WRITEUNIQUEFULL_CLEANSHARED,
      svt_chi_common_transaction::WRITEUNIQUEFULL_CLEANSHAREDPERSISTSEP,
      svt_chi_common_transaction::WRITEUNIQUEPTL_CLEANSHARED,
      svt_chi_common_transaction::WRITEUNIQUEPTL_CLEANSHAREDPERSISTSEP,
      svt_chi_common_transaction::STASHONCESEPUNIQUE, 
      svt_chi_common_transaction::STASHONCESEPSHARED, 
`endif
      `ifdef SVT_CHI_ISSUE_B_ENABLE
      svt_chi_common_transaction::WRITEUNIQUEFULLSTASH, 
      svt_chi_common_transaction::WRITEUNIQUEPTLSTASH, 
      svt_chi_common_transaction::STASHONCEUNIQUE, 
      svt_chi_common_transaction::STASHONCESHARED, 
      `endif    
      svt_chi_common_transaction::WRITEUNIQUEFULL, 
      svt_chi_common_transaction::WRITEUNIQUEPTL  : 
        begin  
          get_random_initial_cachestate = 3'b000; //CS - I
        end 
      `ifdef SVT_CHI_ISSUE_B_ENABLE
      svt_chi_common_transaction::CLEANSHAREDPERSIST,
      `endif 
      `ifdef SVT_CHI_ISSUE_D_ENABLE
      svt_chi_common_transaction::CLEANSHAREDPERSISTSEP,
      `endif
      svt_chi_common_transaction::CLEANSHARED     :
        begin  
          // Possible initial cache state - I, UC, SC
          // Other Initial states that are valid: UC, SC   
          rand_cs_selector = $urandom_range(2,0);
          if(rand_cs_selector == 0 )  //CS - I 
            get_random_initial_cachestate = 3'b000;
          else if(rand_cs_selector == 1) //CS - UC
            get_random_initial_cachestate = 3'b111;
          else //CS - SC
            get_random_initial_cachestate = 3'b101;
        end     
      svt_chi_common_transaction::CLEANINVALID,
      svt_chi_common_transaction::MAKEINVALID     :
        begin
          if (is_other_initial_cache_state_enabled) begin
            // Only I is valid state
            // Other Initial states that are valid: UC, SC
            rand_cs_selector = $urandom_range(2,0);
            case (rand_cs_selector) 
              0: begin
                // I
                get_random_initial_cachestate = 3'b000;
              end
              1: begin
                // UC
                get_random_initial_cachestate = 3'b111;
              end
              2: begin
                // SC
                get_random_initial_cachestate = 3'b101;
              end
            endcase // case (rand_cs_selector)
          end
          else begin  
            get_random_initial_cachestate = 3'b000; //CS - I
          end    
        end
      
      //Cache state  dont cake for these transaction
      svt_chi_common_transaction::EOBARRIER       : begin get_random_initial_cachestate = 3'b000;  end       
      svt_chi_common_transaction::ECBARRIER       : begin get_random_initial_cachestate = 3'b000;  end       
      svt_chi_common_transaction::DVMOP           : begin get_random_initial_cachestate = 3'b000;  end           
      svt_chi_common_transaction::PCRDRETURN      : begin get_random_initial_cachestate = 3'b000;  end      
      svt_chi_common_transaction::REQLINKFLIT     : begin get_random_initial_cachestate = 3'b000;  end
`ifdef SVT_CHI_ISSUE_B_ENABLE

      svt_chi_common_transaction::ATOMICSWAP,
      svt_chi_common_transaction::ATOMICCOMPARE,
      svt_chi_common_transaction::ATOMICSTORE_ADD,
      svt_chi_common_transaction::ATOMICSTORE_CLR,
      svt_chi_common_transaction::ATOMICSTORE_EOR,
      svt_chi_common_transaction::ATOMICSTORE_SET,
      svt_chi_common_transaction::ATOMICSTORE_SMAX,
      svt_chi_common_transaction::ATOMICSTORE_SMIN,
      svt_chi_common_transaction::ATOMICSTORE_UMAX,
      svt_chi_common_transaction::ATOMICSTORE_UMIN,
      svt_chi_common_transaction::ATOMICLOAD_ADD,
      svt_chi_common_transaction::ATOMICLOAD_CLR,
      svt_chi_common_transaction::ATOMICLOAD_EOR,
      svt_chi_common_transaction::ATOMICLOAD_SET,
      svt_chi_common_transaction::ATOMICLOAD_SMAX,
      svt_chi_common_transaction::ATOMICLOAD_SMIN,
      svt_chi_common_transaction::ATOMICLOAD_UMAX,
      svt_chi_common_transaction::ATOMICLOAD_UMIN:
        begin
          if(is_other_initial_cache_state_enabled)begin 
            // I, SC, UC, UD and SD are valid states
            rand_cs_selector = $urandom_range(4,0);
            rand_cs_selector = 0;
            case (rand_cs_selector) 
              0: begin
                // I
                get_random_initial_cachestate = 3'b000;
              end
              1: begin
                // SC
                get_random_initial_cachestate = 3'b101;
              end
              2: begin
                // SD
                get_random_initial_cachestate = 3'b100;
              end
              3: begin
                // UC
                get_random_initial_cachestate = 3'b111;
              end
              4: begin
                // UD/UDP
                get_random_initial_cachestate = 3'b110;
              end
            endcase     
          end 
          else if(is_partial_cache_line_states_enabled ==1) begin
            if(bypass_cacheinit_sd_wrclean_rdshared == 0) begin 
              // I, UCE, SC and SD are valid states
              rand_cs_selector = $urandom_range(3,0);
              case (rand_cs_selector) 
                0: begin
                  // I
                  get_random_initial_cachestate = 3'b000;
                end
                1: begin
                  // SC
                  get_random_initial_cachestate = 3'b101;
                end
                2: begin
                  // SD
                  get_random_initial_cachestate = 3'b100;
                end
                3: begin
                  //UCE :: is_empty flag will be assigned from get_random_initial_empty_cachestate method
                  get_random_initial_cachestate = 3'b111;
                end
              endcase 
            end 
            else begin 
              // I, SC are valid states
              rand_cs_selector = $urandom_range(2,0);
              case (rand_cs_selector) 
                0: begin
                  // I
                  get_random_initial_cachestate = 3'b000;
                end
                1: begin
                  // SC
                  get_random_initial_cachestate = 3'b101;
                end
                2: begin
                  //UCE :: is_empty flag will be assigned from get_random_initial_empty_cachestate method
                  get_random_initial_cachestate = 3'b111;
                end
              endcase 
            end
          end
          else begin
            if(bypass_cacheinit_sd_wrclean_rdshared == 0) begin 
              // I, SC and SD are valid states
              rand_cs_selector = $urandom_range(2,0);
              case (rand_cs_selector) 
                0: begin
                  // I
                  get_random_initial_cachestate = 3'b000;
                end
                1: begin
                  // SC
                  get_random_initial_cachestate = 3'b101;
                end
                2: begin
                  // SD
                  get_random_initial_cachestate = 3'b100;
                end
              endcase 
            end 
            else begin 
              // I, SC are valid states
              rand_cs_selector = $urandom_range(1,0);
              case (rand_cs_selector) 
                0: begin
                  // I
                  get_random_initial_cachestate = 3'b000;
                end
                1: begin
                  // SC
                  get_random_initial_cachestate = 3'b101;
                end
              endcase 
            end 
          end //if(!is_other_initial_cache_state_enabled)
        end//svt_chi_common_transaction::ATOMICSTORE_ADD,... 

      svt_chi_common_transaction::READSPEC        :
        begin
          if(bypass_cacheinit_sd_wrclean_rdshared == 0) begin 
            // I, SC, UC, UCE, UD, UDP and SD are valid states
            rand_cs_selector = $urandom_range(4,0);
            case (rand_cs_selector) 
              0: begin
                // I
                get_random_initial_cachestate = 3'b000;
              end
              1: begin
                // SC
                get_random_initial_cachestate = 3'b101;
              end
              2: begin
                // SD
                get_random_initial_cachestate = 3'b100;
              end
              3: begin
                // UC/UCE
                get_random_initial_cachestate = 3'b111;
              end
              4: begin
                // UD/UDP
                get_random_initial_cachestate = 3'b110;
              end
            endcase     
          end 
          else begin 
            // I, SC, UC, UCE, UD, UDP are valid states
            rand_cs_selector = $urandom_range(3,0);
            case (rand_cs_selector) 
              0: begin
                // I
                get_random_initial_cachestate = 3'b000;
              end
              1: begin
                // SC
                get_random_initial_cachestate = 3'b101;
              end
              2: begin
                // UC/UCE
                get_random_initial_cachestate = 3'b111;
              end
              3: begin
                // UD/UDP
                get_random_initial_cachestate = 3'b110;
              end
            endcase  
          end 
        end  
      svt_chi_common_transaction::READNOTSHAREDDIRTY :
        begin
          if(is_partial_cache_line_states_enabled ==1) begin
            //I and UCE are valid states
            rand_cs_selector = $urandom_range(1,0);
            case (rand_cs_selector) 
              0: begin
                // I
                get_random_initial_cachestate = 3'b000;
              end
              1: begin
                // UC-E will be assigned further through get_random_initial_empty_cacheline method
                get_random_initial_cachestate = 3'b111;
              end
            endcase
          end
          else begin
            // Only I is valid state
            rand_cs_selector = 0;
            case (rand_cs_selector) 
              0: begin
                // I
                get_random_initial_cachestate = 3'b000;
              end
            endcase // case (rand_cs_selector)
          end
        end
      svt_chi_common_transaction::READONCECLEANINVALID,
      svt_chi_common_transaction::READONCEMAKEINVALID:
        begin
          if(is_partial_cache_line_states_enabled ==1) begin
            //I and UCE are valid states
            rand_cs_selector = $urandom_range(1,0);
            case (rand_cs_selector) 
              0: begin
                // I
                get_random_initial_cachestate = 3'b000;
              end
              1: begin
                // UCE is_empty flag will be assigned from get_random_initial_empty_cachestate method
                get_random_initial_cachestate = 3'b111;
              end
            endcase
            get_random_initial_cachestate = 3'b111;
          end
          else begin
            // Only I is the valid state
            rand_cs_selector = 0;
            case (rand_cs_selector) 
              0: begin
                // I
                get_random_initial_cachestate = 3'b000;
              end
            endcase // case (rand_cs_selector)
          end
        end
`endif        
      default : begin `svt_xvm_error("check_if_cacheline_state_valid","Invalid xact_type"); end
    endcase // case (xact_type)
  endfunction // get_random_initial_cachestate

//-----------------------------------------------------------------------------------------------
  function bit get_random_initial_empty_cachestate(svt_chi_common_transaction::xact_type_enum xact_type,bit is_valid,bit is_unique,bit is_clean);
    get_random_initial_empty_cachestate =0;

    if(is_partial_cache_line_states_enabled ==1)begin
      case(xact_type)
        svt_chi_common_transaction::READONCE,
        `ifdef SVT_CHI_ISSUE_B_ENABLE
        svt_chi_common_transaction::READONCECLEANINVALID,
        svt_chi_common_transaction::READONCEMAKEINVALID,
        svt_chi_common_transaction::READNOTSHAREDDIRTY,
        `endif
        svt_chi_common_transaction::READCLEAN,
        svt_chi_common_transaction::READSHARED: begin
          if(is_valid && is_unique && is_clean)begin
            if(is_other_initial_cache_state_enabled)begin //if(is_partial_cache_line_states_enabled && is_other_initial_cache_state_enabled)
              case($urandom_range(1,0))
                0: get_random_initial_empty_cachestate =0; //UC
                1: get_random_initial_empty_cachestate =1; //UCE
              endcase
            end
            else begin //if(is_partial_cache_line_states_enabled ==1)
              get_random_initial_empty_cachestate =1; //UCE
            end
          end
        end

      `ifdef SVT_CHI_ISSUE_B_ENABLE
        svt_chi_common_transaction::ATOMICSWAP,
        svt_chi_common_transaction::ATOMICCOMPARE,
        svt_chi_common_transaction::ATOMICSTORE_ADD,
        svt_chi_common_transaction::ATOMICSTORE_CLR,
        svt_chi_common_transaction::ATOMICSTORE_EOR,
        svt_chi_common_transaction::ATOMICSTORE_SET,
        svt_chi_common_transaction::ATOMICSTORE_SMAX,
        svt_chi_common_transaction::ATOMICSTORE_SMIN,
        svt_chi_common_transaction::ATOMICSTORE_UMAX,
        svt_chi_common_transaction::ATOMICSTORE_UMIN,
        svt_chi_common_transaction::ATOMICLOAD_ADD,
        svt_chi_common_transaction::ATOMICLOAD_CLR,
        svt_chi_common_transaction::ATOMICLOAD_EOR,
        svt_chi_common_transaction::ATOMICLOAD_SET,
        svt_chi_common_transaction::ATOMICLOAD_SMAX,
        svt_chi_common_transaction::ATOMICLOAD_SMIN,
        svt_chi_common_transaction::ATOMICLOAD_UMAX,
        svt_chi_common_transaction::ATOMICLOAD_UMIN: begin
          if(is_valid && is_unique && is_clean)begin
            if(is_other_initial_cache_state_enabled)begin //if(is_partial_cache_line_states_enabled && is_other_initial_cache_state_enabled)
              case($urandom_range(1,0))
                0: get_random_initial_empty_cachestate =0; //UC
                1: get_random_initial_empty_cachestate =1; //UCE
              endcase
            end
            else begin //if(is_partial_cache_line_states_enabled ==1)
              get_random_initial_empty_cachestate =1; //UCE
            end
          end
        end
      `endif //issue_b_enable
        
        default: get_random_initial_empty_cachestate =0;
      endcase
    end //if(is_partial_cache_line_states_enabled ==1)
  endfunction //get_random_initial_empty_cachestate
//-----------------------------------------------------------------------------------------------------------------
  function bit get_random_initial_partial_dirty_cachestate(svt_chi_common_transaction::xact_type_enum xact_type,bit is_valid,bit is_unique,bit is_clean);
    get_random_initial_partial_dirty_cachestate =0;
    if(is_partial_cache_line_states_enabled) begin
      case(xact_type)
        svt_chi_common_transaction::WRITEBACKPTL:begin
          if(is_valid && is_unique && is_clean ==0)begin
            get_random_initial_partial_dirty_cachestate =1;
          end
        end
      endcase
    end

    if(is_other_initial_cache_state_enabled)begin
      case(xact_type)
        svt_chi_common_transaction::READUNIQUE:begin
          if(is_valid && is_unique && is_clean ==0)begin
            case($urandom_range(1,0))
              1: get_random_initial_partial_dirty_cachestate =1;
              0: get_random_initial_partial_dirty_cachestate =0;
            endcase
          end
        end
      endcase
    end

  endfunction //get_random_initial_partial_dirty_cachestate
endclass: svt_chi_system_cacheline_initialization_virtual_sequence 

// =============================================================================
/** 
 * This sequence invalidates the cache line of a RN F node.
 * It checks the state of the cache line and initiaties the appropriate transaction
 * If the cacheline state is dirty, a WRITEBACK is initiated.
 * If the cacheline state is clean, an EVICT is initiated.
 */
class svt_chi_system_cacheline_invalidation_virtual_sequence extends svt_chi_system_rn_coherent_transaction_base_virtual_sequence;

  /**  If use_directed_addr is set, this variable decides the addr to be invalidated */
  bit[`SVT_CHI_MAX_ADDR_WIDTH-1:0]  invalidate_addr;
  
  /** The snoop attribute which needs to be initialized. */
  bit                              init_snp_attr_is_snoopable;

  /** The snoop attribute which needs to be initialized. */
  svt_chi_common_transaction::snp_attr_snp_domain_type_enum                              init_snp_attr_snp_domain_type;

  /** The memory attribute which needs to be initialized. */
  bit                              init_mem_attr_allocate_hint;

  /** The NS attribute which needs to be initialized. */
  bit                              init_is_non_secure_access;

  /*
   * The node on which invalidate operation needs to be done.
   */
  int invalidate_node = 0;
`ifdef SVT_CHI_ISSUE_B_ENABLE  
  bit program_poison_to_zero_cache_initialization = 0;
`endif  
  svt_chi_rn_coherent_transaction_base_sequence           basic_writebackfull;
  svt_chi_rn_coherent_transaction_base_sequence           basic_evict;

  `svt_xvm_object_utils(svt_chi_system_cacheline_invalidation_virtual_sequence)

  function new(string name = "svt_chi_system_cacheline_invalidation_virtual_sequence");
    super.new(name);
  endfunction

  virtual task body();
    `SVT_XVM(component)           my_component;
    svt_axi_cache                 my_cache;
    int                           target_node, get_cache_status;
    // Populates master_xacts from parent
    super.body();
    target_node = invalidate_node;
    
    if(p_sequencer.rn_virt_seqr[target_node].rn_xact_seqr != null) begin
      my_component = p_sequencer.rn_virt_seqr[target_node].rn_xact_seqr.get_parent();
      get_cache_status = svt_config_object_db#(svt_axi_cache)::get(my_component,"",{my_component.get_name(),"_cache"}, my_cache);
    end
    else begin
      `svt_xvm_error("body",$psprintf("p_sequencer.rn_virt_seqr[target_node(%0d)].rn_xact_seqr is NULL",target_node));
    end
    
    begin
      bit is_unique, is_clean, cache_status;
      svt_configuration seq_cfg;  
      svt_chi_node_configuration seq_node_cfg;  
      p_sequencer.rn_virt_seqr[target_node].get_cfg(seq_cfg);
      if (!$cast(seq_node_cfg, seq_cfg)) begin
        `svt_xvm_fatal("body", "Unable to $cast the configuration to a svt_chi_node_configuration class");
      end 
      else begin  
          if (seq_node_cfg.enable_secure_nonsecure_address_space) 
            cache_status = my_cache.get_status({seq_node_cfg.sys_cfg.compute_tagged_addr_bit_based_on_non_secure_attribute(init_is_non_secure_access),invalidate_addr},is_unique,is_clean);
          else 
            cache_status = my_cache.get_status({invalidate_addr},is_unique,is_clean);
      end
      
      `svt_xvm_debug("body",$psprintf(" cacheline_invalidation:Node_index - %d, addr - %h cache_status - %b, is_unique - %b , is_clean - %b init_is_non_secure_access - %b ", target_node, invalidate_addr, cache_status, is_unique, is_clean,init_is_non_secure_access));
      if (cache_status && is_clean) 
        initiate_basic_evict(target_node,invalidate_addr);
      else if(cache_status && !is_clean) 
        initiate_basic_writeback(target_node,invalidate_addr);
    end
    `svt_xvm_debug("body","Exiting svt_chi_system_cacheline_invalidation_virtual_sequence");
  endtask: body

  /** Initiates an evict transaction for the specified node and address */
  task initiate_basic_evict(int target_node, bit[`SVT_CHI_MAX_ADDR_WIDTH-1:0] addr);
    `svt_xvm_debug("initiate_basic_evict","Sending EVICT");
    `svt_xvm_create_on(basic_evict, p_sequencer.rn_virt_seqr[target_node].rn_xact_seqr)
    basic_evict.disable_all_weights();
    basic_evict.evict_wt = 1;
    basic_evict.directed_addr_mailbox.put(addr);
    basic_evict.directed_snp_attr_is_snoopable_mailbox.put(init_snp_attr_is_snoopable);
    basic_evict.directed_mem_attr_allocate_hint_mailbox.put(init_mem_attr_allocate_hint);
    basic_evict.directed_is_non_secure_access_mailbox.put(init_is_non_secure_access);
    `ifndef SVT_CHI_ISSUE_B_ENABLE
      basic_evict.directed_snp_attr_snp_domain_type_mailbox.put(init_snp_attr_snp_domain_type);
    `endif
    void'(basic_evict.randomize with {use_directed_addr == 1; sequence_length==1;});
    `ifdef SVT_CHI_ISSUE_B_ENABLE
      /** Poison **/
      if(`SVT_CHI_POISON_INTERNAL_WIDTH_ENABLE == 1 && 
          sys_cfg.rn_cfg[target_node].poison_enable == 1
        )begin
        basic_evict.program_poison_to_zero_cache_initialization = this.program_poison_to_zero_cache_initialization;
      end 
    `endif    
    basic_evict.start(p_sequencer.rn_virt_seqr[target_node].rn_xact_seqr);
    basic_evict.wait_for_active_xacts_to_end();
  endtask

  /** Initiates a writeback transaction for the specified node and address */
  task initiate_basic_writeback(int target_node, bit[`SVT_CHI_MAX_ADDR_WIDTH-1:0] addr);
    `svt_xvm_debug("initiate_basic_writeback","Sending WRITEBACKFULL");
    `svt_xvm_create_on(basic_writebackfull, p_sequencer.rn_virt_seqr[target_node].rn_xact_seqr)
    basic_writebackfull.disable_all_weights();
    basic_writebackfull.writebackfull_wt = 1;
    basic_writebackfull.directed_addr_mailbox.put(addr);
    basic_writebackfull.directed_snp_attr_is_snoopable_mailbox.put(init_snp_attr_is_snoopable);
    basic_writebackfull.directed_mem_attr_allocate_hint_mailbox.put(init_mem_attr_allocate_hint);
    basic_writebackfull.directed_is_non_secure_access_mailbox.put(init_is_non_secure_access);
    `ifndef SVT_CHI_ISSUE_B_ENABLE
      basic_writebackfull.directed_snp_attr_snp_domain_type_mailbox.put(init_snp_attr_snp_domain_type);
    `endif
    void'(basic_writebackfull.randomize with {use_directed_addr == 1;sequence_length==1;});
    `ifdef SVT_CHI_ISSUE_B_ENABLE
      /** Poison **/
      if(`SVT_CHI_POISON_INTERNAL_WIDTH_ENABLE == 1 && 
          sys_cfg.rn_cfg[target_node].poison_enable == 1
        )begin
        basic_writebackfull.program_poison_to_zero_cache_initialization = this.program_poison_to_zero_cache_initialization;
      end 
    `endif     
    basic_writebackfull.start(p_sequencer.rn_virt_seqr[target_node].rn_xact_seqr);
    basic_writebackfull.wait_for_active_xacts_to_end();
  endtask

endclass: svt_chi_system_cacheline_invalidation_virtual_sequence

/** 
 * @groupname CHI_SINGLE_RN_BASE
 *  Base sequence for all the single node RN coherent transaction type derived
 *  virtual sequences. <br>
 *  If node_index is programmed through config DB, the value of node_index gets 
 *  priority over the results of the below settings.
 *  If a given derived RN coherent transaction virtual sequence can be initiated
 *  from either RN-F or RN-I or both types of nodes as per CHI specification, 
 *  the following controls can be used from the test through config DB programming.
 *  - select_rn_f_node: When set to 1, randomly one of the active and participating RN-F
 *    nodes will be the initiator.
 *  - select_rn_i_node: When set to 1, randomly one of the active and participating RN-I
 *    nodes will be the initiator.
 *  - select_rn_d_node: When set to 1, randomly one of the active and participating RN-D
 *    nodes will be the initiator.
 *  - If select_rn_f_node, select_rn_d_node and select_rn_i_node are together 1 or 0: randomly one of
 *    the active and participating RN-F/RN-I nodes will be the initiator.
 *  .
 * Following is the user interface for programming the address ranges. 
 * This is supported currently only for single non coherent transaction type sequences.
 * Note that both these attributes need to be programmed together through config DB. 
 * The address generated will be in the range [start_addr:end_addr]. It is required
 * to ensure that start_addr <= end_addr. Typically, this can be used to target
 * the address ranges that correspond to HN-I. Note that when hn_index is programmed
 * using config DB, the start_addr and end_addr values will be ignored. Refer to 
 * documentation of hn_index.
 *  - start_addr: Start address for the address range
 *  - end_addr: End address range for the address range
 *  .
 * Following is the user interface to generate transactions to a given Home Node index.
 * This is supported currently only for single non coherent transaction type sequences.
 * Note that when this attribute is programmed through config DB, values of start_addr
 * and end_addr will be ignored.
 * - hn_index: Index of home node to which transactions should be generated to
 * .
 */  
// =============================================================================
class svt_chi_system_single_node_rn_coherent_transaction_base_virtual_sequence extends svt_chi_system_rn_coherent_transaction_base_virtual_sequence;
  
  svt_chi_rn_coherent_transaction_base_sequence  coherent_seq;

`protected
c)U:dF;,VR94F<D.[gY8O5\[@S#&7RKX/ANW7/^1N70bW?:=ggfD5)>gVG=XfVIL
BZJ_@GcL>.+6;g=0bH@>2K;EOFc0&&c9HWYgFP73O6PLXf>UdZa1XPX#X@FIWaK=
cS>eL&(RYIaVN@.ULP@/TCUR:.AT-)::18I5f(-O0E1B&0DK66VZ+Fc[VYDa#<C3
T&b;U2f[XO^O/-BN=e6fAbFW0Z>R8d60^>LF#5-6NZ&XZ/7I[g[cKT31XL)@7X@Q
N(>BXL?V8@]ZE)fUDc]b67N8WW8?g)?,ce21>aY8FP2[UeOO&+e14R>R&[L4C-4g
D@3VVdMOX#[Z.$
`endprotected


  /** Variable that is used to decide if the initiating nodes to be of RN-F type.
   *  If this variable, select_rn_d_node and select_rn_i_node together are set to 0, either of RN-I/RN-F/RN-D 
   *  node types will be selected. This can be controlled through config DB. <br>
   *  When node_index is programmed, this setting will be ignored.
   */ 
  int select_rn_f_node = 0;

  /** Variable that is used to decide if the initiating nodes to be of RN-I type.
   *  If this variable, select_rn_d_node  and select_rn_f_node together are set to 0, either of RN-I/RN-F/RN-D 
   *  node types will be selected. This can be controlled through config DB. <br>
   *  When node_index is programmed, this setting will be ignored.
   */  
  int select_rn_i_node = 0; 

  /** Variable that is used to decide if the initiating nodes to be of RN-D type.
   *  If this variable ,select_rn_i_node and select_rn_f_node together are set to 0, either of RN-I/RN-F/RN-D 
   *  node types will be selected. This can be controlled through config DB. <br>
   *  When node_index is programmed, this setting will be ignored.
   */  
  int select_rn_d_node = 0; 

  /** Status field for capturing config DB get status for select_rn_f_node */  
  bit select_rn_f_node_status;

  /** Status field for capturing config DB get status for select_rn_i_node */  
  bit select_rn_i_node_status;

  /** Status field for capturing config DB get status for select_rn_d_node */  
  bit select_rn_d_node_status;

  /** Status field for capturing config DB get status for request_ordering */  
  bit request_ordering_status;
  
  /** Status field for capturing config DB get status for gen_diff_txn_id*/  
  bit gen_diff_txn_id_status;

  /** Status field for capturing config DB get status for node_index */
  bit node_index_status;

  /** Status field for capturing config DB get status for hn_index */
  bit hn_index_status;

  /** Status field for capturing config DB get status for start_addr */
  bit start_addr_status;

  /** Status field for capturing config DB get status for start_addr */  
  bit end_addr_status;

  /** Status field for capturing config DB get status for addr_mode */
  bit addr_mode_status;
  
  /** Variable used to decide if request ordering in the transaction must be set or not.
   *  This can be programmed using config DB.
   *  If not programmed, the request ordering field in the generated transaction will be randomized
   */
  int request_ordering = -1;

  /** Variable used for generating transactions with unique transaction id.
   *  This can be programmed using config DB.
   *  If not programmed, the txn_id field in the generated transaction will be randomized
   */  
  int gen_diff_txn_id = -1;

  /** Represents the RN from which the sequence will be initiated. 
   *  This can be controlled through config DB. */ 
  rand int unsigned node_index;

  /** 
   * Index of home node to which transactions should be generated to.
   * This needs to be prorammed through config DB. When this is programmed,
   * values of start_addr and end_addr will be ignored.
   */
  int unsigned hn_index;

  /** Start address for the sequence that needs to be programmed thorugh config DB.
   *  Also it's needed to program end_addr thorugh config DB.
   *  When programmed, the addresses generated will be random in the range [start_addr:end_addr].
   *  Note that this value will be ignored if hn_index is programmed through config DB.
   */
  bit [`SVT_CHI_MAX_ADDR_WIDTH-1:0] start_addr;

  /** End address for the sequence that needs to be programmed thorugh config DB.
   *  Also it's needed to program end_addr thorugh config DB.
   *  When programmed, the addresses generated will be random in the range [start_addr:end_addr].
   *  Note that this value will be ignored if hn_index is programmed through config DB.
   */  
  bit [`SVT_CHI_MAX_ADDR_WIDTH-1:0] end_addr;

  /** This enum is used to determine how address is generated for a transaction in the RN transaction sequence<br>
   *  - When hn_index is programmed through config DB, then the addr_mode is set to TARGET_HN_INDEX,<br> 
   *    and the address of the transaction is set to a random cacheline size aligned value which falls within the valid address range of the specified HN.<br>
   *  - When start_addr and end_addr are programmed through config DB, then the addr_mode is set to RANDOM_ADDRESS_IN_RANGE,<br>
   *    and the address of the transaction is set to a random cacheline size aligned value which falls within the valid address<br>
   *    range of start_addr and end_addr specified by the user.<br>
   *  - addr_mode can be directly programmed to SEQUENTIAL_NONOVERLAPPED_ADDRESS or RANDOM_ADDRESS by the user from the test using config DB or it takes RANDOM_NONOVERLAPPED_ADDRESS value by default.<br>
   *    - if addr_mode is set to SEQUENTIAL_NONOVERLAPPED_ADDRESS, then address for first transaction will be chosen randomly but addresses for<br> 
   *      subsequent transacitons will be incremented by one cacheline size from previous transaction address.<br>
   *    - if addr_mode is set to RANDOM_ADDRESS, the address of the transaction being generated is set to a random value within the system address range<br>
   *      and is either aligned or unaligned to the cacheline size. start_addr and end_addr, if programmed by the user are ignored.<br>
   *    .
   *  .
   */
  svt_chi_rn_coherent_transaction_base_sequence::addressing_mode_enum addr_mode = svt_chi_rn_coherent_transaction_base_sequence::RANDOM_NONOVERLAPPED_ADDRESS;
  
  /** @cond PRIVATE */
  /** Represents the RN_F node from which the sequence will be initiated. */ 
  rand int unsigned initiating_rn_f_node_index;
  
  /** Represents the RN_I node from which the sequence will be initiated. */ 
  rand int unsigned initiating_rn_i_node_index;

  /** Represents the RN_D node from which the sequence will be initiated. */ 
  rand int unsigned initiating_rn_d_node_index;
  
  /** Represents the RN node from which the sequence will be initiated. */ 
  rand int unsigned initiating_rn_node_index; 

  /** Active Participating SN node **/
  rand int active_participating_sn_node_index;

  `protected
U>6LF8UT(<JN:+=DK4L]X8a7></9E_HOF^fd6OUE;3S,SEg(63H^/)1g4P<K)FMD
JG2ENPOAMFGCR9g,<HIdT(#XZ<g.8fFWWGZe/dfHW>3T)&8/T)?Nb>g+(e.SO20)
cMQ7X3_5O(NSK:b)SRN-VYb1Z6/;ASE<Y-DB4_VMQe7,,YZGQN[TTfTVcL.VR^GP
VINSb,5PGb#S,$
`endprotected

  /** Field to track if both start_addr and end_addr are programmed */
  bit addr_ranges_programmed;

  /** Field to track if addr_mode is programmed*/
  bit addr_mode_programmed;
  
//  // Data value allows the user to program the data for Atomic compare transactions 
//  bit [`SVT_CHI_MAX_DATA_WIDTH-1:0] user_programmed_data = 64'hBEAD_FACE;
//
  /** Indicates whether this sequence is valid to run on RN-I node. 
   *  Note that this is for the is_supported() implementation. 
   *  So users are not expected to program this. 
   *  The extended sequences will set this field to 0 if that sequence is
   *  not applicable for RN-I. 
   */
  bit is_xact_type_valid_for_rn_i = 0;
  
  /** Indicates whether this sequence is valid to run on RN-D node. 
   *  Note that this is for the is_supported() implementation. 
   *  So users are not expected to program this. 
   *  The extended sequences will set this field to 0 if that sequence is
   *  not applicable for RN-D. 
   */
  bit is_xact_type_valid_for_rn_d = 0;

`ifdef SVT_CHI_ISSUE_B_ENABLE

  /** Variable used to decide if requesting Node can be Snooped or not.
   *  This can be programmed using config DB.
   *  If not programmed, the request snoopme field in the generated transaction will be randomized
   */
  int unsigned snoop_me_config_db = 0;
  bit snoop_me_status = 0;
  bit atomic_compare_data_same_as_mem_data_status = 0;
  int unsigned atomic_compare_data_same_as_mem_data_config_db = 0;

  /** Variable used to decide the Endianness of the outbound NonCopyBack Write data sent in Atomic transactions.
   *  This can be programmed using config DB.
   *  If not programmed, the request enum field in the generated transaction will be randomized
   */
  svt_chi_common_transaction::endian_enum  endian_config_db = svt_chi_common_transaction::LITTLE_ENDIAN;
  bit endian_status = 0;
`endif  

  /** Randomize the initiatiating RN node **/
  constraint initiating_rn_c {
    if (active_participating_rn_nodes.size())
    {
      initiating_rn_node_index inside {active_participating_rn_nodes};
    }
  }  

  /** Randomize the initiatiating RN_F node **/
  constraint initiating_rn_f_c {
    if(active_participating_rn_f_nodes.size())
    {
     initiating_rn_f_node_index inside {active_participating_rn_f_nodes};
    }
  }

  /** Randomize the initiatiating RN_I node **/
  constraint initiating_rn_i_c {
    if(active_participating_rn_i_nodes.size())
    {
     initiating_rn_i_node_index inside {active_participating_rn_i_nodes}; 
    }
  }
  
  /** Randomize the initiatiating RN_D node **/
  constraint initiating_rn_d_c {
    if(active_participating_rn_d_nodes.size())
    {
     initiating_rn_d_node_index inside {active_participating_rn_d_nodes}; 
    }
  }

  /** Randomize the Active participating SN node **/
  constraint active_participating_sn_c { 
    if(active_participating_sn_nodes.size())
    {
     active_participating_sn_node_index inside {active_participating_sn_nodes};
    }
  }
  /** @endcond */

  `svt_xvm_object_utils(  svt_chi_system_single_node_rn_coherent_transaction_base_virtual_sequence)

  function new(string name = "  svt_chi_system_single_node_rn_coherent_transaction_base_virtual_sequence");
    super.new(name);
  endfunction
  
  /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting RN-F Nodes = 1
   *          (or)
   *  #- minimum supporting RN-I Nodes = 1
   *          (or)
   *  #- minimum supporting RN-D Nodes = 1
   */
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    /** local variables */
    int   array_idx = -1;
    string str_rn_f_node,str_rn_i_node,str_rn_d_node, str_rn_node, str_hn_f_node, str_hn_i_node;
    string str_illegal_programing_select_rn_f_node, str_illegal_programing_select_rn_i_node;
    string str_is_supported_info_prefix = "This sequence cannot be run based on the current system configuration.\n";
    string str_is_supported_info = "";
    string str_is_supported_info_suffix = "Modify configurations through \n\
                                           svt_chi_system_configuration::num_rn, \n\
                                           svt_chi_node_configuration::is_active,\n\
                                           svt_chi_system_configuration::participating_rn_nodes[]\n";
    `svt_xvm_debug("is_supported",$sformatf("calling is_supported"));

    /** By default is_supported is 0 */
    is_supported = 0;

    /** Display the contents of Active Participating RN_F Nodes */
    foreach (active_participating_rn_f_nodes[j]) begin
      str_rn_f_node = {str_rn_f_node, $sformatf(" %0d", active_participating_rn_f_nodes[j])};
    end 
    `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_f_nodes are %s", str_rn_f_node));
 
    /** Display the contents of Active Participating RN_I Nodes */
    foreach (active_participating_rn_i_nodes[j]) begin
      str_rn_i_node = {str_rn_i_node, $sformatf(" %0d", active_participating_rn_i_nodes[j])};
    end 
    `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_i_nodes are %s", str_rn_i_node));
 
    /** Display the contents of Active Participating RN_D Nodes */
    foreach (active_participating_rn_d_nodes[j]) begin
      str_rn_d_node = {str_rn_d_node, $sformatf(" %0d", active_participating_rn_d_nodes[j])};
    end 
    `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_d_nodes are %s", str_rn_d_node));
 
    /** Display the contents of Active Participating RN Nodes */
    foreach (active_participating_rn_nodes[j]) begin
      str_rn_node = {str_rn_node, $sformatf(" %0d", active_participating_rn_nodes[j])};
    end 
    `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_nodes are %s", str_rn_node));
    
    /** Display the contents of HN-F Nodes */
    foreach (hn_f_nodes[j]) begin
      str_hn_f_node = {str_hn_f_node, $sformatf(" %0d", hn_f_nodes[j])};
    end 
    `svt_xvm_debug("is_supported", $sformatf("contents of hn_f_nodes are %s", str_hn_f_node));

    /** Display the contents of HN-I Nodes */
    foreach (hn_i_nodes[j]) begin
      str_hn_i_node = {str_hn_i_node, $sformatf(" %0d", hn_i_nodes[j])};
    end 
    `svt_xvm_debug("is_supported", $sformatf("contents of hn_i_nodes are %s", str_hn_i_node));

    /**
     * Algorithm for checking is_supported, related to node_index:
     * - If node_index is passed through config DB:
     *   + If it's valid to initiate the sequence from RN-I.RN_D as well, then the
     *     node_index should be part of active_participating_rn_nodes.
     *   + If it's not valid to initiate the sequence from RN-I,RN_D, then the
     *     node_index should be part of active_participating_rn_f_nodes.
     *   .
     * - If node_index is not passed through config DB:
     *   + If only select_rn_f_node is set to 1:
     *     o node_index should be part of active_participating_rn_f_nodes
     *     .
     *   + If only select rn_i_node is set to 1:
     *     o It should be valid to initiate the sequence from RN-I. 
     *     o node_index should be part of active_participating_rn_i_nodes.
     *     .
     *   + If only select rn_d_node is set to 1:
     *     o It should be valid to initiate the sequence from RN-D. 
     *     o node_index should be part of active_participating_rn_d_nodes.
     *     .
     *   + If select_rn_f_node, select_rn_i_node, select_rn_d_node are set to 0 or 1 together:
     *     o If it's valid to initiate the sequence from RN-I, RN_D as well, then the
     *       node_index should be part of active_participating_rn_nodes.
     *     o If it's not valid to initiate the sequence from RN-I, RN_D then the 
     *       node_index should be part of active_participating_rn_f_nodes.
     *     .
     *   .
     * .
     */  
    // node_index is passed through config DB OR
    // it's the condition that node_index can be either of RN-I/RN-F/RN-D
    // types as programmed through config DB
    if ((node_index_status) ||
        ((select_rn_f_node && select_rn_i_node && select_rn_d_node) || 
         ((!select_rn_f_node) && (!select_rn_i_node) && (!select_rn_d_node))
        )
       ) begin
      string str_input_mode = (node_index_status)?" passed through config DB":"";
      if (sys_cfg.rn_cfg[node_index].chi_interface_type == svt_chi_node_configuration::RN_D)begin
      // If node_index is passed through config DB, check validity
        if (is_xact_type_valid_for_rn_d) begin
          // If RN-D can be valid initiating node, check if node_index is part of active_participating_rn_nodes
          is_supported = is_value_found_in_int_assoc_array(active_participating_rn_nodes, node_index, array_idx);
          if (!is_supported) begin
            str_is_supported_info = $sformatf("node_index %0d%0s is not valid for this sequence. The RN corresponding to svt_chi_system_configuration::rn_cfg[%0d] is not active(svt_chi_node_configuration::is_active is 0) and not participating (not part of the array svt_chi_system_configuration::participating_rn_nodes[])", node_index, str_input_mode, node_index);
          end
        end
      end else if (sys_cfg.rn_cfg[node_index].chi_interface_type == svt_chi_node_configuration::RN_I)begin
        // If node_index is passed through config DB, check validity
      if (is_xact_type_valid_for_rn_i) begin
        // If RN-I can be valid initiating node, check if node_index is part of active_participating_rn_nodes
        is_supported = is_value_found_in_int_assoc_array(active_participating_rn_nodes, node_index, array_idx);
        if (!is_supported) begin
          str_is_supported_info = $sformatf("node_index %0d%0s is not valid for this sequence. The RN corresponding to svt_chi_system_configuration::rn_cfg[%0d] is not active(svt_chi_node_configuration::is_active is 0) and not participating (not part of the array svt_chi_system_configuration::participating_rn_nodes[])", node_index, str_input_mode, node_index);
        end
      end
      end
      else begin
        // If only RN-F can be valid initiating node, check if node_index is part of active_participating_rn_f_nodes
        is_supported = is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, node_index, array_idx);
        if (!is_supported) begin
          str_is_supported_info = $sformatf("node_index %0d%0s is not valid for this sequence. The RN corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and participating RN-F type(should be part of the array svt_chi_system_configuration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F).", node_index, str_input_mode, node_index);
        end
      end
    end // if ((node_index_status) ||...
    // node_index is not passed through config DB AND
    // node_index is programmed to be selected a RN-F node type.
    else if ((select_rn_f_node) && (!select_rn_i_node) && (!select_rn_d_node)) begin
      is_supported = is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, node_index, array_idx);
      if (!is_supported) begin
        str_is_supported_info = $sformatf("select_rn_f_node is set to 1. node_index %0d is not valid for this sequence. The RN corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and participating RN-F type(should be part of the array svt_chi_system_configuration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F).", node_index, node_index);
      end
    end
    // node_index is not passed through config DB AND
    // node_index is programmed to be selected as RN-I node type.
    else if ((!select_rn_f_node) && (select_rn_i_node) && (!select_rn_d_node)) begin
      if (!is_xact_type_valid_for_rn_i) begin
        str_is_supported_info = "select_rn_i_node is set to 1. However, this sequence cannot be initiated from RN-I node";
      end
      else begin
        is_supported = is_value_found_in_int_assoc_array(active_participating_rn_i_nodes, node_index, array_idx);
        if (!is_supported) begin
          str_is_supported_info = $sformatf("select_rn_i_node is set to 1. node_index %0d is not valid for this sequence. The RN corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and participating RN-I type(should be part of the array svt_chi_system_configuration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_I).", node_index, node_index);
        end
      end
    end // if ((!select_rn_f_node) && (select_rn_i_node) && (!select_rn_d_node))
    // node_index is not passed through config DB AND
    // node_index is programmed to be selected as RN-D node type.
    else if ((!select_rn_f_node) && (!select_rn_i_node) && (select_rn_d_node)) begin
      if (!is_xact_type_valid_for_rn_d) begin
        str_is_supported_info = "select_rn_d_node is set to 1. However, this sequence cannot be initiated from RN-D node";
      end
      else begin
        is_supported = is_value_found_in_int_assoc_array(active_participating_rn_d_nodes, node_index, array_idx);
        if (!is_supported) begin
          str_is_supported_info = $sformatf("select_rn_d_node is set to 1. node_index %0d is not valid for this sequence. The RN corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and participating RN-D type(should be part of the array svt_chi_system_configuration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_D).", node_index, node_index);
        end
      end
    end // if ((!select_rn_f_node) && (!select_rn_i_node) && (select_rn_d_node))
    // node_index is not passed through config DB AND
    // node_index is not programmed correctly, only one flag is expected to be programmed among select_rn_f_node, select_rn_i_node, select_rn_d_node.
    else begin
       `svt_xvm_error("is_supported",$psprintf("Only one flag is expected to assert at a time. Reconfigure the flags select_rn_f_node - %0d, select_rn_i_node - %0d, select_rn_d_node - %0d", select_rn_f_node, select_rn_i_node, select_rn_d_node));;
    end
    /** 
     * If hn_index is programmed, make sure that it's one of the {hn_f_nodes,hn_i_nodes}.
     * If hn_index is not pgorammed, but both the start_addr, end_addr are programmed,
     * start_addr should be <= end_addr.
     * 
     */
    if (hn_index_status) begin
      if (!(hn_index inside{hn_f_nodes, hn_i_nodes})) begin
        is_supported = 0;
        str_is_supported_info = $sformatf("%0s \nhn_index %0d programmed is not part of both HN-F node indices %0s and HN-I node indices %0s. hn_index should be one of the HN-F or HN-I node indices.", str_is_supported_info,hn_index, str_hn_f_node, str_hn_i_node);
      end
    end
    else if (addr_ranges_programmed) begin
      if (start_addr > end_addr) begin
        is_supported = 0;
        str_is_supported_info = $sformatf("%0s \nstart_addr 'h%0h is greater than end_addr 'h%0h. start_addr should be less than or equal to end_addr.", str_is_supported_info, start_addr, end_addr);
      end
    end
    else if (addr_mode_programmed) begin
      if ((addr_mode != svt_chi_rn_coherent_transaction_base_sequence::SEQUENTIAL_NONOVERLAPPED_ADDRESS) && (addr_mode != svt_chi_rn_coherent_transaction_base_sequence::RANDOM_ADDRESS)) begin
        is_supported = 0;
        str_is_supported_info = $sformatf("%0s \addr_mode_programmed is set to 1. but the addr_mode is %0s, start_addr is 'h%0h, end_addr is 'h%0h. However, this addr_mode is not directly supported through config DB yet. Ignoring the setting.", str_is_supported_info, addr_mode.name(), start_addr, end_addr);
      end
    end

    if (!is_supported) begin
      string str_complete_is_supported_info = {str_is_supported_info_prefix, str_is_supported_info, str_is_supported_info_suffix};
      issue_is_supported_failure(str_complete_is_supported_info);
    end
  endfunction : is_supported
  
  virtual task pre_start();
    bit status;
    super.pre_start();
    raise_phase_objection();
`ifdef SVT_UVM_TECHNOLOGY
  `ifdef SVT_CHI_ISSUE_B_ENABLE    
    cache_init_for_non_coh_status = uvm_config_db#(bit)::get(null, get_full_name(), "perform_cacheinit_for_non_coherent_xacts", perform_cacheinit_for_non_coherent_xacts);
  `endif
    `protected
QIB\8[,VF<.(AG2Ufd=deMdV]+J\,XVd2W>8::[\1UJ(=5FBTRc_0)D0+dAEE#eA
@[U;7SD?<=S-1VY;CW,b)XMJb8c51HR1T)EH)L]TfG(&c3WW.1V9G3<g(;^DQ,.+
e:;_X\6JG^/MTa=>Q[0LK>6KJ]JdAYY_g/a&,W(Kf.HE1N5RJLNOeU-0E=Hf.ZVF
KZJad9Z6TG&PLPJ:S[Yf60W28GE=1ESAf;(QZHR>gXEX6:B[Je+2CZCZF\[#[D<I
&UO=fYZ[Q_eK;AU2W7)=fRW23$
`endprotected

    node_index_status = uvm_config_db#(int unsigned)::get(null, get_full_name(), "node_index", node_index);
    select_rn_f_node_status = uvm_config_db#(int unsigned)::get(null, get_full_name(), "select_rn_f_node", select_rn_f_node);
    select_rn_i_node_status = uvm_config_db#(int unsigned)::get(null, get_full_name(), "select_rn_i_node", select_rn_i_node);
    select_rn_d_node_status = uvm_config_db#(int unsigned)::get(null, get_full_name(), "select_rn_d_node", select_rn_d_node);
    request_ordering_status = uvm_config_db#(int unsigned)::get(null, get_full_name(), "request_ordering", request_ordering);
    gen_diff_txn_id_status = uvm_config_db#(int unsigned)::get(null, get_full_name(), "gen_diff_txn_id", gen_diff_txn_id);
    start_addr_status = uvm_config_db#(bit[`SVT_CHI_MAX_ADDR_WIDTH-1:0])::get(null, get_full_name(), "start_addr",start_addr);
    end_addr_status = uvm_config_db#(bit[`SVT_CHI_MAX_ADDR_WIDTH-1:0])::get(null, get_full_name(), "end_addr",end_addr);
    hn_index_status = uvm_config_db#(int unsigned)::get(null, get_full_name(), "hn_index",hn_index);
    addr_mode_status = uvm_config_db#(svt_chi_rn_coherent_transaction_base_sequence::addressing_mode_enum)::get(null, get_full_name(), "addr_mode",addr_mode);

`elsif SVT_OVM_TECHNOLOGY
  `ifdef SVT_CHI_ISSUE_B_ENABLE       
    cache_init_for_non_coh_status = m_sequencer.get_config_int({get_type_name(), ".perform_cacheinit_for_non_coherent_xacts"}, perform_cacheinit_for_non_coherent_xacts);
  `endif
  `protected
Y9K:IGK3T]AfWLWXa@C75+QQRDaOQA0,5I,D;ee@^=SNS,T\ND/O&)\=BN3XJ\6B
+6>4RH=RP.D<;Vd@ZC>BR3f<0Uce,eHV)&CXWDgS-fK]SWSCf3->?]VS5NAD-aeK
TF1;Vc<RH2gWVS[]b4RK=VL_ZL^Z-79[=d^L#SXTYB[\bNIT(Z94M^A>Hb@U[4N#
@9,\>[SVa;LA3;&X:@XIY85A@aIF\2_LYV_.-#_F?P.<S.O>d9cS>]-1AL>/X\(=
Gaeb48[BQAOA0$
`endprotected

    node_index_status = m_sequencer.get_config_int({get_type_name(), ".node_index"}, node_index);
    select_rn_f_node_status = m_sequencer.get_config_int({get_type_name(), ".select_rn_f_node"}, select_rn_f_node);
    select_rn_i_node_status = m_sequencer.get_config_int({get_type_name(), ".select_rn_i_node"}, select_rn_i_node);
    select_rn_d_node_status = m_sequencer.get_config_int({get_type_name(), ".select_rn_d_node"}, select_rn_d_node);
    request_ordering_status = m_sequencer.get_config_int({get_type_name(), ".request_ordering"}, request_ordering);
    gen_diff_txn_id_status = m_sequencer.get_config_int({get_type_name(), ".gen_diff_txn_id"}, gen_diff_txn_id);
    start_addr_status = m_sequencer.get_config_int({get_type_name(), ".start_addr"}, start_addr);
    end_addr_status = m_sequencer.get_config_int({get_type_name(), ".end_addr"}, end_addr);
    hn_index_status = m_sequencer.get_config_int({get_type_name(), ".hn_index"}, hn_index);
    addr_mode_status = svt_chi_rn_coherent_transaction_base_sequence::addressing_mode_enum'(m_sequencer.get_config_int({get_type_name(), ".addr_mode"},addr_mode));
`endif

`ifdef SVT_CHI_ISSUE_B_ENABLE    
    `svt_xvm_debug("pre_start", $sformatf("perform_cacheinit_for_non_coherent_xacts is %0b as a result of %0s.", perform_cacheinit_for_non_coherent_xacts, cache_init_for_non_coh_status ? "config DB" : "default value"));
`endif
    `protected
@4O8](4gbbKG=KFD+c\eG<+#^Dc0N&YcO?>-;/3;<I>:Y/YP?O/S5)=dP17W//KY
ZLAbaN#g>dL2X]QO4F_H/L5dX:6.=:9G8LMK6N3TU<ZE]dQLR=_BM^A3#5bH@UH1
/4^K#fM1AQfV5Q=P4<]&[+^.2K31WZMXCe>@6E:AD-94Td]RK4M0UaW53?^F4=@J
,#Q.T.F]^0/14Ta>R8X7edLKUaa^3cOT;7OEWV))BMKE+,#>>,?3K3T4P2)=X((f
[2X]&MA_?/0^[2f=,:d1RUZ7]IDgfE+^6Y]g[IfD]N4^SQ?GIPNP2.NW5F.e7b&>
_4S:=MZFU_+IcFEQ>,\K2DZ74$
`endprotected

    `svt_xvm_debug("pre_start", $sformatf("node_index is %0d as a result of %0s.", node_index, node_index_status ? "config DB" : "default value"));
    `svt_xvm_debug("pre_start", $sformatf("select_rn_f_node is %0d as a result of %0s.", select_rn_f_node, select_rn_f_node_status ? "config DB" : "default value"));
    `svt_xvm_debug("pre_start", $sformatf("select_rn_i_node is %0d as a result of %0s.", select_rn_i_node, select_rn_i_node_status ? "config DB" : "default value"));
    `svt_xvm_debug("pre_start", $sformatf("select_rn_d_node is %0d as a result of %0s.", select_rn_d_node, select_rn_d_node_status ? "config DB" : "default value"));
    `svt_xvm_debug("pre_start", $sformatf("request_ordering is %0d as a result of %0s.", request_ordering, request_ordering_status ? "config DB" : "default value"));
    `svt_xvm_debug("pre_start", $sformatf("gen_diff_txn_id  is %0d as a result of %0s.", gen_diff_txn_id, gen_diff_txn_id_status ? "config DB" : "default value"));
    `svt_xvm_debug("pre_start", $sformatf("addr_mode_status is %0d addr_mode is %0s. start_addr is 'h%0h, end_addr is updated to 'h%0h based on sequence_length %0d.",addr_mode_status,addr_mode.name(), start_addr, end_addr, sequence_length));

    if (hn_index_status) begin
       `svt_xvm_debug("pre_start", $sformatf("hn_index is 'd%0d as a result of config DB. Any values programmed for start_addr and end_addr will be ignored.", hn_index));
    end
    else begin
      addr_ranges_programmed = ((start_addr_status && end_addr_status)?1:0);

        
      if (addr_ranges_programmed) begin
        `svt_xvm_debug("pre_start", $sformatf("addr_ranges_programmed is 1. start_addr is 'h%0h, end_addr is 'h%0h as a result of config DB.", start_addr, end_addr));
      end
      
      if (addr_mode_status) begin
        if (addr_mode == svt_chi_rn_coherent_transaction_base_sequence::SEQUENTIAL_NONOVERLAPPED_ADDRESS) begin
          end_addr = (start_addr + ((sequence_length-1) * `SVT_CHI_CACHE_LINE_SIZE));
          addr_mode_programmed = 1;
          `svt_xvm_debug("pre_start", $sformatf("addr_mode_status is 1. addr_mode is %0s. start_addr is 'h%0h, end_addr is updated to 'h%0h based on sequence_length %0d.", addr_mode.name(), start_addr, end_addr, sequence_length));
        end
        else if (addr_mode == svt_chi_rn_coherent_transaction_base_sequence::RANDOM_ADDRESS) begin
          addr_mode_programmed = 1;
          `svt_xvm_debug("pre_start", $sformatf("addr_mode_status is 1. addr_mode is %0s allows the RN to generate aligned/unaligned address for a given transaction ignoring the start_addr and end_addr is programmed by the user. sequence_length %0d.", addr_mode.name(), sequence_length));
        end
        else begin
          `svt_xvm_debug("pre_start", $sformatf("addr_mode_status is 1. addr_mode is %0s. start_addr is 'h%0h, end_addr is 'h%0h , sequence_length is %0d. However, this addr_mode is not directly supported through config DB yet. Ignoring the setting.", addr_mode.name(), start_addr, end_addr, sequence_length));
        end
      end
      else if ((start_addr_status && (!end_addr_status)) ||
               ((!start_addr_status) && end_addr_status)) begin
        `svt_xvm_debug("pre_start", $sformatf("Both start_addr and end_addr need to be programmed together through config DB. start_addr is %0s, end_addr is %0s.", 
                                        (start_addr_status?"programmed":"not programmed"), (end_addr_status?"programmed":"not programmed")));
      end
    end // else: !if(hn_index_status)
    
    if (node_index_status) begin
      node_index = this.node_index;
    end
    else begin
      string str_msg, str_msg_prefix, str_full_msg;
      str_msg_prefix = $sformatf("select_rn_f_node = %0d. select_rn_i_node = %0d. select_rn_d_node = %0d is_xact_type_valid_for_rn_i = %0d. is_xact_type_valid_for_rn_d = %0d", select_rn_f_node, select_rn_i_node, select_rn_d_node, is_xact_type_valid_for_rn_i, is_xact_type_valid_for_rn_d);
      str_msg = $sformatf(" node_index is same as initiating_rn_f_node_index %0d.", initiating_rn_f_node_index);
      // Setup default value of node_index as RN-F type
      node_index = initiating_rn_f_node_index;
      if ((is_xact_type_valid_for_rn_i) || (is_xact_type_valid_for_rn_d)) begin
        if (
            ((select_rn_f_node == 0) && (select_rn_i_node == 0) && (select_rn_d_node == 0)) ||
            ((select_rn_f_node == 1) && (select_rn_i_node == 1) && (select_rn_d_node == 1))
           ) begin
          // Either of RN-F/RN-I/RN-D type can be selected
          node_index = initiating_rn_node_index;
          str_msg = $sformatf("node_index is same as initiating_rn_node_index %0d.", initiating_rn_node_index);          
        end
        else if ((select_rn_i_node) && (!select_rn_d_node)) begin
          // Only RN-I can be selected
          node_index = initiating_rn_i_node_index;
          str_msg = $sformatf("node_index is same as initiating_rn_i_node_index %0d.", initiating_rn_i_node_index);                    
        end
        else if ((!select_rn_i_node) && (select_rn_d_node)) begin
          // Only RN-D can be selected
          node_index = initiating_rn_d_node_index;
          str_msg = $sformatf("node_index is same as initiating_rn_i_node_index %0d.", initiating_rn_d_node_index);                    
        end
      end // if ((is_xact_type_valid_for_rn_i) || (is_xact_type_valid_for_rn_d))
      str_full_msg = {str_msg_prefix,str_msg};
      `svt_xvm_debug("pre_start", str_full_msg);
    end // if (!node_index_status)
    `svt_xvm_debug("pre_start", $sformatf("node_index is %0d as a result of %0s.", node_index, node_index_status ? "config DB" : "randomization"));    
  endtask // pre_start
  

 /** Drop objection */
  virtual task post_start();
    super.post_start();
    drop_phase_objection();
  endtask: post_start

      
  task send_coherent_transactions(svt_chi_common_transaction::xact_type_enum rn_xact_type ,bit init_cachelines);

    `svt_xvm_create_on(coherent_seq, p_sequencer.rn_virt_seqr[node_index].rn_xact_seqr)    
    coherent_seq.disable_all_weights();
    coherent_seq.assign_xact_weights(rn_xact_type);
    if (hn_index_status) begin
      coherent_seq.addr_mode = svt_chi_rn_coherent_transaction_base_sequence::TARGET_HN_INDEX;
    end
    // addr_mode_programmed is set to 1 for the following address modes
    // svt_chi_rn_coherent_transaction_base_sequence::SEQUENTIAL_NONOVERLAPPED_ADDRESS
    // svt_chi_rn_coherent_transaction_base_sequence::RANDOM_ADDRESS
    else if (addr_mode_programmed) begin
      coherent_seq.addr_mode = this.addr_mode;
    end
    else if (addr_ranges_programmed) begin
      coherent_seq.addr_mode = svt_chi_rn_coherent_transaction_base_sequence::RANDOM_ADDRESS_IN_RANGE;
    end
    coherent_seq.initialize_cachelines = init_cachelines ;

    `svt_xvm_debug("send_coherent_transactions",$sformatf("Updated the svt_chi_rn_coherent_transaction_base_sequence::addr_mode=%s with addr_mode=%s passed from test. addr_ranges_programmed=%0d hn_index_status=%0d %s",coherent_seq.addr_mode.name(),this.addr_mode.name(),addr_ranges_programmed,hn_index_status,coherent_seq.addr_mode.name()));

`ifdef SVT_CHI_ISSUE_B_ENABLE
    coherent_seq.perform_cacheinit_for_non_coherent_xacts = perform_cacheinit_for_non_coherent_xacts;
    
    `svt_xvm_debug("send_coherent_transactions",$sformatf("snoop_me_status=%0d endian_status=%0d atomic_compare_data_same_as_mem_data_status=%0d snoop_me_config_db=%0d endian_config_db=%0d atomic_compare_data_same_as_mem_data_config_db=%0d",snoop_me_status,endian_status,atomic_compare_data_same_as_mem_data_status,snoop_me_config_db,endian_config_db,atomic_compare_data_same_as_mem_data_config_db));
`endif    

    void'(coherent_seq.randomize with {
                                   use_directed_addr == 0;
                                   sequence_length==local::sequence_length;
                                   if (hn_index_status) seq_hn_node_idx==local::hn_index;
                                   if (addr_ranges_programmed || addr_mode_programmed) start_addr==local::start_addr;
                                   if (addr_ranges_programmed || addr_mode_programmed) end_addr==local::end_addr;
                                   if (request_ordering == 1) seq_order_type != svt_chi_transaction::NO_ORDERING_REQUIRED;
                                   if (((rn_xact_type == svt_chi_transaction::WRITEUNIQUEPTL) || (rn_xact_type == svt_chi_transaction::WRITEUNIQUEFULL) 
          `ifdef SVT_CHI_ISSUE_E_ENABLE
                                        || (rn_xact_type == svt_chi_transaction::WRITEUNIQUEZERO) || (rn_xact_type == svt_chi_transaction::WRITEUNIQUEPTL_CLEANSHARED) || (rn_xact_type == svt_chi_transaction::WRITEUNIQUEPTL_CLEANSHAREDPERSISTSEP) || (rn_xact_type == svt_chi_transaction::WRITEUNIQUEFULL_CLEANSHARED) || (rn_xact_type == svt_chi_transaction::WRITEUNIQUEFULL_CLEANSHAREDPERSISTSEP)
          `endif
                                       ) && request_ordering == 1) seq_order_type == svt_chi_transaction::REQ_ORDERING_REQUIRED;
                                   if (gen_diff_txn_id) generate_unique_txn_id == 1;
                                   `ifdef SVT_CHI_ISSUE_B_ENABLE
                                     if (request_ordering == 1) seq_order_type != svt_chi_transaction::REQ_ACCEPTED;
                                     if (snoop_me_status) seq_snoopme == snoop_me_config_db;
                                     if (endian_status) seq_endian == endian_config_db;
                                     if (atomic_compare_data_same_as_mem_data_status) seq_atomic_compare_data_same_as_mem_data == atomic_compare_data_same_as_mem_data_config_db;
                                   `endif
                                   if (request_ordering == 0) seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
                                });
     coherent_seq.start(p_sequencer.rn_virt_seqr[node_index].rn_xact_seqr);

   endtask
`protected
[1Q88P5df(,[(/Gf=BgM9=Z8O9)&TVU@LQ_N>@e1^0O)DW;We#1;5)1fK)KeFN_W
gOE6Kgd(a+M,cTc_DXQX3e8/[>^[VQVeWTG6N4ZWWWa\/XCUU]5LF8/VC4ZH&-X2
G=;VV1.?QAaIUWY]BdN:2@RNMRNeP3]V8@aP7F2C-b/L@<U_8F.-@a]?T>.LW&:O
X/4TH[1QCR[Z.UQ-14dJ8;T6>R+KZFc6[]BP^Wd9.f>X5B/&ga=^92Q\BSCVUY;4
9NJ>-VD.2f]gV8N9X>-fd;(NXff?Na@VP+eFU^O+b+?Z]/NGN;HC>Z.B0(MJM(2W
<=5^-(FDDV9[4&\7-d4@cZYgFZ9/#<I9EL;_8aceGWCRP],3391H_CEcHIeQ4aVI
ZbA+1>6)d1D7+3d?186\]=F=44adCG>Q4,LT\CQ/P^;7eF=0NMBg]&X=4gY:&>VL
3ATcSN],QQYT2eNUB@b96Z+6<;;I>77bEOTO8b6CbCWZZ1[OW&E:e]]e_SU@d9Of
/>>#d;<:#F0dS.,IXYY)GRA.P:9+7>5,FT\NA::0VWF>TP8-=7d18BPJKc<-1KF)
,_?7>g-&UZ03^/RU@Wed:A:;fFBd:EVKEf?FR#>?3LVJ43(A\H#K4FYGJ&C[K&B.
5]S-<=A_/JLT544:WOaF4]YT14+Nfec5L]PDH1eA/UI@-=@#-9VCd<\7@:S=J[P-
?&IBbZ0FTA?bW+.M[9I@Q;2:0;WAQUZbVGWDQA:V^1^NF;3=@?g_Tb_.b63gAR6D
LSH\5>Ia7T.\[2=::OY(A.+S?[\bWfBR<-D+R?(E24L2NO&&&&GSOZ(&5?38UI-]
(HJdTXNN\Q(ea+<N5/Z4@&T@gC6J_UR9W0Y_DRcAP;=37H(&[;d6RCY62MZN0K^#
17bO\E#CFf18W#CDcd;f=PCJ(d(AH&_JV(75=CG]R>BL5XO\Q2WDPgT,g?82OSP\
,#_;M[\JN;MCGM5F?ec(-BXAT)/TMB1:A0=0[@@ZLS80;1L?8;a-B+81]T+b0ERI
MRM&/^@;EWPQg-afQbBUQcSSRaIVb\LO0OT@MW2FZ]QXc4CFJS/2NK,G9_B]Lb^Q
)cY])@KbA#9,.@DI=I3597&_gZc62eEYV0AZ#<OC18XfQgXY^e-PF4gGZ07G,/DU
<J6A29>^gEXW4BXZ0G\&A_E(faU,9c]c;:a-M^,bf@OEUO[Oe)ITRYNe^?M12WbN
QU/(:K3f)K_2b_^/L+/T2\#+gRQa)XAJC0FEDEYRVdU0N@\_;g.>g/RC>-gc(e<1
?_P>R5H/6RES.Ce02B2FT.3X,.KC8KdG1AJTCMbW8fd???=U5@9,)M0HF;C?G)/a
@dfAOMF.H.Z6>V#-gQC/-G470A1>?W7X+2:/8)7:Z,Wg1PY4UH=M(F[V;(^RS8BD
WY<@VgRJ50,Gg>1^@XETJ=d=PbBU4^CF@8_V\ScRP7HWc4L;)])GK4H^LQ&>Nb86
&0)SK21UB_]Le6I<<:;40_-Y43=PD8M[XD=O;H?g.JA@J2FX;-S</1@U#Z))WYUR
MV;^645\3e.94N8b8.KeISL-F?O?4g</e/4TObLGeM1T=F+?ZgQB[W[TdV/0HJ[-
^OM2>-0[@64R?+Fgf_R:_.JIB@H,YcCJ?JHVC7^N+dL-7ZY&>1CU[J&S6_VZ/E^.
I.6KZ,1R)OU4O+McA-NYc2]?QTC,&?C4Ge==#/d/;F(KSe0G;VU6a:e7MJ\EXMQ3
bP43OA<,fHWH,Ie^6(]3[E,I(ZXU5F0O>$
`endprotected

endclass: svt_chi_system_single_node_rn_coherent_transaction_base_virtual_sequence

// **************************************************************************
// ************************* BASIC LEVEL SEQUENCES *******************
// **************************************************************************

//------------------------------------------------------------------------------
class svt_chi_system_multi_node_random_virtual_sequence extends svt_chi_system_single_node_rn_coherent_transaction_base_virtual_sequence;
  
  bit[`SVT_CHI_MAX_ADDR_WIDTH-1:0]            _addr, coh_addrs[$] = {8'h00, 8'h40, 8'h80, 8'hC0};
  svt_chi_common_transaction::xact_type_enum  _xact_type, store_types[$], cmo_types[$], load_types[$], evict_types[$], memupdate_types[$];

  `svt_xvm_object_utils(svt_chi_system_multi_node_random_virtual_sequence)
  
  function new(string name = "svt_chi_system_multi_node_random_virtual_sequence");
    super.new(name);
  endfunction

  //
  // Initializes cachelines and sends random transactions from multiple nodes
  // 
  virtual task body();
    super.body();

    //  check if current environment is supported or not 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end
    load_types = {svt_chi_common_transaction::READSHARED, svt_chi_common_transaction::READCLEAN, svt_chi_common_transaction::READONCE};
    store_types = {svt_chi_common_transaction::READUNIQUE, svt_chi_common_transaction::MAKEUNIQUE, svt_chi_common_transaction::CLEANUNIQUE};
    cmo_types = {svt_chi_common_transaction::MAKEINVALID, svt_chi_common_transaction::CLEANINVALID, svt_chi_common_transaction::CLEANSHARED};
    evict_types = {svt_chi_common_transaction::EVICT, svt_chi_common_transaction::WRITEEVICTFULL, svt_chi_common_transaction::CLEANSHARED};
    memupdate_types = {svt_chi_common_transaction::WRITEBACKFULL, svt_chi_common_transaction::WRITEBACKPTL, 
                       svt_chi_common_transaction::WRITECLEANFULL, svt_chi_common_transaction::WRITECLEANPTL};
    //  active_participating_rn_f_nodes
    for(int i=0; i<sequence_length; i++) begin
      node_index = i%2;
      if(i<4) begin
         send_coherent_transactions(load_types[0],0);
         //send_directed_coherent_transactions(load_types[0] ,0, coh_addrs[1],i%4);
      end else begin
         send_coherent_transactions(load_types[0],0);
         //send_directed_coherent_transactions(load_types[0] ,0, coh_addrs[1],i%4);
      end
      // Wait for readshared transactions to finish 
      coherent_seq.wait_for_active_xacts_to_end();
    end
    print_caches();
    
  endtask: body
endclass: svt_chi_system_multi_node_random_virtual_sequence


//------------------------------------------------------------------------------
/** 
 * @groupname CHI_SINGLE_RN_WR_TYPE
 *  This sequence initiates Write transaction followed by CMO targeting the same address from the RN-F node specified with 
 *  node_index, which can be a random node or a specific node configured by the user.
 *  The transactions will be targeted to a random address that is serviced by the target HN specfied with target_hn_node_idx_0.
 *  If the target_hn_node_idx_0 is not configured by the user, it will be set to its default value '0'.
 */

class svt_chi_system_single_node_write_followed_by_cmo_virtual_sequence extends svt_chi_system_single_node_rn_coherent_transaction_base_virtual_sequence;
  
  `svt_xvm_object_utils(svt_chi_system_single_node_write_followed_by_cmo_virtual_sequence)
  
  function new(string name = "svt_chi_system_single_node_write_followed_by_cmo_virtual_sequence");
    super.new(name);
  endfunction

  /**
   * Initializes cachelines and sends readshared from node "node_index"
   */
  virtual task body();
    svt_chi_rn_cmo_type_transaction_directed_sequence cmo_seq_0[int],cmo_seq_1[int];
    svt_chi_rn_write_type_transaction_directed_sequence write_seq_0[int];
    super.body();

    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db:0;
    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end
    for(int i=0; i<sequence_length; i++) begin
      fork
      begin
        //Send a WriteNoSnpFull or WriteUnique transaction
        `svt_xvm_do_on_with(write_seq_0[i], p_sequencer.rn_virt_seqr[node_index].rn_xact_seqr,
              {
              `ifdef SVT_CHI_ISSUE_E_ENABLE
               if (sys_cfg.rn_cfg[node_index].chi_spec_revision == svt_chi_node_configuration::ISSUE_A ){
                 seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL};
               }            
               else if (sys_cfg.rn_cfg[node_index].chi_spec_revision >= svt_chi_node_configuration::ISSUE_E ) {
                 if (sys_cfg.rn_cfg[node_index].cache_stashing_enable == 0) {
                   seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEZERO, svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL};
                 }   
                 else if (sys_cfg.rn_cfg[node_index].cache_stashing_enable == 1){
                   seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEZERO, svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL, svt_chi_transaction::WRITEUNIQUEFULLSTASH, svt_chi_transaction::WRITEUNIQUEPTLSTASH};
                 }        
               }
               else if ((sys_cfg.rn_cfg[node_index].chi_spec_revision < svt_chi_node_configuration::ISSUE_E ) && (sys_cfg.rn_cfg[node_index].chi_spec_revision > svt_chi_node_configuration::ISSUE_A )){
                 if (sys_cfg.rn_cfg[node_index].cache_stashing_enable == 0) {
                   seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL};
                 }
                 else if (sys_cfg.rn_cfg[node_index].cache_stashing_enable == 1) {
                   seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL, svt_chi_transaction::WRITEUNIQUEFULLSTASH, svt_chi_transaction::WRITEUNIQUEPTLSTASH};
                 }
               }
              `elsif SVT_CHI_ISSUE_B_ENABLE
               if(sys_cfg.rn_cfg[node_index].chi_spec_revision == svt_chi_node_configuration::ISSUE_A || sys_cfg.rn_cfg[node_index].cache_stashing_enable == 0) {
                 seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL};
               }
               else{
                 seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL, svt_chi_transaction::WRITEUNIQUEFULLSTASH, svt_chi_transaction::WRITEUNIQUEPTLSTASH};
               }
              `else
                 seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL};
              `endif
               sequence_length               == 1;
               seq_order_type   == svt_chi_transaction::NO_ORDERING_REQUIRED;
               hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
               seq_hn_node_idx == target_hn_node_idx_0;
               use_seq_is_non_secure_access == 0;               
              }
            )
        wait(write_seq_0[i].write_tran != null);
        write_seq_0[i].write_tran.wait_end();
        if(write_seq_0[i].write_tran.req_status == svt_chi_transaction::RETRY) begin
          write_seq_0[i].write_tran.wait_end();
        end
      end
      begin
        //Wait until the Write request has been sent out by the RN
        wait(write_seq_0[i] != null);
        wait(write_seq_0[i].write_tran != null);
        wait(write_seq_0[i].write_tran.req_status != svt_chi_transaction::INITIAL);
        //Send a CMO transaction targeting the same address
        `svt_xvm_do_on_with(cmo_seq_0[i], p_sequencer.rn_virt_seqr[node_index].rn_xact_seqr,
              {
                sequence_length == 1;
                hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                min_addr == write_seq_0[i].write_tran.addr;
                max_addr == write_seq_0[i].write_tran.addr;
                seq_mem_attr_allocate_hint == write_seq_0[i].write_tran.mem_attr_allocate_hint;
                seq_snp_attr_is_snoopable == write_seq_0[i].write_tran.snp_attr_is_snoopable;
                seq_snp_attr_snp_domain_type == write_seq_0[i].write_tran.snp_attr_snp_domain_type;
                seq_is_non_secure_access == write_seq_0[i].write_tran.is_non_secure_access;
                use_seq_is_non_secure_access == 1;               
                `ifdef SVT_CHI_ISSUE_B_ENABLE
                  if (sys_cfg.rn_cfg[node_index].chi_spec_revision == svt_chi_node_configuration::ISSUE_A)
                    {
                      !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSIST, svt_chi_transaction::STASHONCEUNIQUE,svt_chi_transaction::STASHONCESHARED});
                    }
                  `ifdef SVT_CHI_ISSUE_E_ENABLE
                  else if(sys_cfg.rn_cfg[node_index].chi_spec_revision < svt_chi_node_configuration::ISSUE_E){
                    !(seq_xact_type inside {svt_chi_transaction::STASHONCESEPUNIQUE, svt_chi_transaction::STASHONCESEPSHARED});
                    if(sys_cfg.rn_cfg[node_index].chi_spec_revision < svt_chi_node_configuration::ISSUE_D){
                      !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                      if(sys_cfg.rn_cfg[node_index].cache_stashing_enable == 0)
                        !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                    }
                    else if(sys_cfg.rn_cfg[node_index].chi_spec_revision >= svt_chi_node_configuration::ISSUE_D){
                      if(sys_cfg.rn_cfg[node_index].cleansharedpersistsep_xact_enable ==0)
                        !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                      if(sys_cfg.rn_cfg[node_index].cache_stashing_enable == 0)
                        !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                    }
                  }
                  else if(sys_cfg.rn_cfg[node_index].chi_spec_revision >= svt_chi_node_configuration::ISSUE_E){
                    if(sys_cfg.rn_cfg[node_index].cleansharedpersistsep_xact_enable == 0)
                      !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                    if (sys_cfg.rn_cfg[node_index].cache_stashing_enable == 0)
                      !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED,svt_chi_transaction::STASHONCESEPUNIQUE, svt_chi_transaction::STASHONCESEPSHARED});
                  }
                  `elsif SVT_CHI_ISSUE_D_ENABLE
                  else if(sys_cfg.rn_cfg[node_index].chi_spec_revision < svt_chi_node_configuration::ISSUE_D){
                    !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                    if(sys_cfg.rn_cfg[node_index].cache_stashing_enable == 0)
                      !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                  }
                  else if(sys_cfg.rn_cfg[node_index].chi_spec_revision >= svt_chi_node_configuration::ISSUE_D){
                    if(sys_cfg.rn_cfg[node_index].cleansharedpersistsep_xact_enable ==0)
                      !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                    if (sys_cfg.rn_cfg[node_index].cache_stashing_enable == 0){
                      !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                    }
                  }
                  `endif //issue_d_enable
                  else if (sys_cfg.rn_cfg[node_index].cache_stashing_enable == 0){
                      !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                    }
                `endif
              }
            )
        wait(cmo_seq_0[i].cmo_tran != null);
        cmo_seq_0[i].cmo_tran.wait_end();
        if(cmo_seq_0[i].cmo_tran.req_status == svt_chi_transaction::RETRY) begin
          cmo_seq_0[i].cmo_tran.wait_end();
        end
      end
      join
    end


  endtask: body
endclass: svt_chi_system_single_node_write_followed_by_cmo_virtual_sequence



//------------------------------------------------------------------------------
/** 
 * @groupname CHI_SINGLE_RN_RD_TYPE
 *  This sequence initiates ReadShared transaction from the RN-F node specified with 
 *  node_index, which can be a random node or a specific node configured by the user. 
 *  Before sending each ReadShard transaction, cachelines of peer node are initialized
 *  to random, valid states.
 */

class svt_chi_system_single_node_readshared_virtual_sequence extends svt_chi_system_single_node_rn_coherent_transaction_base_virtual_sequence;
  
  `svt_xvm_object_utils(svt_chi_system_single_node_readshared_virtual_sequence)
  
  function new(string name = "svt_chi_system_single_node_readshared_virtual_sequence");
    super.new(name);
  endfunction

  /**
   * Initializes cachelines and sends readshared from node "node_index"
   */
  virtual task body();
    super.body();

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end
  
    send_coherent_transactions(svt_chi_common_transaction::READSHARED ,1);
    /** Wait for readshared transactions to finish */
    coherent_seq.wait_for_active_xacts_to_end();
    print_caches();

  endtask: body
endclass: svt_chi_system_single_node_readshared_virtual_sequence

class svt_chi_system_single_node_prefetchtgt_virtual_sequence extends svt_chi_system_single_node_rn_coherent_transaction_base_virtual_sequence;
  
  `svt_xvm_object_utils(svt_chi_system_single_node_prefetchtgt_virtual_sequence)
  
  function new(string name = "svt_chi_system_single_node_prefetchtgt_virtual_sequence");
    super.new(name);
    is_xact_type_valid_for_rn_i = 1;
    is_xact_type_valid_for_rn_d = 1; 
  endfunction

  /** 
  * Function to check if current system configuration meets requirements of this sequence.
  * This sequence requires following configurations
  *  #- minimum supporting RN-F Nodes = 1
  *  #- svt_chi_node_configuration::chi_spec_revision = svt_chi_node_configuration::ISSUE_B
  */
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    string str_is_supported_info_prefix = "This sequence cannot be run based on the current configuration.\n";
    string str_is_supported_info = "";
    string str_is_supported_info_suffix = "Modify configurations through svt_chi_node_configuration::chi_spec_revision\n";
    is_supported = super.is_supported(cfg, silent);
    if(is_supported) begin
      `ifdef SVT_CHI_ISSUE_B_ENABLE
      if(sys_cfg.rn_cfg[node_index].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) begin
        is_supported = 0;
        str_is_supported_info = $sformatf("svt_chi_node_configuration::chi_spec_revision set to svt_chi_node_configuration::ISSUE_A for initiating requester node %0d. PrefetchTgt can only be issued from RN when svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_B or later. ", node_index);
      end else
        is_supported = 1;
      `else
        is_supported = 0;
        str_is_supported_info = $sformatf("Macro SVT_CHI_ISSUE_B_ENABLE or SVT_CHI_ISSUE_C_ENABLE is not defined. PrefetchTgt can only be issued when SVT_CHI_ISSUE_B_ENABLE or SVT_CHI_ISSUE_C_ENABLE is defined and svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_B or later for the Requester Nodes. ");
      `endif
      if (!is_supported) begin
        string str_complete_is_supported_info = {str_is_supported_info_prefix, str_is_supported_info, str_is_supported_info_suffix};
        issue_is_supported_failure(str_complete_is_supported_info);
      end
    end
  endfunction 

  /**
   * Initializes cachelines and sends readshared from node "node_index"
   */
  virtual task body();
    svt_chi_rn_transaction xact;
    `SVT_XVM(sequence_item) rsp;    
    super.body();

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    fork
      begin
        forever begin
          get_response(rsp);
        end
      end
    join_none
    
    fork begin
    `ifdef SVT_CHI_ISSUE_B_ENABLE
      for(int i=0; i<sequence_length; i++) begin
        //send_coherent_transactions(svt_chi_common_transaction::PREFETCHTGT ,1);
        `svt_xvm_create_on(xact, p_sequencer.rn_virt_seqr[node_index].rn_xact_seqr)
        if(xact.randomize() with { xact_type  == svt_chi_rn_transaction::PREFETCHTGT; 
                                  }) begin
        end
        `svt_xvm_send(xact)
        `svt_xvm_debug("body",$sformatf("sent prefetch transaction[%0d]  %s", i, `SVT_CHI_PRINT_PREFIX(xact)));
        xact.wait_end();
        `svt_xvm_debug("body",$sformatf("completed prefetch transaction[%0d]  %s", i, `SVT_CHI_PRINT_PREFIX(xact)));
      end
    `endif
    end
    begin
      send_coherent_transactions(svt_chi_common_transaction::READSHARED ,10);
      /** Wait for readshared transactions to finish */
      coherent_seq.wait_for_active_xacts_to_end();
    end
    join
    print_caches();
    
  endtask: body
endclass: svt_chi_system_single_node_prefetchtgt_virtual_sequence

//------------------------------------------------------------------------------
/** 
 * @groupname CHI_SINGLE_RN_RD_TYPE 
 *  This sequence initiates ReadOnce transaction from the RN-F node specified with 
 *  node_index, which can be a random node or a specific node configured by the user. 
 *  Before sending each ReadOnce transaction, cachelines of peer node are initialized
 *  to random, valid states.
 */
class svt_chi_system_single_node_readonce_virtual_sequence extends svt_chi_system_single_node_rn_coherent_transaction_base_virtual_sequence;

  `svt_xvm_object_utils(svt_chi_system_single_node_readonce_virtual_sequence)
  
 
  function new(string name = "svt_chi_system_single_node_readonce_virtual_sequence");
    super.new(name);
    is_xact_type_valid_for_rn_i = 1;
    is_xact_type_valid_for_rn_d = 1;
  endfunction
  
  /**
   * Initializes cachelines and sends readonce from node "node_index"
   */
  virtual task body();
    super.body();

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /** If the selected node is RN-F/RN-I/RN-D node, do cache line initialization
     * In case of selected node is RN-I/RN-D, the cache initialization happens
     * from one of the peer RN-F nodes.
     */
    if (bypass_cache_initialization) begin
      send_coherent_transactions(svt_chi_common_transaction::READONCE , 0);
    end
    else begin
      send_coherent_transactions(svt_chi_common_transaction::READONCE , 1);
    end
    /** Wait for readshared transactions to finish */
    coherent_seq.wait_for_active_xacts_to_end();
    print_caches();
  endtask: body
endclass: svt_chi_system_single_node_readonce_virtual_sequence

//------------------------------------------------------------------------------
/** 
 * @groupname CHI_B_SINGLE_RN_RD_TYPE 
 *  This sequence initiates ReadOnceCleanInvalid transaction from the RN-F node specified with 
 *  node_index, which can be a random node or a specific node configured by the user. 
 *  Before sending each ReadOnceCleanInvalid transaction, cachelines of peer node are initialized
 *  to random, valid states.
 */
class svt_chi_system_single_node_readoncecleaninvalid_virtual_sequence extends svt_chi_system_single_node_rn_coherent_transaction_base_virtual_sequence;

  `svt_xvm_object_utils(svt_chi_system_single_node_readoncecleaninvalid_virtual_sequence)
  
 
  function new(string name = "svt_chi_system_single_node_readoncecleaninvalid_virtual_sequence");
    super.new(name);
    is_xact_type_valid_for_rn_i = 1;
    is_xact_type_valid_for_rn_d = 1;
  endfunction
   
   /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting RN-F Nodes = 1
   *  #- svt_chi_node_configuration::chi_spec_revision = svt_chi_node_configuration::ISSUE_B
   */
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    string str_is_supported_info_prefix = "This sequence cannot be run based on the current configuration.\n";
    string str_is_supported_info = "";
    string str_is_supported_info_suffix = "Modify configurations through svt_chi_node_configuration::chi_spec_revision\n";
    is_supported = super.is_supported(cfg, silent);
    if(is_supported) begin
      `ifdef SVT_CHI_ISSUE_B_ENABLE
      if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) begin
        is_supported = 0;
        str_is_supported_info = $sformatf("svt_chi_node_configuration::chi_spec_revision set to svt_chi_node_configuration::ISSUE_A for initiating requester node %0d. ReadOnceCleanInvalid can only be issued from RN when svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_B or later. ", initiating_rn_node_idx_0);
      end else
        is_supported = 1;
      `else
        is_supported = 0;
        str_is_supported_info = $sformatf("Macro SVT_CHI_ISSUE_B_ENABLE or SVT_CHI_ISSUE_C_ENABLE is not defined. ReadOnceCleanInvalid can only be issued when SVT_CHI_ISSUE_B_ENABLE or SVT_CHI_ISSUE_C_ENABLE is defined and svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_B or later for the Requester Nodes. ");
      `endif
      if (!is_supported) begin
        string str_complete_is_supported_info = {str_is_supported_info_prefix, str_is_supported_info, str_is_supported_info_suffix};
        issue_is_supported_failure(str_complete_is_supported_info);
      end
    end
  endfunction 
  /**
   * Initializes cachelines and sends readonce from node "node_index"
   */
  virtual task body();
    super.body();

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /** If the selected node is RN-F/RN-I/RN-D node, do cache line initialization
     * In case of selected node is RN-I/RN-D, the cache initialization happens
     * from one of the peer RN-F nodes.
     */
    `ifdef SVT_CHI_ISSUE_B_ENABLE
    send_coherent_transactions(svt_chi_common_transaction::READONCECLEANINVALID ,1);
    /** Wait for read transaction to finish */
    coherent_seq.wait_for_active_xacts_to_end();
    print_caches();
    `else    
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting... Please define the SVT_CHI_ISSUE_B_ENABLE or SVT_CHI_ISSUE_C_ENABLE macro and re-run"))
    `endif    
  endtask: body
endclass: svt_chi_system_single_node_readoncecleaninvalid_virtual_sequence

//------------------------------------------------------------------------------
/** 
 * @groupname CHI_B_SINGLE_RN_RD_TYPE 
 *  This sequence initiates ReadOnceMakeInvalid transaction from the RN-F node specified with 
 *  node_index, which can be a random node or a specific node configured by the user. 
 *  Before sending each ReadOnceMakeInvalid transaction, cachelines of peer node are initialized
 *  to random, valid states.
 */
class svt_chi_system_single_node_readoncemakeinvalid_virtual_sequence extends svt_chi_system_single_node_rn_coherent_transaction_base_virtual_sequence;

  `svt_xvm_object_utils(svt_chi_system_single_node_readoncemakeinvalid_virtual_sequence)
  
 
  function new(string name = "svt_chi_system_single_node_readoncemakeinvalid_virtual_sequence");
    super.new(name);
    is_xact_type_valid_for_rn_i = 1;
    is_xact_type_valid_for_rn_d = 1;
  endfunction
   
   /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting RN-F Nodes = 1
   *  #- svt_chi_node_configuration::chi_spec_revision = svt_chi_node_configuration::ISSUE_B
   */
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    string str_is_supported_info_prefix = "This sequence cannot be run based on the current configuration.\n";
    string str_is_supported_info = "";
    string str_is_supported_info_suffix = "Modify configurations through svt_chi_node_configuration::chi_spec_revision\n";
    is_supported = super.is_supported(cfg, silent);
    if(is_supported) begin
      `ifdef SVT_CHI_ISSUE_B_ENABLE
      if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) begin
        is_supported = 0;
        str_is_supported_info = $sformatf("svt_chi_node_configuration::chi_spec_revision set to svt_chi_node_configuration::ISSUE_A for initiating requester node %0d. ReadOnceMakeInvalid can only be issued from RN when svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_B or later. ", initiating_rn_node_idx_0);
      end else
        is_supported = 1;
      `else
        is_supported = 0;
        str_is_supported_info = $sformatf("Macro SVT_CHI_ISSUE_B_ENABLE or SVT_CHI_ISSUE_C_ENABLE is not defined. ReadOnceMakeInvalid can only be issued when SVT_CHI_ISSUE_B_ENABLE or SVT_CHI_ISSUE_C_ENABLE is defined and svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_B or later for the Requester Nodes. ");
      `endif
      if (!is_supported) begin
        string str_complete_is_supported_info = {str_is_supported_info_prefix, str_is_supported_info, str_is_supported_info_suffix};
        issue_is_supported_failure(str_complete_is_supported_info);
      end
    end
  endfunction 
  /**
   * Initializes cachelines and sends readonce from node "node_index"
   */
  virtual task body();
    super.body();

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /** If the selected node is RN-F/RN-I/RN-D node, do cache line initialization
     * In case of selected node is RN-I/RN-D, the cache initialization happens
     * from one of the peer RN-F nodes.
     */
    `ifdef SVT_CHI_ISSUE_B_ENABLE
    send_coherent_transactions(svt_chi_common_transaction::READONCEMAKEINVALID ,1);
    /** Wait for read transaction to finish */
    coherent_seq.wait_for_active_xacts_to_end();
    print_caches();
    `else    
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting... Please define the SVT_CHI_ISSUE_B_ENABLE or SVT_CHI_ISSUE_C_ENABLE macro and re-run"))
    `endif    
  endtask: body
endclass: svt_chi_system_single_node_readoncemakeinvalid_virtual_sequence

//------------------------------------------------------------------------------
/** 
 * @groupname CHI_SINGLE_RN_RD_TYPE 
 *  This sequence initiates ReadNoSnp transaction from the RN node specified with 
 *  node_index, which can be a random node or a specific node configured by the user. 
 *  Before sending each ReadNoSnp transaction, cachelines of peer node are initialized
 *  to random, valid states.
 */
class svt_chi_system_single_node_readnosnp_virtual_sequence extends svt_chi_system_single_node_rn_coherent_transaction_base_virtual_sequence;

  `svt_xvm_object_utils(svt_chi_system_single_node_readnosnp_virtual_sequence)
  
  
  function new(string name = "svt_chi_system_single_node_readnosnp_virtual_sequence");
    super.new(name);
    is_xact_type_valid_for_rn_i = 1;
    is_xact_type_valid_for_rn_d = 1;
  endfunction
  
  /**
   * Initializes cachelines and sends readnosnp from node "node_index"
   */
  virtual task body();
    super.body();
    
    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    `ifdef SVT_CHI_ISSUE_B_ENABLE
    if ((perform_cacheinit_for_non_coherent_xacts == 1)  &&
        (sys_cfg.rn_cfg.size() > node_index) &&
        (sys_cfg.rn_cfg[node_index].chi_interface_type == svt_chi_node_configuration::RN_F) &&
        (hn_index_status == 1) &&
        (sys_cfg.get_hn_interface_type(hn_index) == svt_chi_address_configuration::HN_F)) begin
      `svt_xvm_debug("body", $sformatf("Performing cache initialization before sending readnosnp: node_index %0d (RN-F), hn_index %0d (HN-F)", node_index, hn_index));
      send_coherent_transactions(svt_chi_common_transaction::READNOSNP ,1);
    end
    else
    `endif
      send_coherent_transactions(svt_chi_common_transaction::READNOSNP ,0);
    /* Wait for readshared transactions to finish */
    coherent_seq.wait_for_active_xacts_to_end();
    print_caches();
  endtask: body
endclass: svt_chi_system_single_node_readnosnp_virtual_sequence
  
//------------------------------------------------------------------------------
/** 
 * @groupname CHI_SINGLE_RN_RD_TYPE 
 *  This sequence initiates ReadClean transaction from the RN-F node specified with 
 *  node_index, which can be a random node or a specific node configured by the user. 
 *  Before sending each ReadShard transaction, cachelines of peer node are initialized
 *  to random, valid states.
 */
class svt_chi_system_single_node_readclean_virtual_sequence extends svt_chi_system_single_node_rn_coherent_transaction_base_virtual_sequence;

  `svt_xvm_object_utils(svt_chi_system_single_node_readclean_virtual_sequence)
  
  function new(string name = "svt_chi_system_single_node_readclean_virtual_sequence");
    super.new(name);
  endfunction

  /**
   * Initializes cachelines and sends readclean from node "node_index"
   */
  virtual task body();
    super.body();
    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end
    send_coherent_transactions(svt_chi_common_transaction::READCLEAN ,1);
    /** Wait for readshared transactions to finish */
    coherent_seq.wait_for_active_xacts_to_end();
    print_caches();
  endtask: body
endclass: svt_chi_system_single_node_readclean_virtual_sequence

//------------------------------------------------------------------------------
/** 
 * @groupname CHI_B_SINGLE_RN_RD_TYPE 
 *  This sequence initiates ReadSpec transaction from the RN-F node specified with 
 *  node_index, which can be a random node or a specific node configured by the user. 
 *  Before sending each ReadSpec transaction, cachelines of peer node are initialized
 *  to random, valid states.
 */
class svt_chi_system_single_node_readspec_virtual_sequence extends svt_chi_system_single_node_rn_coherent_transaction_base_virtual_sequence;

  `svt_xvm_object_utils(svt_chi_system_single_node_readspec_virtual_sequence)
  
  function new(string name = "svt_chi_system_single_node_readspec_virtual_sequence");
    super.new(name);
  endfunction
  
  /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting RN-F Nodes = 1
   *  #- svt_chi_node_configuration::chi_spec_revision = svt_chi_node_configuration::ISSUE_B
   */
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    string str_is_supported_info_prefix = "This sequence cannot be run based on the current configuration.\n";
    string str_is_supported_info = "";
    string str_is_supported_info_suffix = "Modify configurations through svt_chi_node_configuration::chi_spec_revision and svt_chi_system_configuration::readspec_enable\n";
    is_supported = super.is_supported(cfg, silent);
    if(is_supported) begin
      `ifdef SVT_CHI_ISSUE_B_ENABLE
      if(sys_cfg.readspec_enable == 0) begin
        is_supported = 0;
        str_is_supported_info = $sformatf("svt_chi_system_configuration::readspec_enable set to 0. ReadSpec can only be issued from RN when svt_chi_system_configuration::readspec_enable is set to 1. ");
      end else if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) begin
        is_supported = 0;
        str_is_supported_info = $sformatf("svt_chi_node_configuration::chi_spec_revision set to svt_chi_node_configuration::ISSUE_A for initiating requester node %0d. ReadSpec can only be issued from RN when svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_B. ", initiating_rn_node_idx_0);
      end else
        is_supported = 1;
      `else
        is_supported = 0;
        str_is_supported_info = $sformatf("Macro SVT_CHI_ISSUE_B_ENABLE or SVT_CHI_ISSUE_C_ENABLE is not defined. ReadSpec can only be issued when SVT_CHI_ISSUE_B_ENABLE or SVT_CHI_ISSUE_C_ENABLE is defined and svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_B or later for the Requester Nodes. ");
      `endif
      if (!is_supported) begin
        string str_complete_is_supported_info = {str_is_supported_info_prefix, str_is_supported_info, str_is_supported_info_suffix};
        issue_is_supported_failure(str_complete_is_supported_info);
      end
    end
  endfunction

  /**
   * Initializes cachelines and sends readspec from node "node_index"
   */
  virtual task body();
    bit is_valid, is_unique, is_clean,status;
    bit final_is_valid, final_is_unique, final_is_clean;
    svt_axi_cache                     my_cache;
    int unsigned count_num_txns   =   0;
    super.body();

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
       `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
        return;
    end
`ifdef SVT_CHI_ISSUE_B_ENABLE
    fork
      begin //thread_1
        send_coherent_transactions(svt_chi_common_transaction::READSPEC ,1);
        /** Wait for read transactions to finish */
        coherent_seq.wait_for_active_xacts_to_end();
        print_caches();
      end  //thread_1

      begin //thread_2
        /** Wait until transaction started at RN Node */
        forever begin
          svt_chi_rn_transaction            local_rn_xact;
          bit[`SVT_CHI_MAX_ADDR_WIDTH-1:0] txn_address;

          /** Waiting for the READSPEC txn to be sent */ 
          wait (coherent_seq.active_rn_xacts.size > 0);

          /** Retrieving the READSPEC txn from the active_rn_xacts */ 
          local_rn_xact = coherent_seq.active_rn_xacts.pop_front();

          if(local_rn_xact.xact_type == svt_chi_common_transaction::READSPEC)begin
            txn_address = local_rn_xact.addr;
            count_num_txns++ ;
            `svt_xvm_debug("body", {`SVT_CHI_PRINT_PREFIX(local_rn_xact),$sformatf("count_num_txns = %0d",count_num_txns)});

            /** Waitting for transaction to start at RN */
            local_rn_xact.wait_begin();
            `svt_xvm_debug("body", {`SVT_CHI_PRINT_PREFIX(local_rn_xact),$sformatf("Transaction started at RN")});
            /** Check the initial cache line state corresponding to txn_address */
            is_valid = get_cache_status(node_index, txn_address, is_unique, is_clean);
            `svt_xvm_debug("body", $psprintf(" Initial cache state for Address :: txn_address - %0h, is_valid - %0b, is_unique - %0b, is_clean - %0b",txn_address, is_valid, is_unique, is_clean));
          end

          if(is_valid)begin
            svt_chi_rn_transaction rn_xact_valid_state;
            bit[`SVT_CHI_MAX_ADDR_WIDTH-1:0] final_txn_address;
            rn_xact_valid_state = local_rn_xact;

            if(rn_xact_valid_state.xact_type == svt_chi_common_transaction::READSPEC)begin
              /** Waitting for transaction to end at RN */
              rn_xact_valid_state.wait_end();
              `svt_xvm_debug("body", {`SVT_CHI_PRINT_PREFIX(rn_xact_valid_state),$sformatf("Transaction ended at RN")});
              final_txn_address = rn_xact_valid_state.addr;

              /** Check the initial cache line state corresponding to final_txn_address */
              final_is_valid = get_cache_status(node_index, final_txn_address, final_is_unique, final_is_clean);
              `svt_xvm_debug("body", $psprintf(" Final cache state for Address :: final_txn_address - %0h, final_is_valid - %0b, final_is_unique - %0b, final_is_clean - %0b",final_txn_address, final_is_valid, final_is_unique, final_is_clean));

              /** Self Check to check final cache state does not change when initial state was not I for ReadSpec transaction, */
              if((final_is_unique != is_unique) || (final_is_clean != is_clean))begin
                `svt_xvm_error("body", {`SVT_CHI_PRINT_PREFIX(rn_xact_valid_state), $sformatf("Unexpected final cache state change for ReadSpec transaction, when initial state was not I.\n Initial cache state :: txn_address - %0h, is_valid - %b, is_unique - %b, is_clean - %b\n Final cache state :: final_txn_address - %0h, final_is_valid - %b, final_is_unique - %b, final_is_clean - %b\n",txn_address, is_valid, is_unique, is_clean,final_txn_address,final_is_valid, final_is_unique, final_is_clean)});
              end//((final_is_unique != is_unique) || (final_is_clean != is_clean))
            end//if(rn_xact_valid_state.xact_type == svt_chi_common_transaction::READSPEC)
          end//if(is_valid)
          if (count_num_txns == sequence_length)begin
            `svt_xvm_debug("body", $psprintf("count_num_txns = %0d sequence_length = %0d",count_num_txns,sequence_length));
            break ;
          end//if (count_num_txns == sequence_length)
        end//forever begin
      end //thread_2
    join    


`else    
    `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting... Please define the SVT_CHI_ISSUE_B_ENABLE or SVT_CHI_ISSUE_C_ENABLE macro and re-run"))
`endif    
  endtask: body

endclass: svt_chi_system_single_node_readspec_virtual_sequence

//------------------------------------------------------------------------------
/** 
 * @groupname CHI_B_SINGLE_RN_RD_TYPE 
 *  This sequence initiates ReadNotSharedDirty transaction from the RN-F node specified with 
 *  node_index, which can be a random node or a specific node configured by the user. 
 *  Before sending each ReadShard transaction, cachelines of peer node are initialized
 *  to random, valid states.
 */
class svt_chi_system_single_node_readnotshareddirty_virtual_sequence extends svt_chi_system_single_node_rn_coherent_transaction_base_virtual_sequence;

  `svt_xvm_object_utils(svt_chi_system_single_node_readnotshareddirty_virtual_sequence)
  
  function new(string name = "svt_chi_system_single_node_readnotshareddirty_virtual_sequence");
    super.new(name);
  endfunction
  
  /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting RN-F Nodes = 1
   *  #- svt_chi_node_configuration::chi_spec_revision = svt_chi_node_configuration::ISSUE_B
   */
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    string str_is_supported_info_prefix = "This sequence cannot be run based on the current configuration.\n";
    string str_is_supported_info = "";
    string str_is_supported_info_suffix = "Modify configurations through svt_chi_node_configuration::chi_spec_revision\n";
    is_supported = super.is_supported(cfg, silent);
    if(is_supported) begin
      `ifdef SVT_CHI_ISSUE_B_ENABLE
      if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) begin
        is_supported = 0;
        str_is_supported_info = $sformatf("svt_chi_node_configuration::chi_spec_revision set to svt_chi_node_configuration::ISSUE_A for initiating requester node %0d. ReadNotSharedDirty can only be issued from RN when svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_B or later. ", initiating_rn_node_idx_0);
      end else
        is_supported = 1;
      `else
        is_supported = 0;
        str_is_supported_info = $sformatf("Macro SVT_CHI_ISSUE_B_ENABLE or SVT_CHI_ISSUE_C_ENABLE is not defined. ReadNotSharedDirty can only be issued when SVT_CHI_ISSUE_B_ENABLE or SVT_CHI_ISSUE_C_ENABLE is defined and svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_B or later for the Requester Nodes. ");
      `endif
      if (!is_supported) begin
        string str_complete_is_supported_info = {str_is_supported_info_prefix, str_is_supported_info, str_is_supported_info_suffix};
        issue_is_supported_failure(str_complete_is_supported_info);
      end
    end
  endfunction : is_supported

  /**
   * Initializes cachelines and sends readnotshareddirty from node "node_index"
   */
  virtual task body();
    super.body();
    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end
`ifdef SVT_CHI_ISSUE_B_ENABLE
    send_coherent_transactions(svt_chi_common_transaction::READNOTSHAREDDIRTY ,1);
    /** Wait for readshared transactions to finish */
    coherent_seq.wait_for_active_xacts_to_end();
    print_caches();
`else    
    `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting... Please define the SVT_CHI_ISSUE_B_ENABLE or SVT_CHI_ISSUE_C_ENABLE macro and re-run"))
`endif    
  endtask: body
endclass: svt_chi_system_single_node_readnotshareddirty_virtual_sequence

//------------------------------------------------------------------------------
/** 
 * @groupname CHI_SINGLE_RN_RD_TYPE 
 *  This sequence initiates ReadUnique transaction from the RN-F node specified with 
 *  node_index, which can be a random node or a specific node configured by the user. 
 *  Before sending each ReadUnique transaction, cachelines of peer node are initialized
 *  to random, valid states.
 */
class svt_chi_system_single_node_readunique_virtual_sequence extends svt_chi_system_single_node_rn_coherent_transaction_base_virtual_sequence;

  `svt_xvm_object_utils(svt_chi_system_single_node_readunique_virtual_sequence)
  
  function new(string name = "svt_chi_system_single_node_readunique_virtual_sequence");
    super.new(name);
  endfunction

  /**
   * Initializes cachelines and sends readunique from node "node_index"
   */
  virtual task body();
    super.body();
    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    send_coherent_transactions(svt_chi_common_transaction::READUNIQUE ,1);
    /** Wait for readshared transactions to finish */
    coherent_seq.wait_for_active_xacts_to_end();
    print_caches();
  endtask: body
endclass: svt_chi_system_single_node_readunique_virtual_sequence

//------------------------------------------------------------------------------
/** 
 * @groupname CHI_SINGLE_RN_RD_TYPE 
 *  This sequence initiates CleanUnique transaction from the RN-F node specified with 
 *  node_index, which can be a random node or a specific node configured by the user. 
 *  Before sending each CleanUnique transaction, cachelines of peer node are initialized
 *  to random, valid states.
 */
class svt_chi_system_single_node_cleanunique_virtual_sequence extends svt_chi_system_single_node_rn_coherent_transaction_base_virtual_sequence;

  `svt_xvm_object_utils(svt_chi_system_single_node_cleanunique_virtual_sequence)
  
  function new(string name = "svt_chi_system_single_node_cleanunique_virtual_sequence");
    super.new(name);
  endfunction

  /**
   * Initializes cachelines and sends cleanunique from node "node_index"
   */
  virtual task body();
    super.body();

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    send_coherent_transactions(svt_chi_common_transaction::CLEANUNIQUE ,1);
    /** Wait for readshared transactions to finish */
    coherent_seq.wait_for_active_xacts_to_end();
    print_caches();

  endtask: body
endclass: svt_chi_system_single_node_cleanunique_virtual_sequence

//------------------------------------------------------------------------------
/** 
 * @groupname CHI_SINGLE_RN_RD_TYPE 
 *  This sequence initiates MakeUique transaction from the RN-F node specified with 
 *  node_index, which can be a random node or a specific node configured by the user. 
 *  Before sending each MakeUnique transaction, cachelines of peer node are initialized
 *  to random, valid states.
 */
class svt_chi_system_single_node_makeunique_virtual_sequence extends svt_chi_system_single_node_rn_coherent_transaction_base_virtual_sequence;

  `svt_xvm_object_utils(svt_chi_system_single_node_makeunique_virtual_sequence)
  
  function new(string name = "svt_chi_system_single_node_makeunique_virtual_sequence");
    super.new(name);
  endfunction

  /**
   * Initializes cachelines and sends makeunique from node "node_index"
   */
  virtual task body();
    super.body();

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end
    
    send_coherent_transactions(svt_chi_common_transaction::MAKEUNIQUE ,1);
    /** Wait for readshared transactions to finish */
    coherent_seq.wait_for_active_xacts_to_end();
    print_caches();

  endtask: body
endclass: svt_chi_system_single_node_makeunique_virtual_sequence

//------------------------------------------------------------------------------
/** 
 * @groupname CHI_SINGLE_RN_CPBK_TYPE 
 *  This sequence initiates WriteBackFull transaction from the RN-F node specified with 
 *  node_index, which can be a random node or a specific node configured by the user. 
 *  Before sending each WriteBackFull transaction, cachelines of peer node are initialized
 *  to random, valid states.
 */
class svt_chi_system_single_node_writebackfull_virtual_sequence extends svt_chi_system_single_node_rn_coherent_transaction_base_virtual_sequence;

  `svt_xvm_object_utils(svt_chi_system_single_node_writebackfull_virtual_sequence)
  
  function new(string name = "svt_chi_system_single_node_writebackfull_virtual_sequence");
    super.new(name);
  endfunction

  /**
   * Initializes cachelines and sends writebackfull from node "node_index"
   */
  virtual task body();
    super.body();

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end
    
    send_coherent_transactions(svt_chi_common_transaction::WRITEBACKFULL, 1);
    /** Wait for readshared transactions to finish */
    coherent_seq.wait_for_active_xacts_to_end();
    
    print_caches();

  endtask: body
endclass: svt_chi_system_single_node_writebackfull_virtual_sequence

//------------------------------------------------------------------------------
/** 
 * @groupname CHI_SINGLE_RN_CPBK_TYPE  
 *  This sequence initiates WriteBackPlt transaction from the RN-F node specified with 
 *  node_index, which can be a random node or a specific node configured by the user. 
 *  Before sending each WriteBackPlt transaction, cachelines of peer node are initialized
 *  to random, valid states.
 */
class svt_chi_system_single_node_writebackptl_virtual_sequence extends svt_chi_system_single_node_rn_coherent_transaction_base_virtual_sequence;

  
  `svt_xvm_object_utils(svt_chi_system_single_node_writebackptl_virtual_sequence)
  
  function new(string name = "svt_chi_system_single_node_writebackptl_virtual_sequence");
    super.new(name);
    
  endfunction

  /**
   * Initializes cachelines and sends writebackptl from node "node_index"
   */
  virtual task body();
    super.body();

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    send_coherent_transactions(svt_chi_common_transaction::WRITEBACKPTL, 1);
    // Wait for readshared transactions to finish
    coherent_seq.wait_for_active_xacts_to_end();
    
    print_caches();
  endtask: body
endclass: svt_chi_system_single_node_writebackptl_virtual_sequence

//------------------------------------------------------------------------------
/** 
 * @groupname CHI_SINGLE_RN_CPBK_TYPE  
 *  This sequence initiates WriteEvictFull transaction from the RN-F node specified with 
 *  node_index, which can be a random node or a specific node configured by the user. 
 *  Before sending each WriteEvictFull transaction, cachelines of peer node are initialized
 *  to random, valid states.
 */
class svt_chi_system_single_node_writeevictfull_virtual_sequence extends svt_chi_system_single_node_rn_coherent_transaction_base_virtual_sequence;

  `svt_xvm_object_utils(svt_chi_system_single_node_writeevictfull_virtual_sequence)
  
  function new(string name = "svt_chi_system_single_node_writeevictfull_virtual_sequence");
    super.new(name);
  endfunction

  /**
   * Initializes cachelines and sends writeevictfull from node "node_index"
   */
  virtual task body();
    super.body();

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    send_coherent_transactions(svt_chi_common_transaction::WRITEEVICTFULL, 1);
    // Wait for readshared transactions to finish
    coherent_seq.wait_for_active_xacts_to_end();
    print_caches();
  endtask: body
endclass: svt_chi_system_single_node_writeevictfull_virtual_sequence

//------------------------------------------------------------------------------
/** 
 * @groupname CHI_SINGLE_RN_CPBK_TYPE  
 *  This sequence initiates WriteCleanFull transaction from the RN-F node specified with 
 *  node_index, which can be a random node or a specific node configured by the user. 
 *  Before sending each WriteCleanFull transaction, cachelines of peer node are initialized
 *  to random, valid states.
 */
class svt_chi_system_single_node_writecleanfull_virtual_sequence extends svt_chi_system_single_node_rn_coherent_transaction_base_virtual_sequence;
  
  `svt_xvm_object_utils(svt_chi_system_single_node_writecleanfull_virtual_sequence)

  function new(string name = "svt_chi_system_single_node_writecleanfull_virtual_sequence");
    super.new(name);
  endfunction

  /**
   * Initializes cachelines and sends writecleanfull from node "node_index"
   */
  virtual task body();
    super.body();

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    send_coherent_transactions(svt_chi_common_transaction::WRITECLEANFULL, 1);
    // Wait for readshared transactions to finish
    coherent_seq.wait_for_active_xacts_to_end();
    print_caches();
  endtask: body
endclass: svt_chi_system_single_node_writecleanfull_virtual_sequence

//------------------------------------------------------------------------------
/** 
 * @groupname CHI_SINGLE_RN_CPBK_TYPE  
 *  This sequence initiates WriteCleanPtl transaction from the RN-F node specified with 
 *  node_index, which can be a random node or a specific node configured by the user. 
 *  Before sending each WriteCleanPtl transaction, cachelines of peer node are initialized
 *  to random, valid states.
 */
class svt_chi_system_single_node_writecleanptl_virtual_sequence extends svt_chi_system_single_node_rn_coherent_transaction_base_virtual_sequence;
  
  `svt_xvm_object_utils(svt_chi_system_single_node_writecleanptl_virtual_sequence)

  function new(string name = "svt_chi_system_single_node_writecleanptl_virtual_sequence");
    super.new(name);
  endfunction

  /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- svt_chi_node_configuration::chi_spec_revision = svt_chi_node_configuration::ISSUE_A
   */
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    string str_is_supported_info_prefix = "This sequence cannot be run based on the current configuration.\n";
    string str_is_supported_info = "";
    string str_is_supported_info_suffix = "Modify configurations through svt_chi_node_configuration::chi_spec_revision\n";
    is_supported = super.is_supported(cfg, silent);
    if(is_supported) begin
      if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision >= svt_chi_node_configuration::ISSUE_B) begin
        is_supported = 0;
        str_is_supported_info = $sformatf("svt_chi_node_configuration::chi_spec_revision set to %0s for initiating requester node %0d. WriteCleanPtl can only be issued from RN when svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_A. ", sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision.name(), initiating_rn_node_idx_0);
      end else
        is_supported = 1;

      if (!is_supported) begin
        string str_complete_is_supported_info = {str_is_supported_info_prefix, str_is_supported_info, str_is_supported_info_suffix};
        issue_is_supported_failure(str_complete_is_supported_info);
      end
    end
  endfunction

  /**
   * Initializes cachelines and sends writecleanptl from node "node_index"
   */
  virtual task body();
    super.body();

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    send_coherent_transactions(svt_chi_common_transaction::WRITECLEANPTL, 1);
    // Wait for readshared transactions to finish
    coherent_seq.wait_for_active_xacts_to_end();
    print_caches();
  endtask: body
endclass: svt_chi_system_single_node_writecleanptl_virtual_sequence
  
//------------------------------------------------------------------------------
/** 
 * @groupname CHI_SINGLE_RN_CPBK_TYPE  
 *  This sequence initiates Evict transaction from the RN-F node specified with 
 *  node_index, which can be a random node or a specific node configured by the user. 
 *  Before sending each Evict transaction, cachelines of peer node are initialized
 *  to random, valid states.
 */
class svt_chi_system_single_node_evict_virtual_sequence extends svt_chi_system_single_node_rn_coherent_transaction_base_virtual_sequence;
  
  `svt_xvm_object_utils(svt_chi_system_single_node_evict_virtual_sequence)
  
  function new(string name = "svt_chi_system_single_node_evict_virtual_sequence");
    super.new(name);
  endfunction

  /**
   * Initializes cachelines and sends evict from node "node_index"
   */
  virtual task body();
    super.body();

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    send_coherent_transactions(svt_chi_common_transaction::EVICT, 1);
    /** Wait for readshared transactions to finish */
    coherent_seq.wait_for_active_xacts_to_end();
    print_caches();

  endtask: body
endclass: svt_chi_system_single_node_evict_virtual_sequence
  
//------------------------------------------------------------------------------
/** 
 * @groupname CHI_SINGLE_RN_WR_TYPE  
 *  This sequence initiates WriteNoSnpFull transaction from the RN node specified with 
 *  node_index, which can be a random node or a specific node configured by the user. 
 */
class svt_chi_system_single_node_writenosnpfull_virtual_sequence extends svt_chi_system_single_node_rn_coherent_transaction_base_virtual_sequence;

  `svt_xvm_object_utils(svt_chi_system_single_node_writenosnpfull_virtual_sequence)
  
  function new(string name = "svt_chi_system_single_node_writenosnpfull_virtual_sequence");
    super.new(name);
    is_xact_type_valid_for_rn_i = 1;
    is_xact_type_valid_for_rn_d = 1;
  endfunction

  /**
   * Sends WriteNoSnpFull from node "node_index"
   */
  virtual task body();

    super.body();

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    `ifdef SVT_CHI_ISSUE_B_ENABLE
    if ((perform_cacheinit_for_non_coherent_xacts == 1)  &&
        (sys_cfg.rn_cfg.size() > node_index) &&
        (sys_cfg.rn_cfg[node_index].chi_interface_type == svt_chi_node_configuration::RN_F) &&
        (hn_index_status == 1) &&
        (sys_cfg.get_hn_interface_type(hn_index) == svt_chi_address_configuration::HN_F)) begin
      `svt_xvm_debug("body", $sformatf("Performing cache initialization before sending writenosnpfull: node_index %0d (RN-F), hn_index %0d (HN-F)", node_index, hn_index));
      send_coherent_transactions(svt_chi_common_transaction::WRITENOSNPFULL ,1);
    end
    else
    `endif
      send_coherent_transactions(svt_chi_common_transaction::WRITENOSNPFULL ,0);
    /** Wait for readshared transactions to finish */
    coherent_seq.wait_for_active_xacts_to_end();
    print_caches();
  endtask: body
endclass: svt_chi_system_single_node_writenosnpfull_virtual_sequence

`ifdef SVT_CHI_ISSUE_E_ENABLE
//------------------------------------------------------------------------------
class svt_chi_system_single_node_combined_write_cmo_base_virtual_sequence extends svt_chi_system_single_node_rn_coherent_transaction_base_virtual_sequence;
  
  `svt_xvm_object_utils(svt_chi_system_single_node_combined_write_cmo_base_virtual_sequence)

  function new(string name = "svt_chi_system_single_node_combined_write_cmo_base_virtual_sequence");
    super.new(name);
  endfunction

   /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting RN Nodes = 1
   *  #- svt_chi_node_configuration::chi_spec_revision >= svt_chi_node_configuration::ISSUE_E
   */
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    string str_is_supported_info_prefix = "This sequence cannot be run based on the current configuration.\n";
    string str_is_supported_info = "";
    string str_is_supported_info_suffix = "Modify configurations through svt_chi_node_configuration::chi_spec_revision\n";
    is_supported = super.is_supported(cfg, silent);
    if(is_supported) begin
      if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision < svt_chi_node_configuration::ISSUE_E) begin
        is_supported = 0;
        str_is_supported_info = $sformatf("svt_chi_node_configuration::chi_spec_revision is not set to svt_chi_node_configuration::ISSUE_E or later for initiating requester node %0d. This sequence can only be initiated from RN when svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_E or later ", initiating_rn_node_idx_0);
      end else begin
        is_supported = 1;
      end  

      if (!is_supported) begin
        string str_complete_is_supported_info = {str_is_supported_info_prefix, str_is_supported_info, str_is_supported_info_suffix};
        issue_is_supported_failure(str_complete_is_supported_info);
      end
    end
  endfunction

endclass :svt_chi_system_single_node_combined_write_cmo_base_virtual_sequence
/** 
 * @groupname CHI_SINGLE_RN_WR_TYPE  
 *  This sequence initiates WriteNoSnpZero transaction from the RN node specified with 
 *  node_index, which can be a random node or a specific node configured by the user. 
 *  This sequence requires SVT_CHI_ISSUE_E_ENABLE macro to be defined and
 *  svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_E or later.
 *
 */
class svt_chi_system_single_node_writenosnpzero_virtual_sequence extends svt_chi_system_single_node_rn_coherent_transaction_base_virtual_sequence;

  `svt_xvm_object_utils(svt_chi_system_single_node_writenosnpzero_virtual_sequence)
  
  function new(string name = "svt_chi_system_single_node_writenosnpzero_virtual_sequence");
    super.new(name);
    is_xact_type_valid_for_rn_i = 1;
    is_xact_type_valid_for_rn_d = 1;
  endfunction

   /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting RN Nodes = 1
   *  #- svt_chi_node_configuration::chi_spec_revision >= svt_chi_node_configuration::ISSUE_E
   */
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    string str_is_supported_info_prefix = "This sequence cannot be run based on the current configuration.\n";
    string str_is_supported_info = "";
    string str_is_supported_info_suffix = "Modify configurations through svt_chi_node_configuration::chi_spec_revision\n";
    is_supported = super.is_supported(cfg, silent);
    if(is_supported) begin
      if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision < svt_chi_node_configuration::ISSUE_E) begin
        is_supported = 0;
        str_is_supported_info = $sformatf("svt_chi_node_configuration::chi_spec_revision is not set to svt_chi_node_configuration::ISSUE_E or later for initiating requester node %0d. WriteNoSnpzero can only be issued from RN when svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_E or later ", initiating_rn_node_idx_0);
      end else begin
        is_supported = 1;
      end  

      if (!is_supported) begin
        string str_complete_is_supported_info = {str_is_supported_info_prefix, str_is_supported_info, str_is_supported_info_suffix};
        issue_is_supported_failure(str_complete_is_supported_info);
      end
    end
  endfunction

  /**
   * Sends WriteNoSnpZero from node "node_index"
   */
  virtual task body();

    super.body();

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    if ((perform_cacheinit_for_non_coherent_xacts == 1)  &&
        (sys_cfg.rn_cfg.size() > node_index) &&
        (sys_cfg.rn_cfg[node_index].chi_interface_type == svt_chi_node_configuration::RN_F) &&
        (hn_index_status == 1) &&
        (sys_cfg.get_hn_interface_type(hn_index) == svt_chi_address_configuration::HN_F)) begin
      `svt_xvm_debug("body", $sformatf("Performing cache initialization before sending writenosnpzero: node_index %0d (RN-F), hn_index %0d (HN-F)", node_index, hn_index));
      send_coherent_transactions(svt_chi_common_transaction::WRITENOSNPZERO ,1);
    end
    else
      send_coherent_transactions(svt_chi_common_transaction::WRITENOSNPZERO ,0);
    /** Wait for readshared transactions to finish */
    coherent_seq.wait_for_active_xacts_to_end();
    print_caches();
  endtask: body
endclass: svt_chi_system_single_node_writenosnpzero_virtual_sequence

//------------------------------------------------------------------------------
/** 
 * @groupname CHI_SINGLE_RN_WR_TYPE  
 *  This sequence initiates WriteNoSnpFull_cleanshared transaction from the RN node specified with 
 *  node_index, which can be a random node or a specific node configured by the user. 
 */
class svt_chi_system_single_node_writenosnpfull_cleanshared_virtual_sequence extends svt_chi_system_single_node_combined_write_cmo_base_virtual_sequence;

  `svt_xvm_object_utils(svt_chi_system_single_node_writenosnpfull_cleanshared_virtual_sequence)
  
  function new(string name = "svt_chi_system_single_node_writenosnpfull_cleanshared_virtual_sequence");
    super.new(name);
    is_xact_type_valid_for_rn_i = 1;
    is_xact_type_valid_for_rn_d = 1;
  endfunction

  /**
   * Sends WriteNoSnpFull_cleanshared from node "node_index"
   */
  virtual task body();

    super.body();

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    if ((perform_cacheinit_for_non_coherent_xacts == 1)  &&
        (sys_cfg.rn_cfg.size() > node_index) &&
        (sys_cfg.rn_cfg[node_index].chi_interface_type == svt_chi_node_configuration::RN_F) &&
        (hn_index_status == 1) &&
        (sys_cfg.get_hn_interface_type(hn_index) == svt_chi_address_configuration::HN_F)) begin
      `svt_xvm_debug("body", $sformatf("Performing cache initialization before sending writenosnpfull_cleanshared: node_index %0d (RN-F), hn_index %0d (HN-F)", node_index, hn_index));
      send_coherent_transactions(svt_chi_common_transaction::WRITENOSNPFULL_CLEANSHARED ,1);
    end
    else
      send_coherent_transactions(svt_chi_common_transaction::WRITENOSNPFULL_CLEANSHARED ,0);
    /** Wait for readshared transactions to finish */
    coherent_seq.wait_for_active_xacts_to_end();
    print_caches();
  endtask: body
endclass: svt_chi_system_single_node_writenosnpfull_cleanshared_virtual_sequence
//--------------------------------------------------------------------------------

//------------------------------------------------------------------------------
/** 
 * @groupname CHI_SINGLE_RN_WR_TYPE  
 *  This sequence initiates writenosnpfull_cleansharedpersistsep transaction from the RN node specified with 
 *  node_index, which can be a random node or a specific node configured by the user. 
 */
class svt_chi_system_single_node_writenosnpfull_cleansharedpersistsep_virtual_sequence extends svt_chi_system_single_node_combined_write_cmo_base_virtual_sequence;

  `svt_xvm_object_utils(svt_chi_system_single_node_writenosnpfull_cleansharedpersistsep_virtual_sequence)
  
  function new(string name = "svt_chi_system_single_node_writenosnpfull_cleansharedpersistsep_virtual_sequence");
    super.new(name);
    is_xact_type_valid_for_rn_i = 1;
    is_xact_type_valid_for_rn_d = 1;
  endfunction

  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    string str_is_supported_info_prefix = "This sequence cannot be run based on the current configuration.\n";
    string str_is_supported_info = "";
    string str_is_supported_info_suffix = "Modify configurations through svt_chi_node_configuration::cleansharedpersistsep_xact_enable\n";
    is_supported = super.is_supported(cfg, silent);
    if(is_supported) begin
      if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].cleansharedpersistsep_xact_enable == 0) begin
        is_supported = 0;
        str_is_supported_info = $sformatf("svt_chi_node_configuration::cleansharedpersistsep_xact_enable must be set to 1 for initiating requester node %0d. This sequence can only be initiated from RN when svt_chi_node_configuration::cleansharedpersistsep_xact_enable is set to 1 ", initiating_rn_node_idx_0);
      end else begin
        is_supported = 1;
      end  

      if (!is_supported) begin
        string str_complete_is_supported_info = {str_is_supported_info_prefix, str_is_supported_info, str_is_supported_info_suffix};
        issue_is_supported_failure(str_complete_is_supported_info);
      end
    end
  endfunction

  /**
   * Sends writenosnpfull_cleansharedpersistsep from node "node_index"
   */
  virtual task body();

    super.body();

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    if ((perform_cacheinit_for_non_coherent_xacts == 1)  &&
        (sys_cfg.rn_cfg.size() > node_index) &&
        (sys_cfg.rn_cfg[node_index].chi_interface_type == svt_chi_node_configuration::RN_F) &&
        (hn_index_status == 1) &&
        (sys_cfg.get_hn_interface_type(hn_index) == svt_chi_address_configuration::HN_F)) begin
      `svt_xvm_debug("body", $sformatf("Performing cache initialization before sending writenosnpfull_cleansharedpersistsep: node_index %0d (RN-F), hn_index %0d (HN-F)", node_index, hn_index));
      send_coherent_transactions(svt_chi_common_transaction::WRITENOSNPFULL_CLEANSHAREDPERSISTSEP ,1);
    end
    else
      send_coherent_transactions(svt_chi_common_transaction::WRITENOSNPFULL_CLEANSHAREDPERSISTSEP ,0);
    /** Wait for readshared transactions to finish */
    coherent_seq.wait_for_active_xacts_to_end();
    print_caches();
  endtask: body
endclass: svt_chi_system_single_node_writenosnpfull_cleansharedpersistsep_virtual_sequence

//--------------------------------------------------------------------------------
/** 
 * @groupname CHI_SINGLE_RN_WR_TYPE  
 *  This sequence initiates WriteNoSnpFull_cleaninvalid transaction from the RN node specified with 
 *  node_index, which can be a random node or a specific node configured by the user. 
 */
class svt_chi_system_single_node_writenosnpfull_cleaninvalid_virtual_sequence extends svt_chi_system_single_node_combined_write_cmo_base_virtual_sequence;

  `svt_xvm_object_utils(svt_chi_system_single_node_writenosnpfull_cleaninvalid_virtual_sequence)
  
  function new(string name = "svt_chi_system_single_node_writenosnpfull_cleaninvalid_virtual_sequence");
    super.new(name);
    is_xact_type_valid_for_rn_i = 1;
    is_xact_type_valid_for_rn_d = 1;
  endfunction

  /**
   * Sends WriteNoSnpFull_cleaninvalid from node "node_index"
   */
  virtual task body();

    super.body();

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    if ((perform_cacheinit_for_non_coherent_xacts == 1)  &&
        (sys_cfg.rn_cfg.size() > node_index) &&
        (sys_cfg.rn_cfg[node_index].chi_interface_type == svt_chi_node_configuration::RN_F) &&
        (hn_index_status == 1) &&
        (sys_cfg.get_hn_interface_type(hn_index) == svt_chi_address_configuration::HN_F)) begin
      `svt_xvm_debug("body", $sformatf("Performing cache initialization before sending writenosnpfull_cleaninvalid: node_index %0d (RN-F), hn_index %0d (HN-F)", node_index, hn_index));
      send_coherent_transactions(svt_chi_common_transaction::WRITENOSNPFULL_CLEANINVALID ,1);
    end
    else
      send_coherent_transactions(svt_chi_common_transaction::WRITENOSNPFULL_CLEANINVALID ,0);
    /** Wait for readshared transactions to finish */
    coherent_seq.wait_for_active_xacts_to_end();
    print_caches();
  endtask: body
endclass: svt_chi_system_single_node_writenosnpfull_cleaninvalid_virtual_sequence
//--------------------------------------------------------------------------------

/** 
 * @groupname CHI_SINGLE_RN_WR_TYPE  
 *  This sequence initiates WriteNoSnpptl_cleaninvalid transaction from the RN node specified with 
 *  node_index, which can be a random node or a specific node configured by the user. 
 */
class svt_chi_system_single_node_writenosnpptl_cleaninvalid_virtual_sequence extends svt_chi_system_single_node_combined_write_cmo_base_virtual_sequence;

  `svt_xvm_object_utils(svt_chi_system_single_node_writenosnpptl_cleaninvalid_virtual_sequence)
  
  function new(string name = "svt_chi_system_single_node_writenosnpptl_cleaninvalid_virtual_sequence");
    super.new(name);
    is_xact_type_valid_for_rn_i = 1;
    is_xact_type_valid_for_rn_d = 1;
  endfunction

  /**
   * Sends WriteNoSnpptl_cleaninvalid from node "node_index"
   */
  virtual task body();

    super.body();

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    if ((perform_cacheinit_for_non_coherent_xacts == 1)  &&
        (sys_cfg.rn_cfg.size() > node_index) &&
        (sys_cfg.rn_cfg[node_index].chi_interface_type == svt_chi_node_configuration::RN_F) &&
        (hn_index_status == 1) &&
        (sys_cfg.get_hn_interface_type(hn_index) == svt_chi_address_configuration::HN_F)) begin
      `svt_xvm_debug("body", $sformatf("Performing cache initialization before sending writenosnpptl_cleaninvalid: node_index %0d (RN-F), hn_index %0d (HN-F)", node_index, hn_index));
      send_coherent_transactions(svt_chi_common_transaction::WRITENOSNPPTL_CLEANINVALID ,1);
    end
    else
      send_coherent_transactions(svt_chi_common_transaction::WRITENOSNPPTL_CLEANINVALID ,0);
    /** Wait for readshared transactions to finish */
    coherent_seq.wait_for_active_xacts_to_end();
    print_caches();
  endtask: body
endclass: svt_chi_system_single_node_writenosnpptl_cleaninvalid_virtual_sequence
//--------------------------------------------------------------------------------
/** 
 * @groupname CHI_SINGLE_RN_WR_TYPE  
 *  This sequence initiates WriteNoSnpptl_cleanshared transaction from the RN node specified with 
 *  node_index, which can be a random node or a specific node configured by the user. 
 */
class svt_chi_system_single_node_writenosnpptl_cleanshared_virtual_sequence extends svt_chi_system_single_node_combined_write_cmo_base_virtual_sequence;

  `svt_xvm_object_utils(svt_chi_system_single_node_writenosnpptl_cleanshared_virtual_sequence)
  
  function new(string name = "svt_chi_system_single_node_writenosnpptl_cleanshared_virtual_sequence");
    super.new(name);
    is_xact_type_valid_for_rn_i = 1;
    is_xact_type_valid_for_rn_d = 1;
  endfunction

  /**
   * Sends WriteNoSnpPtl_cleanshared from node "node_index"
   */
  virtual task body();

    super.body();

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    if ((perform_cacheinit_for_non_coherent_xacts == 1)  &&
        (sys_cfg.rn_cfg.size() > node_index) &&
        (sys_cfg.rn_cfg[node_index].chi_interface_type == svt_chi_node_configuration::RN_F) &&
        (hn_index_status == 1) &&
        (sys_cfg.get_hn_interface_type(hn_index) == svt_chi_address_configuration::HN_F)) begin
      `svt_xvm_debug("body", $sformatf("Performing cache initialization before sending writenosnpptl_cleanshared: node_index %0d (RN-F), hn_index %0d (HN-F)", node_index, hn_index));
      send_coherent_transactions(svt_chi_common_transaction::WRITENOSNPPTL_CLEANSHARED ,1);
    end
    else
      send_coherent_transactions(svt_chi_common_transaction::WRITENOSNPPTL_CLEANSHARED ,0);
    /** Wait for readshared transactions to finish */
    coherent_seq.wait_for_active_xacts_to_end();
    print_caches();
  endtask: body
endclass: svt_chi_system_single_node_writenosnpptl_cleanshared_virtual_sequence
//--------------------------------------------------------------------------------
/** 
 * @groupname CHI_SINGLE_RN_WR_TYPE  
 *  This sequence initiates WriteNoSnpptl_cleansharedpersistsep transaction from the RN node specified with 
 *  node_index, which can be a random node or a specific node configured by the user. 
 */
class svt_chi_system_single_node_writenosnpptl_cleansharedpersistsep_virtual_sequence extends svt_chi_system_single_node_combined_write_cmo_base_virtual_sequence;

  `svt_xvm_object_utils(svt_chi_system_single_node_writenosnpptl_cleansharedpersistsep_virtual_sequence)
  
  function new(string name = "svt_chi_system_single_node_writenosnpptl_cleansharedpersistsep_virtual_sequence");
    super.new(name);
    is_xact_type_valid_for_rn_i = 1;
    is_xact_type_valid_for_rn_d = 1;
  endfunction

  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    string str_is_supported_info_prefix = "This sequence cannot be run based on the current configuration.\n";
    string str_is_supported_info = "";
    string str_is_supported_info_suffix = "Modify configurations through svt_chi_node_configuration::cleansharedpersistsep_xact_enable\n";
    is_supported = super.is_supported(cfg, silent);
    if(is_supported) begin
      if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].cleansharedpersistsep_xact_enable == 0) begin
        is_supported = 0;
        str_is_supported_info = $sformatf("svt_chi_node_configuration::cleansharedpersistsep_xact_enable must be set to 1 for initiating requester node %0d. This sequence can only be initiated from RN when svt_chi_node_configuration::cleansharedpersistsep_xact_enable is set to 1 ", initiating_rn_node_idx_0);
      end else begin
        is_supported = 1;
      end  

      if (!is_supported) begin
        string str_complete_is_supported_info = {str_is_supported_info_prefix, str_is_supported_info, str_is_supported_info_suffix};
        issue_is_supported_failure(str_complete_is_supported_info);
      end
    end
  endfunction

  /**
   * Sends WriteNoSnpPtl_cleansharedpersistsep from node "node_index"
   */
  virtual task body();

    super.body();

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    if ((perform_cacheinit_for_non_coherent_xacts == 1)  &&
        (sys_cfg.rn_cfg.size() > node_index) &&
        (sys_cfg.rn_cfg[node_index].chi_interface_type == svt_chi_node_configuration::RN_F) &&
        (hn_index_status == 1) &&
        (sys_cfg.get_hn_interface_type(hn_index) == svt_chi_address_configuration::HN_F)) begin
      `svt_xvm_debug("body", $sformatf("Performing cache initialization before sending writenosnpptl_cleanshared: node_index %0d (RN-F), hn_index %0d (HN-F)", node_index, hn_index));
      send_coherent_transactions(svt_chi_common_transaction::WRITENOSNPPTL_CLEANSHAREDPERSISTSEP ,1);
    end
    else
      send_coherent_transactions(svt_chi_common_transaction::WRITENOSNPPTL_CLEANSHAREDPERSISTSEP ,0);
    /** Wait for readshared transactions to finish */
    coherent_seq.wait_for_active_xacts_to_end();
    print_caches();
  endtask: body
endclass: svt_chi_system_single_node_writenosnpptl_cleansharedpersistsep_virtual_sequence

//--------------------------------------------------------------------------------
/** 
 * @groupname CHI_SINGLE_RN_WR_TYPE   
 *  This sequence initiates WriteUniqueFull_CleanShared transaction from the RN node specified with 
 *  node_index, which can be a random node or a specific node configured by the user. 
 */
class svt_chi_system_single_node_writeuniquefull_cleanshared_virtual_sequence extends svt_chi_system_single_node_combined_write_cmo_base_virtual_sequence;
                             
  `svt_xvm_object_utils(svt_chi_system_single_node_writeuniquefull_cleanshared_virtual_sequence)
 
  function new(string name = "svt_chi_system_single_node_writeuniquefull_cleanshared_virtual_sequence");
    super.new(name);
    is_xact_type_valid_for_rn_i = 1;
    is_xact_type_valid_for_rn_d = 1;
  endfunction

  /**
   * Initializes cachelines and sends WriteUniqueFull_cleanshared from node "node_index"
   */
  virtual task body();
    super.body();

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /**
     * If the selected node is RN-F/RN-I/RN-D node, do cache line initialization
     * In case of selected node is RN-I/RN-D, the cache initialization happens
     * from one of the peer RN-F nodes. 
     */
    send_coherent_transactions(svt_chi_common_transaction::WRITEUNIQUEFULL_CLEANSHARED, 1);
    /** Wait for readshared transactions to finish */
    coherent_seq.wait_for_active_xacts_to_end();
    print_caches();
  endtask: body
endclass: svt_chi_system_single_node_writeuniquefull_cleanshared_virtual_sequence
//---------------------------------------------------------------------------------------

/** 
 * @groupname CHI_SINGLE_RN_WR_TYPE   
 *  This sequence initiates WriteUniqueFull_CleanSharedpersistsep transaction from the RN node specified with 
 *  node_index, which can be a random node or a specific node configured by the user. 
 */
class svt_chi_system_single_node_writeuniquefull_cleansharedpersistsep_virtual_sequence extends svt_chi_system_single_node_combined_write_cmo_base_virtual_sequence;
                             
  `svt_xvm_object_utils(svt_chi_system_single_node_writeuniquefull_cleansharedpersistsep_virtual_sequence)
 
  function new(string name = "svt_chi_system_single_node_writeuniquefull_cleansharedpersistsep_virtual_sequence");
    super.new(name);
    is_xact_type_valid_for_rn_i = 1;
    is_xact_type_valid_for_rn_d = 1;
  endfunction

  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    string str_is_supported_info_prefix = "This sequence cannot be run based on the current configuration.\n";
    string str_is_supported_info = "";
    string str_is_supported_info_suffix = "Modify configurations through svt_chi_node_configuration::cleansharedpersistsep_xact_enable\n";
    is_supported = super.is_supported(cfg, silent);
    if(is_supported) begin
      if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].cleansharedpersistsep_xact_enable == 0) begin
        is_supported = 0;
        str_is_supported_info = $sformatf("svt_chi_node_configuration::cleansharedpersistsep_xact_enable must be set to 1 for initiating requester node %0d. This sequence can only be initiated from RN when svt_chi_node_configuration::cleansharedpersistsep_xact_enable is set to 1 ", initiating_rn_node_idx_0);
      end else begin
        is_supported = 1;
      end  

      if (!is_supported) begin
        string str_complete_is_supported_info = {str_is_supported_info_prefix, str_is_supported_info, str_is_supported_info_suffix};
        issue_is_supported_failure(str_complete_is_supported_info);
      end
    end
  endfunction

  /**
   * Initializes cachelines and sends WriteUniqueFull_cleansharedpersistsep from node "node_index"
   */
  virtual task body();
    super.body();

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /**
     * If the selected node is RN-F/RN-I/RN-D node, do cache line initialization
     * In case of selected node is RN-I/RN-D, the cache initialization happens
     * from one of the peer RN-F nodes. 
     */
    send_coherent_transactions(svt_chi_common_transaction::WRITEUNIQUEFULL_CLEANSHAREDPERSISTSEP, 1);
    /** Wait for readshared transactions to finish */
    coherent_seq.wait_for_active_xacts_to_end();
    print_caches();
  endtask: body
endclass: svt_chi_system_single_node_writeuniquefull_cleansharedpersistsep_virtual_sequence
//---------------------------------------------------------------------------------------

/** 
 * @groupname CHI_SINGLE_RN_WR_TYPE   
 *  This sequence initiates WriteUniquePtl_CleanShared transaction from the RN node specified with 
 *  node_index, which can be a random node or a specific node configured by the user. 
 */
class svt_chi_system_single_node_writeuniqueptl_cleanshared_virtual_sequence extends svt_chi_system_single_node_combined_write_cmo_base_virtual_sequence;
                             
  `svt_xvm_object_utils(svt_chi_system_single_node_writeuniqueptl_cleanshared_virtual_sequence)
 
  function new(string name = "svt_chi_system_single_node_writeuniqueptl_cleanshared_virtual_sequence");
    super.new(name);
    is_xact_type_valid_for_rn_i = 1;
    is_xact_type_valid_for_rn_d = 1;
  endfunction

  /**
   * Initializes cachelines and sends WriteUniquePtl_cleanshared from node "node_index"
   */
  virtual task body();
    super.body();

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /**
     * If the selected node is RN-F/RN-I/RN-D node, do cache line initialization
     * In case of selected node is RN-I/RN-D, the cache initialization happens
     * from one of the peer RN-F nodes. 
     */
    send_coherent_transactions(svt_chi_common_transaction::WRITEUNIQUEPTL_CLEANSHARED, 1);
    /** Wait for readshared transactions to finish */
    coherent_seq.wait_for_active_xacts_to_end();
    print_caches();
  endtask: body
endclass: svt_chi_system_single_node_writeuniqueptl_cleanshared_virtual_sequence
//--------------------------------------------------------------------------------

/** 
 * @groupname CHI_SINGLE_RN_WR_TYPE   
 *  This sequence initiates WriteUniquePtl_CleanSharedpersistsep transaction from the RN node specified with 
 *  node_index, which can be a random node or a specific node configured by the user. 
 */
class svt_chi_system_single_node_writeuniqueptl_cleansharedpersistsep_virtual_sequence extends svt_chi_system_single_node_combined_write_cmo_base_virtual_sequence;
                             
  `svt_xvm_object_utils(svt_chi_system_single_node_writeuniqueptl_cleansharedpersistsep_virtual_sequence)
 
  function new(string name = "svt_chi_system_single_node_writeuniqueptl_cleansharedpersistsep_virtual_sequence");
    super.new(name);
    is_xact_type_valid_for_rn_i = 1;
    is_xact_type_valid_for_rn_d = 1;
  endfunction

  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    string str_is_supported_info_prefix = "This sequence cannot be run based on the current configuration.\n";
    string str_is_supported_info = "";
    string str_is_supported_info_suffix = "Modify configurations through svt_chi_node_configuration::cleansharedpersistsep_xact_enable\n";
    is_supported = super.is_supported(cfg, silent);
    if(is_supported) begin
      if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].cleansharedpersistsep_xact_enable == 0) begin
        is_supported = 0;
        str_is_supported_info = $sformatf("svt_chi_node_configuration::cleansharedpersistsep_xact_enable must be set to 1 for initiating requester node %0d. This sequence can only be initiated from RN when svt_chi_node_configuration::cleansharedpersistsep_xact_enable is set to 1 ", initiating_rn_node_idx_0);
      end else begin
        is_supported = 1;
      end  

      if (!is_supported) begin
        string str_complete_is_supported_info = {str_is_supported_info_prefix, str_is_supported_info, str_is_supported_info_suffix};
        issue_is_supported_failure(str_complete_is_supported_info);
      end
    end
  endfunction

  /**
   * Initializes cachelines and sends WriteUniquePtl_cleansharedpersistsep from node "node_index"
   */
  virtual task body();
    super.body();

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /**
     * If the selected node is RN-F/RN-I/RN-D node, do cache line initialization
     * In case of selected node is RN-I/RN-D, the cache initialization happens
     * from one of the peer RN-F nodes. 
     */
    send_coherent_transactions(svt_chi_common_transaction::WRITEUNIQUEPTL_CLEANSHAREDPERSISTSEP, 1);
    /** Wait for readshared transactions to finish */
    coherent_seq.wait_for_active_xacts_to_end();
    print_caches();
  endtask: body
endclass: svt_chi_system_single_node_writeuniqueptl_cleansharedpersistsep_virtual_sequence
//--------------------------------------------------------------------------------

/** 
 * @groupname CHI_SINGLE_RN_WR_TYPE   
 *  This sequence initiates Writebackfull_CleanShared transaction from the RN node specified with 
 *  node_index, which can be a random node or a specific node configured by the user. 
 */
class svt_chi_system_single_node_writebackfull_cleanshared_virtual_sequence extends svt_chi_system_single_node_combined_write_cmo_base_virtual_sequence;
                             
  `svt_xvm_object_utils(svt_chi_system_single_node_writebackfull_cleanshared_virtual_sequence)
 
  function new(string name = "svt_chi_system_single_node_writebackfull_cleanshared_virtual_sequence");
    super.new(name);
  endfunction

  /**
   * Initializes cachelines and sends Writebackfull_cleanshared from node "node_index"
   */
  virtual task body();
    super.body();

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /**
     * If the selected node is RN-F/RN-I/RN-D node, do cache line initialization
     * In case of selected node is RN-I/RN-D, the cache initialization happens
     * from one of the peer RN-F nodes. 
     */
    send_coherent_transactions(svt_chi_common_transaction::WRITEBACKFULL_CLEANSHARED, 1);
    /** Wait for readshared transactions to finish */
    coherent_seq.wait_for_active_xacts_to_end();
    print_caches();
  endtask: body
endclass: svt_chi_system_single_node_writebackfull_cleanshared_virtual_sequence
//---------------------------------------------------------------------------------------

/** 
 * @groupname CHI_SINGLE_RN_WR_TYPE   
 *  This sequence initiates Writebackfull_CleanSharedpersistsep transaction from the RN node specified with 
 *  node_index, which can be a random node or a specific node configured by the user. 
 */
class svt_chi_system_single_node_writebackfull_cleansharedpersistsep_virtual_sequence extends svt_chi_system_single_node_combined_write_cmo_base_virtual_sequence;
                             
  `svt_xvm_object_utils(svt_chi_system_single_node_writebackfull_cleansharedpersistsep_virtual_sequence)
 
  function new(string name = "svt_chi_system_single_node_writebackfull_cleansharedpersistsep_virtual_sequence");
    super.new(name);
  endfunction

  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    string str_is_supported_info_prefix = "This sequence cannot be run based on the current configuration.\n";
    string str_is_supported_info = "";
    string str_is_supported_info_suffix = "Modify configurations through svt_chi_node_configuration::cleansharedpersistsep_xact_enable\n";
    is_supported = super.is_supported(cfg, silent);
    if(is_supported) begin
      if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].cleansharedpersistsep_xact_enable == 0) begin
        is_supported = 0;
        str_is_supported_info = $sformatf("svt_chi_node_configuration::cleansharedpersistsep_xact_enable must be set to 1 for initiating requester node %0d. This sequence can only be initiated from RN when svt_chi_node_configuration::cleansharedpersistsep_xact_enable is set to 1 ", initiating_rn_node_idx_0);
      end else begin
        is_supported = 1;
      end  

      if (!is_supported) begin
        string str_complete_is_supported_info = {str_is_supported_info_prefix, str_is_supported_info, str_is_supported_info_suffix};
        issue_is_supported_failure(str_complete_is_supported_info);
      end
    end
  endfunction

  /**
   * Initializes cachelines and sends Writebackfull_cleanshared from node "node_index"
   */
  virtual task body();
    super.body();

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /**
     * If the selected node is RN-F/RN-I/RN-D node, do cache line initialization
     * In case of selected node is RN-I/RN-D, the cache initialization happens
     * from one of the peer RN-F nodes. 
     */
    send_coherent_transactions(svt_chi_common_transaction::WRITEBACKFULL_CLEANSHAREDPERSISTSEP, 1);
    /** Wait for readshared transactions to finish */
    coherent_seq.wait_for_active_xacts_to_end();
    print_caches();
  endtask: body
endclass: svt_chi_system_single_node_writebackfull_cleansharedpersistsep_virtual_sequence
//---------------------------------------------------------------------------------------

/** 
 * @groupname CHI_SINGLE_RN_WR_TYPE   
 *  This sequence initiates Writebackfull_CleanInvalid transaction from the RN node specified with 
 *  node_index, which can be a random node or a specific node configured by the user. 
 */
class svt_chi_system_single_node_writebackfull_cleaninvalid_virtual_sequence extends svt_chi_system_single_node_combined_write_cmo_base_virtual_sequence;
                             
  `svt_xvm_object_utils(svt_chi_system_single_node_writebackfull_cleaninvalid_virtual_sequence)
 
  function new(string name = "svt_chi_system_single_node_writebackfull_cleaninvalid_virtual_sequence");
    super.new(name);
  endfunction

  /**
   * Initializes cachelines and sends Writebackfull_CleanInvalid from node "node_index"
   */
  virtual task body();
    super.body();

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /**
     * If the selected node is RN-F/RN-I/RN-D node, do cache line initialization
     * In case of selected node is RN-I/RN-D, the cache initialization happens
     * from one of the peer RN-F nodes. 
     */
    send_coherent_transactions(svt_chi_common_transaction::WRITEBACKFULL_CLEANINVALID, 1);
    /** Wait for readshared transactions to finish */
    coherent_seq.wait_for_active_xacts_to_end();
    print_caches();
  endtask: body
endclass: svt_chi_system_single_node_writebackfull_cleaninvalid_virtual_sequence
//-------------------------------------------------------------------------------

/** 
 * @groupname CHI_SINGLE_RN_WR_TYPE   
 *  This sequence initiates Writecleanfull_Cleanshared transaction from the RN node specified with 
 *  node_index, which can be a random node or a specific node configured by the user. 
 */
class svt_chi_system_single_node_writecleanfull_cleanshared_virtual_sequence extends svt_chi_system_single_node_combined_write_cmo_base_virtual_sequence;
                             
  `svt_xvm_object_utils(svt_chi_system_single_node_writecleanfull_cleanshared_virtual_sequence)
 
  function new(string name = "svt_chi_system_single_node_writecleanfull_cleanshared_virtual_sequence");
    super.new(name);
  endfunction

  /**
   * Initializes cachelines and sends Writecleanfull_cleanshared from node "node_index"
   */
  virtual task body();
    super.body();

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /**
     * If the selected node is RN-F/RN-I/RN-D node, do cache line initialization
     * In case of selected node is RN-I/RN-D, the cache initialization happens
     * from one of the peer RN-F nodes. 
     */
    send_coherent_transactions(svt_chi_common_transaction::WRITECLEANFULL_CLEANSHARED, 1);
    /** Wait for readshared transactions to finish */
    coherent_seq.wait_for_active_xacts_to_end();
    print_caches();
  endtask: body
endclass: svt_chi_system_single_node_writecleanfull_cleanshared_virtual_sequence
//---------------------------------------------------------------------------------------
/** 
 * @groupname CHI_SINGLE_RN_WR_TYPE   
 *  This sequence initiates Writecleanfull_Cleansharedpersistsep transaction from the RN node specified with 
 *  node_index, which can be a random node or a specific node configured by the user. 
 */
class svt_chi_system_single_node_writecleanfull_cleansharedpersistsep_virtual_sequence extends svt_chi_system_single_node_combined_write_cmo_base_virtual_sequence;
                             
  `svt_xvm_object_utils(svt_chi_system_single_node_writecleanfull_cleansharedpersistsep_virtual_sequence)
 
  function new(string name = "svt_chi_system_single_node_writecleanfull_cleansharedpersistsep_virtual_sequence");
    super.new(name);
  endfunction

  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    string str_is_supported_info_prefix = "This sequence cannot be run based on the current configuration.\n";
    string str_is_supported_info = "";
    string str_is_supported_info_suffix = "Modify configurations through svt_chi_node_configuration::cleansharedpersistsep_xact_enable\n";
    is_supported = super.is_supported(cfg, silent);
    if(is_supported) begin
      if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].cleansharedpersistsep_xact_enable == 0) begin
        is_supported = 0;
        str_is_supported_info = $sformatf("svt_chi_node_configuration::cleansharedpersistsep_xact_enable must be set to 1 for initiating requester node %0d. This sequence can only be initiated from RN when svt_chi_node_configuration::cleansharedpersistsep_xact_enable is set to 1 ", initiating_rn_node_idx_0);
      end else begin
        is_supported = 1;
      end  

      if (!is_supported) begin
        string str_complete_is_supported_info = {str_is_supported_info_prefix, str_is_supported_info, str_is_supported_info_suffix};
        issue_is_supported_failure(str_complete_is_supported_info);
      end
    end
  endfunction

  /**
   * Initializes cachelines and sends Writecleanfull_cleansharedpersistsep from node "node_index"
   */
  virtual task body();
    super.body();

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /**
     * If the selected node is RN-F/RN-I/RN-D node, do cache line initialization
     * In case of selected node is RN-I/RN-D, the cache initialization happens
     * from one of the peer RN-F nodes. 
     */
    send_coherent_transactions(svt_chi_common_transaction::WRITECLEANFULL_CLEANSHAREDPERSISTSEP, 1);
    /** Wait for readshared transactions to finish */
    coherent_seq.wait_for_active_xacts_to_end();
    print_caches();
  endtask: body
endclass: svt_chi_system_single_node_writecleanfull_cleansharedpersistsep_virtual_sequence
//---------------------------------------------------------------------------------------
`endif
  
//------------------------------------------------------------------------------
/** 
 * @groupname CHI_SINGLE_RN_WR_TYPE   
 *  This sequence initiates WriteNoSnpPtl transaction from the RN node specified with 
 *  node_index, which can be a random node or a specific node configured by the user. 
 */
class svt_chi_system_single_node_writenosnpptl_virtual_sequence extends svt_chi_system_single_node_rn_coherent_transaction_base_virtual_sequence;
  `svt_xvm_object_utils(svt_chi_system_single_node_writenosnpptl_virtual_sequence)
  
  function new(string name = "svt_chi_system_single_node_writenosnpptl_virtual_sequence");
    super.new(name);
    is_xact_type_valid_for_rn_i = 1;
    is_xact_type_valid_for_rn_d = 1;
  endfunction

  /**
   * Sends WriteNoSnpPtl from node "node_index"
   */
  virtual task body();
    super.body();

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    `ifdef SVT_CHI_ISSUE_B_ENABLE
    if ((perform_cacheinit_for_non_coherent_xacts == 1)  &&
        (sys_cfg.rn_cfg.size() > node_index) &&
        (sys_cfg.rn_cfg[node_index].chi_interface_type == svt_chi_node_configuration::RN_F) &&
        (hn_index_status == 1) &&
        (sys_cfg.get_hn_interface_type(hn_index) == svt_chi_address_configuration::HN_F)) begin
      `svt_xvm_debug("body", $sformatf("Performing cache initialization before sending writenosnpptl: node_index %0d (RN-F), hn_index %0d (HN-F)", node_index, hn_index));
      send_coherent_transactions(svt_chi_common_transaction::WRITENOSNPPTL ,1);
    end
    else
    `endif
      send_coherent_transactions(svt_chi_common_transaction::WRITENOSNPPTL ,0);
    /** Wait for readshared transactions to finish */
    coherent_seq.wait_for_active_xacts_to_end();
    print_caches();
  endtask: body
endclass: svt_chi_system_single_node_writenosnpptl_virtual_sequence

//------------------------------------------------------------------------------
/** 
 * @groupname CHI_SINGLE_RN_WR_TYPE   
 *  This sequence initiates WriteUniqueFull transaction from the RN node specified with 
 *  node_index, which can be a random node or a specific node configured by the user. 
 */
class svt_chi_system_single_node_writeuniquefull_virtual_sequence extends svt_chi_system_single_node_rn_coherent_transaction_base_virtual_sequence;
                             
  `svt_xvm_object_utils(svt_chi_system_single_node_writeuniquefull_virtual_sequence)
 
  function new(string name = "svt_chi_system_single_node_writeuniquefull_virtual_sequence");
    super.new(name);
    is_xact_type_valid_for_rn_i = 1;
    is_xact_type_valid_for_rn_d = 1;
  endfunction

  /**
   * Initializes cachelines and sends WriteUniqueFull from node "node_index"
   */
  virtual task body();
    super.body();

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /**
     * If the selected node is RN-F/RN-I/RN-D node, do cache line initialization
     * In case of selected node is RN-I/RN-D, the cache initialization happens
     * from one of the peer RN-F nodes. 
     */
    send_coherent_transactions(svt_chi_common_transaction::WRITEUNIQUEFULL, 1);
    /** Wait for readshared transactions to finish */
    coherent_seq.wait_for_active_xacts_to_end();
    print_caches();
  endtask: body
endclass: svt_chi_system_single_node_writeuniquefull_virtual_sequence

`ifdef SVT_CHI_ISSUE_E_ENABLE
//------------------------------------------------------------------------------
/** 
 * @groupname CHI_SINGLE_RN_WR_TYPE   
 *  This sequence initiates WriteUniqueZero transaction from the RN node specified with 
 *  node_index, which can be a random node or a specific node configured by the user. 
 *  This sequence requires SVT_CHI_ISSUE_E_ENABLE macro to be defined and
 *  svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_E or later.
 *
 */
class svt_chi_system_single_node_writeuniquezero_virtual_sequence extends svt_chi_system_single_node_rn_coherent_transaction_base_virtual_sequence;
                             
  `svt_xvm_object_utils(svt_chi_system_single_node_writeuniquezero_virtual_sequence)
 
  function new(string name = "svt_chi_system_single_node_writeuniquezero_virtual_sequence");
    super.new(name);
    is_xact_type_valid_for_rn_i = 1;
    is_xact_type_valid_for_rn_d = 1;
  endfunction

  /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting RN Nodes = 1
   *  #- svt_chi_node_configuration::chi_spec_revision >= svt_chi_node_configuration::ISSUE_E
   */
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    string str_is_supported_info_prefix = "This sequence cannot be run based on the current configuration.\n";
    string str_is_supported_info = "";
    string str_is_supported_info_suffix = "Modify configurations through svt_chi_node_configuration::chi_spec_revision\n";
    is_supported = super.is_supported(cfg, silent);
    if(is_supported) begin
      if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision < svt_chi_node_configuration::ISSUE_E) begin
        is_supported = 0;
        str_is_supported_info = $sformatf("svt_chi_node_configuration::chi_spec_revision is not set to svt_chi_node_configuration::ISSUE_E or later for initiating requester node %0d. WriteUniquezero can only be issued from RN when svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_E or later ", initiating_rn_node_idx_0);
      end else begin
        is_supported = 1;
      end  

      if (!is_supported) begin
        string str_complete_is_supported_info = {str_is_supported_info_prefix, str_is_supported_info, str_is_supported_info_suffix};
        issue_is_supported_failure(str_complete_is_supported_info);
      end
    end
  endfunction

  /**
   * Initializes cachelines and sends WriteUniquezero from node "node_index"
   */
  virtual task body();
    super.body();

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /**
     * If the selected node is RN-F/RN-I/RN-D node, do cache line initialization
     * In case of selected node is RN-I/RN-D, the cache initialization happens
     * from one of the peer RN-F nodes. 
     */
    send_coherent_transactions(svt_chi_common_transaction::WRITEUNIQUEZERO, 1);
    /** Wait for writeuniquezero transactions to finish */
    coherent_seq.wait_for_active_xacts_to_end();
    print_caches();
  endtask: body
endclass: svt_chi_system_single_node_writeuniquezero_virtual_sequence
`endif

//------------------------------------------------------------------------------
/** 
 * @groupname CHI_E_SINGLE_RN_STASH_TYPE   
 *  This sequence initiates StashOnceSepUnique transaction from the RN node specified with 
 *  node_index, which can be a random node or a specific node configured by the user. 
 */
class svt_chi_system_single_node_stashoncesepunique_virtual_sequence extends svt_chi_system_single_node_rn_coherent_transaction_base_virtual_sequence;
                             
  `svt_xvm_object_utils(svt_chi_system_single_node_stashoncesepunique_virtual_sequence)
 
  function new(string name = "svt_chi_system_single_node_stashoncesepunique_virtual_sequence");
    super.new(name);
    is_xact_type_valid_for_rn_i = 1;
    is_xact_type_valid_for_rn_d = 1;
  endfunction
   
   /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting RN-F Nodes = 1
   *  #- svt_chi_node_configuration::chi_spec_revision >= svt_chi_node_configuration::ISSUE_E
   */
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    string str_is_supported_info_prefix = "This sequence cannot be run based on the current configuration.\n";
    string str_is_supported_info = "";
    string str_is_supported_info_suffix = "Modify configurations through svt_chi_node_configuration::chi_spec_revision\n";
    is_supported = super.is_supported(cfg, silent);
    if(is_supported) begin
      `ifdef SVT_CHI_ISSUE_E_ENABLE
      if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision < svt_chi_node_configuration::ISSUE_E || sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0) begin
        is_supported = 0;
        str_is_supported_info = $sformatf("cache_stashing_enable is set to %0d or svt_chi_node_configuration::chi_spec_revision is set prior to svt_chi_node_configuration::ISSUE_E for initiating requester node %0d. StashOnceSepUnique can only be issued from RN when svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_E or later and cache_stashing_enable is set to 1", sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable, initiating_rn_node_idx_0);
      end else
        is_supported = 1;
      `else
        is_supported = 0;
        str_is_supported_info = $sformatf("Macro SVT_CHI_ISSUE_E_ENABLE is not defined. StashOnceSepUnique can only be issued when SVT_CHI_ISSUE_E_ENABLE is defined and svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_E or later for the Requester Nodes. ");
      `endif
      if (!is_supported) begin
        string str_complete_is_supported_info = {str_is_supported_info_prefix, str_is_supported_info, str_is_supported_info_suffix};
        issue_is_supported_failure(str_complete_is_supported_info);
      end
    end
  endfunction

  /**
   * Initializes cachelines and sends StashOnceSepUnique from node "node_index"
   */
  virtual task body();
    super.body();

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /**
     * If the selected node is RN-F/RN-I/RN-D node, do cache line initialization
     * In case of selected node is RN-I/RN-D, the cache initialization happens
     * from one of the peer RN-F nodes. 
     */
    `ifdef SVT_CHI_ISSUE_E_ENABLE
    send_coherent_transactions(svt_chi_common_transaction::STASHONCESEPUNIQUE, 1);
    /** Wait for readshared transactions to finish */
    coherent_seq.wait_for_active_xacts_to_end();
    print_caches();
    `else    
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting... Please define the SVT_CHI_ISSUE_E_ENABLE macro and re-run"))
    `endif    
  endtask: body
endclass: svt_chi_system_single_node_stashoncesepunique_virtual_sequence

//------------------------------------------------------------------------------
/** 
 * @groupname CHI_E_SINGLE_RN_STASH_TYPE   
 *  This sequence initiates StashOnceSepShared transaction from the RN node specified with 
 *  node_index, which can be a random node or a specific node configured by the user. 
 */
class svt_chi_system_single_node_stashoncesepshared_virtual_sequence extends svt_chi_system_single_node_rn_coherent_transaction_base_virtual_sequence;
                             
  `svt_xvm_object_utils(svt_chi_system_single_node_stashoncesepshared_virtual_sequence)
 
  function new(string name = "svt_chi_system_single_node_stashoncesepshared_virtual_sequence");
    super.new(name);
    is_xact_type_valid_for_rn_i = 1;
    is_xact_type_valid_for_rn_d = 1;
  endfunction
   
   /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting RN-F Nodes = 1
   *  #- svt_chi_node_configuration::chi_spec_revision >= svt_chi_node_configuration::ISSUE_E
   */
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    string str_is_supported_info_prefix = "This sequence cannot be run based on the current configuration.\n";
    string str_is_supported_info = "";
    string str_is_supported_info_suffix = "Modify configurations through svt_chi_node_configuration::chi_spec_revision\n";
    is_supported = super.is_supported(cfg, silent);
    if(is_supported) begin
      `ifdef SVT_CHI_ISSUE_E_ENABLE
      if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision < svt_chi_node_configuration::ISSUE_E || sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0) begin
        is_supported = 0;
        str_is_supported_info = $sformatf("cache_stashing_enable is set to %0d or svt_chi_node_configuration::chi_spec_revision is set prior to svt_chi_node_configuration::ISSUE_E for initiating requester node %0d. StashOnceSepShared can only be issued from RN when svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_E or later and cache_stashing_enable is set to 1", sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable, initiating_rn_node_idx_0);
      end else
        is_supported = 1;
      `else
        is_supported = 0;
        str_is_supported_info = $sformatf("Macro SVT_CHI_ISSUE_E_ENABLE is not defined. StashOnceSepShared can only be issued when SVT_CHI_ISSUE_E_ENABLE is defined and svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_E or later for the Requester Nodes. ");
      `endif
      if (!is_supported) begin
        string str_complete_is_supported_info = {str_is_supported_info_prefix, str_is_supported_info, str_is_supported_info_suffix};
        issue_is_supported_failure(str_complete_is_supported_info);
      end
    end
  endfunction

  /**
   * Initializes cachelines and sends StashOnceSepShared from node "node_index"
   */
  virtual task body();
    super.body();

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /**
     * If the selected node is RN-F/RN-I/RN-D node, do cache line initialization
     * In case of selected node is RN-I/RN-D, the cache initialization happens
     * from one of the peer RN-F nodes. 
     */
    `ifdef SVT_CHI_ISSUE_E_ENABLE
    send_coherent_transactions(svt_chi_common_transaction::STASHONCESEPSHARED, 1);
    /** Wait for readshared transactions to finish */
    coherent_seq.wait_for_active_xacts_to_end();
    print_caches();
    `else    
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting... Please define the SVT_CHI_ISSUE_E_ENABLE macro and re-run"))
    `endif    
  endtask: body
endclass: svt_chi_system_single_node_stashoncesepshared_virtual_sequence
 
//------------------------------------------------------------------------------
/** 
 * @groupname CHI_SINGLE_RN_WR_TYPE   
 *  This sequence initiates WriteUniqueFullStash transaction from the RN node specified with 
 *  node_index, which can be a random node or a specific node configured by the user. 
 */
class svt_chi_system_single_node_writeuniquefullstash_virtual_sequence extends svt_chi_system_single_node_rn_coherent_transaction_base_virtual_sequence;
                             
  `svt_xvm_object_utils(svt_chi_system_single_node_writeuniquefullstash_virtual_sequence)
 
  function new(string name = "svt_chi_system_single_node_writeuniquefullstash_virtual_sequence");
    super.new(name);
    is_xact_type_valid_for_rn_i = 1;
    is_xact_type_valid_for_rn_d = 1;
  endfunction
   
   /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting RN-F Nodes = 1
   *  #- svt_chi_node_configuration::chi_spec_revision >= svt_chi_node_configuration::ISSUE_B
   */
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    string str_is_supported_info_prefix = "This sequence cannot be run based on the current configuration.\n";
    string str_is_supported_info = "";
    string str_is_supported_info_suffix = "Modify configurations through svt_chi_node_configuration::chi_spec_revision\n";
    is_supported = super.is_supported(cfg, silent);
    if(is_supported) begin
      `ifdef SVT_CHI_ISSUE_B_ENABLE
      if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A || sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0) begin
        is_supported = 0;
        str_is_supported_info = $sformatf("cache_stashing_enable is set to %0d or svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_A for initiating requester node %0d. WriteUniqueFullStash can only be issued from RN when svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_B or later and cache_stashing_enable is set to 1", sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable, initiating_rn_node_idx_0);
      end else
        is_supported = 1;
      `else
        is_supported = 0;
        str_is_supported_info = $sformatf("Macro SVT_CHI_ISSUE_B_ENABLE or SVT_CHI_ISSUE_C_ENABLE is not defined. WriteUniqueFullStash can only be issued when SVT_CHI_ISSUE_B_ENABLE or SVT_CHI_ISSUE_C_ENABLE is defined and svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_B or later for the Requester Nodes. ");
      `endif
      if (!is_supported) begin
        string str_complete_is_supported_info = {str_is_supported_info_prefix, str_is_supported_info, str_is_supported_info_suffix};
        issue_is_supported_failure(str_complete_is_supported_info);
      end
    end
  endfunction

  /**
   * Initializes cachelines and sends WriteUniqueFullStash from node "node_index"
   */
  virtual task body();
    super.body();

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /**
     * If the selected node is RN-F/RN-I/RN-D node, do cache line initialization
     * In case of selected node is RN-I/RN-D, the cache initialization happens
     * from one of the peer RN-F nodes. 
     */
    `ifdef SVT_CHI_ISSUE_B_ENABLE
    send_coherent_transactions(svt_chi_common_transaction::WRITEUNIQUEFULLSTASH, 1);
    /** Wait for readshared transactions to finish */
    coherent_seq.wait_for_active_xacts_to_end();
    print_caches();
    `else    
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting... Please define the SVT_CHI_ISSUE_B_ENABLE or SVT_CHI_ISSUE_C_ENABLE macro and re-run"))
    `endif    
  endtask: body
endclass: svt_chi_system_single_node_writeuniquefullstash_virtual_sequence

//------------------------------------------------------------------------------
/** 
 * @groupname CHI_SINGLE_RN_WR_TYPE   
 *  This sequence initiates WriteUniquePtlStash transaction from the RN node specified with 
 *  node_index, which can be a random node or a specific node configured by the user. 
 */
class svt_chi_system_single_node_writeuniqueptlstash_virtual_sequence extends svt_chi_system_single_node_rn_coherent_transaction_base_virtual_sequence;
                             
  `svt_xvm_object_utils(svt_chi_system_single_node_writeuniqueptlstash_virtual_sequence)
 
  function new(string name = "svt_chi_system_single_node_writeuniqueptlstash_virtual_sequence");
    super.new(name);
    is_xact_type_valid_for_rn_i = 1;
    is_xact_type_valid_for_rn_d = 1;
  endfunction
   
   /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting RN-F Nodes = 1
   *  #- svt_chi_node_configuration::chi_spec_revision >= svt_chi_node_configuration::ISSUE_B
   */
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    string str_is_supported_info_prefix = "This sequence cannot be run based on the current configuration.\n";
    string str_is_supported_info = "";
    string str_is_supported_info_suffix = "Modify configurations through svt_chi_node_configuration::chi_spec_revision\n";
    is_supported = super.is_supported(cfg, silent);
    if(is_supported) begin
      `ifdef SVT_CHI_ISSUE_B_ENABLE
      if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A || sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0) begin
        is_supported = 0;
        str_is_supported_info = $sformatf("cache_stashing_enable is set to %0d or svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_A for initiating requester node %0d. WriteUniqueFullStash can only be issued from RN when svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_B or later and cache_stashing_enable is set to 1", sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable, initiating_rn_node_idx_0);
      end else
        is_supported = 1;
      `else
        is_supported = 0;
        str_is_supported_info = $sformatf("Macro SVT_CHI_ISSUE_B_ENABLE or SVT_CHI_ISSUE_C_ENABLE is not defined. WriteUniquePtlStash can only be issued when SVT_CHI_ISSUE_B_ENABLE or SVT_CHI_ISSUE_C_ENABLE is defined and svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_B or later for the Requester Nodes. ");
      `endif
      if (!is_supported) begin
        string str_complete_is_supported_info = {str_is_supported_info_prefix, str_is_supported_info, str_is_supported_info_suffix};
        issue_is_supported_failure(str_complete_is_supported_info);
      end
    end
  endfunction

  /**
   * Initializes cachelines and sends WriteUniquePtlStash from node "node_index"
   */
  virtual task body();
    super.body();

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /**
     * If the selected node is RN-F/RN-I/RN-D node, do cache line initialization
     * In case of selected node is RN-I/RN-D, the cache initialization happens
     * from one of the peer RN-F nodes. 
     */
    `ifdef SVT_CHI_ISSUE_B_ENABLE
    send_coherent_transactions(svt_chi_common_transaction::WRITEUNIQUEPTLSTASH, 1);
    /** Wait for readshared transactions to finish */
    coherent_seq.wait_for_active_xacts_to_end();
    print_caches();
    `else    
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting... Please define the SVT_CHI_ISSUE_B_ENABLE or SVT_CHI_ISSUE_C_ENABLE macro and re-run"))
    `endif    
  endtask: body
endclass: svt_chi_system_single_node_writeuniqueptlstash_virtual_sequence

//------------------------------------------------------------------------------
/** 
 * @groupname CHI_SINGLE_RN_WR_TYPE   
 *  This sequence initiates StashOnceUnique transaction from the RN node specified with 
 *  node_index, which can be a random node or a specific node configured by the user. 
 */
class svt_chi_system_single_node_stashonceunique_virtual_sequence extends svt_chi_system_single_node_rn_coherent_transaction_base_virtual_sequence;
                             
  `svt_xvm_object_utils(svt_chi_system_single_node_stashonceunique_virtual_sequence)
 
  function new(string name = "svt_chi_system_single_node_stashonceunique_virtual_sequence");
    super.new(name);
    is_xact_type_valid_for_rn_i = 1;
    is_xact_type_valid_for_rn_d = 1;
  endfunction
   
   /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting RN-F Nodes = 1
   *  #- svt_chi_node_configuration::chi_spec_revision >= svt_chi_node_configuration::ISSUE_B
   */
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    string str_is_supported_info_prefix = "This sequence cannot be run based on the current configuration.\n";
    string str_is_supported_info = "";
    string str_is_supported_info_suffix = "Modify configurations through svt_chi_node_configuration::chi_spec_revision\n";
    is_supported = super.is_supported(cfg, silent);
    if(is_supported) begin
      `ifdef SVT_CHI_ISSUE_B_ENABLE
      if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A || sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0) begin
        is_supported = 0;
        str_is_supported_info = $sformatf("cache_stashing_enable is set to %0d or svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_A for initiating requester node %0d. StashOnceUnique can only be issued from RN when svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_B or later and cache_stashing_enable is set to 1", sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable, initiating_rn_node_idx_0);
      end else
        is_supported = 1;
      `else
        is_supported = 0;
        str_is_supported_info = $sformatf("Macro SVT_CHI_ISSUE_B_ENABLE or SVT_CHI_ISSUE_C_ENABLE is not defined. StashOnceUnique can only be issued when SVT_CHI_ISSUE_B_ENABLE or SVT_CHI_ISSUE_C_ENABLE is defined and svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_B or later for the Requester Nodes. ");
      `endif
      if (!is_supported) begin
        string str_complete_is_supported_info = {str_is_supported_info_prefix, str_is_supported_info, str_is_supported_info_suffix};
        issue_is_supported_failure(str_complete_is_supported_info);
      end
    end
  endfunction

  /**
   * Initializes cachelines and sends StashOnceUnique from node "node_index"
   */
  virtual task body();
    super.body();

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /**
     * If the selected node is RN-F/RN-I/RN-D node, do cache line initialization
     * In case of selected node is RN-I/RN-D, the cache initialization happens
     * from one of the peer RN-F nodes. 
     */
    `ifdef SVT_CHI_ISSUE_B_ENABLE
    send_coherent_transactions(svt_chi_common_transaction::STASHONCEUNIQUE, 1);
    /** Wait for readshared transactions to finish */
    coherent_seq.wait_for_active_xacts_to_end();
    print_caches();
    `else    
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting... Please define the SVT_CHI_ISSUE_B_ENABLE or SVT_CHI_ISSUE_C_ENABLE macro and re-run"))
    `endif    
  endtask: body
endclass: svt_chi_system_single_node_stashonceunique_virtual_sequence

//------------------------------------------------------------------------------
/** 
 * @groupname CHI_SINGLE_RN_WR_TYPE   
 *  This sequence initiates StashOnceShared transaction from the RN node specified with 
 *  node_index, which can be a random node or a specific node configured by the user. 
 */
class svt_chi_system_single_node_stashonceshared_virtual_sequence extends svt_chi_system_single_node_rn_coherent_transaction_base_virtual_sequence;
                             
  `svt_xvm_object_utils(svt_chi_system_single_node_stashonceshared_virtual_sequence)
 
  function new(string name = "svt_chi_system_single_node_stashonceshared_virtual_sequence");
    super.new(name);
    is_xact_type_valid_for_rn_i = 1;
    is_xact_type_valid_for_rn_d = 1;
  endfunction
   
   /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting RN-F Nodes = 1
   *  #- svt_chi_node_configuration::chi_spec_revision >= svt_chi_node_configuration::ISSUE_B
   */
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    string str_is_supported_info_prefix = "This sequence cannot be run based on the current configuration.\n";
    string str_is_supported_info = "";
    string str_is_supported_info_suffix = "Modify configurations through svt_chi_node_configuration::chi_spec_revision\n";
    is_supported = super.is_supported(cfg, silent);
    if(is_supported) begin
      `ifdef SVT_CHI_ISSUE_B_ENABLE
      if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A || sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0) begin
        is_supported = 0;
        str_is_supported_info = $sformatf("cache_stashing_enable is set to %0d or svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_A for initiating requester node %0d. StashOnceShared can only be issued from RN when svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_B or later and cache_stashing_enable is set to 1", sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable, initiating_rn_node_idx_0);
      end else
        is_supported = 1;
      `else
        is_supported = 0;
        str_is_supported_info = $sformatf("Macro SVT_CHI_ISSUE_B_ENABLE or SVT_CHI_ISSUE_C_ENABLE is not defined. StashOnceShared can only be issued when SVT_CHI_ISSUE_B_ENABLE or SVT_CHI_ISSUE_C_ENABLE is defined and svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_B or later for the Requester Nodes. ");
      `endif
      if (!is_supported) begin
        string str_complete_is_supported_info = {str_is_supported_info_prefix, str_is_supported_info, str_is_supported_info_suffix};
        issue_is_supported_failure(str_complete_is_supported_info);
      end
    end
  endfunction

  /**
   * Initializes cachelines and sends StashOnceShared from node "node_index"
   */
  virtual task body();
    super.body();

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /**
     * If the selected node is RN-F/RN-I/RN-D node, do cache line initialization
     * In case of selected node is RN-I/RN-D, the cache initialization happens
     * from one of the peer RN-F nodes. 
     */
    `ifdef SVT_CHI_ISSUE_B_ENABLE
    send_coherent_transactions(svt_chi_common_transaction::STASHONCESHARED, 1);
    /** Wait for readshared transactions to finish */
    coherent_seq.wait_for_active_xacts_to_end();
    print_caches();
    `else    
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting... Please define the SVT_CHI_ISSUE_B_ENABLE or SVT_CHI_ISSUE_C_ENABLE macro and re-run"))
    `endif    
  endtask: body
endclass: svt_chi_system_single_node_stashonceshared_virtual_sequence
    
//------------------------------------------------------------------------------
/** 
 * @groupname CHI_SINGLE_RN_WR_TYPE   
 *  This sequence initiates WriteUniquePtl transaction from the RN node specified with 
 *  node_index, which can be a random node or a specific node configured by the user. 
 */
class svt_chi_system_single_node_writeuniqueptl_virtual_sequence extends svt_chi_system_single_node_rn_coherent_transaction_base_virtual_sequence;
  
  `svt_xvm_object_utils(svt_chi_system_single_node_writeuniqueptl_virtual_sequence)
 
  function new(string name = "svt_chi_system_single_node_writeuniqueptl_virtual_sequence");
    super.new(name);
    is_xact_type_valid_for_rn_i = 1;
    is_xact_type_valid_for_rn_d = 1;
  endfunction

  /**
   * Sends WriteUniqueptl from node "node_index"
   */
  virtual task body();
    super.body();

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /**
     * If the selected node is RN-F/RN-I/RN-D node, do cache line initialization
     * In case of selected node is RN-I/RN-D, the cache initialization happens
     * from one of the peer RN-F nodes.
     */
    send_coherent_transactions(svt_chi_common_transaction::WRITEUNIQUEPTL, 1);
    /** Wait for readshared transactions to finish */
    coherent_seq.wait_for_active_xacts_to_end();
    print_caches();
  endtask: body
endclass: svt_chi_system_single_node_writeuniqueptl_virtual_sequence

//------------------------------------------------------------------------------
/** 
 * @groupname CHI_SINGLE_RN_CMO_TYPE   
 *  This sequence initiates CleanShared transaction from the RN node specified with 
 *  node_index, which can be a random node or a specific node configured by the user.
 *  Before sending each CleanShared transaction, cachelines of peer node are initialized
 *  to random, valid states. 
 */
class svt_chi_system_single_node_cleanshared_virtual_sequence extends svt_chi_system_single_node_rn_coherent_transaction_base_virtual_sequence;

  `svt_xvm_object_utils(svt_chi_system_single_node_cleanshared_virtual_sequence)
  
  function new(string name = "svt_chi_system_single_node_cleanshared_virtual_sequence");
    super.new(name);
    is_xact_type_valid_for_rn_i = 1;
    is_xact_type_valid_for_rn_d = 1;
  endfunction

  /**
   * Initializes cachelines and sends CleanShared from node "node_index"
   */
  virtual task body();
    super.body();

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /**
     * If the selected node is RN-F/RN-I/RN-D node, do cache line initialization
     * In case of selected node is RN-I/RN-D, the cache initialization happens
     * from one of the peer RN-F nodes.    
     */
    send_coherent_transactions(svt_chi_common_transaction::CLEANSHARED, 1);
    /** Wait for cleanshared transactions to finish */
    coherent_seq.wait_for_active_xacts_to_end();
    print_caches();
  endtask: body

endclass: svt_chi_system_single_node_cleanshared_virtual_sequence

//------------------------------------------------------------------------------
/** 
 * @groupname CHI_B_SINGLE_RN_CMO_TYPE   
 *  This sequence initiates CleanSharedPersist transaction from the RN node specified with 
 *  node_index, which can be a random node or a specific node configured by the user.
 *  Before sending each CleanSharedPersist transaction, cachelines of peer node are initialized
 *  to random, valid states. 
 */
class svt_chi_system_single_node_cleansharedpersist_virtual_sequence extends svt_chi_system_single_node_rn_coherent_transaction_base_virtual_sequence;

  `svt_xvm_object_utils(svt_chi_system_single_node_cleansharedpersist_virtual_sequence)
  
  function new(string name = "svt_chi_system_single_node_cleansharedpersist_virtual_sequence");
    super.new(name);
    is_xact_type_valid_for_rn_i = 1;
    is_xact_type_valid_for_rn_d = 1;
  endfunction
   
   /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting RN-F Nodes = 1
   *  #- svt_chi_node_configuration::chi_spec_revision = svt_chi_node_configuration::ISSUE_B
   */
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    string str_is_supported_info_prefix = "This sequence cannot be run based on the current configuration.\n";
    string str_is_supported_info = "";
    string str_is_supported_info_suffix = "Modify configurations through svt_chi_node_configuration::chi_spec_revision\n";
    is_supported = super.is_supported(cfg, silent);
    if(is_supported) begin
      `ifdef SVT_CHI_ISSUE_B_ENABLE
      if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) begin
        is_supported = 0;
        str_is_supported_info = $sformatf("svt_chi_node_configuration::chi_spec_revision set to svt_chi_node_configuration::ISSUE_A for initiating requester node %0d. CleanSharedPersist can only be issued from RN when svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_B or later. ", initiating_rn_node_idx_0);
      end else
        is_supported = 1;
      `else
        is_supported = 0;
        str_is_supported_info = $sformatf("Macro SVT_CHI_ISSUE_B_ENABLE or SVT_CHI_ISSUE_C_ENABLE is not defined. CleanSharedPersist can only be issued when SVT_CHI_ISSUE_B_ENABLE or SVT_CHI_ISSUE_C_ENABLE is defined and svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_B or later for the Requester Nodes. ");
      `endif
      if (!is_supported) begin
        string str_complete_is_supported_info = {str_is_supported_info_prefix, str_is_supported_info, str_is_supported_info_suffix};
        issue_is_supported_failure(str_complete_is_supported_info);
      end
    end
  endfunction 
  /**
   * Initializes cachelines and sends CleanSharedPersist from node "node_index"
   */
  virtual task body();
    super.body();

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /**
     * If the selected node is RN-F/RN-I/RN-D node, do cache line initialization
     * In case of selected node is RN-I/RN-D, the cache initialization happens
     * from one of the peer RN-F nodes.    
     */
    `ifdef SVT_CHI_ISSUE_B_ENABLE
    send_coherent_transactions(svt_chi_common_transaction::CLEANSHAREDPERSIST, 1);
    /** Wait for cleansharedpersist transactions to finish */
    coherent_seq.wait_for_active_xacts_to_end();
    print_caches();
    `else    
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting... Please define the SVT_CHI_ISSUE_B_ENABLE or later macro and re-run"))
    `endif    
  endtask: body

endclass: svt_chi_system_single_node_cleansharedpersist_virtual_sequence
   
//------------------------------------------------------------------------------
/** 
 * @groupname CHI_SINGLE_RN_CMO_TYPE    
 *  This sequence initiates CleanInvalid transaction from the RN node specified with 
 *  node_index, which can be a random node or a specific node configured by the user.
 *  Before sending each CleanInvalid transaction, cachelines of peer node are initialized
 *  to random, valid states. 
 */
class svt_chi_system_single_node_cleaninvalid_virtual_sequence extends svt_chi_system_single_node_rn_coherent_transaction_base_virtual_sequence;

  `svt_xvm_object_utils(svt_chi_system_single_node_cleaninvalid_virtual_sequence)
  
  function new(string name = "svt_chi_system_single_node_cleaninvalid_virtual_sequence");
    super.new(name);
    is_xact_type_valid_for_rn_i = 1;
    is_xact_type_valid_for_rn_d = 1;
  endfunction

  /**
   * Initializes cachelines and sends Cleaninvalid from node "node_index"
   */
  virtual task body();
    super.body();

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /** If the selected node is RN-F/RN-I/RN-D node, do cache line initialization
     * In case of selected node is RN-I/RN-D, the cache initialization happens
     * from one of the peer RN-F nodes.    
     */
    send_coherent_transactions(svt_chi_common_transaction::CLEANINVALID, 1);
    /** Wait for CleanInvalid transactions to finish */
    coherent_seq.wait_for_active_xacts_to_end();
    print_caches();
  endtask: body

endclass: svt_chi_system_single_node_cleaninvalid_virtual_sequence
//-------------------------------------------------------------------
/** 
 * @groupname CHI_D_SINGLE_RN_CMO_TYPE   
 *  This sequence initiates CleanSharedPersistSep transaction from the RN node specified with 
 *  node_index, which can be a random node or a specific node configured by the user.
 *  Before sending each CleanSharedPersistSep transaction, cachelines of peer node are initialized
 *  to random, valid states. 
 */
class svt_chi_system_single_node_cleansharedpersistsep_virtual_sequence extends svt_chi_system_single_node_rn_coherent_transaction_base_virtual_sequence;

  `svt_xvm_object_utils(svt_chi_system_single_node_cleansharedpersistsep_virtual_sequence)
  
  function new(string name = "svt_chi_system_single_node_cleansharedpersistsep_virtual_sequence");
    super.new(name);
    is_xact_type_valid_for_rn_i = 1;
    is_xact_type_valid_for_rn_d = 1;
  endfunction
   
   /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting RN-F Nodes = 1
   *  #- svt_chi_node_configuration::chi_spec_revision = svt_chi_node_configuration::ISSUE_B
   */
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    string str_is_supported_info_prefix = "This sequence cannot be run based on the current configuration.\n";
    string str_is_supported_info = "";
    string str_is_supported_info_suffix = "Modify configurations through svt_chi_node_configuration::chi_spec_revision\n";
    is_supported = super.is_supported(cfg, silent);
    if(is_supported) begin
      `ifdef SVT_CHI_ISSUE_D_ENABLE
      if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision < svt_chi_node_configuration::ISSUE_D) begin
        is_supported = 0;
        str_is_supported_info = $sformatf("svt_chi_node_configuration::chi_spec_revision set to svt_chi_node_configuration::%s for initiating requester node %0d. CleanSharedPersistSep can only be issued from RN when svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_D or later. ", sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision.name(),initiating_rn_node_idx_0);
      end 
      else if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].cleansharedpersistsep_xact_enable ==0) begin
        is_supported =0;
        str_is_supported_info = $sformatf("svt_chi_node_configuration::cleansharedpersistsep_xact_enable is set to 0 for initiating requester node %0d. CleanSharedPersistSep transaction can only be issued from RN when svt_chi_node_configuration::cleansharedpersistsep_xact_enable is set to 1.", initiating_rn_node_idx_0);
      end
      else
        is_supported = 1;
      `else
        is_supported = 0;
        str_is_supported_info = $sformatf("Macro SVT_CHI_ISSUE_D_ENABLE is not defined. CleanSharedPersistSep can only be issued when SVT_CHI_ISSUE_D_ENABLE or SVT_CHI_ISSUE_E_ENABLE is defined and svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_D or later for the Requester Nodes. ");
      `endif
      if (!is_supported) begin
        string str_complete_is_supported_info = {str_is_supported_info_prefix, str_is_supported_info, str_is_supported_info_suffix};
        issue_is_supported_failure(str_complete_is_supported_info);
      end
    end
  endfunction 
  /**
   * Initializes cachelines and sends CleanSharedPersistSep from node "node_index"
   */
  virtual task body();
    super.body();

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /**
     * If the selected node is RN-F/RN-I/RN-D node, do cache line initialization
     * In case of selected node is RN-I/RN-D, the cache initialization happens
     * from one of the peer RN-F nodes.    
     */
    `ifdef SVT_CHI_ISSUE_D_ENABLE
    send_coherent_transactions(svt_chi_common_transaction::CLEANSHAREDPERSISTSEP, 1);
    /** Wait for cleansharedpersistsep transactions to finish */
    coherent_seq.wait_for_active_xacts_to_end();
    print_caches();
    `else    
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting... Please define the SVT_CHI_ISSUE_D_ENABLE or later macro and re-run"))
    `endif    
  endtask: body

endclass: svt_chi_system_single_node_cleansharedpersistsep_virtual_sequence

//------------------------------------------------------------------------------
/** 
 * @groupname CHI_SINGLE_RN_CMO_TYPE    
 *  This sequence initiates MakeInvalid transaction from the RN node specified with 
 *  node_index, which can be a random node or a specific node configured by the user.
 *  Before sending each MakeInvalid transaction, cachelines of peer node are initialized
 *  to random, valid states. 
 */
class svt_chi_system_single_node_makeinvalid_virtual_sequence extends svt_chi_system_single_node_rn_coherent_transaction_base_virtual_sequence;

  `svt_xvm_object_utils(svt_chi_system_single_node_makeinvalid_virtual_sequence)
  function new(string name = "svt_chi_system_single_node_makeinvalid_virtual_sequence");
    super.new(name);
    is_xact_type_valid_for_rn_i = 1;
    is_xact_type_valid_for_rn_d = 1;
  endfunction

  /**
   * Initializes cachelines and sends MakeInvalid from node "node_index"
   */
  virtual task body();
    super.body();

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /** If the selected node is RN-F/RN-I/RN-D node, do cache line initialization
     * In case of selected node is RN-I/RN-D, the cache initialization happens
     * from one of the peer RN-F nodes.    
     */
    send_coherent_transactions(svt_chi_common_transaction::MAKEINVALID, 1);
    /** Wait for MakeInvalid transactions to finish */
    coherent_seq.wait_for_active_xacts_to_end();
    print_caches();
  endtask: body

endclass: svt_chi_system_single_node_makeinvalid_virtual_sequence

//------------------------------------------------------------------------------
// ---------------------------- DVM Sequences ----------------------------------
/** 
 * @groupname CHI_SINGLE_RN_DVM_TYPE    
 *  This sequence initiates DVM operations followed by a DVM sync from the RN node 
 *  specified with node_index, which can be a random node or a specific node 
 *  configured by the user.The above sequence is repeated for sequence_length.
 * The sequence terminates only when each of the DVM syncs sent out from a port 
 * are received from the interconnect.
 */

class svt_chi_system_single_node_dvm_virtual_sequence extends svt_chi_system_single_node_rn_coherent_transaction_base_virtual_sequence;

  /** Controls the number of random DVM write semantic operations that 
    * will be generated */
  int unsigned dvm_write_semantic_length = 5;

  /** Queue which holds all DVM transactions */
  svt_chi_transaction  dvm_xact[$];
 
  bit dvm_sync_data_phase_complete = 0;

  `svt_xvm_object_utils(svt_chi_system_single_node_dvm_virtual_sequence)
 
  function new(string name = "svt_chi_system_single_node_dvm_virtual_sequence");
    super.new(name);
  endfunction

/**
 * Sends DVM transactions from node "node_index"
 */
  virtual task body();
    bit dvm_write_semantic_length_status;  
    /** Represents the RN node indices which are used by the sequence 
     *  to initiate the transactions.
     *  initiating_rn_node_idx_0 can be programmed by the user
     *  using config_db, otherwise it picks random node indices depending 
     *  on the flag select_rn_f_node.if select_rn_f_node is programed to one
     *  from the test RN node of type RN-F is selected else RN-D is selected.
     */
    int unsigned sel_initiating_rn_node_idx;

    super.body();
    dvm_write_semantic_length_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(), "dvm_write_semantic_length", dvm_write_semantic_length);
    `svt_xvm_debug("body", $sformatf("dvm_write_semantic_length is %0d as a result of %0s.", dvm_write_semantic_length, dvm_write_semantic_length_status ? "the config DB" : "default value"));
    initiating_rn_node_index_0_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(), "initiating_rn_node_idx_0", initiating_rn_node_index_0_from_config_db);
    // Setup default value of sel_initiating_rn_node_idx as RN-F type
    if(select_rn_f_node)
      sel_initiating_rn_node_idx = initiating_rn_f_node_index_0;
    else if(select_rn_d_node) 
      sel_initiating_rn_node_idx = initiating_rn_d_node_index_0;
    else
      sel_initiating_rn_node_idx = initiating_rn_f_node_index_0;

    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :sel_initiating_rn_node_idx;
    node_index = initiating_rn_node_idx_0;

    `svt_xvm_debug("pre_start", $sformatf("select_rn_f_node is %0d as a result of %0s.", select_rn_f_node, select_rn_f_node_status ? "config DB" : "default value"));
    `svt_xvm_debug("pre_start", $sformatf("select_rn_d_node is %0d as a result of %0s.", select_rn_d_node, select_rn_d_node_status ? "config DB" : "default value"));

    `svt_xvm_debug("body",$sformatf("sel_initiating_rn_node_idx = %d,initiating_rn_f_node_index_0=%d,initiating_rn_d_node_index_0=%d",sel_initiating_rn_node_idx,initiating_rn_f_node_index_0,initiating_rn_d_node_index_0));

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

      send_dvm_sequence(sequence_length);
  endtask: body

  virtual task send_dvm_sequence(int num_of_syncs);
    svt_chi_rn_transaction_dvm_sync_sequence dvm_sync_seq;
    svt_chi_rn_transaction dvm_sync_xact;

    for (int sync_num = 0; sync_num < num_of_syncs; sync_num++) begin
      `svt_xvm_debug("body",$sformatf("Starting DVM Operation on RN %0d",node_index));
      dvm_sync_data_phase_complete = 0;
      fork
      begin
        `svt_xvm_do_on_with(dvm_sync_seq,p_sequencer.rn_virt_seqr[node_index].rn_xact_seqr, {sequence_length == local::sequence_length;})
      end
      begin
        wait(dvm_sync_seq != null);
        wait(dvm_sync_seq.dvm_sync_data_phase_complete == 1);
        dvm_sync_data_phase_complete = 1;
      end
      join
  
      if (!$cast(dvm_sync_xact, p_sequencer.rn_virt_seqr[node_index].rn_xact_seqr.last_req())) begin
        `svt_xvm_fatal("body", $psprintf("Unable to cast last_req from seqr"));
      end
      else begin
        `svt_xvm_debug("body", $psprintf("Got the last_req %0s from seqr", `SVT_CHI_PRINT_PREFIX(dvm_sync_xact)));
      end
    end
  endtask

  /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting RN-F Nodes = 1
   *          (or)
   *  #- minimum supporting RN-D Nodes = 1
   */
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    /** local variables */
    int   array_idx = -1;
    bit is_supported_rn_f,is_supported_rn_d;
    string str_rn_f_node,str_rn_d_node,str_rn_node;
    string str_is_supported_info_prefix = "This sequence cannot be run based on the current system configuration.\n";
    string str_is_supported_info = "";
    string str_is_supported_info_suffix = "Modify configurations through \n\
                                           svt_chi_system_configuration::num_rn, \n\
                                           svt_chi_node_configuration::is_active,\n\
                                           svt_chi_system_configuration::participating_rn_nodes[]\n";
    `svt_xvm_debug("is_supported",$sformatf("calling is_supported"));

    /** By default is_supported, is_supported_rn_f, is_supported_rn_d
     *  variables are set to 0.
     */
    is_supported = 0;
    is_supported_rn_f = 0;
    is_supported_rn_d = 0;

    /** Display the contents of Active Participating RN_F Nodes */
    foreach (active_participating_rn_f_nodes[j]) begin
      str_rn_f_node = {str_rn_f_node, $sformatf(" %0d", active_participating_rn_f_nodes[j])};
    end 
    `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_f_nodes are %s", str_rn_f_node));
 
    /** Display the contents of Active Participating RN_I Nodes */
    foreach (active_participating_rn_d_nodes[j]) begin
      str_rn_d_node = {str_rn_d_node, $sformatf(" %0d", active_participating_rn_d_nodes[j])};
    end 
    `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_d_nodes are %s", str_rn_d_node));
 
    /** Display the contents of Active Participating RN Nodes */
    foreach (active_participating_rn_nodes[j]) begin
      str_rn_node = {str_rn_node, $sformatf(" %0d", active_participating_rn_nodes[j])};
    end 
    `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_nodes are %s", str_rn_node));
    
    /**
     * Algorithm for checking is_supported, related to node_index:
     * - If node_index is passed through config DB:
     *   + This sequence is valid to initiate from RN-F and RN-D as well, so the
     *     node_index should be part of active_participating_rn_f_nodes or
     *     active_participating_rn_d_nodes
     *   .
     * - If node_index is not passed through config DB:
     *   + If only select_rn_f_node is set to 1:
     *     o node_index should be part of active_participating_rn_f_nodes
     *     .
     *   + If only select rn_d_node is set to 1:
     *     o It should be valid to initiate the sequence from RN-D. 
     *     o node_index should be part of active_participating_rn_d_nodes.
     *     .
     *   + If both select_rn_f_node, select_rn_d_node are set to 0 or 1 together:
     *     o This sequence is valid to initiate from RN-F and RN-D as well, so the
     *       node_index should be part of active_participating_rn_f_nodes
     *       or active_participating_rn_d_nodes
     *     .
     *   .
     * .
     */  
    // node_index is passed through config DB OR
    // it's the condition that node_index can be either of RN-D/RN-F
    // types as programmed through config DB
    if ((node_index_status) ||
        ((select_rn_f_node && select_rn_d_node) || 
         ((!select_rn_f_node) && (!select_rn_d_node))
        )
       ) begin
      string str_input_mode = (node_index_status)?" passed through config DB":"";
      // If node_index is passed through config DB, check validity
      // As RN-F is a valid initiating node, check if node_index is part of active_participating_rn_f_nodes
      is_supported_rn_f = is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, node_index, array_idx);
      // As RN-D is a valid initiating node, check if node_index is part of active_participating_rn_d_nodes
      is_supported_rn_d = is_value_found_in_int_assoc_array(active_participating_rn_d_nodes, node_index, array_idx);

      if(is_supported_rn_f || is_supported_rn_d)
        is_supported = 1;
      else
        is_supported = 0;

      if (!is_supported) begin
        str_is_supported_info = $sformatf("node_index %0d%0s is not valid for this sequence. The RN corresponding to svt_chi_system_configuration::rn_cfg[%0d] is not active(svt_chi_node_configuration::is_active is 0) and not participating (not part of the array svt_chi_system_configuration::participating_rn_nodes[])", node_index, str_input_mode, node_index);
      end
    end // if ((node_index_status) ||...
    // node_index is not passed through config DB AND
    // node_index is programmed to be selected a RN-F node type.
    else if (select_rn_f_node && (!select_rn_d_node)) begin
      is_supported = is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, node_index, array_idx);
      if (!is_supported) begin
        str_is_supported_info = $sformatf("select_rn_f_node is set to 1. node_index %0d is not valid for this sequence. The RN corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and participating RN-F type(should be part of the array svt_chi_system_configuration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F).", node_index, node_index);
      end
    end
    // node_index is not passed through config DB AND
    // node_index is programmed to be selected as RN-D node type.
    else if ((!select_rn_f_node) && select_rn_d_node) begin
      is_supported = is_value_found_in_int_assoc_array(active_participating_rn_d_nodes, node_index, array_idx);
      if (!is_supported) begin
        str_is_supported_info = $sformatf("select_rn_d_node is set to 1. node_index %0d is not valid for this sequence. The RN corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and participating RN-D type(should be part of the array svt_chi_system_configuration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_D).", node_index, node_index);
      end
    end // if ((!select_rn_f_node) && select_rn_d_node)

    if (!is_supported) begin
      string str_complete_is_supported_info = {str_is_supported_info_prefix, str_is_supported_info, str_is_supported_info_suffix};
      issue_is_supported_failure(str_complete_is_supported_info);
    end
  endfunction : is_supported

endclass: svt_chi_system_single_node_dvm_virtual_sequence
//------------------------------------------------------------------------------
/**
 * @groupname CHI_SINGLE_RN_BARRIER_TYPE    
 * svt_chi_system_barrier_sequence
 * The sequence sends number of pre-barrier store transaction, controlled by 
 * num_pre_barrier_stores knobe from RN Node followed by ECBARRIER or EOBARRIER
 * transaction. After sending Barrier transaction initiating node send a post 
 * barrier store to user controlled address (post_barrier_store_address) with a
 * specific value (post_barrier_store_data).
 * 
 * User can configure the number of nodes that observe (poll) post_barrier_store_address
 * to be updated with post_barrier_store_data. When the observing node find expected 
 * data at post_barrier_store_address, mean the post-barrier store transaction has
 * reached the endpoint, which implies all the pre-barrier store must have finish.
 * 
 * As a check the observing nodes initiate load transaction corresponging to all
 * the pre-barrier store transaction, and check for data integrity between the
 * pre-barrier store and post-barrier load.     
 */ 
class svt_chi_system_barrier_sequence extends svt_chi_system_single_node_rn_coherent_transaction_base_virtual_sequence;
  rand int unsigned                          num_pre_barrier_stores;

  // Node to initiate pre-barrier store & post-barrier store and barrier transaction
  rand int unsigned                          initiating_node_index;

  // Node with observers post-barrier store for specific value, followed by reading 
  // the pre-barrier write locations and checking data integrity between per & post 
  // barrier store & load instruction.
  // Note - If the num_observers is ZERO, initiating_node_index will be used as observer node
  rand int unsigned                          num_observers;

  // Type of berrier to issue EOBARRIER or ECBARRIER
  rand svt_chi_common_transaction::xact_type_enum barrier_xact = svt_chi_common_transaction::EOBARRIER;

  // Timeout value for all polling observer thread for post barrier store
  real observer_thread_timeout = 1000000;

  // Address of post barrier store which is polled by observers 
  bit [`SVT_CHI_MAX_ADDR_WIDTH-1:0] post_barrier_store_address;
  
  // Data value of post barrier store which is polled by observers 
  bit [`SVT_CHI_MAX_DATA_WIDTH-1:0] post_barrier_store_data = 64'hBEAD_FACE;

  // Queue for generating random RN observers index
  int                               unsigned rn_index[$];

  bit post_barrier_store_address_status;

  svt_chi_rn_go_noncoherent_sequence         pre_barrier_store_seq, post_barrier_store_seq;
  svt_chi_rn_go_noncoherent_sequence         post_barrier_load_seq;

  int active_participating_q [$];

  `svt_xvm_object_utils(svt_chi_system_barrier_sequence)
  `svt_xvm_declare_p_sequencer(svt_chi_system_virtual_sequencer)

  constraint valid_barrier_xact {barrier_xact inside {svt_chi_common_transaction::EOBARRIER, svt_chi_common_transaction::ECBARRIER};}

  extern virtual task send_pre_parrier_store_xact(int num_of_xact, int node_index);

  extern virtual task send_post_barrier_store(int node_index, bit[`SVT_CHI_MAX_ADDR_WIDTH-1:0] store_addr, bit [(`SVT_CHI_MAX_DATA_WIDTH-1):0] store_data_val, output svt_chi_rn_transaction post_barrier_store_xact);
  
  extern virtual task send_barrier_xact(int node_index);
  
  extern virtual task poll_post_barrier_store(int node_index, svt_chi_rn_transaction post_barrier_store_xact, bit [(`SVT_CHI_MAX_DATA_WIDTH-1):0] exp_data_val);

  extern virtual task send_post_barrier_load_xact(int node_index);

  extern virtual task check_pre_barrier_and_post_barrier_xact_contents(svt_chi_rn_go_noncoherent_sequence pre_barrier_seq,
                                                                       svt_chi_rn_go_noncoherent_sequence post_barrier_seq);
    
  /** 
   * Gets system configuration from sequencer.
   */
  extern virtual task pre_start();

  extern virtual task body();

  /** Class Constructor */
  function new (string name = "svt_chi_system_barrier_sequence");
    super.new(name);
    is_xact_type_valid_for_rn_i = 1;
    is_xact_type_valid_for_rn_d = 1;
  endfunction : new

  extern virtual function bit[`SVT_CHI_MAX_ADDR_WIDTH-1:0] get_pre_barrier_store_addr();
  extern virtual function bit[`SVT_CHI_MAX_ADDR_WIDTH-1:0] get_post_barrier_store_addr();
  
  extern virtual function int unsigned get_random_observer_index();

endclass // svt_chi_system_barrier_sequence
  
task svt_chi_system_barrier_sequence::send_pre_parrier_store_xact(int num_of_xact, int node_index);
  bit [`SVT_CHI_MAX_ADDR_WIDTH-1:0] store_address;
  svt_chi_rn_transaction rand_xact;
  `svt_xvm_debug("send_pre_parrier_store_xact",$psprintf("num_of_xact - %0d and node_index - %0d", num_of_xact, node_index));
  `svt_xvm_create_on(pre_barrier_store_seq, p_sequencer.rn_virt_seqr[node_index].rn_xact_seqr)
  pre_barrier_store_seq.disable_all_weights();
  pre_barrier_store_seq.writenosnpfull_wt = 1;
  pre_barrier_store_seq.initialize_cachelines = 0;
  pre_barrier_store_seq.randomize_with_directed_data = 0;
  pre_barrier_store_seq.store_data = 0;
  for(int a =0; a < num_pre_barrier_stores; a++) begin
    store_address = get_pre_barrier_store_addr();
    store_address[5:0] = 'h0;
    //rand_xact = new();
    `svt_xvm_create(rand_xact);
    rand_xact.cfg = sys_cfg.rn_cfg[node_index];
    void'(rand_xact.randomize with {xact_type == WRITENOSNPFULL; mem_attr_is_cacheable == 0;});
    `svt_xvm_debug("send_pre_parrier_store_xact",$psprintf("For pre-barrier store number - %0d - store_addr - %h", a, store_address));
    pre_barrier_store_seq.directed_addr_mailbox.put(store_address);
    pre_barrier_store_seq.directed_snp_attr_is_snoopable_mailbox.put(rand_xact.snp_attr_is_snoopable);
    `ifndef SVT_CHI_ISSUE_B_ENABLE
      pre_barrier_store_seq.directed_snp_attr_snp_domain_type_mailbox.put(rand_xact.snp_attr_snp_domain_type);
    `endif
    pre_barrier_store_seq.directed_mem_attr_allocate_hint_mailbox.put(rand_xact.mem_attr_allocate_hint);
    pre_barrier_store_seq.directed_is_non_secure_access_mailbox.put(rand_xact.is_non_secure_access);
  end
  void'(pre_barrier_store_seq.randomize with {use_directed_addr == 1; sequence_length==local::num_pre_barrier_stores;});
  pre_barrier_store_seq.start(p_sequencer.rn_virt_seqr[node_index].rn_xact_seqr);
  `svt_xvm_debug("send_pre_parrier_store_xact","After pre_barrier_store_seq.start");
endtask // send_pre_parrier_trasnaction

task svt_chi_system_barrier_sequence::send_post_barrier_store(int node_index, bit[`SVT_CHI_MAX_ADDR_WIDTH-1:0] store_addr, bit [(`SVT_CHI_MAX_DATA_WIDTH-1):0] store_data_val, output svt_chi_rn_transaction post_barrier_store_xact);
  svt_chi_rn_transaction rand_xact;
  `svt_xvm_debug("send_post_barrier_store", $psprintf("node_index - %d store_addr - %h \n store_data_val - %h", node_index, store_addr , store_data_val));
  
  `svt_xvm_create_on(post_barrier_store_seq, p_sequencer.rn_virt_seqr[node_index].rn_xact_seqr)
  post_barrier_store_seq.disable_all_weights();
  post_barrier_store_seq.writenosnpfull_wt = 1;
  post_barrier_store_seq.initialize_cachelines = 0;
  post_barrier_store_seq.randomize_with_directed_data = 0;
  post_barrier_store_seq.directed_addr_mailbox.put(store_addr);
  //rand_xact = new();
  `svt_xvm_create(rand_xact);
  rand_xact.cfg = sys_cfg.rn_cfg[node_index];
  void'(rand_xact.randomize with {xact_type == WRITENOSNPFULL; mem_attr_is_cacheable == 0;});
  post_barrier_store_seq.directed_snp_attr_is_snoopable_mailbox.put(rand_xact.snp_attr_is_snoopable);
  `ifndef SVT_CHI_ISSUE_B_ENABLE
    post_barrier_store_seq.directed_snp_attr_snp_domain_type_mailbox.put(rand_xact.snp_attr_snp_domain_type);
  `endif
  post_barrier_store_seq.directed_mem_attr_allocate_hint_mailbox.put(rand_xact.mem_attr_allocate_hint);
  post_barrier_store_seq.directed_is_non_secure_access_mailbox.put(rand_xact.is_non_secure_access);
  post_barrier_store_seq.store_data = store_data_val;
  void'(post_barrier_store_seq.randomize with {use_directed_addr == 1;sequence_length==1;});
  post_barrier_store_seq.start(p_sequencer.rn_virt_seqr[node_index].rn_xact_seqr);
  `svt_xvm_debug("send_post_barrier_store", $psprintf("After post_barrier_store_seq.start() node_index - %d store_addr - %h \n store_data_val - %h", node_index, store_addr , store_data_val));
  post_barrier_store_xact = post_barrier_store_seq.get_xact_from_active_queue(0);
endtask // send_post_barrier_store

task svt_chi_system_barrier_sequence::send_barrier_xact(int node_index);
  `svt_xvm_debug("send_barrier_xact", $psprintf("node_index - %0d, barrier_xact - %s ", node_index, barrier_xact.name()));
  
  if(barrier_xact == svt_chi_common_transaction::EOBARRIER) begin
    svt_chi_rn_eobarrier_sequence eobarrier_seq;
    `svt_xvm_create_on(eobarrier_seq, p_sequencer.rn_virt_seqr[node_index].rn_xact_seqr)
    void'(eobarrier_seq.randomize with {use_directed_addr == 0; sequence_length==1;});
    eobarrier_seq.start(p_sequencer.rn_virt_seqr[node_index].rn_xact_seqr);
  end
  else begin
    svt_chi_rn_ecbarrier_sequence ecbarrier_seq;
    `svt_xvm_create_on(ecbarrier_seq, p_sequencer.rn_virt_seqr[node_index].rn_xact_seqr)
    void'(ecbarrier_seq.randomize with {use_directed_addr == 0; sequence_length==1;});
    ecbarrier_seq.start(p_sequencer.rn_virt_seqr[node_index].rn_xact_seqr);
  end
endtask // send_barrier_xact

task svt_chi_system_barrier_sequence::poll_post_barrier_store(int node_index, svt_chi_rn_transaction post_barrier_store_xact, bit [(`SVT_CHI_MAX_DATA_WIDTH-1):0] exp_data_val);
  svt_chi_rn_go_noncoherent_sequence post_barrier_poll_seq;
  svt_chi_rn_transaction             load_xact;
  int                                poll_attempts = 1;
  
  `svt_xvm_debug("poll_post_barrier_store", $psprintf("node_index - %0d, load_addr - %h \n exp_data_val - %h ", node_index, post_barrier_store_xact.addr, exp_data_val));
  while(1) begin
    `svt_xvm_create_on(post_barrier_poll_seq, p_sequencer.rn_virt_seqr[node_index].rn_xact_seqr)
    post_barrier_poll_seq.disable_all_weights();
    post_barrier_poll_seq.readnosnp_wt = 1;
    post_barrier_poll_seq.initialize_cachelines = 0;
    post_barrier_poll_seq.directed_addr_mailbox.put(post_barrier_store_xact.addr);
    post_barrier_poll_seq.directed_snp_attr_is_snoopable_mailbox.put(post_barrier_store_xact.snp_attr_is_snoopable);
    `ifndef SVT_CHI_ISSUE_B_ENABLE
      post_barrier_poll_seq.directed_snp_attr_snp_domain_type_mailbox.put(post_barrier_store_xact.snp_attr_snp_domain_type);
    `endif
    post_barrier_poll_seq.directed_mem_attr_allocate_hint_mailbox.put(post_barrier_store_xact.mem_attr_allocate_hint);
    post_barrier_poll_seq.directed_is_non_secure_access_mailbox.put(post_barrier_store_xact.is_non_secure_access);
    void'(post_barrier_poll_seq.randomize with {use_directed_addr == 1; sequence_length==1;});
    post_barrier_poll_seq.start(p_sequencer.rn_virt_seqr[node_index].rn_xact_seqr);
    `svt_xvm_debug("poll_post_barrier_store", $psprintf("poll_attempts - %0d, after post_barrier_poll_seq.start() ", poll_attempts));
    post_barrier_poll_seq.wait_for_active_xacts_to_end();
    `svt_xvm_debug("poll_post_barrier_store", $psprintf("poll_attempts - %0d finished, for node_index - %0d, load_addr - %h ", poll_attempts, node_index, post_barrier_store_xact.addr));
    
    load_xact = post_barrier_poll_seq.get_xact_from_active_queue(0);

    if(load_xact != null) begin
      if((load_xact.data_status == svt_chi_common_transaction::ACCEPT) &&
         (load_xact.data == exp_data_val)) begin
        `svt_xvm_debug("poll_post_barrier_store", $psprintf("poll_attempts - %0d succeeded for node_index - %0d, load_addr - %h ", poll_attempts, node_index, post_barrier_store_xact.addr));
        break;
      end
      else begin
        `svt_xvm_debug("poll_post_barrier_store", $psprintf("poll_attempts - %0d unsuccessful for node_index - %0d, load_addr - %h data_status - %s, \n data returned - %h \n exp_data_val - %h",poll_attempts, node_index, post_barrier_store_xact.addr, load_xact.data_status.name(),load_xact.data, exp_data_val));
      end
    end
    else begin
      `svt_xvm_error("poll_post_barrier_store","get_xact_from_active_queue() returned NULL");
    end
    poll_attempts++;
  end // while (1)
  `svt_xvm_debug("poll_post_barrier_store", "Exiting poll_post_barrier_store()");
endtask

task svt_chi_system_barrier_sequence::send_post_barrier_load_xact(int node_index);
  svt_chi_rn_transaction                     rn_xact;
  `svt_xvm_debug("send_post_barrier_load_xact", $psprintf("node_index - %0d", node_index));
  
  `svt_xvm_create_on(post_barrier_load_seq, p_sequencer.rn_virt_seqr[node_index].rn_xact_seqr)
  post_barrier_load_seq.readnosnp_wt = 1;
  post_barrier_load_seq.initialize_cachelines = 0;
  post_barrier_load_seq.randomize_with_directed_data = 1;
  for(int i =0; i < num_pre_barrier_stores; i++) begin
    rn_xact = pre_barrier_store_seq.get_xact_from_active_queue(i);
    if(rn_xact != null) begin
      post_barrier_load_seq.directed_addr_mailbox.put(rn_xact.addr);
      post_barrier_load_seq.directed_data_mailbox.put(rn_xact.data);
      post_barrier_load_seq.directed_snp_attr_is_snoopable_mailbox.put(rn_xact.snp_attr_is_snoopable);
      `ifndef SVT_CHI_ISSUE_B_ENABLE
        post_barrier_load_seq.directed_snp_attr_snp_domain_type_mailbox.put(rn_xact.snp_attr_snp_domain_type);
      `endif
      post_barrier_load_seq.directed_mem_attr_allocate_hint_mailbox.put(rn_xact.mem_attr_allocate_hint);
      post_barrier_load_seq.directed_is_non_secure_access_mailbox.put(rn_xact.is_non_secure_access);
      `svt_xvm_debug("send_post_barrier_load_xact",$psprintf("For post-barrier load number - %0d - load_addr - %h", i, rn_xact.addr));
    end
    else begin
      `svt_xvm_error("send_post_barrier_load_xact","get_xact_from_active_queue() returned NULL");
    end
  end
  void'(post_barrier_load_seq.randomize with {use_directed_addr == 1;sequence_length==local::num_pre_barrier_stores;});
  post_barrier_load_seq.start(p_sequencer.rn_virt_seqr[node_index].rn_xact_seqr);
  `svt_xvm_debug("send_post_barrier_load_xact", $psprintf("After post_barrier_load_seq.start() node_index - %0d", node_index));
  post_barrier_load_seq.wait_for_active_xacts_to_end();

  check_pre_barrier_and_post_barrier_xact_contents(pre_barrier_store_seq, post_barrier_load_seq);
  `svt_xvm_debug("svt_chi_system_barrier_sequence","Exiting svt_chi_system_barrier_sequence");
endtask // send_post_barrier_load_xact

task svt_chi_system_barrier_sequence::check_pre_barrier_and_post_barrier_xact_contents(svt_chi_rn_go_noncoherent_sequence pre_barrier_seq,
                                                                                        svt_chi_rn_go_noncoherent_sequence post_barrier_seq);
  svt_chi_rn_transaction pre_barrier_xact, post_barrier_xact;
  `svt_xvm_debug("check_pre_barrier_and_post_barrier_xact_contents","Entering check_pre_barrier_and_post_barrier_xact_contents");
  
  if((pre_barrier_seq != null) && (post_barrier_seq != null)) begin
    for(int i =0; i < num_pre_barrier_stores; i++) begin
      pre_barrier_xact  = pre_barrier_seq.get_xact_from_active_queue(i);
      post_barrier_xact = post_barrier_seq.get_xact_from_active_queue(i);

      if((pre_barrier_xact != null) && (post_barrier_xact != null)) begin
        if(pre_barrier_xact.addr === post_barrier_xact.addr) begin
`protected
^UM<09C9O95;S]]8Mef33.Z4N6+7aU/A;T0c_QVZSAS=(GJ@QP-R/)G&R0DgA;JY
330)H8MF/#Q&L6-aTK1RRHa87,#@-]H.>9C0eG0N7:c=D$
`endprotected
          
          if(pre_barrier_xact.data[63:0] != post_barrier_xact.data[63:0]) begin
            `svt_xvm_error("check_pre_barrier_and_post_barrier_xact_contents",
                             $psprintf("Data missmatch for address - %h \n Pre-Barrier store data - %h \n Post-Barrier load data - %h", pre_barrier_xact.addr, pre_barrier_xact.data, post_barrier_xact.data));
          end
          else begin
            `svt_xvm_debug("check_pre_barrier_and_post_barrier_xact_contents",
                             $psprintf("Data matches for address - %h \n Pre-Barrier store data - %h \n Post-Barrier load data - %h", pre_barrier_xact.addr, pre_barrier_xact.data, post_barrier_xact.data));
          end
        end
        else begin
          `svt_xvm_error("check_pre_barrier_and_post_barrier_xact_contents","Address missmatch");
        end // else: !if(pre_barrier_xact.addr === post_barrier_xact.addr)
      end // if ((pre_barrier_xact != null) && (post_barrier_xact != null))
    end // for (int i =0; i < num_pre_barrier_stores; i++)
  end // if ((pre_barrier_seq != null) && (post_barrier_seq != null))
  else begin
    `svt_xvm_error("check_pre_barrier_and_post_barrier_xact_contents","pre_barrier_seq or post_barrier_seq sequence handle is NULL");
  end // else: !if((pre_barrier_seq != null) && (post_barrier_seq != null))
  `svt_xvm_debug("check_pre_barrier_and_post_barrier_xact_contents","Exiting check_pre_barrier_and_post_barrier_xact_contents");
endtask // check_pre_barrier_and_post_barrier_xact_contents

task svt_chi_system_barrier_sequence::pre_start();
  `SVT_XVM(object) base_obj;
  svt_configuration base_cfg;
  super.pre_start();
endtask

task svt_chi_system_barrier_sequence::body();
  svt_chi_rn_transaction post_barrier_store_xact;
  bit          status;
  int unsigned active_observer;
  super.body();

  /** check if current environment is supported or not */ 
  if(!is_supported(sys_cfg, silent))  begin
    `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
    return;
  end

  status = uvm_config_db#(int unsigned)::get(m_sequencer, get_type_name(), "num_pre_barrier_stores", num_pre_barrier_stores);
  `svt_xvm_debug("body", $sformatf("num_pre_barrier_stores is %0d as a result of %0s.", num_pre_barrier_stores, status ? "the config DB" : "randomization"));
  status = uvm_config_db#(svt_chi_common_transaction::xact_type_enum)::get(m_sequencer, get_type_name(), "barrier_xact", barrier_xact);
  `svt_xvm_debug("body", $sformatf("barrier_xact is %s as a result of %0s.", barrier_xact.name(), status ? "the config DB" : "randomization"));
  status = uvm_config_db#(int unsigned)::get(m_sequencer, get_type_name(), "num_observers",num_observers);
  `svt_xvm_debug("body", $sformatf("num_observers is %0d as a result of %0s.", num_observers, status ? "the config DB" : "randomization"));
  status = uvm_config_db#(real)::get(m_sequencer, get_type_name(), "observer_thread_timeout", observer_thread_timeout);
  `svt_xvm_debug("body", $sformatf("observer_thread_timeout is %0d as a result of %0s.", observer_thread_timeout, status ? "the config DB" : "default value"));
  post_barrier_store_address_status = uvm_config_db#(bit [`SVT_CHI_MAX_ADDR_WIDTH-1:0])::get(m_sequencer, get_type_name(), "post_barrier_store_address", post_barrier_store_address);
  `svt_xvm_debug("body", $sformatf("post_barrier_store_address is %h as a result of %0s.", post_barrier_store_address, post_barrier_store_address_status ? "the config DB" : "randomization"));
  status = uvm_config_db#(bit [`SVT_CHI_MAX_DATA_WIDTH-1:0])::get(m_sequencer, get_type_name(), "post_barrier_store_data", post_barrier_store_data);
  `svt_xvm_debug("body", $sformatf("post_barrier_store_data is %h as a result of %0s.", post_barrier_store_data, status ? "the config DB" : "default value"));

  if(active_participating_rn_nodes.size() < (num_observers + 1))begin
    `svt_xvm_fatal("body",$psprintf("Programed number of observing RN node (%0d) greater that total RN node in system that are active and participating (%0d).", num_observers, active_participating_rn_nodes.size()));
  end
  else begin
    // Update active_participating_q array such that it contains all the
    // RN indices except the node_index.  
    active_participating_q = active_participating_rn_nodes.find with ((item != node_index));
    foreach(active_participating_q[i])begin
      `svt_xvm_debug("body", $psprintf("node_index - %0h active_participating_q[%d] - %0h",node_index,i,active_participating_q[i]));
    end
    //Reprograming the num_observers passed by the user if it is greater than total number of RN nodes 
    //present in the system that are active and participating except initiating RN node
    if(active_participating_q.size() < num_observers)begin
      `svt_xvm_debug("body",$psprintf(" Programmed number of observing RN node (%0d) greater that total RN node in system that are active and participating (%0d) excluding the initiating node_index (%0d).", num_observers, active_participating_q.size(),node_index));
      num_observers = active_participating_q.size();
      `svt_xvm_debug("body",$psprintf("Programmed number of observing RN nodes (%0d) greater than the total RN nodes (%0d), excluding the initiating node_index (%0d), that are active and participating", num_observers, active_participating_q.size(),node_index));
    end
    active_observer = num_observers;
    `svt_xvm_debug("body", $psprintf("num_observers - %d", num_observers));
  end

  if(!post_barrier_store_address_status)
    post_barrier_store_address = get_post_barrier_store_addr;

  `svt_xvm_debug("body", $psprintf("post_barrier_store_address - %0h get_post_barrier_store_addr - %0h, post_barrier_store_address_status=%0d",post_barrier_store_address,get_post_barrier_store_addr,post_barrier_store_address_status));

  if(post_barrier_store_address[5:0] != 'h0)begin
    post_barrier_store_address[5:0] = 'h0;
  end
  `svt_xvm_debug("body", $psprintf("post_barrier_store_address - %0h post_barrier_store_data - %0h",post_barrier_store_address,post_barrier_store_data));

  send_pre_parrier_store_xact(num_pre_barrier_stores, node_index);
  send_barrier_xact(node_index);
  send_post_barrier_store(node_index, post_barrier_store_address, post_barrier_store_data, post_barrier_store_xact);
  
  begin : observer_thread
    if(num_observers > 0) begin
      for(int k = 0; k < num_observers; k++) begin
        `svt_xvm_debug("body::observer_thread", $psprintf("num_observers loop - %d", k));
        fork
          begin
            int observer_node_index = get_random_observer_index();
            `svt_xvm_debug("body::observer_thread", $psprintf("num_observers loop - %d, observer_node_index - %0d", k, observer_node_index));
            poll_post_barrier_store(observer_node_index, post_barrier_store_xact, post_barrier_store_data);
            `svt_xvm_debug("body", "After poll_post_barrier_store()");
            send_post_barrier_load_xact(observer_node_index);
            `svt_xvm_debug("body", "After send_post_barrier_load_xact()");
            active_observer--;
            `svt_xvm_debug("body", $psprintf("active_observer - %0d",active_observer));
          end
        join_none
        `svt_xvm_debug("body::observer_thread", $psprintf("num_observers loop - %d after kicking off polling thread", k));
      end // for (int k = -1; k < num_observers; k++)
    end // if(num_observers > 0)
  end // block: observer_thread
  
  fork
    begin : wait_for_observer_thread
      `svt_xvm_debug("body::wait_for_observer_thread", "Waiting for all observer_thread to finish");
      wait(active_observer == 0);
      `svt_xvm_debug("body::wait_for_observer_thread", "All observer_thread's finished");
    end
    begin : watchdog
      #observer_thread_timeout;
      `svt_xvm_error("body",$psprintf("Sequence %s timed out waiting for observer_thread to finish", this.get_full_name()));
    end
  join_any
  
  disable observer_thread;
  disable wait_for_observer_thread;
  active_participating_q.delete();

  `svt_xvm_debug("body", "Exiting svt_chi_system_barrier_sequence::body()");
  
endtask // body
  
function bit[`SVT_CHI_MAX_ADDR_WIDTH-1:0] svt_chi_system_barrier_sequence::get_pre_barrier_store_addr();
  bit[`SVT_CHI_MAX_ADDR_WIDTH-1:0] start_addr, end_addr;
  int reg_idx = 0;
  start_addr = sys_cfg.get_hn_start_addr(0);
  end_addr = sys_cfg.get_hn_end_addr(0);
  //Make sure that the random address generated does not fall within the register address space
  while(reg_idx >= 0) begin
    //$urandom_range only works on int (32 bit numbers). So, break the address into chunks of 32 bits
    get_pre_barrier_store_addr[31:0] = $urandom_range(end_addr[31:0], start_addr[31:0]);
    get_pre_barrier_store_addr[`SVT_CHI_MAX_ADDR_WIDTH-1:32] = $urandom_range(int'(end_addr[`SVT_CHI_MAX_ADDR_WIDTH-1:32]), int'(start_addr[`SVT_CHI_MAX_ADDR_WIDTH-1:32]));
    reg_idx = sys_cfg.chi_addr_cfg.get_mn_addr_range_index(get_pre_barrier_store_addr);
  end
endfunction // get_pre_barrier_store_addr

function bit[`SVT_CHI_MAX_ADDR_WIDTH-1:0] svt_chi_system_barrier_sequence::get_post_barrier_store_addr();
  bit[`SVT_CHI_MAX_ADDR_WIDTH-1:0] start_addr, end_addr;
  int reg_idx = 0;
  start_addr = sys_cfg.get_hn_start_addr(0);
  end_addr = sys_cfg.get_hn_end_addr(0);
  while(reg_idx >= 0) begin
    //$urandom_range only works on int (32 bit numbers). So, break the address into chunks of 32 bits
    get_post_barrier_store_addr[31:0] = $urandom_range(end_addr[31:0], start_addr[31:0]);
    get_post_barrier_store_addr[`SVT_CHI_MAX_ADDR_WIDTH-1:32] = $urandom_range(int'(end_addr[`SVT_CHI_MAX_ADDR_WIDTH-1:32]), int'(start_addr[`SVT_CHI_MAX_ADDR_WIDTH-1:32]));
    reg_idx = sys_cfg.chi_addr_cfg.get_mn_addr_range_index(get_post_barrier_store_addr);
  end
endfunction // get_post_barrier_store_addr

function int unsigned svt_chi_system_barrier_sequence::get_random_observer_index();
  get_random_observer_index = active_participating_q.pop_back();
endfunction 


//------------------------------------------------------------------------------------
/** 
  * @groupname CHI_SYS_MULTI_RN
  * This sequence sends coherent transactions from multiple RN and provides mechanism
  * to control following parameters.
  *  - transactions are sent from each RN only which are applicable to those RNs
  *  - specific transactions can be controlled seperately for each RN by setting corresponding weights
  *  - transaction can either be sent with random address or sequential address
  *  - transactions from different RNs can be set to send with overlapped addresses or
  *       completely seperate non-overlapped addresses. These are achieved by setting
  *       "addr_mode" along with "rn_start_addr[]" and "rn_end_addr[]" address array.
  *  - it allows user to send transactions in blocking or sequential manner
  *  - user can specify number of RN from which transactions will be sent as well as
  *  - specific RN indexes from which transactions will be sent
  *  - sequence takes care of cacheline initiallization in order to send transactions
  *       from correct initial state without getting dropped by RN driver layer
  *  - sequence provides necessary constraints to randomize above parameters 
  *  - it also allows user to override sequence members
  *
  *  - address ranges for each RN are specified through combination of "rn_start_addr" and "rn_end_addr"
  *  - index of rn_start_addr or rn_end_addr for a specific RN is determined by the
  *       position of that RN in the rn_index_list_for_sending_transaction[] array.
  *       Ex: rn_index_list_for_sending_transaction = {1, 3} and rn_start_addr = {32'h1000, 32'h2000}
  *           This means RN-1 and RN-3 will be used to send transactions to interconnect and
  *           RN-1 will have start address of its accessible address region as 32'h1000 and
  *           RN-3 as 32'h2000
  *
  *  - even though sequence can be randomized to automatically create mutually exclusive or
  *    overlapped address regions for different RNs either random or sequential, user can also
  *    specifically set such address regions by means of configuration override
  *  - Failure severity of is_supported functionality of the sequence can be controlled by the attribute is_supported_failure_severity.
  *  - In case of addr_mode set to SEQUENTIAL_NONOVERLAPPED_ADDRESS or SEQUENTIAL_OVERLAPPED_ADDRESS, rn_end_addr is
  *    not required to be programmed as rn_end_addr will be calculated based on the rn_start_addr and the sequece_length.
  *    Even if rn_end_addr is programmed it will be overriden with the value calculated based on the rn_start_addr and the sequece_length.
  *  - Mix of coherent and non-coherent transactions within an RN is not allowed as there can be a possibility of mismatch attributes to the same address resulting into software error sceanrio.
  *  - When addr_mode is set to RANDOM_OVERLAPPED_ADDRESS  or SEQUENTIAL_OVERLAPPED_ADDRESS, no 2 RN's should have transaction weights as one RN enabled with non-coherent transactions and the other with coherent transactions as ther can be mismatched memory attributes to the same address resulting into software error scenario.
  *  - Transaction weights for each RN should be configured through config_db setting. If not the default weights will be set wherein all the coherent transaction weights will be enabled.
  *  - For cache initialization, single attribute 'initialize_cachelines' which is applicable for all RN's can be programmed or 'rn_initialize_cachelines' attribute can be programmed per RN basis. When both are programmed, rn_initialize_cachelines will take the precedence.
  *  - For CMO transactions and atomic transactions from a particular node, the memory attributes (Cacheable, Device, EWA) and Snp_attr will be configured same as that of other coherent transactions if atleast one coherent transaction weights is programmed for that node. This behavior can be controlled through the attribute use_coherent_xacts_mem_attr_snp_attr_for_cmo_atomics per RN basis.
  *  - Currently this sequence doesn't factor in non_secure_access bit for address calculation. i.e, tagged address
  *  .
  *
  *  NOTE: sequence is currently supported in UVM or OVM methodology
  */
//------------------------------------------------------------------------------------
  
class svt_chi_system_coherent_virtual_sequence extends svt_chi_system_rn_coherent_transaction_base_virtual_sequence;

  typedef svt_chi_rn_coherent_transaction_base_sequence::addressing_mode_enum addr_mode_type;

  /** determines addresses for each transaction generated by this sequence.
    * indicates whether random address will be chosen or if sequential addresses
    * will be used for successive transactions.
    *
    * if SEQUENTIAL_NONOVERLAPPED_ADDRESS or SEQUENTIAL_OVERLAPPED_ADDRESS
    * addressing mode is chosen then address for first transaction
    * will be chosen randomly but addresses for subsequent transacitons will be 
    * incremented by one cacheline size from previous transaction address.
    *
    * if RANDOM_NONOVERLAPPED_ADDRESS or RANDOM_OVERLAPPED_ADDRESS
    * addressing mode is chosen then address for all transaction will be chosen
    * randomly within the boundary of rn_start_addr and rn_end_addr.
    *
    * It also supports overlapped and nonoverlapped aspect of addressing.
    * if RANDOM_NONOVERLAPPED_ADDRESS or SEQUENTIAL_NONOVERLAPPED_ADDRESS 
    * addressing mode is chosen then address boundary rn_start_addr and rn_end_addr
    * of each RN will be determined such that, each RN will have disjoint address
    * space.
    * Otherwise, if RANDOM_OVERLAPPED_ADDRESS or SEQUENTIAL_OVERLAPPED_ADDRESS 
    * addressing mode is chosen then address boundary rn_start_addr and rn_end_addr
    * of each RN will be determined such that, at least one RN will have address
    * space overlapped with other RN address space.
    *
    * If USER_DEFINED mode is chosen then addresses are not restricted by sequential
    * or overlapping rules as described above. In other words, addresses will simply
    * be generated in random manner.
    *
    * Currently supported modes: RANDOM_NONOVERLAPPED_ADDRESS, SEQUENTIAL_NONOVERLAPPED_ADDRESS,
    *                            RANDOM_OVERLAPPED_ADDRESS,    SEQUENTIAL_OVERLAPPED_ADDRESS,
    *                            USER_DEFINED
    *
    * NOTE: addr_mode can be overridden by user directly without waiting on randomization
    *       of the sequence member. 
    */
  rand addr_mode_type addr_mode = svt_chi_rn_coherent_transaction_base_sequence::RANDOM_NONOVERLAPPED_ADDRESS;

  /** Status field for capturing config DB get status for addr_mode */
  bit addr_mode_status;

  /** determines if transactions are sent by this sequence sequentially as
    * blocking transaction or as non-blocking outstanding transactions
    */
  rand bit send_blocking_transactions = 0;

  /** Indicates number of RNs to be used by this sequence for sending transactions
    */
  rand int unsigned num_rn_to_send_transaction = 2;

  /** Holds RN indexes or port-id(s) to which this sequence will send transactions
    * Total size of this list must be same as num_rn_to_send_transaction
    */
  rand int unsigned rn_index_list_for_sending_transaction[];

  /** holds start address of accessible address ranges of each RN */
  rand bit[`SVT_CHI_MAX_ADDR_WIDTH-1:0] rn_start_addr[];

  /** holds end address of accessible address ranges of each RN */
  rand bit[`SVT_CHI_MAX_ADDR_WIDTH-1:0] rn_end_addr[];

  /** Internal attribute which calculates the value to be added to start addr based on sequence length */
  bit[`SVT_CHI_MAX_ADDR_WIDTH-1:0] add_to_start_addr;

  /** Attribute to control the cache initialization, applicable for all the RN's*/
  bit initialize_cachelines = 1;

  /** Attribute to control the cache initialization per RN basis*/
  bit rn_initialize_cachelines[];
  bit rn_init_cachelines_status[];

  /** Attribute to constrain the CMO and Atomic transactions memory attributes (Cacheable, EWA, Device) and SnpAttr to be same as that of other coherent transactions (Cacheable[1], EWA[1], Device[0], SnpAttr[1]) */
  bit use_coherent_xacts_mem_attr_snp_attr_for_cmo_atomics[];
  bit use_coherent_xacts_mem_attr_snp_attr_for_cmo_atomics_status[];

  /** Attribute to constrain the order_type field of transactions to that of the seq_order_type field of the primitive sequences. Default value is set to 1 */
  bit use_seq_order_type[];
  bit use_seq_order_type_status[];

  /** Active transaction queue */
  protected svt_chi_rn_transaction active_xacts[$];
  
  /** Distribution weight for generation of READNOSNOOP transactions */
  int unsigned readnosnp_wt[];
  /** Distribution weight for generation of READONCE transaction */
  int unsigned readonce_wt[];
  /** Distribution weight for generation of READCLEAN transaction */
  int unsigned readclean_wt[];

`ifdef SVT_CHI_ISSUE_E_ENABLE
  /** Distribution weight for generation of WRITEEVICTOREVICT transactions */
  int unsigned writeevictorevict_wt[];
  /** Distribution weight for generation of WRITENOSNPZERO transactions */
  int unsigned writenosnpzero_wt[];
  /** Distribution weight for generation of WRITEUNIQUEZERO transactions */
  int unsigned writeuniquezero_wt[];
  /** Distribution weight for generation of MAKEREADUNIQUE transactions */
  int unsigned makereadunique_wt[];
  /** Distribution weight for generation of READPREFERUNIQUE transactions */
  int unsigned readpreferunique_wt[];
  /** Distribution weight for generation of WRITENOSNPFULL_CLEANSHARED transactions */
  int unsigned writenosnpfull_cleanshared_wt[];
  /** Distribution weight for generation of WRITENOSNPFULL_CLEANSHAREDPERSISTSEP transactions */
  int unsigned writenosnpfull_cleansharedpersistsep_wt[];
  /** Distribution weight for generation of WRITEUNIQUEFULL_CLEANSHARED transactions */
  int unsigned writeuniquefull_cleanshared_wt[];
  /** Distribution weight for generation of WRITEUNIQUEFULL_CLEANSHAREDPERSISTSEP transactions */
  int unsigned writeuniquefull_cleansharedpersistsep_wt[];
  /** Distribution weight for generation of WRITENOSNPFULL_CLEANINVALID transactions */
  int unsigned writenosnpfull_cleaninvalid_wt[];
  /** Distribution weight for generation of WRITENOSNPPTL_CLEANINVALID transactions */
  int unsigned writenosnpptl_cleaninvalid_wt[];
  /** Distribution weight for generation of WRITENOSNPPTL_CLEANSHARED transactions */
  int unsigned writenosnpptl_cleanshared_wt[];
  /** Distribution weight for generation of WRITENOSNPPTL_CLEANSHAREDPERSISTSEP transactions */
  int unsigned writenosnpptl_cleansharedpersistsep_wt[];
  /** Distribution weight for generation of WRITEUNIQUEPTL_CLEANSHARED transactions */
  int unsigned writeuniqueptl_cleanshared_wt[];
  /** Distribution weight for generation of WRITEUNIQUEPTL_CLEANSHAREDPERSISTSEP transactions */
  int unsigned writeuniqueptl_cleansharedpersistsep_wt[];
  /** Distribution weight for generation of WRITEBACKFULL_CLEANSHARED transactions */
  int unsigned writebackfull_cleanshared_wt[];
  /** Distribution weight for generation of WRITEBACKFULL_CLEANSHAREDPERSISTSEP transactions */
  int unsigned writebackfull_cleansharedpersistsep_wt[];
  /** Distribution weight for generation of WRITEBACKFULL_CLEANINVALID transactions */
  int unsigned writebackfull_cleaninvalid_wt[];
  /** Distribution weight for generation of WRITECLEANFULL_CLEANSHARED transactions */
  int unsigned writecleanfull_cleanshared_wt[];
  /** Distribution weight for generation of WRITECLEANFULL_CLEANSHAREDPERSISTSEP transactions */
  int unsigned writecleanfull_cleansharedpersistsep_wt[];
  /** Distribution weight for generation of STASHONCESEPUNIQUE transaction */
  int unsigned stashoncesepunique_wt[];
  /** Distribution weight for generation of STASHONCESEPSHARED transaction */
  int unsigned stashoncesepshared_wt[];
`endif //issue_e_enable

  `ifdef SVT_CHI_ISSUE_D_ENABLE
  /** Distribution weight for generation of CleanSharedPersistSep transaction */
  int unsigned cleansharedpersistsep_wt[];
  `endif  //issue_d_enable

`ifdef SVT_CHI_ISSUE_B_ENABLE
  /** Distribution weight for generation of READSPEC transaction */
  int unsigned readspec_wt[];
  /** Distribution weight for generation of READNOTSHAREDDIRTY transaction */
  int unsigned readnotshareddirty_wt[];
  /** Distribution weight for generation of READONCECLEANINVALID transaction */
  int unsigned readoncecleaninvalid_wt[];
  /** Distribution weight for generation of READONCEMAKEINVALID transaction */
  int unsigned readoncemakeinvalid_wt[];
  /** Distribution weight for generation of CLEANSHAREDPERSIST transaction */
  int unsigned cleansharedpersist_wt[];
  /** Distribution weight for generation of ATOMICSTORE_ADD transaction */
  int unsigned atomicstore_add_wt[];
  /** Distribution weight for generation of ATOMICSTORE_CLR transaction */
  int unsigned atomicstore_clr_wt[];
  /** Distribution weight for generation of ATOMICSTORE_EOR transaction */
  int unsigned atomicstore_eor_wt[];
  /** Distribution weight for generation of ATOMICSTORE_SET transaction */
  int unsigned atomicstore_set_wt[];
  /** Distribution weight for generation of ATOMICSTORE_SMAX transaction */
  int unsigned atomicstore_smax_wt[];
  /** Distribution weight for generation of ATOMICSTORE_SMIN transaction */
  int unsigned atomicstore_smin_wt[];
  /** Distribution weight for generation of ATOMICSTORE_UMAX transaction */
  int unsigned atomicstore_umax_wt[];
  /** Distribution weight for generation of ATOMICSTORE_UMIN transaction */
  int unsigned atomicstore_umin_wt[];
  /** Distribution weight for generation of ATOMICLOAD_ADD transaction */
  int unsigned atomicload_add_wt[];
  /** Distribution weight for generation of ATOMICLOAD_CLR transaction */
  int unsigned atomicload_clr_wt[];
  /** Distribution weight for generation of ATOMICLOAD_EOR transaction */
  int unsigned atomicload_eor_wt[];
  /** Distribution weight for generation of ATOMICLOAD_SET transaction */
  int unsigned atomicload_set_wt[];
  /** Distribution weight for generation of ATOMICLOAD_SMAX transaction */
  int unsigned atomicload_smax_wt[];
  /** Distribution weight for generation of ATOMICLOAD_SMIN transaction */
  int unsigned atomicload_smin_wt[];
  /** Distribution weight for generation of ATOMICLOAD_UMAX transaction */
  int unsigned atomicload_umax_wt[];
  /** Distribution weight for generation of ATOMICLOAD_UMIN transaction */
  int unsigned atomicload_umin_wt[];
  /** Distribution weight for generation of ATOMICSWAP transaction */
  int unsigned atomicswap_wt[];
  /** Distribution weight for generation of ATOMICOMPARE transaction */
  int unsigned atomiccompare_wt[];
  /** Distribution weight for generation of PREFETCHTGT transaction */
  int unsigned prefetchtgt_wt[];
  /** Distribution weight for generation of WRITEUNIQUEFULLSTASH transaction */
  int unsigned writeuniquefullstash_wt[];
  /** Distribution weight for generation of WRITEUNIQUEPTLSTASH transaction */
  int unsigned writeuniqueptlstash_wt[];
  /** Distribution weight for generation of STASHONCEUNIQUE transaction */
  int unsigned stashonceunique_wt[];
  /** Distribution weight for generation of STASHONCESHARED transaction */
  int unsigned stashonceshared_wt[];
`endif
  /** Distribution weight for generation of READSHARED transaction */
  int unsigned readshared_wt[];
  /** Distribution weight for generation of READUNIQUE transaction */
  int unsigned readunique_wt[];
  /** Distribution weight for generation of CLEANUNIQUE transaction */
  int unsigned cleanunique_wt[];
  /** Distribution weight for generation of MAKEUNIQUE transaction */
  int unsigned makeunique_wt[];
  /** Distribution weight for generation of WRITEBACKFULL transaction */
  int unsigned writebackfull_wt[];
  /** Distribution weight for generation of WRITEBACKPTL transaction */
  int unsigned writebackptl_wt[];
  /** Distribution weight for generation of WRITEEVICTFULL transaction */
  int unsigned writeevictfull_wt[];
  /** Distribution weight for generation of WRITECLEANFULL transaction */
  int unsigned writecleanfull_wt[];
  /** Distribution weight for generation of WRITECLEANPTL transaction */
  int unsigned writecleanptl_wt[];
  /** Distribution weight for generation of EVICT transaction */
  int unsigned evict_wt[];
  /** Distribution weight for generation of WRITENOSNPFULL transaction */
  int unsigned writenosnpfull_wt[];
  /** Distribution weight for generation of WRITENOSNPPTL transaction */
  int unsigned writenosnpptl_wt[];
  /** Distribution weight for generation of WRITEUNIQUEFULL transaction */
  int unsigned writeuniquefull_wt[];
  /** Distribution weight for generation of WRITEUNIQUEPTL transaction */
  int unsigned writeuniqueptl_wt[];
  /** Distribution weight for generation of CLEANSHARED transaction */
  int unsigned cleanshared_wt[];
  /** Distribution weight for generation of CLEANINVALID transaction */
  int unsigned cleaninvalid_wt[];
  /** Distribution weight for generation of MAKEINVALID transaction */
  int unsigned makeinvalid_wt[];
  /** Distribution weight for generation of EOBARRIER transaction */
  int unsigned eobarrier_wt[];
  /** Distribution weight for generation of ECBARRIER transaction */
  int unsigned ecbarrier_wt[];
  /** Distribution weight for generation of DVMOP transaction */
  int unsigned dvmop_wt[];
  /** Distribution weight for generation of PCRDRETURN transaction */
  int unsigned pcrdreturn_wt[];
  /** Distribution weight for generation of REQLINKFLIT transaction */
  int unsigned reqlinkflit_wt[];
  // ---------------------------------------------------------------------------------------------------

  local bit status_wt[];
  protected int cacheline_size = 8, cacheline_size_log2; // (in bytes)
  protected bit coherent_transactions_sent_from_rn_process_completed[int];
  svt_chi_rn_coherent_transaction_base_sequence  active_seq_queue[$];
  // ---------------------------------------------------------------------------------------------------
  
  `svt_xvm_object_utils(svt_chi_system_coherent_virtual_sequence)
  
  function void pre_randomize();
    super.pre_randomize();
    cacheline_size = sys_cfg.get_max_cacheline_size();
    cacheline_size_log2 = sys_cfg.rn_cfg[0].log_base_2(cacheline_size);
  endfunction

  constraint valid_node_constraint {
      solve num_rn_to_send_transaction before rn_index_list_for_sending_transaction;

      num_rn_to_send_transaction > 0;
      num_rn_to_send_transaction <= active_participating_rn_nodes.size();

      rn_index_list_for_sending_transaction.size() == num_rn_to_send_transaction;

      foreach(rn_index_list_for_sending_transaction[ix]) {
              rn_index_list_for_sending_transaction[ix] inside {active_participating_rn_nodes};
          `ifndef INCA
          `ifndef QUESTA
              if(ix>0) {
                 solve rn_index_list_for_sending_transaction[ix-1] before rn_index_list_for_sending_transaction[ix];
              }
          `endif
          `endif
      }
      foreach(rn_index_list_for_sending_transaction[ix]) {
        foreach(rn_index_list_for_sending_transaction[jx]) {
          (jx>ix) -> rn_index_list_for_sending_transaction[ix] != rn_index_list_for_sending_transaction[jx];
        }
      }
  } 

  constraint valid_addr_ranges {
      solve addr_mode before num_rn_to_send_transaction;
      solve addr_mode before rn_start_addr;
      solve addr_mode before rn_end_addr;
      solve num_rn_to_send_transaction before rn_start_addr;
      solve num_rn_to_send_transaction before rn_end_addr;

      addr_mode inside {svt_chi_rn_coherent_transaction_base_sequence::RANDOM_NONOVERLAPPED_ADDRESS, svt_chi_rn_coherent_transaction_base_sequence::SEQUENTIAL_NONOVERLAPPED_ADDRESS, svt_chi_rn_coherent_transaction_base_sequence::RANDOM_OVERLAPPED_ADDRESS, svt_chi_rn_coherent_transaction_base_sequence::SEQUENTIAL_OVERLAPPED_ADDRESS, svt_chi_rn_coherent_transaction_base_sequence::USER_DEFINED};
      
      rn_start_addr.size() == num_rn_to_send_transaction;
      rn_end_addr.size() == num_rn_to_send_transaction;

      foreach(rn_start_addr[ix]) {
          // each RN should have accessible address space of minimum one cacheline size
          //(rn_start_addr[ix] + cacheline_size) <= rn_end_addr[ix];
          rn_start_addr[ix] <= rn_end_addr[ix];
           rn_start_addr[ix] < ({`SVT_CHI_MAX_ADDR_WIDTH{1'b1}} - ((num_rn_to_send_transaction-ix+2) << (cacheline_size_log2+16)));

          // all RNs will have disjoint address spaces if address mode is marked non-overlapped
          if(addr_mode == svt_chi_rn_coherent_transaction_base_sequence::RANDOM_NONOVERLAPPED_ADDRESS ||
             addr_mode == svt_chi_rn_coherent_transaction_base_sequence::SEQUENTIAL_NONOVERLAPPED_ADDRESS) {
             (ix > 0) -> (rn_start_addr[ix] > rn_end_addr[ix-1]);
          }

          if(addr_mode == svt_chi_rn_coherent_transaction_base_sequence::SEQUENTIAL_OVERLAPPED_ADDRESS ||
             addr_mode == svt_chi_rn_coherent_transaction_base_sequence::SEQUENTIAL_NONOVERLAPPED_ADDRESS) {
             (rn_end_addr[ix] == (rn_start_addr[ix] + ((sequence_length-1) * `SVT_CHI_CACHE_LINE_SIZE)));
          }

          // all RNs will have at least one overlapped address space if address mode is marked overlapped
          if(addr_mode == svt_chi_rn_coherent_transaction_base_sequence::RANDOM_OVERLAPPED_ADDRESS ||
             addr_mode == svt_chi_rn_coherent_transaction_base_sequence::SEQUENTIAL_OVERLAPPED_ADDRESS) {
             (ix > 0) -> (((rn_start_addr[ix] <= rn_end_addr[ix-1]) && (rn_start_addr[ix] >= rn_start_addr[ix-1])) ||
                          ((rn_end_addr[ix]   <= rn_end_addr[ix-1]) && (rn_end_addr[ix]   >= rn_start_addr[ix-1])) );
          }

          `ifndef INCA
              solve rn_start_addr[ix] before rn_end_addr[ix] ;
          `ifndef QUESTA
          if(ix > 0) {
              solve rn_end_addr[ix-1] before rn_start_addr[ix] ;
              solve rn_end_addr[ix-1] before rn_end_addr[ix] ;
              solve rn_start_addr[ix-1] before rn_start_addr[ix] ;
              solve rn_start_addr[ix-1] before rn_end_addr[ix] ;
          }
          `endif
          `endif
      }
  }
  
  // -------------------------------------------------------------------
  function new(string name = "svt_chi_system_coherent_virtual_sequence");
    super.new(name);
    add_to_start_addr = ((sequence_length-1) * `SVT_CHI_CACHE_LINE_SIZE);
  endfunction

  virtual task pre_start();
    super.pre_start();
    raise_phase_objection();
    get_overridden_sequence_member_values();
    //set_rn_transaction_start_ports();
  endtask

  virtual task post_start();
    super.post_start();
    drop_phase_objection();
  endtask

  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    is_supported = 1;
    `svt_xvm_debug("is_supported",$sformatf("Entering ..."));

    if (rn_index_list_for_sending_transaction.size() != num_rn_to_send_transaction) begin
      issue_is_supported_failure($sformatf("rn_index_list_for_sending_transaction.size() observed value is %0d. However, rn_index_list_for_sending_transaction.size() must be equal to num_rn_to_send_transaction %0d.", rn_index_list_for_sending_transaction.size(), num_rn_to_send_transaction));
      is_supported = 0;
    end
    else begin
      foreach(rn_index_list_for_sending_transaction[ix]) begin
        if (!(rn_index_list_for_sending_transaction[ix] inside {active_participating_rn_nodes})) begin
          issue_is_supported_failure($sformatf("rn_index_list_for_sending_transaction[%0d]: %0d. Should be one of the active_participating_rn_nodes %0p",ix, rn_index_list_for_sending_transaction[ix], active_participating_rn_nodes));
          is_supported = 0;
        end
      end
      foreach(rn_index_list_for_sending_transaction[ix]) begin
        foreach(rn_index_list_for_sending_transaction[jx]) begin
          if (jx > ix) begin
            if (rn_index_list_for_sending_transaction[ix] == rn_index_list_for_sending_transaction[jx]) begin
              issue_is_supported_failure($sformatf("elements of rn_index_list_for_sending_transaction must be unique. However, rn_index_list_for_sending_transaction[%0d]: %0d and rn_index_list_for_sending_transaction[%0d]: %0d are same.", ix, rn_index_list_for_sending_transaction[ix], jx, rn_index_list_for_sending_transaction[jx]));
              is_supported = 0;
            end
          end
        end
      end
    end

    if (rn_start_addr.size() != num_rn_to_send_transaction || rn_end_addr.size() != num_rn_to_send_transaction) begin
      issue_is_supported_failure($sformatf("Observed rn_start_addr.size() is %0d and rn_end_addr.size() is %0d. However, they must be equal to num_rn_to_send_transaction %0d", rn_start_addr.size(), rn_end_addr.size(), num_rn_to_send_transaction));
      is_supported = 0;
    end
    else begin
      foreach(rn_start_addr[ix]) begin
        //if (rn_end_addr[ix] < (rn_start_addr[ix] + cacheline_size)) begin
        //  issue_is_supported_failure($sformatf("Observed rn_end_addr[%0d] is 'h%0x. However, each RN should have accessible address space of minimum one cacheline size. rn_end_addr[%0d] should be greater than or equal to (rn_start_addr[%0d] 'h%0x + cacheline_size 'd%0d)",ix, rn_end_addr[ix], ix, ix, rn_start_addr[ix], `SVT_CHI_CACHE_LINE_SIZE));
        //  is_supported = 0;
        //end
        if (rn_end_addr[ix] < rn_start_addr[ix]) begin
          issue_is_supported_failure($sformatf("Observed rn_end_addr[%0d] is 'h%0x. However, rn_end_addr[%0d] should be greater than or equal to rn_start_addr[%0d] 'h%0x",ix, rn_end_addr[ix], ix, ix, rn_start_addr[ix]));
          is_supported = 0;
        end
        if (rn_start_addr[ix] >= ({`SVT_CHI_MAX_ADDR_WIDTH{1'b1}} - ((num_rn_to_send_transaction-ix+2) << (cacheline_size_log2+16)))) begin
          issue_is_supported_failure($sformatf("Observed rn_start_addr[%0d] is 'h%0x. However, rn_start_addr[%0d] should be less than 'h%0x to provide atleast a cacheline size for each participating RN", ix, rn_start_addr[ix], ix, ({`SVT_CHI_MAX_ADDR_WIDTH{1'b1}} - ((num_rn_to_send_transaction-ix+2) << (cacheline_size_log2+16)))));
          is_supported = 0;
        end
      end
    end

    if (addr_mode == svt_chi_rn_coherent_transaction_base_sequence::SEQUENTIAL_NONOVERLAPPED_ADDRESS || addr_mode == svt_chi_rn_coherent_transaction_base_sequence::SEQUENTIAL_OVERLAPPED_ADDRESS) begin
      foreach(rn_index_list_for_sending_transaction[ix]) begin
        if (rn_end_addr[ix] < (rn_start_addr[ix] + ((sequence_length-1) * `SVT_CHI_CACHE_LINE_SIZE))) begin
          issue_is_supported_failure($sformatf("addr_mode is %0s. For rn_index_list_for_sending_transaction[%0d] - RN[%0d]: rn_end_addr[%0d] 'h%0h must be greater than or equal to {rn_start_addr[%0d] 'h%0h + ((sequence_length(%0d)-1) * `SVT_CHI_CACHE_LINE_SIZE(%0d))}", addr_mode.name(), ix, rn_index_list_for_sending_transaction[ix], ix, rn_end_addr[ix], ix, rn_start_addr[ix], sequence_length, `SVT_CHI_CACHE_LINE_SIZE));
          is_supported = 0;
        end
      end
    end
    if (addr_mode == svt_chi_rn_coherent_transaction_base_sequence::SEQUENTIAL_OVERLAPPED_ADDRESS || addr_mode == svt_chi_rn_coherent_transaction_base_sequence::RANDOM_OVERLAPPED_ADDRESS) begin
      bit address_overlap_found = 0;
      for (int i = 0; i < (rn_index_list_for_sending_transaction.size() - 1); i++) begin
        for (int j = i+1; j < rn_index_list_for_sending_transaction.size(); j++) begin
          if (i != j) begin
            if ((rn_start_addr[i] <= rn_end_addr[j]) && (rn_start_addr[j] <= rn_end_addr[i])) begin
              `svt_debug("is_supported", $sformatf("overlapping address found between rn_index_list_for_sending_transaction[%0d] RN[%0d] and rn_index_list_for_sending_transaction[%0d] RN[%0d].", i, rn_index_list_for_sending_transaction[i], j, rn_index_list_for_sending_transaction[j]));
              address_overlap_found = 1;
              if ((is_non_coherent_xact_wt_set(i) == 1 && is_coherent_xact_wt_set(i) == 0 && is_coherent_xact_wt_set(j) == 1 && is_non_coherent_xact_wt_set(j) == 0) || (is_non_coherent_xact_wt_set(j) == 1 && is_coherent_xact_wt_set(j) == 0 && is_coherent_xact_wt_set(i) == 1 && is_non_coherent_xact_wt_set(i) == 0)) begin
                issue_is_supported_failure($sformatf("Overlapping address found between RN's with one RN targetting coherent transactions and other RN targetting non-coherent transactions which might result in mismatched memory attributes to the same address. rn_index_list_for_sending_transaction[%0d]: RN[%0d] is_non_coherent_xact_wt_set = %0d is_coherent_xact_wt_set = %0d and rn_index_list_for_sending_transaction[%0d]: RN[%0d] is_non_coherent_xact_wt_set = %0d is_coherent_xact_wt_set = %0d.", i, rn_index_list_for_sending_transaction[i], is_non_coherent_xact_wt_set(i), is_coherent_xact_wt_set(i), j, rn_index_list_for_sending_transaction[j], is_non_coherent_xact_wt_set(j), is_coherent_xact_wt_set(j)));
                is_supported = 0;
              end
            end
          end
        end
      end
      if (!address_overlap_found) begin
        issue_is_supported_failure($sformatf("addr_mode is set to %0s. However, no 2 RN's adrres ranges are overlapping. Address ranges and addr_mode must be programmed correctly", addr_mode.name()));
        is_supported = 0;
      end
    end
    if (addr_mode == svt_chi_rn_coherent_transaction_base_sequence::SEQUENTIAL_NONOVERLAPPED_ADDRESS || addr_mode == svt_chi_rn_coherent_transaction_base_sequence::RANDOM_NONOVERLAPPED_ADDRESS) begin
      bit address_overlap_found = 0;
      string err_msg = "";
      for (int i = 0; i < (rn_index_list_for_sending_transaction.size() - 1); i++) begin
        for (int j = i+1; j < rn_index_list_for_sending_transaction.size(); j++) begin
          if (i != j) begin
            if ((rn_start_addr[i] <= rn_end_addr[j]) && (rn_start_addr[j] <= rn_end_addr[i])) begin
              `svt_debug("is_supported", $sformatf("overlapping address found between rn_index_list_for_sending_transaction[%0d] RN[%0d] and rn_index_list_for_sending_transaction[%0d] RN[%0d].", i, rn_index_list_for_sending_transaction[i], j, rn_index_list_for_sending_transaction[j]));
              err_msg = {err_msg, $sformatf("overlapping address found between rn_index_list_for_sending_transaction[%0d] RN[%0d] and rn_index_list_for_sending_transaction[%0d] RN[%0d].....", i, rn_index_list_for_sending_transaction[i], j, rn_index_list_for_sending_transaction[j])};
              address_overlap_found = 1;
            end
          end
        end
      end
      if (address_overlap_found) begin
        issue_is_supported_failure($sformatf("addr_mode is set to %0s. However, atleast 2 RN's adrres ranges are overlapping. Address ranges and addr_mode must be programmed correctly. %0s", addr_mode.name(), err_msg));
        is_supported = 0;
      end
    end

    foreach(rn_index_list_for_sending_transaction[ix]) begin
      if (is_non_coherent_xact_wt_set(ix) == 1 && is_coherent_xact_wt_set(ix) == 1) begin
        issue_is_supported_failure($sformatf("rn_index_list_for_sending_transaction[%0d]: RN[%0d] weights for both coherent and non-coherent transactions are set to 1, which might result in mismatched memory attributes to a same address location. It is recommended to set weights for either coherent transactions only or non-coherent transactions only", ix, rn_index_list_for_sending_transaction[ix]));
        is_supported = 0;
      end
      `ifdef SVT_CHI_ISSUE_B_ENABLE
      if (is_atomic_xact_wt_set(ix) == 1) begin
        if (sys_cfg.rn_cfg[rn_index_list_for_sending_transaction[ix]].atomic_transactions_enable == 0) begin
          issue_is_supported_failure($sformatf("Atomic transaction weights are enabled. However, corresponding rn_index_list_for_sending_transaction[%0d] RN[%0d] configuration atomic_transactions_enable is set to 0. To exercise atomic transactions atomic_transactions_enable must be set to 1.", ix, rn_index_list_for_sending_transaction[ix]));
          is_supported = 0;
        end
      end
      if (is_stash_xact_wt_set(ix) == 1) begin
        if (sys_cfg.rn_cfg[rn_index_list_for_sending_transaction[ix]].cache_stashing_enable == 0) begin
          issue_is_supported_failure($sformatf("Cache Stashing transaction weights are enabled. However, corresponding rn_index_list_for_sending_transaction[%0d] RN[%0d] configuration cache_stashing_enable is set to 0. To exercise stashing transactions cache_stashing_enable must be set to 1.", ix, rn_index_list_for_sending_transaction[ix]));
          is_supported = 0;
        end
      end
      `endif

      `ifdef SVT_CHI_ISSUE_D_ENABLE
      if (is_cspsep_xact_wt_set(ix) == 1) begin
        if (sys_cfg.rn_cfg[rn_index_list_for_sending_transaction[ix]].cleansharedpersistsep_xact_enable  == 0) begin
          issue_is_supported_failure($sformatf("Cleansharedpersistsep or Combined Write plus persistentsep CMO transaction weights are enabled. However, corresponding rn_index_list_for_sending_transaction[%0d] RN[%0d] configuration cleansharedpersistsep_xact_enable is set to 0. To exercise persistentsep transactions cleansharedpersistsep_xact_enable must be set to 1.", ix, rn_index_list_for_sending_transaction[ix]));
          is_supported = 0;
        end
      end
      `endif
    end
    `svt_xvm_debug("is_supported",$sformatf("Exiting ..."));
  endfunction

  function bit is_non_coherent_xact_wt_set(int indx);
    is_non_coherent_xact_wt_set = 0;
    if (readnosnp_wt[indx] == 1 ||
        `ifdef SVT_CHI_ISSUE_E_ENABLE
        writenosnpzero_wt[indx] == 1 ||
        writenosnpfull_cleanshared_wt[indx] == 1 ||
        writenosnpfull_cleansharedpersistsep_wt[indx] == 1 ||
        writenosnpfull_cleaninvalid_wt[indx] == 1 ||
        writenosnpptl_cleaninvalid_wt[indx] == 1 ||
        writenosnpptl_cleanshared_wt[indx] == 1 ||
        writenosnpptl_cleansharedpersistsep_wt[indx] == 1 ||
        `endif
        writenosnpfull_wt[indx] == 1 || 
        writenosnpptl_wt[indx] == 1
       ) begin
      is_non_coherent_xact_wt_set = 1;
     end
  endfunction

  function bit is_coherent_xact_wt_set(int indx);
    is_coherent_xact_wt_set = 0;
    if (readonce_wt[indx] == 1 || 
        readclean_wt[indx] == 1 || 
        `ifdef SVT_CHI_ISSUE_E_ENABLE
        writeevictorevict_wt[indx] == 1 ||
        writeuniquezero_wt[indx] == 1 ||
        makereadunique_wt[indx] == 1 ||
        readpreferunique_wt[indx] == 1 ||
        writeuniquefull_cleanshared_wt[indx] == 1 ||
        writeuniquefull_cleansharedpersistsep_wt[indx] == 1 ||
        writeuniqueptl_cleanshared_wt[indx] == 1 ||
        writeuniqueptl_cleansharedpersistsep_wt[indx] == 1 ||
        writebackfull_cleanshared_wt[indx] == 1 ||
        writebackfull_cleansharedpersistsep_wt[indx] == 1 ||
        writebackfull_cleaninvalid_wt[indx] == 1 ||
        writecleanfull_cleanshared_wt[indx] == 1 ||
        writecleanfull_cleansharedpersistsep_wt[indx] == 1 ||
        stashoncesepunique_wt[indx] == 1 ||
        stashoncesepshared_wt[indx] == 1 ||
        `endif
        `ifdef SVT_CHI_ISSUE_D_ENABLE
        cleansharedpersistsep_wt[indx] == 1 ||
        `endif
        `ifdef SVT_CHI_ISSUE_B_ENABLE
        readspec_wt[indx] == 1 || 
        readnotshareddirty_wt[indx] == 1 || 
        readoncecleaninvalid_wt[indx] == 1 || 
        readoncemakeinvalid_wt[indx] == 1 || 
        cleansharedpersist_wt[indx] == 1 || 
        atomicstore_add_wt[indx] == 1 || 
        atomicstore_clr_wt[indx] == 1 || 
        atomicstore_eor_wt[indx] == 1 || 
        atomicstore_set_wt[indx] == 1 || 
        atomicstore_smax_wt[indx] == 1 || 
        atomicstore_smin_wt[indx] == 1 || 
        atomicstore_umax_wt[indx] == 1 || 
        atomicstore_umin_wt[indx] == 1 || 
        atomicload_add_wt[indx] == 1 || 
        atomicload_clr_wt[indx] == 1 || 
        atomicload_eor_wt[indx] == 1 || 
        atomicload_set_wt[indx] == 1 || 
        atomicload_smax_wt[indx] == 1 || 
        atomicload_smin_wt[indx] == 1 || 
        atomicload_umax_wt[indx] == 1 || 
        atomicload_umin_wt[indx] == 1 || 
        atomicswap_wt[indx] == 1 || 
        atomiccompare_wt[indx] == 1 || 
        prefetchtgt_wt[indx] == 1 || 
        writeuniquefullstash_wt[indx] == 1 || 
        writeuniqueptlstash_wt[indx] == 1 || 
        stashonceunique_wt[indx] == 1 || 
        stashonceshared_wt[indx] == 1 || 
        `endif
        readshared_wt[indx] == 1 || 
        readunique_wt[indx] == 1 || 
        cleanunique_wt[indx] == 1 || 
        makeunique_wt[indx] == 1 || 
        writebackfull_wt[indx] == 1 || 
        writebackptl_wt[indx] == 1 || 
        writeevictfull_wt[indx] == 1 || 
        writecleanfull_wt[indx] == 1 || 
        writecleanptl_wt[indx] == 1 || 
        evict_wt[indx] == 1 || 
        writeuniquefull_wt[indx] == 1 || 
        writeuniqueptl_wt[indx] == 1 || 
        cleanshared_wt[indx] == 1 || 
        cleaninvalid_wt[indx] == 1 || 
        makeinvalid_wt[indx] == 1  
      ) begin
        is_coherent_xact_wt_set = 1;
      end
  endfunction

  `ifdef SVT_CHI_ISSUE_D_ENABLE
  function bit is_cspsep_xact_wt_set(int indx);
    is_cspsep_xact_wt_set = 0;
    if (cleansharedpersistsep_wt[indx] == 1  
        `ifdef SVT_CHI_ISSUE_E_ENABLE
        || writenosnpfull_cleansharedpersistsep_wt[indx] == 1 
        || writenosnpptl_cleansharedpersistsep_wt[indx] == 1 
        || writeuniquefull_cleansharedpersistsep_wt[indx] == 1 
        || writeuniqueptl_cleansharedpersistsep_wt[indx] == 1 
        || writebackfull_cleansharedpersistsep_wt[indx] == 1 
        || writecleanfull_cleansharedpersistsep_wt[indx] == 1
        `endif
      ) begin
        is_cspsep_xact_wt_set = 1;
      end
  endfunction
  `endif

  `ifdef SVT_CHI_ISSUE_B_ENABLE
  function bit is_atomic_xact_wt_set(int indx);
    is_atomic_xact_wt_set = 0;
    if (atomicstore_add_wt[indx] == 1 || 
        atomicstore_clr_wt[indx] == 1 || 
        atomicstore_eor_wt[indx] == 1 || 
        atomicstore_set_wt[indx] == 1 || 
        atomicstore_smax_wt[indx] == 1 || 
        atomicstore_smin_wt[indx] == 1 || 
        atomicstore_umax_wt[indx] == 1 || 
        atomicstore_umin_wt[indx] == 1 || 
        atomicload_add_wt[indx] == 1 || 
        atomicload_clr_wt[indx] == 1 || 
        atomicload_eor_wt[indx] == 1 || 
        atomicload_set_wt[indx] == 1 || 
        atomicload_smax_wt[indx] == 1 || 
        atomicload_smin_wt[indx] == 1 || 
        atomicload_umax_wt[indx] == 1 || 
        atomicload_umin_wt[indx] == 1 || 
        atomicswap_wt[indx] == 1 || 
        atomiccompare_wt[indx] == 1  
      ) begin
        is_atomic_xact_wt_set = 1;
      end
  endfunction

  function bit is_stash_xact_wt_set(int indx);
    is_stash_xact_wt_set = 0;
    if (writeuniquefullstash_wt[indx] == 1 || 
        writeuniqueptlstash_wt[indx] == 1 || 
        `ifdef SVT_CHI_ISSUE_E_ENABLE
        stashoncesepunique_wt[indx] == 1 ||
        stashoncesepshared_wt[indx] == 1 ||
        `endif
        stashonceunique_wt[indx] == 1 || 
        stashonceshared_wt[indx] == 1  
      ) begin
        is_stash_xact_wt_set = 1;
      end
  endfunction
  `endif

//------------------------------------------------------------------------------
/**
  * Initializes cachelines and sends coherent transactions from nodes specified 
  * in rn_index_list_for_sending_transaction associative array
  */
  virtual task body();
    
      super.body();


      /** check if current environment is supported or not */ 
      if(!is_supported(sys_cfg, silent))  begin
        `svt_xvm_note("body",$sformatf("This sequence doesn't meet the intent as the programmed sequence attributes are incorrect. However, proceeding..."));
      end 

      /*
      repeat(10) begin
      if(!this.randomize())
         `svt_fatal("body","can't randomize()");
         get_overridden_sequence_member_values();
      end
      $finish;
      */

      `svt_debug("body",$sformatf("coherent_seq:: starting with %0d RN", rn_index_list_for_sending_transaction.size()));
      foreach(rn_index_list_for_sending_transaction[ix]) begin
      bit _init_cachelines = ((rn_init_cachelines_status[ix]) ? rn_initialize_cachelines[ix] : initialize_cachelines);
      fork 
        automatic int _ix = ix;
        automatic int _indx = rn_index_list_for_sending_transaction[ix];
        coherent_transactions_sent_from_rn_process_completed[_indx] = 0;

        send_coherent_transactions_from_rn(_ix,_indx,_init_cachelines,0);
      join_none
      end

      `svt_debug("body",$sformatf("coherent_seq:: launched with %0d RN", rn_index_list_for_sending_transaction.size()));
      #0;

      // wait for all active sequence items or transactions to be started or finished 
      foreach(coherent_transactions_sent_from_rn_process_completed[ix]) 
        wait(coherent_transactions_sent_from_rn_process_completed[ix]==1);
      `svt_debug("body",$sformatf("coherent_seq:: sent with %0d RN", rn_index_list_for_sending_transaction.size()));

      if(!send_blocking_transactions) begin
         foreach(active_seq_queue[ix])
           active_seq_queue[ix].wait_for_active_xacts_to_end();
      end
      `svt_debug("body",$sformatf("coherent_seq:: seq-completed with %0d RN", rn_index_list_for_sending_transaction.size()));

      print_caches();
  endtask: body


  // -------------------------------------------------------------------------
  virtual task send_coherent_transactions_from_rn(int list_index, int rn_index, 
                                                  bit init_cachelines,
                                                  bit direct_address_used);

    string str="";
    bit num_iterations;
    svt_chi_rn_coherent_transaction_base_sequence  seq;

      `svt_xvm_create_on(seq, p_sequencer.rn_virt_seqr[rn_index].rn_xact_seqr)    
      seq.blocking_mode = send_blocking_transactions;
      seq.disable_all_weights();
      seq.addr_mode = this.addr_mode;
      seq.use_coherent_xacts_mem_attr_snp_attr_for_cmo_atomics = use_coherent_xacts_mem_attr_snp_attr_for_cmo_atomics[list_index];
      seq.use_seq_order_type = use_seq_order_type[list_index];
      seq.initialize_cachelines = (rn_index inside {rn_f_nodes}) ? init_cachelines : 0;
      set_transaction_type_wt(list_index, seq);
      void'(seq.randomize with {use_directed_addr == direct_address_used;sequence_length==local::sequence_length;
                          start_addr == rn_start_addr[list_index]; end_addr == rn_end_addr[list_index];});
      //seq.sequence_length = sequence_length;
      //seq.force_cache_initialization = 0;

      active_seq_queue.push_back(seq);
      seq.set_response_queue_depth(-1);
      seq.start(p_sequencer.rn_virt_seqr[rn_index].rn_xact_seqr);
      `svt_debug("send_coherent_transactions_from_rn",$sformatf("started sequence[%0d] from RN[%0d] seqLen=%0d DA=%0d",seq, rn_index, sequence_length, direct_address_used));
  
    // mark completion of current process
    coherent_transactions_sent_from_rn_process_completed[rn_index] = 1;
  endtask

  // ----------------------------------------------------------------------
  virtual task set_rn_transaction_start_ports();
      string str="";
      int _rn_list_size, _rn_indx_list[$];

      _rn_list_size = rn_index_list_for_sending_transaction.size();

      if(_rn_list_size == 0) begin
        if(num_rn_to_send_transaction == 0)
           num_rn_to_send_transaction = $urandom_range(active_participating_rn_nodes.size(), 1);
        else 
        if(num_rn_to_send_transaction > active_participating_rn_nodes.size())
           num_rn_to_send_transaction = active_participating_rn_nodes.size();

         _rn_indx_list = rn_f_nodes;
         repeat(num_rn_to_send_transaction) begin
           _rn_indx_list.shuffle();
           rn_index_list_for_sending_transaction = new[_rn_list_size+1] (rn_index_list_for_sending_transaction);
           rn_index_list_for_sending_transaction[_rn_list_size] = _rn_indx_list[0];
           _rn_list_size = rn_index_list_for_sending_transaction.size();
           _rn_indx_list.delete(0);
         end
      end else if(_rn_list_size > active_participating_rn_nodes.size()) begin
         do begin
              rn_index_list_for_sending_transaction = new[(active_participating_rn_nodes.size())] (rn_index_list_for_sending_transaction);
              _rn_list_size = rn_index_list_for_sending_transaction.size();
         end
         while(_rn_list_size > active_participating_rn_nodes.size());
      end

      `svt_debug("set_rn_transaction_start_ports", $sformatf("sequence configuration:: send_blocking_transactions=%b num_rn_to_send_transactions=%0d ", send_blocking_transactions, rn_index_list_for_sending_transaction.size()));
      str = $sformatf("ports to be used to send transactions::");
      foreach(rn_index_list_for_sending_transaction[ix]) str = $sformatf("%s RN[%0d]",str,rn_index_list_for_sending_transaction[ix]);
      str = $sformatf("%s\n",str);
      `svt_debug("set_rn_transaction_start_ports", $sformatf("%s",str));
  endtask


  // ----------------------------------------------------------------------
  task set_transaction_type_wt(int indx, svt_chi_rn_coherent_transaction_base_sequence seq);
    seq.readnosnp_wt = (status_wt[indx]) ? readnosnp_wt[indx] : 0 ;       
    seq.readonce_wt = (status_wt[indx]) ? readonce_wt[indx] : 1 ;        
    seq.readclean_wt = (status_wt[indx]) ? readclean_wt[indx] : 1 ;       
`ifdef SVT_CHI_ISSUE_E_ENABLE
    seq.writeevictorevict_wt = (status_wt[indx]) ? writeevictorevict_wt[indx] : 0 ;
    seq.writenosnpzero_wt = (status_wt[indx]) ? writenosnpzero_wt[indx] : 0 ;
    seq.writeuniquezero_wt = (status_wt[indx]) ? writeuniquezero_wt[indx] : 0 ;
    seq.makereadunique_wt = (status_wt[indx]) ? makereadunique_wt[indx] : 0 ;
    seq.readpreferunique_wt = (status_wt[indx]) ? readpreferunique_wt[indx] : 0 ;
    seq.writenosnpfull_cleanshared_wt = (status_wt[indx]) ? writenosnpfull_cleanshared_wt[indx] : 0 ;
    seq.writenosnpfull_cleansharedpersistsep_wt = (status_wt[indx]) ? writenosnpfull_cleansharedpersistsep_wt[indx] : 0 ;
    seq.writeuniquefull_cleanshared_wt = (status_wt[indx]) ? writeuniquefull_cleanshared_wt[indx] : 0 ;
    seq.writeuniquefull_cleansharedpersistsep_wt = (status_wt[indx]) ? writeuniquefull_cleansharedpersistsep_wt[indx] : 0 ;
    seq.writenosnpfull_cleaninvalid_wt = (status_wt[indx]) ? writenosnpfull_cleaninvalid_wt[indx] : 0 ;
    seq.writenosnpptl_cleaninvalid_wt = (status_wt[indx]) ? writenosnpptl_cleaninvalid_wt[indx] : 0 ;
    seq.writenosnpptl_cleanshared_wt = (status_wt[indx]) ? writenosnpptl_cleanshared_wt[indx] : 0 ;
    seq.writenosnpptl_cleansharedpersistsep_wt = (status_wt[indx]) ? writenosnpptl_cleansharedpersistsep_wt[indx] : 0 ;
    seq.writeuniqueptl_cleanshared_wt = (status_wt[indx]) ? writeuniqueptl_cleanshared_wt[indx] : 0 ;
    seq.writeuniqueptl_cleansharedpersistsep_wt = (status_wt[indx]) ? writeuniqueptl_cleansharedpersistsep_wt[indx] : 0 ;
    seq.writebackfull_cleanshared_wt = (status_wt[indx]) ? writebackfull_cleanshared_wt[indx] : 0 ;
    seq.writebackfull_cleansharedpersistsep_wt = (status_wt[indx]) ? writebackfull_cleansharedpersistsep_wt[indx] : 0 ;
    seq.writebackfull_cleaninvalid_wt = (status_wt[indx]) ? writebackfull_cleaninvalid_wt[indx] : 0 ;
    seq.writecleanfull_cleanshared_wt = (status_wt[indx]) ? writecleanfull_cleanshared_wt[indx] : 0 ;
    seq.writecleanfull_cleansharedpersistsep_wt = (status_wt[indx]) ? writecleanfull_cleansharedpersistsep_wt[indx] : 0 ;
    seq.stashoncesepunique_wt = (status_wt[indx]) ? stashoncesepunique_wt[indx] : 0 ;
    seq.stashoncesepshared_wt = (status_wt[indx]) ? stashoncesepshared_wt[indx] : 0 ;
`endif
`ifdef SVT_CHI_ISSUE_D_ENABLE
    seq.cleansharedpersistsep_wt = (status_wt[indx]) ? cleansharedpersistsep_wt[indx] : 0 ;
`endif

`ifdef SVT_CHI_ISSUE_B_ENABLE
    seq.readspec_wt = (status_wt[indx]) ? readspec_wt[indx] : 0 ;       
    seq.readnotshareddirty_wt = (status_wt[indx]) ? readnotshareddirty_wt[indx] : 0 ;       
    seq.readoncecleaninvalid_wt = (status_wt[indx]) ? readoncecleaninvalid_wt[indx] : 0 ;       
    seq.readoncemakeinvalid_wt = (status_wt[indx]) ? readoncemakeinvalid_wt[indx] : 0 ;       
    seq.cleansharedpersist_wt = (status_wt[indx]) ? cleansharedpersist_wt[indx] : 0 ;       
    seq.atomicstore_add_wt = (status_wt[indx]) ? atomicstore_add_wt[indx] : 0 ;       
    seq.atomicstore_clr_wt = (status_wt[indx]) ? atomicstore_clr_wt[indx] : 0 ;       
    seq.atomicstore_eor_wt = (status_wt[indx]) ? atomicstore_eor_wt[indx] : 0 ;       
    seq.atomicstore_set_wt = (status_wt[indx]) ? atomicstore_set_wt[indx] : 0 ;       
    seq.atomicstore_smax_wt = (status_wt[indx]) ? atomicstore_smax_wt[indx] : 0 ;       
    seq.atomicstore_smin_wt = (status_wt[indx]) ? atomicstore_smin_wt[indx] : 0 ;       
    seq.atomicstore_umax_wt = (status_wt[indx]) ? atomicstore_umax_wt[indx] : 0 ;       
    seq.atomicstore_umin_wt = (status_wt[indx]) ? atomicstore_umin_wt[indx] : 0 ;       
    seq.atomicload_add_wt = (status_wt[indx]) ? atomicload_add_wt[indx] : 0 ;       
    seq.atomicload_clr_wt = (status_wt[indx]) ? atomicload_clr_wt[indx] : 0 ;       
    seq.atomicload_eor_wt = (status_wt[indx]) ? atomicload_eor_wt[indx] : 0 ;       
    seq.atomicload_set_wt = (status_wt[indx]) ? atomicload_set_wt[indx] : 0 ;       
    seq.atomicload_smax_wt = (status_wt[indx]) ? atomicload_smax_wt[indx] : 0 ;       
    seq.atomicload_smin_wt = (status_wt[indx]) ? atomicload_smin_wt[indx] : 0 ;       
    seq.atomicload_umax_wt = (status_wt[indx]) ? atomicload_umax_wt[indx] : 0 ;       
    seq.atomicload_umin_wt = (status_wt[indx]) ? atomicload_umin_wt[indx] : 0 ;       
    seq.atomicswap_wt = (status_wt[indx]) ? atomicswap_wt[indx] : 0 ;       
    seq.atomiccompare_wt = (status_wt[indx]) ? atomicswap_wt[indx] : 0 ;       
    seq.prefetchtgt_wt = (status_wt[indx]) ? prefetchtgt_wt[indx] : 0 ;       
    seq.writeuniquefullstash_wt = (status_wt[indx]) ? writeuniquefullstash_wt[indx] : 0 ;       
    seq.writeuniqueptlstash_wt = (status_wt[indx]) ? writeuniqueptlstash_wt[indx] : 0 ;       
    seq.stashonceunique_wt = (status_wt[indx]) ? stashonceunique_wt[indx] : 0 ;       
    seq.stashonceshared_wt = (status_wt[indx]) ? stashonceshared_wt[indx] : 0 ;       
`endif
    seq.readshared_wt = (status_wt[indx]) ? readshared_wt[indx] : 1 ;      
    seq.readunique_wt = (status_wt[indx]) ? readunique_wt[indx] : 1 ;      
    seq.cleanunique_wt = (status_wt[indx]) ? cleanunique_wt[indx] : 1 ;     
    seq.makeunique_wt = (status_wt[indx]) ? makeunique_wt[indx] : 1 ;      
    seq.writebackfull_wt = (status_wt[indx]) ? writebackfull_wt[indx] : 1 ;   
    seq.writebackptl_wt = (status_wt[indx]) ? writebackptl_wt[indx] : 1 ;    
    seq.writeevictfull_wt = (status_wt[indx]) ? writeevictfull_wt[indx] : 1 ;  
    seq.writecleanfull_wt = (status_wt[indx]) ? writecleanfull_wt[indx] : 1 ;  
    `ifdef SVT_CHI_ISSUE_B_ENABLE
    seq.writecleanptl_wt = 0;   
    `else
    seq.writecleanptl_wt = (status_wt[indx]) ? writecleanptl_wt[indx] : 1 ;   
    `endif
    seq.evict_wt = (status_wt[indx]) ? evict_wt[indx] : 1 ;           
    seq.writenosnpfull_wt = (status_wt[indx]) ? writenosnpfull_wt[indx] : 0 ;  
    seq.writenosnpptl_wt = (status_wt[indx]) ? writenosnpptl_wt[indx] : 0 ;   
    seq.writeuniquefull_wt = (status_wt[indx]) ? writeuniquefull_wt[indx] : 1 ; 
    seq.writeuniqueptl_wt = (status_wt[indx]) ? writeuniqueptl_wt[indx] : 1 ;  
    seq.cleanshared_wt = (status_wt[indx]) ? cleanshared_wt[indx] : 1 ;     
    seq.cleaninvalid_wt = (status_wt[indx]) ? cleaninvalid_wt[indx] : 1 ;    
    seq.makeinvalid_wt = (status_wt[indx]) ? makeinvalid_wt[indx] : 1 ;     
    seq.eobarrier_wt = 0; //(status_wt[indx]) ? eobarrier_wt[indx] : 0 ;       
    seq.ecbarrier_wt = 0; //(status_wt[indx]) ? ecbarrier_wt[indx] : 0 ;       
    seq.dvmop_wt = 0; //(status_wt[indx]) ? dvmop_wt[indx] : 0 ;           
    seq.pcrdreturn_wt = 0; //(status_wt[indx]) ? pcrdreturn_wt[indx] : 0 ;      
    seq.reqlinkflit_wt = 0; //(status_wt[indx]) ? reqlinkflit_wt[indx] : 0 ;        
  endtask

  // ----------------------------------------------------------------------
  /** gets overridden value of sequence members */
  // ----------------------------------------------------------------------
  task get_overridden_sequence_member_values();
    bit status = 0;
    string seq_member_val_str = "*************** svt_chi_system_coherent_virtual_sequence: Sequence members after override  ***************\n";
    string rand_member_val_str = "*************** svt_chi_system_coherent_virtual_sequence: Sequence members on randomization ***************\n";

    use_coherent_xacts_mem_attr_snp_attr_for_cmo_atomics = new[num_rn_to_send_transaction];
    use_coherent_xacts_mem_attr_snp_attr_for_cmo_atomics_status = new[num_rn_to_send_transaction];
    foreach(use_coherent_xacts_mem_attr_snp_attr_for_cmo_atomics_status[ix]) begin
      use_coherent_xacts_mem_attr_snp_attr_for_cmo_atomics_status[ix] = 0;
    end

    use_seq_order_type = new[num_rn_to_send_transaction];
    use_seq_order_type_status = new[num_rn_to_send_transaction];
    foreach(use_seq_order_type[ix]) begin
      use_seq_order_type[ix] = 1;
      use_seq_order_type_status[ix] = 0;
    end

    rn_initialize_cachelines = new[num_rn_to_send_transaction];
    rn_init_cachelines_status = new[num_rn_to_send_transaction];
    foreach(rn_initialize_cachelines[ix])
      rn_initialize_cachelines[ix] = 1;
    foreach(rn_init_cachelines_status[ix])
      rn_init_cachelines_status[ix] = 0;

    status_wt = new[num_rn_to_send_transaction];
    foreach(status_wt[ix]) status_wt[ix] = 0;

    //START: rand_member_val_str
    rand_member_val_str = {rand_member_val_str, $sformatf("-----------------------------------------------------------------------------\n")};
    rand_member_val_str = {rand_member_val_str, $sformatf("--    MEMBER NAME                                         VALUES           --\n")};
    rand_member_val_str = {rand_member_val_str, $sformatf("-----------------------------------------------------------------------------\n")};
    rand_member_val_str = {rand_member_val_str, $sformatf("sequence_length                                  = %0d\n",sequence_length)};
    rand_member_val_str = {rand_member_val_str, $sformatf("addr_mode                                        = %s\n" ,addr_mode)};
    rand_member_val_str = {rand_member_val_str, $sformatf("send_blocking_transactions                       = %0b\n",send_blocking_transactions)};
    rand_member_val_str = {rand_member_val_str, $sformatf("num_rn_to_send_transaction                       = %0d\n",num_rn_to_send_transaction)};
    rand_member_val_str = {rand_member_val_str, $sformatf("initialize_cachelines                            = %0b\n",initialize_cachelines)};
    for(int i=0; i<num_rn_to_send_transaction; i++) begin
      rand_member_val_str = {rand_member_val_str, $sformatf("rn_index_list_for_sending_transaction[%0d]         = %0d\n"   ,i, rn_index_list_for_sending_transaction[i])};
      rand_member_val_str = {rand_member_val_str, $sformatf("rn_initialize_cachelines[%0d]                      = %0b\n"   ,i, rn_initialize_cachelines[i])};
      rand_member_val_str = {rand_member_val_str, $sformatf("use_coherent_xacts_mem_attr_snp_attr_for_cmo_atomics[%0d] = %0b\n"   ,i, use_coherent_xacts_mem_attr_snp_attr_for_cmo_atomics[i])};
      rand_member_val_str = {rand_member_val_str, $sformatf("use_seq_order_type[%0d] = %0b\n"   ,i, use_seq_order_type[i])};
      rand_member_val_str = {rand_member_val_str, $sformatf("rn_start_addr[%0d]                                 = 0x%0x\n" ,i, rn_start_addr[i])};
      rand_member_val_str = {rand_member_val_str, $sformatf("rn_end_addr[%0d]                                   = 0x%0x\n" ,i, rn_end_addr[i])};
    end
    rand_member_val_str = {rand_member_val_str, $sformatf("-----------------------------------------------------------------------------\n")};
    //END: rand_member_val_str

    seq_member_val_str = {seq_member_val_str, $sformatf("-----------------------------------------------------------------------------\n")};
    seq_member_val_str = {seq_member_val_str, $sformatf("--    MEMBER NAME                                         VALUES           --\n")};
    seq_member_val_str = {seq_member_val_str, $sformatf("-----------------------------------------------------------------------------\n")};
    `_SVT_CHI_SYSTEM_SEQUENCE_GET_OVERRIDE(bit,initialize_cachelines)
    `_SVT_CHI_SYSTEM_SEQUENCE_GET_OVERRIDE(int unsigned,sequence_length)
    `_SVT_CHI_SYSTEM_SEQUENCE_GET_OVERRIDE(addr_mode_type,addr_mode)
    addr_mode_status = status;
    `_SVT_CHI_SYSTEM_SEQUENCE_GET_OVERRIDE(bit,send_blocking_transactions)
    `_SVT_CHI_SYSTEM_SEQUENCE_GET_OVERRIDE(int unsigned,num_rn_to_send_transaction)
    seq_member_val_str = {seq_member_val_str, $sformatf("sequence_length                                  = %0d\n",sequence_length)};
    seq_member_val_str = {seq_member_val_str, $sformatf("addr_mode                                        = %s\n" ,addr_mode)};
    seq_member_val_str = {seq_member_val_str, $sformatf("send_blocking_transactions                       = %0b\n",send_blocking_transactions)};
    seq_member_val_str = {seq_member_val_str, $sformatf("num_rn_to_send_transaction                       = %0d\n",num_rn_to_send_transaction)};
    seq_member_val_str = {seq_member_val_str, $sformatf("initialize_cachelines                            = %0b\n",initialize_cachelines)};

    readnosnp_wt = new[num_rn_to_send_transaction];
    readonce_wt = new[num_rn_to_send_transaction];
    readclean_wt = new[num_rn_to_send_transaction];
`ifdef SVT_CHI_ISSUE_E_ENABLE
    writeevictorevict_wt = new[num_rn_to_send_transaction];
    writenosnpzero_wt = new[num_rn_to_send_transaction];
    writeuniquezero_wt = new[num_rn_to_send_transaction];
    makereadunique_wt = new[num_rn_to_send_transaction];
    readpreferunique_wt = new[num_rn_to_send_transaction];
    writenosnpfull_cleanshared_wt = new[num_rn_to_send_transaction];
    writenosnpfull_cleansharedpersistsep_wt = new[num_rn_to_send_transaction];
    writeuniquefull_cleanshared_wt = new[num_rn_to_send_transaction];
    writeuniquefull_cleansharedpersistsep_wt = new[num_rn_to_send_transaction];
    writenosnpfull_cleaninvalid_wt = new[num_rn_to_send_transaction];
    writenosnpptl_cleaninvalid_wt = new[num_rn_to_send_transaction];
    writenosnpptl_cleanshared_wt = new[num_rn_to_send_transaction];
    writenosnpptl_cleansharedpersistsep_wt = new[num_rn_to_send_transaction];
    writeuniqueptl_cleanshared_wt = new[num_rn_to_send_transaction];
    writeuniqueptl_cleansharedpersistsep_wt = new[num_rn_to_send_transaction];
    writebackfull_cleanshared_wt = new[num_rn_to_send_transaction];
    writebackfull_cleansharedpersistsep_wt = new[num_rn_to_send_transaction];
    writebackfull_cleaninvalid_wt = new[num_rn_to_send_transaction];
    writecleanfull_cleanshared_wt = new[num_rn_to_send_transaction];
    writecleanfull_cleansharedpersistsep_wt = new[num_rn_to_send_transaction];
    stashoncesepunique_wt = new[num_rn_to_send_transaction];
    stashoncesepshared_wt = new[num_rn_to_send_transaction];
`endif
`ifdef SVT_CHI_ISSUE_D_ENABLE
    cleansharedpersistsep_wt = new[num_rn_to_send_transaction];
`endif

`ifdef SVT_CHI_ISSUE_B_ENABLE
    readspec_wt = new[num_rn_to_send_transaction];
    readnotshareddirty_wt = new[num_rn_to_send_transaction];
    readoncecleaninvalid_wt = new[num_rn_to_send_transaction];
    readoncemakeinvalid_wt = new[num_rn_to_send_transaction];
    cleansharedpersist_wt = new[num_rn_to_send_transaction];
    atomicstore_add_wt = new[num_rn_to_send_transaction];
    atomicstore_clr_wt = new[num_rn_to_send_transaction];
    atomicstore_eor_wt = new[num_rn_to_send_transaction];
    atomicstore_set_wt = new[num_rn_to_send_transaction];
    atomicstore_smax_wt = new[num_rn_to_send_transaction];
    atomicstore_smin_wt = new[num_rn_to_send_transaction];
    atomicstore_umax_wt = new[num_rn_to_send_transaction];
    atomicstore_umin_wt = new[num_rn_to_send_transaction];
    atomicload_add_wt = new[num_rn_to_send_transaction];
    atomicload_clr_wt = new[num_rn_to_send_transaction];
    atomicload_eor_wt = new[num_rn_to_send_transaction];
    atomicload_set_wt = new[num_rn_to_send_transaction];
    atomicload_smax_wt = new[num_rn_to_send_transaction];
    atomicload_smin_wt = new[num_rn_to_send_transaction];
    atomicload_umax_wt = new[num_rn_to_send_transaction];
    atomicload_umin_wt = new[num_rn_to_send_transaction];
    atomicswap_wt = new[num_rn_to_send_transaction];
    atomiccompare_wt = new[num_rn_to_send_transaction];
    prefetchtgt_wt = new[num_rn_to_send_transaction];
    writeuniquefullstash_wt = new[num_rn_to_send_transaction];
    writeuniqueptlstash_wt = new[num_rn_to_send_transaction];
    stashonceunique_wt = new[num_rn_to_send_transaction];
    stashonceshared_wt = new[num_rn_to_send_transaction];
`endif
    readshared_wt = new[num_rn_to_send_transaction];
    readunique_wt = new[num_rn_to_send_transaction];
    cleanunique_wt = new[num_rn_to_send_transaction];
    makeunique_wt = new[num_rn_to_send_transaction];
    writebackfull_wt = new[num_rn_to_send_transaction];
    writebackptl_wt = new[num_rn_to_send_transaction];
    writeevictfull_wt = new[num_rn_to_send_transaction];
    writecleanfull_wt = new[num_rn_to_send_transaction];
    writecleanptl_wt = new[num_rn_to_send_transaction];
    evict_wt = new[num_rn_to_send_transaction];
    writenosnpfull_wt = new[num_rn_to_send_transaction];
    writenosnpptl_wt = new[num_rn_to_send_transaction];
    writeuniquefull_wt = new[num_rn_to_send_transaction];
    writeuniqueptl_wt = new[num_rn_to_send_transaction];
    cleanshared_wt = new[num_rn_to_send_transaction];
    cleaninvalid_wt = new[num_rn_to_send_transaction];
    makeinvalid_wt = new[num_rn_to_send_transaction];
    eobarrier_wt = new[num_rn_to_send_transaction];
    ecbarrier_wt = new[num_rn_to_send_transaction];
    dvmop_wt = new[num_rn_to_send_transaction];
    pcrdreturn_wt = new[num_rn_to_send_transaction];
    reqlinkflit_wt = new[num_rn_to_send_transaction];

    if(rn_start_addr.size() != num_rn_to_send_transaction)
       rn_start_addr = new[num_rn_to_send_transaction] (rn_start_addr);

    if(rn_end_addr.size() != num_rn_to_send_transaction)
       rn_end_addr = new[num_rn_to_send_transaction] (rn_end_addr);

    if(rn_index_list_for_sending_transaction.size() != num_rn_to_send_transaction)
       rn_index_list_for_sending_transaction = new[num_rn_to_send_transaction] (rn_index_list_for_sending_transaction);

    for(int i=0; i<num_rn_to_send_transaction; i++) begin
`ifdef SVT_UVM_TECHNOLOGY
     status = uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("rn_index_list_for_sending_transaction[%0d]",i), rn_index_list_for_sending_transaction[i]);
     status = uvm_config_db#(bit[`SVT_CHI_MAX_ADDR_WIDTH-1:0])::get(null, get_full_name(), $sformatf("rn_start_addr[%0d]",i), rn_start_addr[i]);
     status = uvm_config_db#(bit[`SVT_CHI_MAX_ADDR_WIDTH-1:0])::get(null, get_full_name(), $sformatf("rn_end_addr[%0d]",i), rn_end_addr[i]);
     rn_init_cachelines_status[i] = uvm_config_db#(bit)::get(null, get_full_name(), $sformatf("rn_initialize_cachelines[%0d]",i),rn_initialize_cachelines[i] );       
     use_coherent_xacts_mem_attr_snp_attr_for_cmo_atomics_status[i] = uvm_config_db#(bit)::get(null, get_full_name(), $sformatf("use_coherent_xacts_mem_attr_snp_attr_for_cmo_atomics[%0d]",i),use_coherent_xacts_mem_attr_snp_attr_for_cmo_atomics[i] );       
     use_seq_order_type_status[i] = uvm_config_db#(bit)::get(null, get_full_name(), $sformatf("use_seq_order_type[%0d]",i),use_seq_order_type[i] );       
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("readnosnp_wt[%0d]",i),readnosnp_wt[i] );       
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("readonce_wt[%0d]",i),readonce_wt[i] );        
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("readclean_wt[%0d]",i),readclean_wt[i] );       
`ifdef SVT_CHI_ISSUE_E_ENABLE
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("writeevictorevict_wt[%0d]",i),writeevictorevict_wt[i] );
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("writenosnpzero_wt[%0d]",i),writenosnpzero_wt[i] );
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("writeuniquezero_wt[%0d]",i),writeuniquezero_wt[i] );
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("makereadunique_wt[%0d]",i),makereadunique_wt[i] );
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("readpreferunique_wt[%0d]",i),readpreferunique_wt[i] );
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("writenosnpfull_cleanshared_wt[%0d]",i),writenosnpfull_cleanshared_wt[i] );
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("writenosnpfull_cleansharedpersistsep_wt[%0d]",i),writenosnpfull_cleansharedpersistsep_wt[i] );
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("writeuniquefull_cleanshared_wt[%0d]",i),writeuniquefull_cleanshared_wt[i] );
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("writeuniquefull_cleansharedpersistsep_wt[%0d]",i),writeuniquefull_cleansharedpersistsep_wt[i] );
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("writenosnpfull_cleaninvalid_wt[%0d]",i),writenosnpfull_cleaninvalid_wt[i] );
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("writenosnpptl_cleaninvalid_wt[%0d]",i),writenosnpptl_cleaninvalid_wt[i] );
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("writenosnpptl_cleanshared_wt[%0d]",i),writenosnpptl_cleanshared_wt[i] );
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("writenosnpptl_cleansharedpersistsep_wt[%0d]",i),writenosnpptl_cleansharedpersistsep_wt[i] );
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("writeuniqueptl_cleanshared_wt[%0d]",i),writeuniqueptl_cleanshared_wt[i] );
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("writeuniqueptl_cleansharedpersistsep_wt[%0d]",i),writeuniqueptl_cleansharedpersistsep_wt[i] );
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("writebackfull_cleanshared_wt[%0d]",i),writebackfull_cleanshared_wt[i] );
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("writebackfull_cleansharedpersistsep_wt[%0d]",i),writebackfull_cleansharedpersistsep_wt[i] );
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("writebackfull_cleaninvalid_wt[%0d]",i),writebackfull_cleaninvalid_wt[i] );
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("writecleanfull_cleanshared_wt[%0d]",i),writecleanfull_cleanshared_wt[i] );
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("writecleanfull_cleansharedpersistsep_wt[%0d]",i),writecleanfull_cleansharedpersistsep_wt[i] );
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("stashoncesepunique_wt[%0d]",i),stashoncesepunique_wt[i] );
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("stashoncesepshared_wt[%0d]",i),stashoncesepshared_wt[i] );
`endif
`ifdef SVT_CHI_ISSUE_D_ENABLE
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("cleansharedpersistsep_wt[%0d]",i),cleansharedpersistsep_wt[i] );
`endif
`ifdef SVT_CHI_ISSUE_B_ENABLE
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("readspec_wt[%0d]",i),readspec_wt[i] );       
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("readnotshareddirty_wt[%0d]",i),readnotshareddirty_wt[i] );       
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("readoncecleaninvalid_wt[%0d]",i),readoncecleaninvalid_wt[i] );       
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("readoncemakeinvalid_wt[%0d]",i),readoncemakeinvalid_wt[i] );       
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("cleansharedpersist_wt[%0d]",i),cleansharedpersist_wt[i] );       
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("atomicstore_add_wt[%0d]",i),atomicstore_add_wt[i] );       
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("atomicstore_clr_wt[%0d]",i),atomicstore_clr_wt[i] );       
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("atomicstore_eor_wt[%0d]",i),atomicstore_eor_wt[i] );       
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("atomicstore_set_wt[%0d]",i),atomicstore_set_wt[i] );       
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("atomicstore_smax_wt[%0d]",i),atomicstore_smax_wt[i] );       
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("atomicstore_smin_wt[%0d]",i),atomicstore_smin_wt[i] );       
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("atomicstore_umax_wt[%0d]",i),atomicstore_umax_wt[i] );       
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("atomicstore_umin_wt[%0d]",i),atomicstore_umin_wt[i] );       
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("atomicload_add_wt[%0d]",i),atomicload_add_wt[i] );       
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("atomicload_clr_wt[%0d]",i),atomicload_clr_wt[i] );       
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("atomicload_eor_wt[%0d]",i),atomicload_eor_wt[i] );       
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("atomicload_set_wt[%0d]",i),atomicload_set_wt[i] );       
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("atomicload_smax_wt[%0d]",i),atomicload_smax_wt[i] );       
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("atomicload_smin_wt[%0d]",i),atomicload_smin_wt[i] );       
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("atomicload_umax_wt[%0d]",i),atomicload_umax_wt[i] );       
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("atomicload_umin_wt[%0d]",i),atomicload_umin_wt[i] );       
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("atomicswap_wt[%0d]",i),atomicswap_wt[i] );       
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("atomiccompare_wt[%0d]",i),atomiccompare_wt[i] );       
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("prefetchtgt_wt[%0d]",i),prefetchtgt_wt[i] );       
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("writeuniquefullstash_wt[%0d]",i),writeuniquefullstash_wt[i] );       
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("writeuniqueptlstash_wt[%0d]",i),writeuniqueptlstash_wt[i] );       
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("stashonceunique_wt[%0d]",i),stashonceunique_wt[i] );       
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("stashonceshared_wt[%0d]",i),stashonceshared_wt[i] );       
`endif
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("readshared_wt[%0d]",i),readshared_wt[i] );      
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("readunique_wt[%0d]",i),readunique_wt[i] );      
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("cleanunique_wt[%0d]",i),cleanunique_wt[i] );     
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("makeunique_wt[%0d]",i),makeunique_wt[i] );      
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("writebackfull_wt[%0d]",i),writebackfull_wt[i] );   
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("writebackptl_wt[%0d]",i),writebackptl_wt[i] );    
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("writeevictfull_wt[%0d]",i),writeevictfull_wt[i] );  
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("writecleanfull_wt[%0d]",i),writecleanfull_wt[i] );  
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("writecleanptl_wt[%0d]",i),writecleanptl_wt[i] );   
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("evict_wt[%0d]",i),evict_wt[i] );           
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("writenosnpfull_wt[%0d]",i),writenosnpfull_wt[i] );  
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("writenosnpptl_wt[%0d]",i),writenosnpptl_wt[i] );   
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("writeuniquefull_wt[%0d]",i),writeuniquefull_wt[i] ); 
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("writeuniqueptl_wt[%0d]",i),writeuniqueptl_wt[i] );  
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("cleanshared_wt[%0d]",i),cleanshared_wt[i] );     
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("cleaninvalid_wt[%0d]",i),cleaninvalid_wt[i] );    
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("makeinvalid_wt[%0d]",i),makeinvalid_wt[i] );     
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("eobarrier_wt[%0d]",i),eobarrier_wt[i] );       
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("ecbarrier_wt[%0d]",i),ecbarrier_wt[i] );       
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("dvmop_wt[%0d]",i),dvmop_wt[i] );           
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("pcrdreturn_wt[%0d]",i),pcrdreturn_wt[i] );      
     status_wt[i] = status_wt[i] | uvm_config_db#(int unsigned)::get(null, get_full_name(), $sformatf("reqlinkflit_wt[%0d]",i),reqlinkflit_wt[i] );        
`elsif SVT_OVM_TECHNOLOGY
     status = m_sequencer.get_config_int({get_type_name(), $sformatf("rn_index_list_for_sending_transaction[%0d]",i), rn_index_list_for_sending_transaction[i]);
     `protected
gL3T9CH.=:9&.&ZXa\3<9V;WLD_A3QW_BR^<HQ2^RBA,]K\.1P4&/)GdFb:0B5gB
+1<QO2GC9(\NNSJTYLb0)/;W8$
`endprotected
   
     status = m_sequencer.get_config_int({get_type_name(), $sformatf("rn_start_addr[%0d]",i), rn_start_addr[i]);
     `protected
^EP1ZCQPM[G^cG?fJ<YO]afe;c/B6.8#,+3232@17KY0,3<BNRaZ6)9TEOME57FC
[;@_YS6,8.b;XP2\\f?3=Jfe8$
`endprotected
   
     status = m_sequencer.get_config_int({get_type_name(), $sformatf("rn_end_addr[%0d]",i), rn_end_addr[i]);
     rn_init_cachelines_status[i] = m_sequencer.get_config_int({get_type_name(), $sformatf(".rn_initialize_cachelines[%0d]",i)},rn_initialize_cachelines[i] );       
     use_coherent_xacts_mem_attr_snp_attr_for_cmo_atomics_status[i] = m_sequencer.get_config_int({get_type_name(), $sformatf(".use_coherent_xacts_mem_attr_snp_attr_for_cmo_atomics[%0d]",i)},use_coherent_xacts_mem_attr_snp_attr_for_cmo_atomics[i] );       
     use_seq_order_type_status[i] = m_sequencer.get_config_int({get_type_name(), $sformatf(".use_seq_order_type[%0d]",i)},use_seq_order_type[i] );       
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".readnosnp_wt[%0d]",i)},readnosnp_wt[i] );       
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".readonce_wt[%0d]",i)},readonce_wt[i] );          
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".readclean_wt[%0d]",i)},readclean_wt[i] );         
`ifdef SVT_CHI_ISSUE_E_ENABLE
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".writeevictorevict_wt[%0d]",i)},writeevictorevict_wt[i] );
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".writenosnpzero_wt[%0d]",i)},writenosnpzero_wt[i] );
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".writeuniquezero_wt[%0d]",i)},writeuniquezero_wt[i] );
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".makereadunique_wt[%0d]",i)},makereadunique_wt[i] );
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".readpreferunique_wt[%0d]",i)},readpreferunique_wt[i] );
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".writenosnpfull_cleanshared_wt[%0d]",i)},writenosnpfull_cleanshared_wt[i] );
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".writenosnpfull_cleansharedpersistsep_wt[%0d]",i)},writenosnpfull_cleansharedpersistsep_wt[i] );
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".writeuniquefull_cleanshared_wt[%0d]",i)},writeuniquefull_cleanshared_wt[i] );
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".writeuniquefull_cleansharedpersistsep_wt[%0d]",i)},writeuniquefull_cleansharedpersistsep_wt[i] );
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".writenosnpfull_cleaninvalid_wt[%0d]",i)},writenosnpfull_cleaninvalid_wt[i] );
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".writenosnpptl_cleaninvalid_wt[%0d]",i)},writenosnpptl_cleaninvalid_wt[i] );
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".writenosnpptl_cleanshared_wt[%0d]",i)},writenosnpptl_cleanshared_wt[i] );
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".writenosnpptl_cleansharedpersistsep_wt[%0d]",i)},writenosnpptl_cleansharedpersistsep_wt[i] );
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".writeuniqueptl_cleanshared_wt[%0d]",i)},writeuniqueptl_cleanshared_wt[i] );
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".writeuniqueptl_cleansharedpersistsep_wt[%0d]",i)},writeuniqueptl_cleansharedpersistsep_wt[i] );
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".writebackfull_cleanshared_wt[%0d]",i)},writebackfull_cleanshared_wt[i] );
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".writebackfull_cleansharedpersistsep_wt[%0d]",i)},writebackfull_cleansharedpersistsep_wt[i] );
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".writebackfull_cleaninvalid_wt[%0d]",i)},writebackfull_cleaninvalid_wt[i] );
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".writecleanfull_cleanshared_wt[%0d]",i)},writecleanfull_cleanshared_wt[i] );
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".writecleanfull_cleansharedpersistsep_wt[%0d]",i)},writecleanfull_cleansharedpersistsep_wt[i] );
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".stashoncesepunique_wt[%0d]",i)},stashoncesepunique_wt[i] );
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".stashoncesepshared_wt[%0d]",i)},stashoncesepshared_wt[i] );
`endif
`ifdef SVT_CHI_ISSUE_D_ENABLE
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".cleansharedpersistsep_wt[%0d]",i)},cleansharedpersistsep_wt[i] );
`endif
`ifdef SVT_CHI_ISSUE_B_ENABLE
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".readspec_wt[%0d]",i)},readspec_wt[i] );         
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".readnotshareddirty_wt[%0d]",i)},readnotshareddirty_wt[i] );         
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".readoncecleaninvalid_wt[%0d]",i)},readoncecleaninvalid_wt[i] );         
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".readoncemakeinvalid_wt[%0d]",i)},readoncemakeinvalid_wt[i] );         
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".cleansharedpersist_wt[%0d]",i)},cleansharedpersist_wt[i] );

     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".atomicstore_add_wt[%0d]",i),atomicstore_add_wt[i] );       
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".atomicstore_clr_wt[%0d]",i),atomicstore_clr_wt[i] );       
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".atomicstore_eor_wt[%0d]",i),atomicstore_eor_wt[i] );       
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".atomicstore_set_wt[%0d]",i),atomicstore_set_wt[i] );       
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".atomicstore_smax_wt[%0d]",i),atomicstore_smax_wt[i] );       
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".atomicstore_smin_wt[%0d]",i),atomicstore_smin_wt[i] );       
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".atomicstore_umax_wt[%0d]",i),atomicstore_umax_wt[i] );       
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".atomicstore_umin_wt[%0d]",i),atomicstore_umin_wt[i] );       
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".atomicload_add_wt[%0d]",i),atomicload_add_wt[i] );       
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".atomicload_clr_wt[%0d]",i),atomicload_clr_wt[i] );       
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".atomicload_eor_wt[%0d]",i),atomicload_eor_wt[i] );       
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".atomicload_set_wt[%0d]",i),atomicload_set_wt[i] );       
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".atomicload_smax_wt[%0d]",i),atomicload_smax_wt[i] );       
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".atomicload_smin_wt[%0d]",i),atomicload_smin_wt[i] );       
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".atomicload_umax_wt[%0d]",i),atomicload_umax_wt[i] );       
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".atomicload_umin_wt[%0d]",i),atomicload_umin_wt[i] );       
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".atomicswap_wt[%0d]",i),atomicswap_wt[i] );       
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".atomiccompare_wt[%0d]",i),atomiccompare_wt[i] );       
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".prefetchtgt_wt[%0d]",i),prefetchtgt_wt[i] );       
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".writeuniquefullstash_wt[%0d]",i),writeuniquefullstash_wt[i] );       
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".writeuniqueptlstash_wt[%0d]",i),writeuniqueptlstash_wt[i] );       
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".stashonceunique_wt[%0d]",i),stashonceunique_wt[i] );       
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".stashonceshared_wt[%0d]",i),stashonceshared_wt[i] );
`endif
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".readshared_wt[%0d]",i)},readshared_wt[i] );        
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".readunique_wt[%0d]",i)},readunique_wt[i] );        
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".cleanunique_wt[%0d]",i)},cleanunique_wt[i] );       
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".makeunique_wt[%0d]",i)},makeunique_wt[i] );        
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".writebackfull_wt[%0d]",i)},writebackfull_wt[i] );     
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".writebackptl_wt[%0d]",i)},writebackptl_wt[i] );      
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".writeevictfull_wt[%0d]",i)},writeevictfull_wt[i] );    
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".writecleanfull_wt[%0d]",i)},writecleanfull_wt[i] );    
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".writecleanptl_wt[%0d]",i)},writecleanptl_wt[i] );     
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".evict_wt[%0d]",i)},evict_wt[i] );             
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".writenosnpfull_wt[%0d]",i)},writenosnpfull_wt[i] );    
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".writenosnpptl_wt[%0d]",i)},writenosnpptl_wt[i] );     
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".writeuniquefull_wt[%0d]",i)},writeuniquefull_wt[i] );   
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".writeuniqueptl_wt[%0d]",i)},writeuniqueptl_wt[i] );    
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".cleanshared_wt[%0d]",i)},cleanshared_wt[i] );       
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".cleaninvalid_wt[%0d]",i)},cleaninvalid_wt[i] );      
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".makeinvalid_wt[%0d]",i)},makeinvalid_wt[i] );     
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".eobarrier_wt[%0d]",i)},eobarrier_wt[i] );       
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".ecbarrier_wt[%0d]",i)},ecbarrier_wt[i] );       
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".dvmop_wt[%0d]",i)},dvmop_wt[i] );           
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".pcrdreturn_wt[%0d]",i)},pcrdreturn_wt[i] );      
     status_wt[i] = status_wt[i] | m_sequencer.get_config_int({get_type_name(), $sformatf(".reqlinkflit_wt[%0d]",i)},reqlinkflit_wt[i] );      
`endif
    seq_member_val_str = {seq_member_val_str, $sformatf("rn_index_list_for_sending_transaction[%0d]         = %0d\n"   ,i, rn_index_list_for_sending_transaction[i])};
    seq_member_val_str = {seq_member_val_str, $sformatf("rn_initialize_cachelines[%0d]                      = %0b\n"   ,i, rn_initialize_cachelines[i])};
    if (!use_coherent_xacts_mem_attr_snp_attr_for_cmo_atomics_status[i]) begin
      if (!is_non_coherent_xact_wt_set(i)) begin
        use_coherent_xacts_mem_attr_snp_attr_for_cmo_atomics[i] = 1;
      end
    end
    seq_member_val_str = {seq_member_val_str, $sformatf("use_coherent_xacts_mem_attr_snp_attr_for_cmo_atomics[%0d] = %0b\n"   ,i, use_coherent_xacts_mem_attr_snp_attr_for_cmo_atomics[i])};
    seq_member_val_str = {seq_member_val_str, $sformatf("use_seq_order_type[%0d] = %0b\n"   ,i, use_seq_order_type[i])};
    if (addr_mode_status) begin
      if (addr_mode == svt_chi_rn_coherent_transaction_base_sequence::SEQUENTIAL_NONOVERLAPPED_ADDRESS || addr_mode == svt_chi_rn_coherent_transaction_base_sequence::SEQUENTIAL_OVERLAPPED_ADDRESS) begin
        rn_end_addr[i] = (rn_start_addr[i] + ((sequence_length-1) * `SVT_CHI_CACHE_LINE_SIZE));
        `svt_xvm_debug("pre_start", $sformatf("addr_mode_status is 1. addr_mode is %0s. For rn_index_list_for_sending_transaction[%0d] - RN[%0d]: rn_start_addr[%0d] is 'h%0h, rn_end_addr[%0d] is updated to 'h%0h based on sequence_length %0d.", addr_mode.name(), i, rn_index_list_for_sending_transaction[i] , i, rn_start_addr[i], i, rn_end_addr[i], sequence_length));
      end
    end
    seq_member_val_str = {seq_member_val_str, $sformatf("rn_start_addr[%0d]                                 = 0x%0x\n" ,i, rn_start_addr[i])};
    seq_member_val_str = {seq_member_val_str, $sformatf("rn_end_addr[%0d]                                   = 0x%0x\n" ,i, rn_end_addr[i])};
    end
    seq_member_val_str = {seq_member_val_str, $sformatf("-----------------------------------------------------------------------------\n")};
    `svt_note("get_overridden_sequence_member_values", $sformatf("%0s",rand_member_val_str));                                      
    `svt_note("get_overridden_sequence_member_values", $sformatf("%0s",seq_member_val_str));                                      
  endtask
endclass: svt_chi_system_coherent_virtual_sequence


/** @cond PRIVATE */
//------------------------------------------------------------------------------
/**
  * @groupname CHI_SYS_MULTI_RN
  * This Sequence is un-supported. <br>
  * this sequence ensures sending overlapped transactions from multiple RNs with 
  * same addresses. 
  * Even though it can send overlapped transactions from multiple RNs but, it is
  * by default constrained with 2 RNs in non-blocking mode. User can either override
  * or disable reasonable_constraints to change number of RNs supported.
  * 
  * This sequence also allows user to override sequence members or randomize it with
  * default built-in constraints.
  * Currently this sequence doesn't factor in non_secure_access bit for address calculation. i.e, tagged address
  * is not yet supported in this sequence.
  */
//------------------------------------------------------------------------------
class svt_chi_system_coherent_overlapped_virtual_sequence extends svt_chi_system_coherent_virtual_sequence;

  constraint reasonable_constraints {
      num_rn_to_send_transaction == 2;
      send_blocking_transactions == 0;
  }

  `svt_xvm_object_utils(svt_chi_system_coherent_overlapped_virtual_sequence)

  function new(string name = "svt_chi_system_coherent_overlapped_virtual_sequence");
    super.new(name);
  endfunction

/**
  * Initializes cachelines and sends coherent transactions from nodes specified 
  * in rn_index_list_for_sending_transaction associative array
  */
  virtual task body();

      int txn_count, primary_rn_index, primary_seq_index;
      svt_chi_rn_transaction _xact;

      primary_rn_index = rn_index_list_for_sending_transaction[$urandom_range(rn_index_list_for_sending_transaction.size()-1,0)];
      `svt_debug("body",$sformatf("primary_rn RN[%0d]", primary_rn_index));
      // launch transaction thread from each RN with empty address mailbox
      // so that, all threads are in wait state starving for address
      foreach(rn_index_list_for_sending_transaction[ix]) begin
        automatic int _ix   = ix;
        automatic int _indx = rn_index_list_for_sending_transaction[ix];
        fork 
          begin
            coherent_transactions_sent_from_rn_process_completed[_indx] = 0;
            if(_indx == primary_rn_index) begin
               primary_seq_index = active_seq_queue.size();
               `svt_debug("body",$sformatf("Primary Sequence idx %0d active_seq_queue[%0d]", primary_seq_index, primary_seq_index));
                    // Don't use directed address and no need for cacheline initiallization
               send_coherent_transactions_from_rn(_ix, _indx, 1, 0);
            end else
                    // Use directed address and initiallize cacheline 
               send_coherent_transactions_from_rn(_ix, _indx, 1, 1);
          end
        join_none
      end
        #0;

      // now control execution of above threads by selectively distributing
      // addresses to different RNs. For this, below steps are followed
      //   1. randomly choose one of the RN waiting to send transaction
      //   3. wait for transaction handle from output_xact_mailbox of the RN randomly chosen above
      //   2. provide address to direct address mailbox of this RN from address queue of the chosen RN
      //   4. now provide same address to other RNs
      //   5. increment iteration count
      //   6. if count < sequence length then go to step 1
      //      else exit
      fork 
      begin
        txn_count =0;

        while(txn_count < sequence_length) begin
          //active_seq_queue[primary_seq_index].directed_addr_mailbox.put(rn_addr_ranges[primary_rn_index].addr[txn_count]);
          active_seq_queue[primary_seq_index].output_xact_mailbox.get(_xact); 
          foreach(active_seq_queue[ix]) begin
            if(ix != primary_seq_index) begin 
               active_seq_queue[ix].directed_addr_mailbox.put(_xact.addr);
               active_seq_queue[ix].directed_snp_attr_is_snoopable_mailbox.put(_xact.snp_attr_is_snoopable);
               active_seq_queue[ix].directed_mem_attr_allocate_hint_mailbox.put(_xact.mem_attr_allocate_hint);
               active_seq_queue[ix].directed_snp_attr_snp_domain_type_mailbox.put(_xact.snp_attr_snp_domain_type);
               active_seq_queue[ix].directed_is_non_secure_access_mailbox.put(_xact.is_non_secure_access);
            end
          end
          txn_count++;
        end
      end

      // wait for all transactions to finish. For this reason first,
      // wait for coherent_transactions_sent_from_rn_process_completed flag to be set to 1 for all RN
      // wait for all active sequence items or transactions to finish
      begin
             #0;
             foreach(coherent_transactions_sent_from_rn_process_completed[ix]) 
               wait(coherent_transactions_sent_from_rn_process_completed[ix]==1);

             if(!send_blocking_transactions) begin
                foreach(active_seq_queue[ix])
                  active_seq_queue[ix].wait_for_active_xacts_to_end();
             end
      end
      join
      ////////////////////////////////////////////////////////////////
//--------------------------------------------------------------

      print_caches();
  endtask: body

endclass: svt_chi_system_coherent_overlapped_virtual_sequence
/** @endcond */

//====================================================================================
/** CHI system flow control virtual sequences */
//====================================================================================

/////////////////////////////
// Read type
/////////////////////////////
//====================================================================================
/**
 * @groupname CHI_FLOW_CTRL_RD_TYPE 
 *    #- Optionally program a randomly selected RN to send two MAKEUNIQUE transaction targeted to<br> 
 *       randomly selected different target IDs when number of RN-F is 3 or more incase of RN-F test<br>
 *       or number of RN-F is atleast 1 incase of RN-I test.<br>
 *    #- Program other two randomly selected RNs to send a read type coherent transaction<br>
 *       with same TxnID simultaneously to above selected different target IDs of MAKEUNIQUE 
 *       transactions if MAKEQNIQUE transaction is sent for initilization.<br>
 *    #- If MAKEQNIQUE transaction is not sent for initilization program two randomly<br> 
 *       selected different RNs to send a read type coherent transaction with same TxnID simultaneously<br>
 *       to randomly selected different target IDs.<br> 
 *    #- Check that the HN's responds with same TxnId to respective RNs.<br>
 *    .
 */

class svt_chi_system_protocol_flow_ctrl_read_resp_same_txnid_diff_rn_diff_hn_virtual_sequence extends svt_chi_system_base_virtual_sequence;

  /** Represents the RN-F node for which the sequence will be initiated */ 
  int select_rn_f_node = 0;  
  
  /** Represents the RN-I node for which the sequence will be initiated */ 
  int select_rn_i_node = 0;
  
  /** Represents the RN-D node for which the sequence will be initiated */ 
  int select_rn_d_node = 0;
  
  /** Status filed for capturing config DB get status for select_rn_f_node */
  bit select_rn_f_node_status = 0;
  
  /** Status filed for capturing config DB get status for select_rn_i_node */
  bit select_rn_i_node_status = 0;

  /** Status filed for capturing config DB get status for select_rn_d_node */
  bit select_rn_d_node_status = 0;

  /** Sub Read type transaction directed sequences initiated from this sequence */
  svt_chi_rn_read_type_transaction_directed_sequence chi0_rn_seq[int];

  /** UVM Object Utility macro */
  `uvm_object_utils(svt_chi_system_protocol_flow_ctrl_read_resp_same_txnid_diff_rn_diff_hn_virtual_sequence)

  extern function new(string name="svt_chi_system_protocol_flow_ctrl_read_resp_same_txnid_diff_rn_diff_hn_virtual_sequence"); 

  virtual task pre_start();
    super.pre_start();
    raise_phase_objection();
    select_rn_f_node_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(),"select_rn_f_node", select_rn_f_node);
    `svt_xvm_debug("body", $sformatf("select_rn_f_node is %0d as a result of %0s", select_rn_f_node, (select_rn_f_node_status ?"config DB":"Default setting")));
    select_rn_i_node_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(),"select_rn_i_node", select_rn_i_node);
    `svt_xvm_debug("body", $sformatf("select_rn_i_node is %0d as a result of %0s", select_rn_i_node, (select_rn_i_node_status ?"config DB":"Default setting")));
    select_rn_d_node_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(),"select_rn_d_node", select_rn_d_node);
    `svt_xvm_debug("body", $sformatf("select_rn_d_node is %0d as a result of %0s", select_rn_d_node, (select_rn_d_node_status ?"config DB":"Default setting")));
  endtask // pre_start
  
  /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting RN-F Nodes = 2 when select_rn_f_node is programmed to 1
   *  #- minimum supporting RN-I Nodes = 2 when select_rn_i_node is programmed to 1
   *  #- minimum supporting RN-D Nodes = 2 when select_rn_d_node is programmed to 1
   */
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    
    /** local variables */
    int num_supporting_rn_f_nodes;
    int num_supporting_rn_i_nodes;
    int num_supporting_rn_d_nodes;
    string str_is_supported_info_prefix = "";
    string str_is_supported_info = "";

    /** Supporting Request Nodes required */
    int required_num_supporting_rn_f_nodes = 0;
    int required_num_supporting_rn_i_nodes = 0;
    int required_num_supporting_rn_d_nodes = 0;
    int required_num_hn_nodes = 2;
    int num_hn_f_nodes;
    int array_idx;
    string str_idx0_info = "";
    string str_idx1_info = ""; 
    bit    is_rn_idx_0_participating, is_rn_idx_1_participating;   
    `svt_xvm_debug("is_supported",$sformatf("calling is_supported"));
                 
    /** By default is_supported is 0 */
    is_supported = 0;
    
    /** Check for minimum required HN-F nodes */
    num_hn_f_nodes = hn_f_nodes.size();

    /** Check requirment of number of HN nodes needed */
    if (num_hn_f_nodes < required_num_hn_nodes) begin
      issue_is_supported_failure($sformatf("This sequence requires minimum %0d HN-F nodes to be present in the system. Number of HN-F nodes are %0d. Program number of HN nodes using svt_chi_system_configuration::num_hn. Program the HN interface type using svt_chi_system_configuration::chi_addr_cfg.hn_interface_type[].", required_num_hn_nodes, num_hn_f_nodes));
      return 0;      
    end
    
    /** Either of select_rn_d_node, select_rn_i_node, select_rn_f_node needs to be programmed to 1.
     *  More than one flag cannot be 1 or 0 together.
     */
    if (((select_rn_f_node == 0) && (select_rn_i_node == 0) && (select_rn_d_node == 0)) ||
        ((select_rn_f_node == 1) && (select_rn_i_node == 1) && (select_rn_d_node == 1))) begin
      issue_is_supported_failure($sformatf("select_rn_f_node = %0d. select_rn_i_node = %0d. select_rn_d_node = %0d. Programming one of these two variables to 1 through config DB is required for this sequence to be run.", select_rn_f_node, select_rn_i_node, select_rn_d_node));
      return 0;
    end

    /** Set minimum required supporting RN-F, RN-D and RN-I nodes depending on  
     *  select_rn_f_node or select_rn_d_node or select_rn_i_node flags respectively.
     */   
    if(select_rn_f_node)
      required_num_supporting_rn_f_nodes = 2;
    else if(select_rn_i_node) begin
      required_num_supporting_rn_i_nodes = 2;
    end else if (select_rn_d_node)begin
      required_num_supporting_rn_d_nodes = 2;
    end
    
    /** Check for minimum required RN-F, RN-D and RN-I nodes.
     *  Also check whether the selected RN-F, RN-D and RN-I nodes are part of participating arrays or not.
     */ 
    num_supporting_rn_f_nodes = active_participating_rn_f_nodes.size();
    num_supporting_rn_d_nodes = active_participating_rn_d_nodes.size();
    num_supporting_rn_i_nodes = active_participating_rn_i_nodes.size();

    /** Check the requirements of RN nodes */
    if (num_supporting_rn_f_nodes) begin
      /** Display the contents of Active Participating RN-F Nodes */
      foreach (active_participating_rn_f_nodes[j]) begin
        str_node_info = {str_node_info, $sformatf(" %0d", active_participating_rn_f_nodes[j])};
      end      
      `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_f_nodes are %0s", str_node_info));
    end
    
    /** Display the contents of Active Participating RN-D Nodes */
    str_node_info = "";

    /** Check the requirement of RN-D nodes */ 
    if (num_supporting_rn_d_nodes) begin
      foreach (active_participating_rn_d_nodes[j]) begin
        str_node_info = {str_node_info, $sformatf(" %0d", active_participating_rn_d_nodes[j])};
      end 
      `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_d_nodes are %0s", str_node_info));
    end

    /** Display the contents of Active Participating RN-I Nodes */
    str_node_info = "";

    /** Check the requirement of RN-I nodes */ 
    if (num_supporting_rn_i_nodes) begin
      foreach (active_participating_rn_i_nodes[j]) begin
        str_node_info = {str_node_info, $sformatf(" %0d", active_participating_rn_i_nodes[j])};
      end 
      `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_i_nodes are %0s", str_node_info));
    end

    /** Check the required supporting Request Nodes */
    if (select_rn_f_node == 1) begin
      
      str_is_supported_info_prefix = $sformatf("select_rn_f_node is set to 1. Number of Supporting RN-F Node(s)  - Minimum Required : %0d Current : %0d", required_num_supporting_rn_f_nodes,num_supporting_rn_f_nodes);

      if ((initiating_rn_node_index_0_status==0)&&(valid_initiating_rn_f_node_index_0==0)) begin
          str_idx0_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN-Fs that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)";
      end
      else begin
        is_rn_idx_0_participating = is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_node_idx_0, array_idx);
        if (!is_rn_idx_0_participating) begin
          str_idx0_info = $sformatf("initiating_rn_node_idx_0 %0d is not valid for this sequence. The RN-F corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)", initiating_rn_node_idx_0, initiating_rn_node_idx_0);
        end
      end

      if ((initiating_rn_node_index_1_status==0)&&(valid_initiating_rn_f_node_index_1==0)) begin
        str_idx1_info = "Valid initiating_rn_node_idx_1 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN-Fs that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)";
      end 
      else begin
        is_rn_idx_1_participating = is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_node_idx_1, array_idx);
        if (!is_rn_idx_1_participating) begin
          str_idx1_info = $sformatf("initiating_rn_node_idx_1 %0d is not valid for this sequence. The RN-F corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)", initiating_rn_node_idx_1, initiating_rn_node_idx_1);
        end
      end    
    end
    else if (select_rn_i_node == 1) begin
      
      str_is_supported_info_prefix = $sformatf("select_rn_i_node is set to 1. Number of Supporting RN-I Node(s)  - Minimum Required : %0d Current : %0d", required_num_supporting_rn_i_nodes,num_supporting_rn_i_nodes);

      if ((initiating_rn_node_index_0_status==0)&&(valid_initiating_rn_i_node_index_0==0)) begin
        str_idx0_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN-Is that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_I)";
      end
      else begin
        is_rn_idx_0_participating = is_value_found_in_int_assoc_array(active_participating_rn_i_nodes, initiating_rn_node_idx_0, array_idx);
        if (!is_rn_idx_0_participating) begin
         
          str_idx0_info = $sformatf("initiating_rn_node_idx_0 %0d is not valid for this sequence. The RN-I corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_I)", initiating_rn_node_idx_0, initiating_rn_node_idx_0);
        end  
      end

      if ((initiating_rn_node_index_1_status==0)&&(valid_initiating_rn_i_node_index_1==0)) begin
        str_idx1_info = "Valid initiating_rn_node_idx_1 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN-Is that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_I)";
      end
      else begin
        is_rn_idx_1_participating = is_value_found_in_int_assoc_array(active_participating_rn_i_nodes, initiating_rn_node_idx_1, array_idx);
        if (!is_rn_idx_1_participating) begin
          str_idx1_info = $sformatf("initiating_rn_node_idx_1 %0d is not valid for this sequence. The RN-I corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_I)", initiating_rn_node_idx_1, initiating_rn_node_idx_1);
        end 
      end
    end
    else if (select_rn_d_node == 1) begin

      str_is_supported_info_prefix = $sformatf("select_rn_d_node is set to 1. Number of Supporting RN-D Node(s)  - Minimum Required : %0d Current : %0d", required_num_supporting_rn_d_nodes,num_supporting_rn_d_nodes);

      if ((initiating_rn_node_index_0_status==0)&&(valid_initiating_rn_d_node_index_0==0)) begin
        str_idx0_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN-Ds that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_D)";
      end
      else begin
        is_rn_idx_0_participating = is_value_found_in_int_assoc_array(active_participating_rn_d_nodes, initiating_rn_node_idx_0, array_idx);
        if (!is_rn_idx_0_participating) begin
         
          str_idx0_info = $sformatf("initiating_rn_node_idx_0 %0d is not valid for this sequence. The RN-D corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_D)", initiating_rn_node_idx_0, initiating_rn_node_idx_0);
        end  
      end

      if ((initiating_rn_node_index_1_status==0)&&(valid_initiating_rn_d_node_index_1==0)) begin
        str_idx1_info = "Valid initiating_rn_node_idx_1 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN-Ds that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_D)";
      end
      else begin
        is_rn_idx_1_participating = is_value_found_in_int_assoc_array(active_participating_rn_d_nodes, initiating_rn_node_idx_1, array_idx);
        if (!is_rn_idx_1_participating) begin
          str_idx1_info = $sformatf("initiating_rn_node_idx_1 %0d is not valid for this sequence. The RN-D corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_D)", initiating_rn_node_idx_1, initiating_rn_node_idx_1);
        end 
      end
    end

    if (is_rn_idx_0_participating && is_rn_idx_1_participating) begin
      is_supported = 1;
    end
    
    if (!is_supported) begin
      str_is_supported_info = $sformatf("%0s%0s",str_idx0_info, str_idx1_info);
      issue_is_supported_failure($sformatf("This sequence cannot be run based on the current system configuration.\n\
                                            %0s\n\
                                            %0s \n\
                                            Modify configurations through \n\
                                            svt_chi_system_configuration::num_rn,\n\
                                            svt_chi_node_configuration::is_active,\n\
                                            svt_chi_system_configuration::participating_rn_nodes[]\n\
                                            ", str_is_supported_info_prefix, str_is_supported_info));
    end

    if (!is_target_hn_idx_valid_for_curr_cfg()) begin
      is_supported = 0;
      `svt_xvm_note("is_supported", "not a valid hn_idx based on random_tgt_id_enable for current cfg");
    end                                  
  endfunction : is_supported
  
  virtual task body();
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0]                    addr1;
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0]                    addr2;
    int                                                   array_idx;
    bit [`SVT_CHI_MAX_DATA_WIDTH -1:0]                    temp_data_1,temp_data_2;
    bit perform_cache_initialization;
    bit txn1_is_non_secure_access;
    bit txn2_is_non_secure_access;

    string str_node_types = "";
    int unsigned sel_initiating_rn_node_index_0,sel_initiating_rn_node_index_1;
    /** Sub sequences initiated from this sequence */
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq[int];

    `svt_xvm_debug("body", "Entering ...");
    super.body();

    if (select_rn_f_node) begin
      str_node_types = "Iniating nodes are of RN-F type.";
      // If the initiating_rn_f_node_index_2 is part of active_participating_rn_f_nodes array, and
      // it is not equal to initiating_rn_f_node_index_0, initiating_rn_f_node_index_1; then we can
      // perform cache initialization from the RN[cache_line_init_rn_f_node_index].
      if ((is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_f_node_index_2, array_idx)) &&
          (initiating_rn_f_node_index_2 != initiating_rn_f_node_index_0) &&
          (initiating_rn_f_node_index_2 != initiating_rn_f_node_index_1)) begin
        perform_cache_initialization = 1;
        cache_line_init_rn_f_node_index = initiating_rn_f_node_index_2;          
      end
      sel_initiating_rn_node_index_0 = initiating_rn_f_node_index_0;
      sel_initiating_rn_node_index_1 = initiating_rn_f_node_index_1;
    end
    else if (select_rn_i_node) begin
      str_node_types = "Iniating nodes are of RN-I type.";
      // If the initiating_rn_f_node_index_0 is part of active_participating_rn_f_nodes array
      // then we can perform cache initialization from the RN[cache_line_init_rn_f_node_index].
      if (is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_f_node_index_0, array_idx)) begin
        perform_cache_initialization = 1;
        cache_line_init_rn_f_node_index = initiating_rn_f_node_index_0;          
      end
     sel_initiating_rn_node_index_0 = initiating_rn_i_node_index_0;
     sel_initiating_rn_node_index_1 = initiating_rn_i_node_index_1;
    end
    else if (select_rn_d_node) begin
      str_node_types = "Initiating nodes are of RN-D type.";
      // If the initiating_rn_f_node_index_0 is part of active_participating_rn_f_nodes array
      // then we can perform cache initialization from the RN[cache_line_init_rn_f_node_index].
      if (is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_f_node_index_0, array_idx)) begin
        perform_cache_initialization = 1;
        cache_line_init_rn_f_node_index = initiating_rn_f_node_index_0;          
      end
      sel_initiating_rn_node_index_0 = initiating_rn_d_node_index_0;
      sel_initiating_rn_node_index_1 = initiating_rn_d_node_index_1;
    end

    `svt_xvm_debug("body", $sformatf("%0s perform_cache_initialization = %0b. cache_line_init_rn_f_node_index = %0d. sel_initiating_rn_node_index_0 = %0d. sel_initiating_rn_node_index_1 = %0d.", str_node_types, perform_cache_initialization, cache_line_init_rn_f_node_index, sel_initiating_rn_node_index_0, sel_initiating_rn_node_index_1));
    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :sel_initiating_rn_node_index_0;
    initiating_rn_node_idx_1 = initiating_rn_node_index_1_status ? initiating_rn_node_index_1_from_config_db :sel_initiating_rn_node_index_1;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_f_node_index_0;
    target_hn_node_idx_1 = target_hn_node_index_1_status ? target_hn_node_index_1_from_config_db :target_hn_f_node_index_1;

    `svt_xvm_debug("body", $sformatf("initiating_rn_node_idx_0 is %0d as a result of %0s.", initiating_rn_node_idx_0, initiating_rn_node_index_0_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("initiating_rn_node_idx_1 is %0d as a result of %0s.", initiating_rn_node_idx_1, initiating_rn_node_index_1_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("target_hn_node_idx_0 is %0d as a result of %0s.", target_hn_node_idx_0, target_hn_node_index_0_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("target_hn_node_idx_1 is %0d as a result of %0s.", target_hn_node_idx_1, target_hn_node_index_1_status ? "config DB" : "Randomization"));  
    `svt_xvm_debug("body", $sformatf("perform_cache_initialization is %0b, cache_line_init_rn_f_node_index is %0d, initiating_rn_node_idx_0 is %0d, initiating_rn_node_idx_1 is %0d", perform_cache_initialization, cache_line_init_rn_f_node_index, initiating_rn_node_idx_0, initiating_rn_node_idx_1));    

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /**
     * If the cache_line_init_rn_f_node_index is same as any of the RN node indices 
     * which are passed through config i.e initiating_rn_node_idx_0,initiating_rn_node_idx_1,
     * then re-assign the cache_line_init_rn_f_node_index with RN node index ,which is active,
     * participating and not equal to initiating_rn_node_idx_0, initiating_rn_node_idx_1.
     */
    if(initiating_rn_node_index_0_status||initiating_rn_node_index_1_status)begin  
      if((cache_line_init_rn_f_node_index == initiating_rn_node_idx_0)||(cache_line_init_rn_f_node_index == initiating_rn_node_idx_1))begin  
        int active_participating_q [$];
        `svt_chi_xxm_debug("body",$sformatf("cache_line_init_rn_f_node_index= %0d is same as initiating_rn_node_idx_0=%0d or initiating_rn_node_idx_1=%0d and active_participating_rn_f_nodes.size()= %0d",cache_line_init_rn_f_node_index,initiating_rn_node_idx_0,initiating_rn_node_idx_1,active_participating_rn_f_nodes.size()));
        if(active_participating_rn_f_nodes.size()>2)begin
          active_participating_q = active_participating_rn_f_nodes.find with ((item != initiating_rn_node_idx_0) && (item != initiating_rn_node_idx_1));
          cache_line_init_rn_f_node_index = active_participating_q.pop_back();
          `svt_chi_xxm_debug("body", $sformatf("active_participating_q.size() is %0d and Selected different cache_line_init_rn_f_node_index=%0d", active_participating_q.size(),cache_line_init_rn_f_node_index));
          active_participating_q.delete();
        end else begin
          perform_cache_initialization=0;
          `svt_chi_xxm_debug("body",$sformatf("BYPASSING Cache Initialization as selected cache_line_init_rn_f_node_index= %0d is same as initiating_rn_node_index_0_from_config_db=%0d or initiating_rn_node_index_1_from_config_db=%0d and active_participating_rn_f_nodes.size()= %0d",cache_line_init_rn_f_node_index,initiating_rn_node_index_0_from_config_db,initiating_rn_node_index_1_from_config_db,active_participating_rn_f_nodes.size()));
        end
      end  
    end 

    /**
     * If the cache_line_init_rn_f_node_index is part of active_participating_rn_f_nodes array, and
     * it is not equal to initiating_rn_node_idx_0, initiating_rn_node_idx_1; then we can
     * perform cache initialization from the RN[cache_line_init_rn_f_node_index].
     */
    if ((is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, cache_line_init_rn_f_node_index, array_idx)) &&
        (cache_line_init_rn_f_node_index != initiating_rn_node_idx_0) &&
        (cache_line_init_rn_f_node_index != initiating_rn_node_idx_1)) begin
      perform_cache_initialization = 1;
    end

    `svt_chi_xxm_debug("body",$sformatf("Selected RN indices are cache_line_init_rn_f_node_index= %0d initiating_rn_node_idx_0=%0d initiating_rn_node_idx_1=%0d and perform_cache_initialization= %0d",cache_line_init_rn_f_node_index,initiating_rn_node_idx_0,initiating_rn_node_idx_1,perform_cache_initialization));

    for(int i = 0; i < sequence_length; i++) begin
      if(perform_cache_initialization) begin
        /** 
         * Write data into Cache of Randomly selected first RN with address of randomly
         * selected first HN Node.
         */
        `svt_xvm_do_on_with(makeunique_seq[0], p_sequencer.rn_virt_seqr[cache_line_init_rn_f_node_index].rn_xact_seqr,
                                              {sequence_length    == 1;
                                               hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
                                               seq_hn_node_idx    == target_hn_node_idx_0;
                                               use_seq_is_non_secure_access == 0;              
                                              })
         /** Wait for MakeUnique transactions to finish */ 
         makeunique_seq[0].write_tran.wait_end();
         txn1_is_non_secure_access=makeunique_seq[0].output_xacts[0].is_non_secure_access; 
        
        /** Write data into Cache of Randomly selected first RN with address of randomly 
         *  selected second HN Node.
         */
        `svt_xvm_do_on_with(makeunique_seq[1], p_sequencer.rn_virt_seqr[cache_line_init_rn_f_node_index].rn_xact_seqr,
                                              {sequence_length    == 1;
                                               hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
                                               seq_hn_node_idx    == target_hn_node_idx_1;
                                               use_seq_is_non_secure_access == 0;       
                                              })
         txn2_is_non_secure_access=makeunique_seq[1].output_xacts[0].is_non_secure_access; 
        /** Wait for MakeUnique transactions to finish */ 
        makeunique_seq[1].write_tran.wait_end();

        /** Retrieving address from output transactions generated by the above MakeUnique sequences */
        addr1 = makeunique_seq[0].output_xacts[0].addr;
        addr2 = makeunique_seq[1].output_xacts[0].addr;
        temp_data_1 = makeunique_seq[0].output_xacts[0].data;
        temp_data_2 = makeunique_seq[1].output_xacts[0].data;
      end

      fork
        begin: rn_0_thread
          /** Randomly selected first RN-F fires a read transaction with MAKEUNIQUE 
           *  transaction address of randomly selected second HN Node.
           */
          `svt_xvm_do_on_with(chi0_rn_seq[0], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
          {
            sequence_length == 1;
            seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
            if (perform_cache_initialization) {
              hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
              min_addr == addr1;
              max_addr == addr1;
              data_in_cache == temp_data_1;
              by_pass_read_data_check == 0;
              seq_is_non_secure_access == txn1_is_non_secure_access; 
              use_seq_is_non_secure_access == 1;
            }
            else {
              hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
              seq_hn_node_idx    == target_hn_node_idx_0; 
              by_pass_read_data_check == 1;
              use_seq_is_non_secure_access == 0;
            }
            if (select_rn_f_node) seq_xact_type != svt_chi_transaction::READNOSNP;
            if (select_rn_i_node || select_rn_d_node) seq_xact_type == svt_chi_transaction::READONCE;
            `ifdef SVT_CHI_ISSUE_B_ENABLE
              if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type != svt_chi_transaction::READNOTSHAREDDIRTY;
              if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A || sys_cfg.readspec_enable == 0) seq_xact_type != svt_chi_transaction::READSPEC;
              if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type != svt_chi_transaction::READONCECLEANINVALID;
              if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type != svt_chi_transaction::READONCEMAKEINVALID;
            `endif
            `ifdef SVT_CHI_ISSUE_E_ENABLE
              if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision <= svt_chi_node_configuration::ISSUE_D) seq_xact_type != svt_chi_transaction::READPREFERUNIQUE;
            `endif
          }
          )
        end: rn_0_thread
        begin: rn_1_thread
          /** Randomly selected first RN-F fires a read transaction with MAKEUNIQUE 
           *  transaction address of randomly selected second HN Node.
           */
          `svt_xvm_do_on_with(chi0_rn_seq[1], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,
          {
            sequence_length == 1;
            seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;    
            seq_txn_id == chi0_rn_seq[0].seq_txn_id;
            if (perform_cache_initialization) {
              hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
              min_addr == addr2;
              max_addr == addr2;
              data_in_cache == temp_data_2;
              by_pass_read_data_check == 0;
              seq_is_non_secure_access == txn2_is_non_secure_access;
              use_seq_is_non_secure_access == 1;
            }
            else {
              hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
              seq_hn_node_idx    == target_hn_node_idx_1; 
              by_pass_read_data_check == 1;
              use_seq_is_non_secure_access == 0;
            }
            if (select_rn_f_node) {
              seq_xact_type != svt_chi_transaction::READNOSNP;
              seq_xact_type != chi0_rn_seq[0].seq_xact_type;
            }
            if (select_rn_i_node || select_rn_d_node) seq_xact_type == svt_chi_transaction::READONCE;
            `ifdef SVT_CHI_ISSUE_B_ENABLE
              if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type != svt_chi_transaction::READNOTSHAREDDIRTY;
              if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision == svt_chi_node_configuration::ISSUE_A || sys_cfg.readspec_enable == 0) seq_xact_type != svt_chi_transaction::READSPEC;
              if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type != svt_chi_transaction::READONCECLEANINVALID;
              if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type != svt_chi_transaction::READONCEMAKEINVALID;
            `endif
            `ifdef SVT_CHI_ISSUE_E_ENABLE
              if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision <= svt_chi_node_configuration::ISSUE_D) seq_xact_type != svt_chi_transaction::READPREFERUNIQUE;
            `endif
            
          }
          )
        end: rn_1_thread
      join

      // TxnID should be the same from both the RNs      
      if (chi0_rn_seq[0].output_xacts[0].txn_id == chi0_rn_seq[1].output_xacts[0].txn_id) begin
        // pass
        `svt_xvm_debug("body", $sformatf("TxnID match: TxnID 'd%0d is the same from both the RNs", chi0_rn_seq[0].output_xacts[0].txn_id));
      end
      else begin
        // fail
        `svt_xvm_error("body", $sformatf("TxnID mismatch: TxnID is expected to be the same from both the RNs, but that is not the case. Transaction %0s from rn[%0d] has TxnID 'd%0d, transaction %0s from rn[%0d] has TxnId 'd%0d ", 
                                         `SVT_CHI_PRINT_PREFIX( chi0_rn_seq[0].output_xacts[0]),initiating_rn_node_idx_0, chi0_rn_seq[0].output_xacts[0].txn_id, `SVT_CHI_PRINT_PREFIX( chi0_rn_seq[1].output_xacts[0]), initiating_rn_node_idx_1, chi0_rn_seq[1].output_xacts[0].txn_id));
      end

      // Targetted HN IDs from both RNs should be different
      begin
        int hn_idx_0, hn_idx_1;
        hn_idx_0 = sys_cfg.get_hn_idx(chi0_rn_seq[0].output_xacts[0].addr);
        hn_idx_1 = sys_cfg.get_hn_idx(chi0_rn_seq[1].output_xacts[0].addr);
        if (hn_idx_0 != hn_idx_1) begin
          // pass
          `svt_xvm_debug("body", $sformatf("Targeted HN Index from both RNs is different as expected.  rn[%0d] to hn_idx[%0d], rn[%0d] to hn_idx[%0d]", initiating_rn_node_idx_0, hn_idx_0, initiating_rn_node_idx_1, hn_idx_1));
        end
        else begin
          // fail
          `svt_xvm_error("body", $sformatf("Targeted HN Index from both RNs is same, which is unexpected.  rn[%0d] %0s transaction to hn_idx[%0d], rn[%0d] %0s transaction to hn_idx[%0d]", 
                                           initiating_rn_node_idx_0, `SVT_CHI_PRINT_PREFIX( chi0_rn_seq[0].output_xacts[0]), hn_idx_0, initiating_rn_node_idx_1, `SVT_CHI_PRINT_PREFIX( chi0_rn_seq[1].output_xacts[0]), hn_idx_1));
        end
      end
      
    end
    /** 
     * To check the Interconnect HN's shall responds with same TxnID to 
     * respective RN's.<br>
     * Check done by System monitor(List of checkers)<br>
     *  #- read_data_integrity_check
     *  #- coherent_and_snoop_data_match_check
     *  .
     */

    `svt_xvm_debug("body", "Exiting...");
  endtask: body

  virtual task post_start();
    super.post_start();
    drop_phase_objection();
  endtask

endclass: svt_chi_system_protocol_flow_ctrl_read_resp_same_txnid_diff_rn_diff_hn_virtual_sequence

function svt_chi_system_protocol_flow_ctrl_read_resp_same_txnid_diff_rn_diff_hn_virtual_sequence::new(string name="svt_chi_system_protocol_flow_ctrl_read_resp_same_txnid_diff_rn_diff_hn_virtual_sequence");
  super.new(name);
endfunction

//====================================================================================
/**
 * @groupname CHI_EXCLUSIVE_ACCESS 
 * Abstract:<br>
 * This sequence generates traffic to test the exclusive access feature support.<br>
 *    #- Program a randomly selected RN1 to send an exclusive load type transaction<br>
 *       with an LPID followed by an exclusive store transaction with the same LPID and address<br> 
 *       set to same value as that of exclusive load transaction.<br>
 *    #- Optionally program to send MAKEUNIQUE transaction targeted to<br> 
 *       randomly selected RN with address of randomly selected first HN Node. 
 *    #- Optionally program a randomly selected RN2 to intervene the exclusive sequence from RN1.<br>
 *    #- Supports both coherent and non coherent transactions.<br>
 *    .
 */

class svt_chi_system_protocol_flow_ctrl_exclusive_access_virtual_sequence extends svt_chi_system_base_virtual_sequence;

  /** Represents the RN-F node for which the sequence will be initiated */ 
  int select_rn_f_node = 0;  
  
  /** Represents the RN-I node for which the sequence will be initiated */ 
  int select_rn_i_node = 0;

  /** Represents the RN-D node for which the sequence will be initiated */ 
  int select_rn_d_node = 0;
  
  /** Status field for capturing config DB get status for select_rn_f_node */
  bit select_rn_f_node_status = 0;
  
  /** Status field for capturing config DB get status for select_rn_i_node */
  bit select_rn_i_node_status = 0;

  /** Status field for capturing config DB get status for select_rn_d_node */
  bit select_rn_d_node_status = 0;
  
  /** Represents the HN-I node to which the transaction will be sent */ 
  rand int unsigned target_hn_i_node_index_0;

  /** 
   * Control on the exclusive sequences generated 
   *  - DIRECTED_EXCLUSIVE_SEQUENCE : Exclusive load followed by exclusive store.
   *  - RANDOM_EXCLUSIVE_SEQUENCE : Two RN generates exclusive sequence, One of the exclusive sequence will be intervened by the other if no exclusive store is dropped due to self store of the initiating RN
   *  - STORE_FROM_RN2_BEFORE_LOAD_FROM_RN1 : Two RN generates exclusive sequence, After the first exclusive sequence is completed the next exclusive sequence is started
   *  - LOAD_FOLLOWED_BY_STORE_WITH_SUSP_COMPACK_FROM_RN1_BEFORE_STORE_FROM_RN2 : Store from RN2 after load is finished from RN1, store from RN1 is held by suspending CompAck, then store from RN2 is initiated
   *  - LOAD_FROM_RN1_FOLLOWED_BY_EXCLUSIVE_SEQ_FROM_RN2_FOLLOWED_BY_STORE_FROM_RN1 : Exclusive load from RN1 followed by exclusive sequence from RN2, followed by exclusive store from RN1
   *  - EXCLUSIVE_LOAD_FOLLOWED_BY_NORMAL_STORE_FROM_DIFF_LPID_FOLLOWED_BY_EXCLUSIVE_STORE : Exclusive load from RN1 followed by normal store sequence from RN2 to the same address, followed by exclusive store from RN1
   *  - EXCLUSIVE_LOAD_FOLLOWED_BY_NORMAL_STORE_FROM_SAME_LPID_FOLLOWED_BY_EXCLUSIVE_STORE : Exclusive load from RN1 followed by normal store sequence from same lpid to the same address, followed by exclusive store from RN1
   *  - MAX_NUM_OF_EXCLUSIVE_ACCESS_SATURATION : Generates max supported exclusive sequence from diff LPID 
   *  - EXCLUSIVE_LOAD_FOLLOWED_BY_NORMAL_STORE_FROM_SAME_RN_BUT_DIFF_LPID_FOLLOWED_BY_EXCLUSIVE_STORE : Exclusive load from an RN followed by normal store from same RN but different LPID to the same address, followed by exclusive store from same RN
   *  - NON_COHERENT_EXCLUSIVE_LOAD_STORE_WITH_MISMATCHED_ATTRIBUTE : Non Exclusive load from an RN followed by non coherent exclusive store from same LPID to the same address with mismatched attributes, followed by exclusive store with matched attributes from same LPID
   *  - EXCLUSIVE_LOAD_FOLLOWED_BY_EXCLUSIVE_SEQ_DIFF_LPID_FOLLOWED_BY_EXCLUSIVE_STORE: Exclusive load from an RN followed by exclusive sequence from different LPID to the same address, followed by exclusive store from same LPID as first exclusive load, all generated from same RN
   *  - NON_COHERENT_EXCLUSIVE_LOAD1_FOLLOWED_BY_EXCLUSIVE_LOAD2_FROM_SAME_LPID_BUT_TO_DIFF_ADDR_FOLLOWED_BY_EXCLUSIVE_STORE1_FOLLOWED_BY_EXCLUSIVE_STORE2: Currently Not supported.
   *  .
   */
  typedef enum {
    DIRECTED_EXCLUSIVE_SEQUENCE = 0,
    RANDOM_EXCLUSIVE_SEQUENCE = 1,
    STORE_FROM_RN2_BEFORE_LOAD_FROM_RN1 = 2,
    LOAD_FOLLOWED_BY_STORE_WITH_SUSP_COMPACK_FROM_RN1_BEFORE_STORE_FROM_RN2 = 3,
    LOAD_FROM_RN1_FOLLOWED_BY_EXCLUSIVE_SEQ_FROM_RN2_FOLLOWED_BY_STORE_FROM_RN1 = 4,
    EXCLUSIVE_LOAD_FOLLOWED_BY_NORMAL_STORE_FROM_DIFF_LPID_FOLLOWED_BY_EXCLUSIVE_STORE = 5,
    EXCLUSIVE_LOAD_FOLLOWED_BY_NORMAL_STORE_FROM_SAME_LPID_FOLLOWED_BY_EXCLUSIVE_STORE = 6,
    MAX_NUM_OF_EXCLUSIVE_ACCESS_SATURATION = 7,
    EXCLUSIVE_LOAD_FOLLOWED_BY_NORMAL_STORE_FROM_SAME_RN_BUT_DIFF_LPID_FOLLOWED_BY_EXCLUSIVE_STORE = 8,
    NON_COHERENT_EXCLUSIVE_LOAD_STORE_WITH_MISMATCHED_ATTRIBUTE = 9,
    CONSECUTIVE_EXCLUSIVE_LOAD_FOLLOWED_BY_CONSECUTIVE_EXCLUSIVE_STORES = 10,
    CONSECUTIVE_EXCLUSIVE_LOAD_FOLLOWED_BY_CONSECUTIVE_ORDERED_EXCLUSIVE_STORES = 11,
    EXCLUSIVE_LOAD_FOLLOWED_BY_EXCLUSIVE_SEQ_DIFF_LPID_FOLLOWED_BY_EXCLUSIVE_STORE = 12,
    EXCLUSIVE_LOAD_FOLLOWED_BY_MULTIPLE_EXCLUSIVE_STORE = 13,
    EXCLUSIVE_STORE_WITHOUT_LOAD = 14,
    EXCLUSIVE_LOAD_FOLLOWED_BY_EXCLUSIVE_SECURE_SEQ_FOLLOWED_BY_EXCLUSIVE_STORE = 15, 
    DIRECTED_EXCLUSIVE_SEQUENCE_WITH_LOAD_STORE_RETRIED = 16,
    NON_COHERENT_EXCLUSIVE_LOAD1_FOLLOWED_BY_EXCLUSIVE_LOAD2_FROM_SAME_LPID_BUT_TO_DIFF_ADDR_FOLLOWED_BY_EXCLUSIVE_STORE1_FOLLOWED_BY_EXCLUSIVE_STORE2 = 17,
    CUSTOM_NON_COHERENT_EXCLUSIVE_LOAD_STORE_WITH_MISMATCHED_ATTRIBUTE = 18,
    CUSTOM_NON_COHERENT_EXCLUSIVE_LOAD_STORE_WITH_MISMATCHED_ATTRIBUTE_WITH_INTERVENING_STORE = 19
  } select_mode_enum;

  select_mode_enum select_mode;

  /**
   * control on transaction type
   *  - COHERENT: 
   *    - LOAD: READSHARED, READCLEAN, READNOTSHAREDDIRTY 
   *    - STORE: CLEANUNIQUE
   *    .
   *  - NON_COHERENT:
   *    - LOAD: READNOSNP 
   *    - STORE: WRITENOSNPPTL, WRITENOSNPFULL 
   *    .
   *  .
   */
  typedef enum {
    COHERENT = 0,
    NON_COHERENT = 1 
  } select_transaction_type_enum;
   
  select_transaction_type_enum select_transaction_type = COHERENT;

  /**
   * Control on to target HN node
   * - HN_F
   * - HN_I
   * . 
   */
   typedef enum {
     HN_F = 0,
     HN_I = 1
   } select_hn_type_enum;
  
  int rand_subsequent_store;

  select_hn_type_enum select_hn_type = HN_F;
  
  bit select_mode_status, select_transaction_type_status, select_hn_type_status;

  /**
   * Control on whether Exclusive load is Retried or Cancelled upon getting RETRY.
   */
  typedef enum {
    LOAD_RETRIED = 0,
    LOAD_RETRIED_AND_CANCELLED = 1
  } p_crd_return_for_load_enum;

  p_crd_return_for_load_enum p_crd_return_for_load = LOAD_RETRIED; 
  
  /** Status field for capturing config DB get status for p_crd_return_for_load */
  bit p_crd_return_for_load_status;

  /**
   * Control on whether Exclusive store is Retried or Cancelled upon getting RETRY.
   */
  typedef enum {
    STORE_RETRIED = 0,
    STORE_RETRIED_AND_CANCELLED = 1
  } p_crd_return_for_store_enum;

  p_crd_return_for_store_enum p_crd_return_for_store = STORE_RETRIED; 
  
  /** Status field for capturing config DB get status for p_crd_return_for_store */
  bit p_crd_return_for_store_status;

  /** Sub Read and write type transaction sequences initiated from this sequence */
  svt_chi_rn_exclusive_access_sequence chi0_rn_seq[int];
  
  /** Sub write type transaction sequences initiated from this sequence, used only to max exclusive access test limit*/
  svt_chi_rn_exclusive_access_sequence chi_rn_seq_write[int];
  
  /** Randomize the target_hn_i_node_index_0 */
  constraint target_hn_i_node_index_0_c {
    if(hn_i_nodes.size()>=1) { 
      target_hn_i_node_index_0 inside {hn_i_nodes};
    }
  }

  /** UVM Object Utility macro */
  `uvm_object_utils(svt_chi_system_protocol_flow_ctrl_exclusive_access_virtual_sequence)

  extern function new(string name="svt_chi_system_protocol_flow_ctrl_exclusive_access_virtual_sequence"); 
  
  /**
   * Method to check whether the expectation of the exclusive sequence is valid
   * When pass_expectation is set to 1 the exclusive sequence is expected to pass.
   * When pass_expectation is set to 0 the exclusive sequence is expected to fail.
   */
  extern task check_exclusive_sequence_validity(select_transaction_type_enum select_transaction_type, svt_chi_transaction xact, bit pass_expectation); 

  virtual task pre_start();
    super.pre_start();
    raise_phase_objection();
    select_rn_f_node_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(),"select_rn_f_node", select_rn_f_node);
    `svt_xvm_debug("body", $sformatf("select_rn_f_node is %0d as a result of %0s", select_rn_f_node, (select_rn_f_node_status ?"config DB":"Default setting")));
    select_rn_i_node_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(),"select_rn_i_node", select_rn_i_node);
    `svt_xvm_debug("body", $sformatf("select_rn_i_node is %0d as a result of %0s", select_rn_i_node, (select_rn_i_node_status ?"config DB":"Default setting")));
    select_rn_d_node_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(),"select_rn_d_node", select_rn_d_node);
    `svt_xvm_debug("body", $sformatf("select_rn_d_node is %0d as a result of %0s", select_rn_d_node, (select_rn_d_node_status ?"config DB":"Default setting")));
    select_mode_status = svt_config_int_db#(select_mode_enum)::get(null, get_full_name(),"select_mode", select_mode);
    `svt_xvm_debug("body", $sformatf("select_mode is %s as a result of %0s", select_mode, (select_mode_status ?"config DB":"Default setting")));
    select_transaction_type_status = svt_config_int_db#(select_transaction_type_enum)::get(null, get_full_name(),"select_transaction_type", select_transaction_type);
    `svt_xvm_debug("body", $sformatf("select_transaction_type is %s as a result of %0s", select_transaction_type, (select_transaction_type_status ?"config DB":"Default setting")));
    select_hn_type_status = svt_config_int_db#(select_hn_type_enum)::get(null, get_full_name(),"select_hn_type", select_hn_type);
    `svt_xvm_debug("body", $sformatf("select_hn_type is %s as a result of %0s", select_hn_type, (select_hn_type_status ?"config DB":"Default setting")));
    p_crd_return_for_load_status = svt_config_int_db#(p_crd_return_for_load_enum)::get(null, get_full_name(),"p_crd_return_for_load", p_crd_return_for_load);
    `svt_xvm_debug("body", $sformatf("p_crd_return_for_load is %0s as a result of %0s", p_crd_return_for_load, (p_crd_return_for_load_status ?"config DB":"Default setting")));
    p_crd_return_for_store_status = svt_config_int_db#(p_crd_return_for_store_enum)::get(null, get_full_name(),"p_crd_return_for_store", p_crd_return_for_store);
    `svt_xvm_debug("body", $sformatf("p_crd_return_for_store is %0s as a result of %0s", p_crd_return_for_store, (p_crd_return_for_store_status ?"config DB":"Default setting")));
  endtask // pre_start
  
  /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting RN-F Nodes = 2 when select_rn_f_node is programmed to 1
   *  #- minimum supporting RN-I Nodes = 2 when select_rn_i_node is programmed to 1
   *  #- minimum supporting RN-D Nodes = 2 when select_rn_d_node is programmed to 1
   */
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    
    /** local variables */
    int num_supporting_rn_f_nodes;
    int num_supporting_rn_i_nodes;
    int num_supporting_rn_d_nodes;
    int num_supporting_sn_nodes;
    string str_is_supported_info_prefix = "";
    string str_is_supported_info = "";

    /** Supporting Request Nodes required */
    int required_num_supporting_rn_f_nodes = 0;
    int required_num_supporting_rn_i_nodes = 0;
    int required_num_supporting_rn_d_nodes = 0;
    int required_num_hn_nodes = 1;
    int num_hn_f_nodes;
    int num_hn_i_nodes;
    int array_idx;
    string str_idx0_info = "";
    string str_idx1_info = "";
    string addl_info = "";
                 
    bit    is_rn_idx_0_participating, is_rn_idx_1_participating;   
    `svt_xvm_debug("is_supported",$sformatf("calling is_supported"));
                 
    /** By default is_supported is 0 */
    is_supported = 0;
    
    /** Check for minimum required HN-F, HN-I nodes */
    num_hn_f_nodes = hn_f_nodes.size();
    num_hn_i_nodes = hn_i_nodes.size();

    /** Check requirment of number of HN nodes needed */
    if ((num_hn_f_nodes + num_hn_i_nodes) < required_num_hn_nodes) begin
      issue_is_supported_failure($sformatf("This sequence requires minimum %0d HN nodes to be present in the system. Number of HN-F %0d and HN-I %0d nodes are present. Program number of HN nodes using svt_chi_system_configuration::num_hn. Program the HN interface type using svt_chi_system_configuration::chi_addr_cfg.hn_interface_type[].", required_num_hn_nodes, num_hn_f_nodes, num_hn_i_nodes));
      return 0;      
    end
    
    /** Either of select_rn_d_node, select_rn_i_node, select_rn_f_node needs to be programmed to 1.
     *  More than one flag cannot be 1 or 0 together.
     */
    if (((select_rn_f_node == 0) && (select_rn_i_node == 0) && (select_rn_d_node == 0)) ||
        ((select_rn_f_node == 1) && (select_rn_i_node == 1) && (select_rn_d_node == 1))) begin
      issue_is_supported_failure($sformatf("select_rn_f_node = %0d. select_rn_i_node = %0d. select_rn_d_node = %0d. Programming one of these two variables to 1 through config DB is required for this sequence to be run.", select_rn_f_node, select_rn_i_node, select_rn_d_node));
      return 0;
    end
    
    /** Coherent traffic should be from RN-F */
    if((select_transaction_type == COHERENT) && (select_rn_f_node == 0))begin
      issue_is_supported_failure($sformatf("For %s transaction type select_rn_f_node should not be %d", select_transaction_type, select_rn_f_node));
      return 0;
    end
   
    // num_supporting_sn_nodes will be 0 for ICN Full-Slave mode.
    num_supporting_sn_nodes = active_participating_sn_nodes.size();

    /** Set minimum required supporting RN-F, RN-D and RN-I nodes depending on  
     *  select_rn_f_node or select_rn_d_node or select_rn_i_node flags respectively.
     */   
    if(select_rn_f_node) begin
      if (num_supporting_sn_nodes)
        required_num_supporting_rn_f_nodes = 2;
      else
        required_num_supporting_rn_f_nodes = 1;
    end
    else if(select_rn_i_node) begin
      required_num_supporting_rn_i_nodes = 2;
    end else if (select_rn_d_node)begin
      required_num_supporting_rn_d_nodes = 2;
    end
    
    /** Check for minimum required RN-F, RN-D and RN-I nodes.
     *  Also check whether the selected RN-F, RN-D and RN-I nodes are part of participating arrays or not.
     */ 
    num_supporting_rn_f_nodes = active_participating_rn_f_nodes.size();
    num_supporting_rn_d_nodes = active_participating_rn_d_nodes.size();
    num_supporting_rn_i_nodes = active_participating_rn_i_nodes.size();

    /** Check the requirements of RN nodes */
    if (num_supporting_rn_f_nodes) begin
      /** Display the contents of Active Participating RN-F Nodes */
      foreach (active_participating_rn_f_nodes[j]) begin
        str_node_info = {str_node_info, $sformatf(" %0d", active_participating_rn_f_nodes[j])};
      end      
      `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_f_nodes are %0s", str_node_info));
    end
    
    /** Display the contents of Active Participating RN-D Nodes */
    str_node_info = "";

    /** Check the requirement of RN-D nodes */ 
    if (num_supporting_rn_d_nodes) begin
      foreach (active_participating_rn_d_nodes[j]) begin
        str_node_info = {str_node_info, $sformatf(" %0d", active_participating_rn_d_nodes[j])};
      end 
      `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_d_nodes are %0s", str_node_info));
    end

    /** Display the contents of Active Participating RN-I Nodes */
    str_node_info = "";

    /** Check the requirement of RN-I nodes */ 
    if (num_supporting_rn_i_nodes) begin
      foreach (active_participating_rn_i_nodes[j]) begin
        str_node_info = {str_node_info, $sformatf(" %0d", active_participating_rn_i_nodes[j])};
      end 
      `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_i_nodes are %0s", str_node_info));
    end

    /** Check the required supporting Request Nodes */
    if (select_rn_f_node == 1) begin
      
      str_is_supported_info_prefix = $sformatf("select_rn_f_node is set to 1. Number of Supporting RN-F Node(s)  - Minimum Required : %0d Current : %0d", required_num_supporting_rn_f_nodes,num_supporting_rn_f_nodes);

      if ((initiating_rn_node_index_0_status==0)&&(valid_initiating_rn_f_node_index_0==0)) begin
          str_idx0_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN-Fs that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)";
      end
      else begin
        is_rn_idx_0_participating = is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_node_idx_0, array_idx);
        if (!is_rn_idx_0_participating) begin
          str_idx0_info = $sformatf("initiating_rn_node_idx_0 %0d is not valid for this sequence. The RN-F corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)", initiating_rn_node_idx_0, initiating_rn_node_idx_0);
        end
      end

      // Below conditions should not be checked for ICN Full-Slave mode.
      if (num_supporting_sn_nodes) begin
        if ((initiating_rn_node_index_1_status==0)&&(valid_initiating_rn_f_node_index_1==0)) begin
          str_idx1_info = "Valid initiating_rn_node_idx_1 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN-Fs that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)";
        end 
        else begin
          is_rn_idx_1_participating = is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_node_idx_1, array_idx);
          if (!is_rn_idx_1_participating) begin
            str_idx1_info = $sformatf("initiating_rn_node_idx_1 %0d is not valid for this sequence. The RN-F corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)", initiating_rn_node_idx_1, initiating_rn_node_idx_1);
          end
        end    
      end
    end
    else if (select_rn_i_node == 1) begin
      
      str_is_supported_info_prefix = $sformatf("select_rn_i_node is set to 1. Number of Supporting RN-I Node(s)  - Minimum Required : %0d Current : %0d", required_num_supporting_rn_i_nodes,num_supporting_rn_i_nodes);

      if ((initiating_rn_node_index_0_status==0)&&(valid_initiating_rn_i_node_index_0==0)) begin
        str_idx0_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN-Is that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_I)";
      end
      else begin
        is_rn_idx_0_participating = is_value_found_in_int_assoc_array(active_participating_rn_i_nodes, initiating_rn_node_idx_0, array_idx);
        if (!is_rn_idx_0_participating) begin
         
          str_idx0_info = $sformatf("initiating_rn_node_idx_0 %0d is not valid for this sequence. The RN-I corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_I)", initiating_rn_node_idx_0, initiating_rn_node_idx_0);
        end  
      end

      if ((initiating_rn_node_index_1_status==0)&&(valid_initiating_rn_i_node_index_1==0)) begin
        str_idx1_info = "Valid initiating_rn_node_idx_1 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN-Is that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_I)";
      end
      else begin
        is_rn_idx_1_participating = is_value_found_in_int_assoc_array(active_participating_rn_i_nodes, initiating_rn_node_idx_1, array_idx);
        if (!is_rn_idx_1_participating) begin
          str_idx1_info = $sformatf("initiating_rn_node_idx_1 %0d is not valid for this sequence. The RN-I corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_I)", initiating_rn_node_idx_1, initiating_rn_node_idx_1);
        end 
      end
    end
    else if (select_rn_d_node == 1) begin
      
      str_is_supported_info_prefix = $sformatf("select_rn_d_node is set to 1. Number of Supporting RN-D Node(s)  - Minimum Required : %0d Current : %0d", required_num_supporting_rn_d_nodes,num_supporting_rn_d_nodes);

      if ((initiating_rn_node_index_0_status==0)&&(valid_initiating_rn_d_node_index_0==0)) begin
        str_idx0_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN-Ds that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_D)";
      end
      else begin
        is_rn_idx_0_participating = is_value_found_in_int_assoc_array(active_participating_rn_d_nodes, initiating_rn_node_idx_0, array_idx);
        if (!is_rn_idx_0_participating) begin
         
          str_idx0_info = $sformatf("initiating_rn_node_idx_0 %0d is not valid for this sequence. The RN-D corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_D)", initiating_rn_node_idx_0, initiating_rn_node_idx_0);
        end  
      end

      if ((initiating_rn_node_index_1_status==0)&&(valid_initiating_rn_d_node_index_1==0)) begin
        str_idx1_info = "Valid initiating_rn_node_idx_1 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN-Ds that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_D)";
      end
      else begin
        is_rn_idx_1_participating = is_value_found_in_int_assoc_array(active_participating_rn_d_nodes, initiating_rn_node_idx_1, array_idx);
        if (!is_rn_idx_1_participating) begin
          str_idx1_info = $sformatf("initiating_rn_node_idx_1 %0d is not valid for this sequence. The RN-D corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_D)", initiating_rn_node_idx_1, initiating_rn_node_idx_1);
        end 
      end
    end

    if (num_supporting_sn_nodes) begin
      if (is_rn_idx_0_participating && is_rn_idx_1_participating) begin
        is_supported = 1;
      end
    end
    else begin
      if (is_rn_idx_0_participating) begin
        is_supported = 1;
      end
    end

    // select_mode = EXCLUSIVE_LOAD_FOLLOWED_BY_EXCLUSIVE_SECURE_SEQ_FOLLOWED_BY_EXCLUSIVE_STORE
    // requires enabling secure access for the active participating nodes.
    if (select_mode == EXCLUSIVE_LOAD_FOLLOWED_BY_EXCLUSIVE_SECURE_SEQ_FOLLOWED_BY_EXCLUSIVE_STORE) begin
      foreach (active_participating_rn_nodes[_rn_nodes]) begin
        if (sys_cfg.rn_cfg[active_participating_rn_nodes[_rn_nodes]].enable_secure_nonsecure_address_space == 0) begin
          is_supported = 0;
          addl_info = {addl_info, $sformatf("select_mode = EXCLUSIVE_LOAD_FOLLOWED_BY_EXCLUSIVE_SECURE_SEQ_FOLLOWED_BY_EXCLUSIVE_STORE: sys_cfg.rn_cfg[%0d].enable_secure_nonsecure_address_space = 0. However all the participating nodes should have this attribute set to 1.)", active_participating_rn_nodes[_rn_nodes])};
        end
      end
      foreach (active_participating_sn_nodes[_sn_nodes]) begin
        if (sys_cfg.sn_cfg[active_participating_sn_nodes[_sn_nodes]].enable_secure_nonsecure_address_space == 0) begin
          is_supported = 0;
          addl_info = {addl_info, $sformatf("select_mode = EXCLUSIVE_LOAD_FOLLOWED_BY_EXCLUSIVE_SECURE_SEQ_FOLLOWED_BY_EXCLUSIVE_STORE: sys_cfg.sn_cfg[%0d].enable_secure_nonsecure_address_space = 0. However all the participating nodes should have this attribute set to 1.", active_participating_sn_nodes[_sn_nodes])};
        end
      end
    end
                 
    if (!is_supported) begin
      str_is_supported_info = $sformatf("%0s%0s%0s",str_idx0_info, str_idx1_info, addl_info);
      issue_is_supported_failure($sformatf("This sequence cannot be run based on the current system configuration.\n\
                                            %0s\n\
                                            %0s \n\
                                            Modify configurations through \n\
                                            svt_chi_system_configuration::num_rn,\n\
                                            svt_chi_node_configuration::is_active,\n\
                                            svt_chi_system_configuration::participating_rn_nodes[]\n\
                                            ", str_is_supported_info_prefix, str_is_supported_info));
    end
  endfunction : is_supported
  
  virtual task body();
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0]                    addr1;
    svt_chi_transaction::snp_attr_snp_domain_type_enum    vir_seq_snp_attr_snp_domain_type;
    bit                                                   vir_seq_mem_attr_allocate_hint;
    bit                                                   vir_seq_is_non_secure_access;
    int                                                   array_idx;
    bit [`SVT_CHI_MAX_DATA_WIDTH -1:0]                    temp_data_1;

    bit is_valid, is_unique, is_clean;
    svt_axi_cache my_cache;
    bit config_db_status;
    bit cache_status;
    `SVT_XVM(component)           my_component;
    
    bit perform_cache_initialization;
    string str_node_types = "";
    int unsigned sel_initiating_rn_node_index_0,sel_initiating_rn_node_index_1;
    bit comp_received = 0;
    bit xact_dropped = 0;
    bit exok_expected = 0;
    bit rn2_transaction_started = 0;
    svt_chi_flit matched_flits[$], matched_flits_with_opcode[$];
    real comp_flit_end_time;
    /** Sub sequences initiated from this sequence */
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq[int];
    svt_chi_rn_copyback_type_transaction_directed_sequence copyback_seq;

    `svt_xvm_debug("body", "Entering ...");
    super.body();

    if (select_rn_f_node) begin
      str_node_types = "Initiating nodes are of RN-F type.";
      // If the initiating_rn_f_node_index_2 is part of active_participating_rn_f_nodes array, and
      // it is not equal to initiating_rn_f_node_index_0, initiating_rn_f_node_index_1; then we can
      // perform cache initialization from the RN[cache_line_init_rn_f_node_index].
      if ((is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_f_node_index_2, array_idx)) &&
          (initiating_rn_f_node_index_2 != initiating_rn_f_node_index_0) &&
          (initiating_rn_f_node_index_2 != initiating_rn_f_node_index_1)) begin
        perform_cache_initialization = 1;
        cache_line_init_rn_f_node_index = initiating_rn_f_node_index_2;          
      end
      else if((is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_f_node_index_1, array_idx))) begin
        perform_cache_initialization = 1;
        cache_line_init_rn_f_node_index = initiating_rn_f_node_index_1;          
      end
      sel_initiating_rn_node_index_0 = initiating_rn_f_node_index_0;
      sel_initiating_rn_node_index_1 = initiating_rn_f_node_index_1;
    end
    else if (select_rn_i_node) begin
      str_node_types = "Iniating nodes are of RN-I type.";
      // If the initiating_rn_f_node_index_0 is part of active_participating_rn_f_nodes array
      // then we can perform cache initialization from the RN[cache_line_init_rn_f_node_index].
      if (is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_f_node_index_0, array_idx)) begin
        perform_cache_initialization = 1;
        cache_line_init_rn_f_node_index = initiating_rn_f_node_index_0;          
      end
      sel_initiating_rn_node_index_0 = initiating_rn_i_node_index_0;
      sel_initiating_rn_node_index_1 = initiating_rn_i_node_index_1;
    end
    else if (select_rn_d_node) begin
      str_node_types = "Initiating nodes are of RN-D type.";
      // If the initiating_rn_f_node_index_0 is part of active_participating_rn_f_nodes array
      // then we can perform cache initialization from the RN[cache_line_init_rn_f_node_index].
      if (is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_f_node_index_0, array_idx)) begin
        perform_cache_initialization = 1;
        cache_line_init_rn_f_node_index = initiating_rn_f_node_index_0;          
      end
      sel_initiating_rn_node_index_0 = initiating_rn_d_node_index_0;
      sel_initiating_rn_node_index_1 = initiating_rn_d_node_index_1;
    end

    `svt_xvm_debug("body", $sformatf("%0s perform_cache_initialization = %0b. cache_line_init_rn_f_node_index = %0d. sel_initiating_rn_node_index_0 = %0d. sel_initiating_rn_node_index_1 = %0d.", str_node_types, perform_cache_initialization, cache_line_init_rn_f_node_index, sel_initiating_rn_node_index_0, sel_initiating_rn_node_index_1));
    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :sel_initiating_rn_node_index_0;
    initiating_rn_node_idx_1 = initiating_rn_node_index_1_status ? initiating_rn_node_index_1_from_config_db :sel_initiating_rn_node_index_1;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :(select_hn_type == HN_F) ? target_hn_f_node_index_0 : target_hn_i_node_index_0;

    `svt_xvm_debug("body", $sformatf("initiating_rn_node_idx_0 is %0d as a result of %0s.", initiating_rn_node_idx_0, initiating_rn_node_index_0_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("initiating_rn_node_idx_1 is %0d as a result of %0s.", initiating_rn_node_idx_1, initiating_rn_node_index_1_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("target_hn_node_idx_0 is %0d as a result of %0s.", target_hn_node_idx_0, target_hn_node_index_0_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("perform_cache_initialization is %0b, cache_line_init_rn_f_node_index is %0d, initiating_rn_node_idx_0 is %0d, initiating_rn_node_idx_1 is %0d", perform_cache_initialization, cache_line_init_rn_f_node_index, initiating_rn_node_idx_0, initiating_rn_node_idx_1));    

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end 

    /**
     * If the cache_line_init_rn_f_node_index is same as any of the RN node indices 
     * which are passed through config i.e initiating_rn_node_idx_0,initiating_rn_node_idx_1,
     * then re-assign the cache_line_init_rn_f_node_index with RN node index ,which is active,
     * participating and not equal to initiating_rn_node_idx_0, initiating_rn_node_idx_1.
     */
    if(initiating_rn_node_index_0_status||initiating_rn_node_index_1_status)begin  
      if((cache_line_init_rn_f_node_index == initiating_rn_node_idx_0)||(cache_line_init_rn_f_node_index == initiating_rn_node_idx_1))begin  
        int active_participating_q [$];
        `svt_chi_xxm_debug("body",$sformatf("cache_line_init_rn_f_node_index= %0d is same as initiating_rn_node_idx_0=%0d or initiating_rn_node_idx_1=%0d and active_participating_rn_f_nodes.size()= %0d",cache_line_init_rn_f_node_index,initiating_rn_node_idx_0,initiating_rn_node_idx_1,active_participating_rn_f_nodes.size()));
        if(active_participating_rn_f_nodes.size()>2)begin
          active_participating_q = active_participating_rn_f_nodes.find with ((item != initiating_rn_node_idx_0) && (item != initiating_rn_node_idx_1));
          cache_line_init_rn_f_node_index = active_participating_q.pop_back();
          `svt_chi_xxm_debug("body", $sformatf("active_participating_q.size() is %0d and Selected different cache_line_initrn_f_node_index=%0d", active_participating_q.size(),cache_line_init_rn_f_node_index));
          active_participating_q.delete();
        end else begin
          perform_cache_initialization=0;
          `svt_chi_xxm_debug("body",$sformatf("BYPASSING Cache Initialization as selected cache_line_init_rn_f_node_index= %0d is same as initiating_rn_node_index_0_from_config_db=%0d or initiating_rn_node_index_1_from_config_db=%0d and active_participating_rn_f_nodes.size()= %0d",cache_line_init_rn_f_node_index,initiating_rn_node_index_0_from_config_db,initiating_rn_node_index_1_from_config_db,active_participating_rn_f_nodes.size()));
        end
      end  
    end 
    
    my_component = p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr.get_parent();
    config_db_status = svt_config_object_db#(svt_axi_cache)::get(my_component,"",{my_component.get_name(),"_cache"}, my_cache);

    /**
     * If the cache_line_init_rn_f_node_index is part of active_participating_rn_f_nodes array, and
     * it is not equal to initiating_rn_node_idx_0, initiating_rn_node_idx_1; then we can
     * perform cache initialization from the RN[cache_line_init_rn_f_node_index].
     */
    if ((is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, cache_line_init_rn_f_node_index, array_idx)) &&
        (cache_line_init_rn_f_node_index != initiating_rn_node_idx_0) &&
        (cache_line_init_rn_f_node_index != initiating_rn_node_idx_1)) begin
      perform_cache_initialization = 1;
    end
    
    if (select_transaction_type == NON_COHERENT) begin
      perform_cache_initialization = 0;
    end

    `svt_chi_xxm_debug("body",$sformatf("Selected RN indices are cache_line_init_rn_f_node_index= %0d initiating_rn_node_idx_0=%0d initiating_rn_node_idx_1=%0d and perform_cache_initialization= %0d",cache_line_init_rn_f_node_index,initiating_rn_node_idx_0,initiating_rn_node_idx_1,perform_cache_initialization));
    for(int i = 0; i < sequence_length; i++) begin
      if(perform_cache_initialization) begin
        /** 
         * Write data into Cache of Randomly selected first RN with address of randomly
         * selected first HN Node.
         */
        `svt_xvm_do_on_with(makeunique_seq[0], p_sequencer.rn_virt_seqr[cache_line_init_rn_f_node_index].rn_xact_seqr,
                                              {sequence_length    == 1;
                                               hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
                                               seq_hn_node_idx    == target_hn_node_idx_0;
                                               use_seq_is_non_secure_access == 0;
                                              })
         /** Wait for MakeUnique transactions to finish */ 
         makeunique_seq[0].write_tran.wait_end();
         addr1 = makeunique_seq[0].output_xacts[0].addr;
         vir_seq_snp_attr_snp_domain_type = makeunique_seq[0].output_xacts[0].snp_attr_snp_domain_type;
         vir_seq_mem_attr_allocate_hint = makeunique_seq[0].output_xacts[0].mem_attr_allocate_hint;
         vir_seq_is_non_secure_access = makeunique_seq[0].output_xacts[0].is_non_secure_access;
         temp_data_1 = makeunique_seq[0].output_xacts[0].data;
        
        `svt_xvm_debug("exclusive_sequence_cache_init", $sformatf("addr: %0xh, txn_id: %0d",addr1, makeunique_seq[0].output_xacts[0].txn_id));

        `svt_xvm_do_on_with(copyback_seq, p_sequencer.rn_virt_seqr[cache_line_init_rn_f_node_index].rn_xact_seqr,
        {
          sequence_length == 1;
          data_in_cache == temp_data_1;
          seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
          hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
          min_addr == addr1;
          max_addr == addr1;
          seq_xact_type == svt_chi_transaction::WRITEBACKFULL;
          seq_mem_attr_allocate_hint == vir_seq_mem_attr_allocate_hint;
          seq_snp_attr_snp_domain_type == vir_seq_snp_attr_snp_domain_type;
          seq_is_non_secure_access == vir_seq_is_non_secure_access;
          use_seq_is_non_secure_access == 1;
        }
        )
        /** Waiting for copyback transaction to complete */ 
        copyback_seq.copyback_tran.wait_end();
      end
      
      case (select_mode)
        DIRECTED_EXCLUSIVE_SEQUENCE : begin
          `svt_xvm_do_on_with(chi0_rn_seq[0], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
              {
                sequence_length == 1;
                seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
                if (perform_cache_initialization) {
                  hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                  min_addr == addr1;
                  max_addr == addr1;
                  seq_snp_attr_snp_domain_type == vir_seq_snp_attr_snp_domain_type;
                  seq_mem_attr_allocate_hint == vir_seq_mem_attr_allocate_hint;
                  seq_is_non_secure_access == vir_seq_is_non_secure_access;
                  use_seq_is_non_secure_access == 1;
                  data_in_cache == temp_data_1;
                  by_pass_read_data_check == 0;
                }
                else {
                  hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
                  seq_hn_node_idx == target_hn_node_idx_0;
                  by_pass_read_data_check == 1;
                  use_seq_is_non_secure_access == 0;
                }
                if (select_rn_f_node) {
                  if (select_transaction_type == COHERENT) {
                    `ifdef SVT_CHI_ISSUE_B_ENABLE
                    if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type_read != svt_chi_transaction::READNOTSHAREDDIRTY;
                    `endif
                    `ifdef SVT_CHI_ISSUE_E_ENABLE
                    if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision <= svt_chi_node_configuration::ISSUE_D) seq_xact_type_read != svt_chi_transaction::READPREFERUNIQUE;
                    `endif
                    seq_xact_type_read != svt_chi_transaction::READNOSNP;
                    !(seq_xact_type_write inside {svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITENOSNPFULL});
                    `ifdef SVT_CHI_ISSUE_E_ENABLE
                    if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision <= svt_chi_node_configuration::ISSUE_D) seq_xact_type_write != svt_chi_transaction::MAKEREADUNIQUE;
                    `endif
                  }
                  else if (select_transaction_type == NON_COHERENT){
                    seq_xact_type_read == svt_chi_transaction::READNOSNP;
                    seq_xact_type_write inside {svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITENOSNPFULL};
                  }
                }
                if (select_rn_i_node || select_rn_d_node) {
                  seq_xact_type_read == svt_chi_transaction::READNOSNP;  
                  seq_xact_type_write inside {svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITENOSNPFULL};
                }
                seq_xact_type_excl == svt_chi_rn_exclusive_access_sequence::RD_WR;
              }
          )
          // LPID should be the same for Load and store initiated from RN1.      
          if (chi0_rn_seq[0].output_xacts[0].lpid == chi0_rn_seq[0].output_xacts[1].lpid) begin
            // pass
            `svt_xvm_debug("body", $sformatf("LPID match: LPID 'd%0d is same for Load and store initiated from RN1", chi0_rn_seq[0].output_xacts[0].lpid));
          end
          else begin
            // fail
            `svt_xvm_error("body", $sformatf("LPID mismatch: LPID is expected to be the same for Load and store initiated from RN1, but that is not the case. Transaction %0s from rn[%0d] has LPID 'd%0d, transaction %0s from rn[%0d] has LPId 'd%0d ", `SVT_CHI_PRINT_PREFIX(chi0_rn_seq[0].output_xacts[0]), initiating_rn_node_idx_0, chi0_rn_seq[0].output_xacts[0].lpid, `SVT_CHI_PRINT_PREFIX(chi0_rn_seq[0].output_xacts[1]), initiating_rn_node_idx_0, chi0_rn_seq[0].output_xacts[1].lpid));
          end
          check_exclusive_sequence_validity(select_transaction_type, chi0_rn_seq[0].output_xacts[1], 1);
        end
        RANDOM_EXCLUSIVE_SEQUENCE : begin
          fork
            begin: rn_0_thread
              `svt_xvm_do_on_with(chi0_rn_seq[0], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
              {
                sequence_length == 1;
                seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
                if (perform_cache_initialization) {
                  hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                  min_addr == addr1;
                  max_addr == addr1;
                  seq_snp_attr_snp_domain_type == vir_seq_snp_attr_snp_domain_type;
                  seq_mem_attr_allocate_hint == vir_seq_mem_attr_allocate_hint;
                  seq_is_non_secure_access == vir_seq_is_non_secure_access;
                  use_seq_is_non_secure_access == 1;
                  data_in_cache == temp_data_1;
                  by_pass_read_data_check == 0;
                }
                else {
                  hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
                  seq_hn_node_idx == target_hn_node_idx_0;
                  by_pass_read_data_check == 1;
                  use_seq_is_non_secure_access == 0;
                }
                if (select_rn_f_node) {
                  if (select_transaction_type == COHERENT) {
                    `ifdef SVT_CHI_ISSUE_B_ENABLE
                    if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type_read != svt_chi_transaction::READNOTSHAREDDIRTY;
                    `endif
                    `ifdef SVT_CHI_ISSUE_E_ENABLE
                    if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision <= svt_chi_node_configuration::ISSUE_D) seq_xact_type_read != svt_chi_transaction::READPREFERUNIQUE;
                    `endif
                    seq_xact_type_read != svt_chi_transaction::READNOSNP;
                    seq_xact_type_write == svt_chi_transaction::CLEANUNIQUE;
                  }
                  else if (select_transaction_type == NON_COHERENT){
                    seq_xact_type_read == svt_chi_transaction::READNOSNP;
                    seq_xact_type_write inside {svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITENOSNPFULL};
                  }
                }
                if (select_rn_i_node || select_rn_d_node) {
                  seq_xact_type_read == svt_chi_transaction::READNOSNP;  
                  seq_xact_type_write inside {svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITENOSNPFULL};
                }
                seq_xact_type_excl == svt_chi_rn_exclusive_access_sequence::RD_WR;
              }
              )
            end: rn_0_thread
            begin: rn_1_thread
              wait(chi0_rn_seq[0] != null);
              wait(chi0_rn_seq[0].output_xacts.size() > 0);
              `svt_xvm_do_on_with(chi0_rn_seq[1], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,
              {
                sequence_length == 1;
                seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;    
                if (perform_cache_initialization) {
                  hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                  min_addr == addr1;
                  max_addr == addr1;
                  seq_snp_attr_snp_domain_type == vir_seq_snp_attr_snp_domain_type;
                  seq_mem_attr_allocate_hint == vir_seq_mem_attr_allocate_hint;
                  seq_is_non_secure_access == vir_seq_is_non_secure_access;
                  use_seq_is_non_secure_access == 1;
                  data_in_cache == temp_data_1;
                  by_pass_read_data_check == 0;
                }
                else {
                  hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                  min_addr == chi0_rn_seq[0].output_xacts[0].addr;
                  max_addr == chi0_rn_seq[0].output_xacts[0].addr;
                  if(select_transaction_type == COHERENT) {
                    seq_snp_attr_snp_domain_type         == chi0_rn_seq[0].output_xacts[0].snp_attr_snp_domain_type;
                    seq_mem_attr_allocate_hint           == chi0_rn_seq[0].output_xacts[0].mem_attr_allocate_hint;  
                    seq_is_non_secure_access             == chi0_rn_seq[0].output_xacts[0].is_non_secure_access;
                    use_seq_is_non_secure_access == 1;
                  }
                  else if (select_transaction_type == NON_COHERENT) {
                    seq_mem_attr_is_early_wr_ack_allowed == chi0_rn_seq[0].output_xacts[0].mem_attr_is_early_wr_ack_allowed;  
                    seq_mem_attr_mem_type                == chi0_rn_seq[0].output_xacts[0].mem_attr_mem_type;  
                    seq_mem_attr_is_cacheable            == chi0_rn_seq[0].output_xacts[0].mem_attr_is_cacheable;  
                    seq_mem_attr_allocate_hint           == chi0_rn_seq[0].output_xacts[0].mem_attr_allocate_hint;  
                    seq_snp_attr_is_snoopable            == chi0_rn_seq[0].output_xacts[0].snp_attr_is_snoopable;  
                    seq_snp_attr_snp_domain_type         == chi0_rn_seq[0].output_xacts[0].snp_attr_snp_domain_type;
                    seq_is_non_secure_access             == chi0_rn_seq[0].output_xacts[0].is_non_secure_access;
                    use_seq_is_non_secure_access == 1;
                  }
                  by_pass_read_data_check == 1;
                }
                if (select_rn_f_node) {
                  if (select_transaction_type == COHERENT) {
                    `ifdef SVT_CHI_ISSUE_B_ENABLE
                    if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type_read != svt_chi_transaction::READNOTSHAREDDIRTY;
                    `endif
                    `ifdef SVT_CHI_ISSUE_E_ENABLE
                    if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision <= svt_chi_node_configuration::ISSUE_D) seq_xact_type_read != svt_chi_transaction::READPREFERUNIQUE;
                    `endif
                    seq_xact_type_read != svt_chi_transaction::READNOSNP;
                    seq_xact_type_write == svt_chi_transaction::CLEANUNIQUE;
                  }
                  else if (select_transaction_type == NON_COHERENT) {
                    seq_xact_type_read == svt_chi_transaction::READNOSNP;
                    seq_xact_type_write inside {svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITENOSNPFULL};
                  }
                }
                if (select_rn_i_node || select_rn_d_node) {
                  seq_xact_type_write inside {svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITENOSNPFULL};
                }
                seq_xact_type_excl == svt_chi_rn_exclusive_access_sequence::RD_WR;
              }
              )
            end: rn_1_thread
          join
          // LPID should be the same for Load and store initiated from RN1.      
          if (chi0_rn_seq[0].output_xacts[0].lpid == chi0_rn_seq[0].output_xacts[1].lpid) begin
            // pass
            `svt_xvm_debug("body", $sformatf("LPID match: LPID 'd%0d is same for Load and store initiated from RN1", chi0_rn_seq[0].output_xacts[0].lpid));
          end
          else begin
            // fail
            `svt_xvm_error("body", $sformatf("LPID mismatch: LPID is expected to be the same for Load and store initiated from RN1, but that is not the case. Transaction %0s from rn[%0d] has LPID 'd%0d, transaction %0s from rn[%0d] has LPId 'd%0d ", `SVT_CHI_PRINT_PREFIX(chi0_rn_seq[0].output_xacts[0]), initiating_rn_node_idx_0, chi0_rn_seq[0].output_xacts[0].lpid, `SVT_CHI_PRINT_PREFIX(chi0_rn_seq[0].output_xacts[1]), initiating_rn_node_idx_0, chi0_rn_seq[0].output_xacts[1].lpid));
          end
          // LPID should be the same for Load and store initiated from RN2.      
          if (chi0_rn_seq[1].output_xacts[0].lpid == chi0_rn_seq[1].output_xacts[1].lpid) begin
            // pass
            `svt_xvm_debug("body", $sformatf("LPID match: LPID 'd%0d is same for Load and store initiated from RN2", chi0_rn_seq[1].output_xacts[0].lpid));
          end
          else begin
            // fail
            `svt_xvm_error("body", $sformatf("LPID mismatch: LPID is expected to be the same for Load and store initiated from RN2, but that is not the case. Transaction %0s from rn[%0d] has LPID 'd%0d, transaction %0s from rn[%0d] has LPId 'd%0d ", `SVT_CHI_PRINT_PREFIX(chi0_rn_seq[1].output_xacts[0]), initiating_rn_node_idx_1, chi0_rn_seq[1].output_xacts[0].lpid, `SVT_CHI_PRINT_PREFIX(chi0_rn_seq[1].output_xacts[1]), initiating_rn_node_idx_1, chi0_rn_seq[1].output_xacts[1].lpid));
          end
          chi0_rn_seq[0].output_xacts[1].wait_end();
          chi0_rn_seq[1].output_xacts[1].wait_end();
          //One of the exclusive sequence should fail if no exclusive store is
          //dropped due to self store of the initiating RN
          if(!(chi0_rn_seq[0].output_xacts[1].is_xact_dropped || chi0_rn_seq[1].output_xacts[1].is_xact_dropped)) begin
            if((chi0_rn_seq[0].output_xacts[1].response_resp_err_status == svt_chi_transaction::EXCLUSIVE_OKAY && chi0_rn_seq[1].output_xacts[1].response_resp_err_status == svt_chi_transaction::EXCLUSIVE_OKAY) 
              || (chi0_rn_seq[0].output_xacts[1].response_resp_err_status == svt_chi_transaction::NORMAL_OKAY && chi0_rn_seq[1].output_xacts[1].response_resp_err_status == svt_chi_transaction::NORMAL_OKAY))begin
              // Fail
              `svt_xvm_error("body", $sformatf("One of the exclusive sequence is expected to fail however that is not the case: RespErr is %s for transaction %0s and RespErr is %s for transaction %0s", chi0_rn_seq[0].output_xacts[1].response_resp_err_status, `SVT_CHI_PRINT_PREFIX(chi0_rn_seq[0].output_xacts[1]), chi0_rn_seq[1].output_xacts[1].response_resp_err_status, `SVT_CHI_PRINT_PREFIX(chi0_rn_seq[1].output_xacts[1])));
            end
            else begin
              // pass
              `svt_xvm_debug("body", $sformatf("One of the exclusive sequence failed as expected: RespErr is %s for transaction %0s and RespErr is %s for transaction %0s", chi0_rn_seq[0].output_xacts[1].response_resp_err_status, `SVT_CHI_PRINT_PREFIX(chi0_rn_seq[0].output_xacts[1]), chi0_rn_seq[1].output_xacts[1].response_resp_err_status, `SVT_CHI_PRINT_PREFIX(chi0_rn_seq[1].output_xacts[1])));
            end
          end
        end
        STORE_FROM_RN2_BEFORE_LOAD_FROM_RN1 : begin
          `svt_xvm_do_on_with(chi0_rn_seq[0], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,
              {
                sequence_length == 1;
                seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;    
                if (perform_cache_initialization) {
                  hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                  min_addr == addr1;
                  max_addr == addr1;
                  seq_snp_attr_snp_domain_type == vir_seq_snp_attr_snp_domain_type;
                  seq_mem_attr_allocate_hint == vir_seq_mem_attr_allocate_hint;
                  seq_is_non_secure_access == vir_seq_is_non_secure_access;
                  use_seq_is_non_secure_access == 1;
                  data_in_cache == temp_data_1;
                  by_pass_read_data_check == 0;
                }
                else {
                  hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
                  seq_hn_node_idx == target_hn_node_idx_0;
                  by_pass_read_data_check == 1;
                  use_seq_is_non_secure_access == 0;
                }
                if (select_rn_f_node) {
                  if (select_transaction_type == COHERENT) {
                    `ifdef SVT_CHI_ISSUE_B_ENABLE
                    if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type_read != svt_chi_transaction::READNOTSHAREDDIRTY;
                    `endif
                    `ifdef SVT_CHI_ISSUE_E_ENABLE
                    if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision <= svt_chi_node_configuration::ISSUE_D) seq_xact_type_read != svt_chi_transaction::READPREFERUNIQUE;
                    `endif
                    seq_xact_type_read != svt_chi_transaction::READNOSNP;
                    !(seq_xact_type_write inside {svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITENOSNPFULL});
                    `ifdef SVT_CHI_ISSUE_E_ENABLE
                    if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision <= svt_chi_node_configuration::ISSUE_D) seq_xact_type_write != svt_chi_transaction::MAKEREADUNIQUE;
                    `endif
                  }
                  else if (select_transaction_type == NON_COHERENT) {
                    seq_xact_type_read == svt_chi_transaction::READNOSNP;
                    seq_xact_type_write inside {svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITENOSNPFULL};
                  }
                }
                if (select_rn_i_node || select_rn_d_node) {
                  seq_xact_type_read == svt_chi_transaction::READNOSNP;  
                  seq_xact_type_write inside {svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITENOSNPFULL};
                }
                seq_xact_type_excl == svt_chi_rn_exclusive_access_sequence::RD_WR;
              }
          )
          chi0_rn_seq[0].output_xacts[1].wait_end();

          `svt_xvm_do_on_with(chi0_rn_seq[1], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
              {
                sequence_length == 1;
                seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
                if (perform_cache_initialization) {
                  hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                  min_addr == addr1;
                  max_addr == addr1;
                  seq_snp_attr_snp_domain_type == vir_seq_snp_attr_snp_domain_type;
                  seq_mem_attr_allocate_hint == vir_seq_mem_attr_allocate_hint;
                  seq_is_non_secure_access == vir_seq_is_non_secure_access;
                  use_seq_is_non_secure_access == 1;
                  data_in_cache == temp_data_1;
                  by_pass_read_data_check == chi0_rn_seq[0].output_xacts[1].allocate_in_cache;
                }
                else {
                  hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                  min_addr == chi0_rn_seq[0].output_xacts[0].addr;
                  max_addr == chi0_rn_seq[0].output_xacts[0].addr;
                  if (select_transaction_type == COHERENT) {
                    seq_snp_attr_snp_domain_type         == chi0_rn_seq[0].output_xacts[0].snp_attr_snp_domain_type;
                    seq_mem_attr_allocate_hint           == chi0_rn_seq[0].output_xacts[0].mem_attr_allocate_hint;  
                    seq_is_non_secure_access             == chi0_rn_seq[0].output_xacts[0].is_non_secure_access;
                    use_seq_is_non_secure_access == 1;
                  }
                  else if (select_transaction_type == NON_COHERENT){
                    seq_mem_attr_is_early_wr_ack_allowed == chi0_rn_seq[0].output_xacts[0].mem_attr_is_early_wr_ack_allowed;  
                    seq_mem_attr_mem_type                == chi0_rn_seq[0].output_xacts[0].mem_attr_mem_type;  
                    seq_mem_attr_is_cacheable            == chi0_rn_seq[0].output_xacts[0].mem_attr_is_cacheable;  
                    seq_mem_attr_allocate_hint           == chi0_rn_seq[0].output_xacts[0].mem_attr_allocate_hint;  
                    seq_snp_attr_is_snoopable            == chi0_rn_seq[0].output_xacts[0].snp_attr_is_snoopable;  
                    seq_snp_attr_snp_domain_type         == chi0_rn_seq[0].output_xacts[0].snp_attr_snp_domain_type;
                    seq_is_non_secure_access             == chi0_rn_seq[0].output_xacts[0].is_non_secure_access;
                    use_seq_is_non_secure_access == 1;
                  }
                  by_pass_read_data_check == 1;
                }
                if (select_rn_f_node) {
                  if (select_transaction_type == COHERENT) {
                    `ifdef SVT_CHI_ISSUE_B_ENABLE
                    if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type_read != svt_chi_transaction::READNOTSHAREDDIRTY;
                    `endif
                    `ifdef SVT_CHI_ISSUE_E_ENABLE
                    if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision <= svt_chi_node_configuration::ISSUE_D) seq_xact_type_read != svt_chi_transaction::READPREFERUNIQUE;
                    `endif
                    seq_xact_type_read != svt_chi_transaction::READNOSNP;
                    !(seq_xact_type_write inside {svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITENOSNPFULL});
                    `ifdef SVT_CHI_ISSUE_E_ENABLE
                    if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision <= svt_chi_node_configuration::ISSUE_D) seq_xact_type_write != svt_chi_transaction::MAKEREADUNIQUE;
                    `endif
                  }
                  else if (select_transaction_type == NON_COHERENT){
                    seq_xact_type_read == svt_chi_transaction::READNOSNP;
                    seq_xact_type_write inside {svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITENOSNPFULL};
                  }
                }
                if (select_rn_i_node || select_rn_d_node) {
                  seq_xact_type_read == svt_chi_transaction::READNOSNP;  
                  seq_xact_type_write inside {svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITENOSNPFULL};
                }
                seq_xact_type_excl == svt_chi_rn_exclusive_access_sequence::RD_WR;
              }
          )
          // LPID should be the same for Load and store initiated from RN1.      
          if (chi0_rn_seq[0].output_xacts[0].lpid == chi0_rn_seq[0].output_xacts[1].lpid) begin
            // pass
            `svt_xvm_debug("body", $sformatf("LPID match: LPID 'd%0d is same for Load and store initiated from RN1", chi0_rn_seq[0].output_xacts[0].lpid));
          end
          else begin
            // fail
            `svt_xvm_error("body", $sformatf("LPID mismatch: LPID is expected to be the same for Load and store initiated from RN1, but that is not the case. Transaction %0s from rn[%0d] has LPID 'd%0d, transaction %0s from rn[%0d] has LPId 'd%0d ", `SVT_CHI_PRINT_PREFIX(chi0_rn_seq[0].output_xacts[0]), initiating_rn_node_idx_0, chi0_rn_seq[0].output_xacts[0].lpid, `SVT_CHI_PRINT_PREFIX(chi0_rn_seq[0].output_xacts[1]), initiating_rn_node_idx_0, chi0_rn_seq[0].output_xacts[1].lpid));
          end
          // LPID should be the same for Load and store initiated from RN2.      
          if (chi0_rn_seq[1].output_xacts[0].lpid == chi0_rn_seq[1].output_xacts[1].lpid) begin
            // pass
            `svt_xvm_debug("body", $sformatf("LPID match: LPID 'd%0d is same for Load and store initiated from RN2", chi0_rn_seq[1].output_xacts[0].lpid));
          end
          else begin
            // fail
            `svt_xvm_error("body", $sformatf("LPID mismatch: LPID is expected to be the same for Load and store initiated from RN2, but that is not the case. Transaction %0s from rn[%0d] has LPID 'd%0d, transaction %0s from rn[%0d] has LPId 'd%0d ", `SVT_CHI_PRINT_PREFIX(chi0_rn_seq[1].output_xacts[0]), initiating_rn_node_idx_1, chi0_rn_seq[1].output_xacts[0].lpid, `SVT_CHI_PRINT_PREFIX(chi0_rn_seq[1].output_xacts[1]), initiating_rn_node_idx_1, chi0_rn_seq[1].output_xacts[1].lpid));
          end
          //Both the exclusive sequence should pass
          check_exclusive_sequence_validity(select_transaction_type, chi0_rn_seq[0].output_xacts[1], 1);
          check_exclusive_sequence_validity(select_transaction_type, chi0_rn_seq[1].output_xacts[1], 1);
        end
        //This feature is supported only for coherent transaction.
        LOAD_FOLLOWED_BY_STORE_WITH_SUSP_COMPACK_FROM_RN1_BEFORE_STORE_FROM_RN2 : begin
          fork
            begin
              `svt_xvm_do_on_with(chi0_rn_seq[0], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
                {
                  sequence_length == 1;
                  seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
                  if (perform_cache_initialization) {
                    hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                    min_addr == addr1;
                    max_addr == addr1;
                    seq_snp_attr_snp_domain_type == vir_seq_snp_attr_snp_domain_type;
                    seq_mem_attr_allocate_hint == vir_seq_mem_attr_allocate_hint;
                    seq_is_non_secure_access == vir_seq_is_non_secure_access;
                    use_seq_is_non_secure_access == 1;
                    data_in_cache == temp_data_1;
                    by_pass_read_data_check == 0;
                  }
                  else {
                    hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
                    seq_hn_node_idx         == target_hn_node_idx_0;
                    by_pass_read_data_check == 1;
                    use_seq_is_non_secure_access == 0;
                  }
                  if (select_rn_f_node) {
                    `ifdef SVT_CHI_ISSUE_B_ENABLE
                    if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type_read != svt_chi_transaction::READNOTSHAREDDIRTY;
                    `endif
                    `ifdef SVT_CHI_ISSUE_E_ENABLE
                    if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision <= svt_chi_node_configuration::ISSUE_D) seq_xact_type_read != svt_chi_transaction::READPREFERUNIQUE;
                    `endif
                    seq_xact_type_read != svt_chi_transaction::READNOSNP;
                  }
                  seq_xact_type_excl == svt_chi_rn_exclusive_access_sequence::RD;
                }
              )
              chi0_rn_seq[0].transaction.wait_end();
            
              `svt_xvm_create_on(chi0_rn_seq[1], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr)
              chi0_rn_seq[1].enable_outstanding = 1;
              chi0_rn_seq[1].seq_exp_comp_ack = 1;
              chi0_rn_seq[1].seq_suspend_comp_ack = 1;
              void'(chi0_rn_seq[1].randomize() with
                     {
                       sequence_length == 1;
                       seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;    
                       seq_lpid == chi0_rn_seq[0].output_xacts[0].lpid;
                       if (perform_cache_initialization) {
                         hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                         min_addr == addr1;
                         max_addr == addr1;
                         seq_snp_attr_snp_domain_type == vir_seq_snp_attr_snp_domain_type;
                         seq_mem_attr_allocate_hint == vir_seq_mem_attr_allocate_hint;
                         seq_is_non_secure_access == vir_seq_is_non_secure_access;
                         use_seq_is_non_secure_access == 1;
                         data_in_cache == temp_data_1;
                         by_pass_read_data_check == 0;
                       }
                       else {
                         hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                         min_addr == chi0_rn_seq[0].output_xacts[0].addr;
                         max_addr == chi0_rn_seq[0].output_xacts[0].addr;
                         seq_snp_attr_snp_domain_type         == chi0_rn_seq[0].output_xacts[0].snp_attr_snp_domain_type;
                         seq_mem_attr_allocate_hint           == chi0_rn_seq[0].output_xacts[0].mem_attr_allocate_hint;  
                         seq_is_non_secure_access             == chi0_rn_seq[0].output_xacts[0].is_non_secure_access;
                         use_seq_is_non_secure_access == 1;
                         by_pass_read_data_check == 1;
                       }
                       if (select_rn_f_node) {
                         seq_xact_type_write == svt_chi_transaction::CLEANUNIQUE;
                       }

                       seq_xact_type_excl == svt_chi_rn_exclusive_access_sequence::WR;
                     }
                   );
              chi0_rn_seq[1].start(p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr);
              wait((chi0_rn_seq[1].transaction.is_comp_received == 1) || (chi0_rn_seq[1].transaction.is_xact_dropped == 1));
              
              if(chi0_rn_seq[1].transaction.is_comp_received == 1) begin
                comp_received = 1;
                wait (rn2_transaction_started == 1);
                chi0_rn_seq[1].transaction.suspend_comp_ack = 0;
              end
              else if(chi0_rn_seq[1].transaction.is_xact_dropped == 1) begin
                xact_dropped = 1;
              end

            end
            begin

              wait ((comp_received == 1) || (xact_dropped == 1));
              if(comp_received == 1) begin
                `svt_xvm_create_on(chi0_rn_seq[2], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr)
                chi0_rn_seq[2].enable_outstanding = 1;
                void'(chi0_rn_seq[2].randomize() with
                    {
                      sequence_length == 1;
                      seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;    
                      if (perform_cache_initialization) {
                        hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                        min_addr == addr1;
                        max_addr == addr1;
                        seq_snp_attr_snp_domain_type == vir_seq_snp_attr_snp_domain_type;
                        seq_mem_attr_allocate_hint == vir_seq_mem_attr_allocate_hint;
                        seq_is_non_secure_access == vir_seq_is_non_secure_access;
                        use_seq_is_non_secure_access == 1;
                        data_in_cache == temp_data_1;
                        by_pass_read_data_check == 0;
                      }
                      else {
                        hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                        min_addr == chi0_rn_seq[0].output_xacts[0].addr;
                        max_addr == chi0_rn_seq[0].output_xacts[0].addr;
                        seq_snp_attr_snp_domain_type         == chi0_rn_seq[0].output_xacts[0].snp_attr_snp_domain_type;
                        seq_mem_attr_allocate_hint           == chi0_rn_seq[0].output_xacts[0].mem_attr_allocate_hint;  
                        seq_is_non_secure_access             == chi0_rn_seq[0].output_xacts[0].is_non_secure_access;
                        use_seq_is_non_secure_access == 1;
                        by_pass_read_data_check == 1;
                      }
                      
                      if (select_rn_f_node) {
                        `ifdef SVT_CHI_ISSUE_B_ENABLE
                        if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type_read != svt_chi_transaction::READNOTSHAREDDIRTY;
                        `endif
                        `ifdef SVT_CHI_ISSUE_E_ENABLE
                        if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision <= svt_chi_node_configuration::ISSUE_D) seq_xact_type_read != svt_chi_transaction::READPREFERUNIQUE;
                        `endif
                        seq_xact_type_read != svt_chi_transaction::READNOSNP;
                      }

                      seq_xact_type_excl == svt_chi_rn_exclusive_access_sequence::RD;
                    }
                );
                chi0_rn_seq[2].start(p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr);
                chi0_rn_seq[2].output_xacts[0].wait_begin();
                rn2_transaction_started = 1;
                chi0_rn_seq[2].output_xacts[0].wait_end();
                
                `svt_xvm_do_on_with(chi0_rn_seq[3], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,
                  {
                    sequence_length == 1;
                    seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;    
                    seq_lpid == chi0_rn_seq[2].output_xacts[0].lpid;
                    if (perform_cache_initialization) {
                      hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                      min_addr == addr1;
                      max_addr == addr1;
                      seq_snp_attr_snp_domain_type == vir_seq_snp_attr_snp_domain_type;
                      seq_mem_attr_allocate_hint == vir_seq_mem_attr_allocate_hint;
                      seq_is_non_secure_access == vir_seq_is_non_secure_access;
                      use_seq_is_non_secure_access == 1;
                      data_in_cache == temp_data_1;
                      by_pass_read_data_check == 0;
                    }
                    else {
                      hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                      min_addr == chi0_rn_seq[2].output_xacts[0].addr;
                      max_addr == chi0_rn_seq[2].output_xacts[0].addr;
                      seq_snp_attr_snp_domain_type         == chi0_rn_seq[0].output_xacts[0].snp_attr_snp_domain_type;
                      seq_mem_attr_allocate_hint           == chi0_rn_seq[0].output_xacts[0].mem_attr_allocate_hint;  
                      seq_is_non_secure_access             == chi0_rn_seq[0].output_xacts[0].is_non_secure_access;
                      use_seq_is_non_secure_access == 1;
                      by_pass_read_data_check == 1;
                    }
                    if (select_rn_f_node) {
                        `ifdef SVT_CHI_ISSUE_B_ENABLE
                        if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type_read != svt_chi_transaction::READNOTSHAREDDIRTY;
                        `endif
                        seq_xact_type_write == svt_chi_transaction::CLEANUNIQUE;
                    }
                    seq_xact_type_excl == svt_chi_rn_exclusive_access_sequence::WR;
                  }
                )
              end //comp_received

            end
          join

          // LPID should be the same for Load and store initiated from RN1.      
          if (chi0_rn_seq[0].output_xacts[0].lpid == chi0_rn_seq[1].output_xacts[0].lpid) begin
            // pass
            `svt_xvm_debug("body", $sformatf("LPID match: LPID 'd%0d is same for Load and store initiated from RN1", chi0_rn_seq[0].output_xacts[0].lpid));
          end
          else begin
            // fail
            `svt_xvm_error("body", $sformatf("LPID mismatch: LPID is expected to be the same for Load and store initiated from RN1, but that is not the case. Transaction %0s from rn[%0d] has LPID 'd%0d, transaction %0s from rn[%0d] has LPId 'd%0d ", `SVT_CHI_PRINT_PREFIX(chi0_rn_seq[0].output_xacts[0]), initiating_rn_node_idx_0, chi0_rn_seq[0].output_xacts[0].lpid, `SVT_CHI_PRINT_PREFIX(chi0_rn_seq[1].output_xacts[0]), initiating_rn_node_idx_0, chi0_rn_seq[1].output_xacts[0].lpid));
          end
          
          if(!(xact_dropped == 1)) begin
            // LPID should be the same for Load and store initiated from RN2.      
            if (chi0_rn_seq[2].output_xacts[0].lpid == chi0_rn_seq[3].output_xacts[0].lpid) begin
              // pass
              `svt_xvm_debug("body", $sformatf("LPID match: LPID 'd%0d is same for Load and store initiated from RN2", chi0_rn_seq[2].output_xacts[0].lpid));
            end
            else begin
              // fail
              `svt_xvm_error("body", $sformatf("LPID mismatch: LPID is expected to be the same for Load and store initiated from RN2, but that is not the case. Transaction %0s from rn[%0d] has LPID 'd%0d, transaction %0s from rn[%0d] has LPId 'd%0d ", `SVT_CHI_PRINT_PREFIX(chi0_rn_seq[2].output_xacts[0]), initiating_rn_node_idx_1, chi0_rn_seq[2].output_xacts[0].lpid, `SVT_CHI_PRINT_PREFIX(chi0_rn_seq[3].output_xacts[0]), initiating_rn_node_idx_1, chi0_rn_seq[3].output_xacts[0].lpid));
            end
          
            chi0_rn_seq[1].output_xacts[0].wait_end();
            //Exclusive sequence should pass for RN1 with RespErr equal to EXCLUSIVE_OKAY
            if(chi0_rn_seq[1].output_xacts[0].response_resp_err_status == svt_chi_transaction::EXCLUSIVE_OKAY) begin
              // pass
              `svt_xvm_debug("body", $sformatf("RespErr is %s which is as expected", chi0_rn_seq[1].output_xacts[0].response_resp_err_status));
            end
            else begin
              // fail
              `svt_xvm_error("body", $sformatf("RespErr is %s for transaction %0s however it should be EXCLUSIVE_OKAY", chi0_rn_seq[1].output_xacts[0].response_resp_err_status, `SVT_CHI_PRINT_PREFIX(chi0_rn_seq[1].output_xacts[0])));
            end
            chi0_rn_seq[3].output_xacts[0].wait_end();
            
            // exok_expected == 1 - RN2 can expect the response to be EXCLUSIVE_OKAY
            // only when the read data response flit to RN2 is sent after the
            // exclusive store at RN1 is complete.
            //
            // exok_expected == 0 - RN2 can expect the response to be
            // NORMAL_OKAY only when the read data response flit to RN2 is sent
            // before the exclusive store at RN1 is complete.
            //
            if(chi0_rn_seq[2].output_xacts[0].get_matched_flits(svt_chi_transaction::DAT, matched_flits)) begin
              if(matched_flits[0].get_end_time() > chi0_rn_seq[1].output_xacts[0].get_end_time())
                exok_expected = 1;
              else
                exok_expected = 0;
            end


            //Exclusive sequence should pass for RN2 with RespErr equal to EXCLUSIVE_OKAY
            if(chi0_rn_seq[3].output_xacts[0].response_resp_err_status == svt_chi_transaction::EXCLUSIVE_OKAY && exok_expected == 1) begin
              // pass
              `svt_xvm_debug("body", $sformatf("RespErr is %s which is as expected", chi0_rn_seq[3].output_xacts[0].response_resp_err_status));
            end
            else if (chi0_rn_seq[3].output_xacts[0].response_resp_err_status == svt_chi_transaction::NORMAL_OKAY && exok_expected == 0) begin
              `svt_xvm_debug("body", $sformatf("RespErr is %s which is as expected", chi0_rn_seq[3].output_xacts[0].response_resp_err_status));
            end
            else begin
              // fail
              `svt_xvm_error("body", $sformatf("RespErr is %s for transaction %0s however it should be %0s", chi0_rn_seq[3].output_xacts[0].response_resp_err_status, `SVT_CHI_PRINT_PREFIX(chi0_rn_seq[3].output_xacts[0]), exok_expected ? "EXCLUSIVE_OKAY" : "NORMAL_OKAY"));
            end
          end
          rn2_transaction_started = 0;
          comp_received = 0;
          xact_dropped = 0;
          exok_expected = 0;
        end

        LOAD_FROM_RN1_FOLLOWED_BY_EXCLUSIVE_SEQ_FROM_RN2_FOLLOWED_BY_STORE_FROM_RN1 : begin
          `svt_xvm_do_on_with(chi0_rn_seq[0], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
            {
              sequence_length == 1;
              seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
              if (perform_cache_initialization) {
                hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                min_addr == addr1;
                max_addr == addr1;
                seq_snp_attr_snp_domain_type == vir_seq_snp_attr_snp_domain_type;
                seq_mem_attr_allocate_hint == vir_seq_mem_attr_allocate_hint;
                seq_is_non_secure_access == vir_seq_is_non_secure_access;
                use_seq_is_non_secure_access == 1;
                data_in_cache == temp_data_1;
                by_pass_read_data_check == 0;
              }
              else {
                hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
                seq_hn_node_idx == target_hn_node_idx_0;
                by_pass_read_data_check == 1;
                use_seq_is_non_secure_access == 0;
              }
              if (select_rn_f_node) {
                if (select_transaction_type == COHERENT) {
                  `ifdef SVT_CHI_ISSUE_B_ENABLE
                  if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type_read != svt_chi_transaction::READNOTSHAREDDIRTY;
                  `endif
                  `ifdef SVT_CHI_ISSUE_E_ENABLE
                  if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision <= svt_chi_node_configuration::ISSUE_D) seq_xact_type_read != svt_chi_transaction::READPREFERUNIQUE;
                  `endif
                  seq_xact_type_read != svt_chi_transaction::READNOSNP;
                } 
                else if (select_transaction_type == NON_COHERENT){
                  seq_xact_type_read == svt_chi_transaction::READNOSNP;
                }  
              }
              if (select_rn_i_node || select_rn_d_node) {
                seq_xact_type_read == svt_chi_transaction::READNOSNP;  
              }
              seq_xact_type_excl == svt_chi_rn_exclusive_access_sequence::RD;
            }
          )
          
          chi0_rn_seq[0].output_xacts[0].wait_end();
          
          `svt_xvm_do_on_with(chi0_rn_seq[2], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,
            {
              sequence_length == 1;
              seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
              if (perform_cache_initialization) {
                hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                min_addr == addr1;
                max_addr == addr1;
                seq_snp_attr_snp_domain_type == vir_seq_snp_attr_snp_domain_type;
                seq_mem_attr_allocate_hint == vir_seq_mem_attr_allocate_hint;
                seq_is_non_secure_access == vir_seq_is_non_secure_access;
                use_seq_is_non_secure_access == 1;
                data_in_cache == temp_data_1;
                by_pass_read_data_check == 0;
              }
              else {
                hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                min_addr == chi0_rn_seq[0].output_xacts[0].addr;
                max_addr == chi0_rn_seq[0].output_xacts[0].addr;
                if (select_transaction_type == COHERENT) {
                  seq_snp_attr_snp_domain_type         == chi0_rn_seq[0].output_xacts[0].snp_attr_snp_domain_type;
                  seq_mem_attr_allocate_hint           == chi0_rn_seq[0].output_xacts[0].mem_attr_allocate_hint;  
                  seq_is_non_secure_access             == chi0_rn_seq[0].output_xacts[0].is_non_secure_access;
                  use_seq_is_non_secure_access == 1;
                }
                else if (select_transaction_type == NON_COHERENT) {
                  seq_mem_attr_is_early_wr_ack_allowed == chi0_rn_seq[0].output_xacts[0].mem_attr_is_early_wr_ack_allowed;  
                  seq_mem_attr_mem_type                == chi0_rn_seq[0].output_xacts[0].mem_attr_mem_type;  
                  seq_mem_attr_is_cacheable            == chi0_rn_seq[0].output_xacts[0].mem_attr_is_cacheable;  
                  seq_mem_attr_allocate_hint           == chi0_rn_seq[0].output_xacts[0].mem_attr_allocate_hint;  
                  seq_snp_attr_is_snoopable            == chi0_rn_seq[0].output_xacts[0].snp_attr_is_snoopable;  
                  seq_snp_attr_snp_domain_type         == chi0_rn_seq[0].output_xacts[0].snp_attr_snp_domain_type;
                  seq_is_non_secure_access             == chi0_rn_seq[0].output_xacts[0].is_non_secure_access;
                  use_seq_is_non_secure_access == 1;
                }

                by_pass_read_data_check == 1;
              }
              if (select_rn_f_node) {
                if (select_transaction_type == COHERENT) {
                  `ifdef SVT_CHI_ISSUE_B_ENABLE
                  if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type_read != svt_chi_transaction::READNOTSHAREDDIRTY;
                  `endif
                  `ifdef SVT_CHI_ISSUE_E_ENABLE
                  if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision <= svt_chi_node_configuration::ISSUE_D) seq_xact_type_read != svt_chi_transaction::READPREFERUNIQUE;
                  `endif
                  seq_xact_type_read != svt_chi_transaction::READNOSNP;
                  !(seq_xact_type_write inside {svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITENOSNPFULL});
                  `ifdef SVT_CHI_ISSUE_E_ENABLE
                  if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision <= svt_chi_node_configuration::ISSUE_D) seq_xact_type_write != svt_chi_transaction::MAKEREADUNIQUE;
                  `endif
                }
                else if (select_transaction_type == NON_COHERENT){
                  seq_xact_type_read == svt_chi_transaction::READNOSNP;
                  seq_xact_type_write inside {svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITENOSNPFULL};
                }
              }
              if (select_rn_i_node || select_rn_d_node) {
                seq_xact_type_read == svt_chi_transaction::READNOSNP;  
                seq_xact_type_write inside {svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITENOSNPFULL};
              }
              seq_xact_type_excl == svt_chi_rn_exclusive_access_sequence::RD_WR;
            }
          )
          chi0_rn_seq[2].output_xacts[1].wait_end();
          
          `svt_xvm_do_on_with(chi0_rn_seq[1], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
            {
              sequence_length == 1;
              seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;    
              seq_lpid == chi0_rn_seq[0].output_xacts[0].lpid;
              if (perform_cache_initialization) {
                hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                min_addr == addr1;
                max_addr == addr1;
                seq_snp_attr_snp_domain_type == vir_seq_snp_attr_snp_domain_type;
                seq_mem_attr_allocate_hint == vir_seq_mem_attr_allocate_hint;
                seq_is_non_secure_access == vir_seq_is_non_secure_access;
                use_seq_is_non_secure_access == 1;
                data_in_cache == temp_data_1;
                by_pass_read_data_check == 0;
              }
              else {
                hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                min_addr == chi0_rn_seq[0].output_xacts[0].addr;
                max_addr == chi0_rn_seq[0].output_xacts[0].addr;
                if (select_transaction_type == COHERENT) {
                  seq_snp_attr_snp_domain_type         == chi0_rn_seq[0].output_xacts[0].snp_attr_snp_domain_type;
                  seq_mem_attr_allocate_hint           == chi0_rn_seq[0].output_xacts[0].mem_attr_allocate_hint;  
                  seq_is_non_secure_access             == chi0_rn_seq[0].output_xacts[0].is_non_secure_access;
                  use_seq_is_non_secure_access == 1;
                }
                else if (select_transaction_type == NON_COHERENT) {
                  seq_mem_attr_is_early_wr_ack_allowed == chi0_rn_seq[0].output_xacts[0].mem_attr_is_early_wr_ack_allowed;  
                  seq_mem_attr_mem_type                == chi0_rn_seq[0].output_xacts[0].mem_attr_mem_type;  
                  seq_mem_attr_is_cacheable            == chi0_rn_seq[0].output_xacts[0].mem_attr_is_cacheable;  
                  seq_mem_attr_allocate_hint           == chi0_rn_seq[0].output_xacts[0].mem_attr_allocate_hint;  
                  seq_snp_attr_is_snoopable            == chi0_rn_seq[0].output_xacts[0].snp_attr_is_snoopable;  
                  seq_snp_attr_snp_domain_type         == chi0_rn_seq[0].output_xacts[0].snp_attr_snp_domain_type;
                  seq_is_non_secure_access             == chi0_rn_seq[0].output_xacts[0].is_non_secure_access;
                  use_seq_is_non_secure_access == 1;
                  seq_data_size                        == chi0_rn_seq[0].output_xacts[0].data_size;
                }
                by_pass_read_data_check == 1;
              }
              if (select_rn_f_node) {
                if (select_transaction_type == COHERENT) {
                  !(seq_xact_type_write inside {svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITENOSNPFULL});
                  `ifdef SVT_CHI_ISSUE_E_ENABLE
                  if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision <= svt_chi_node_configuration::ISSUE_D) seq_xact_type_write != svt_chi_transaction::MAKEREADUNIQUE;
                  `endif
                }
                if (select_transaction_type == NON_COHERENT) {
                  seq_xact_type_write inside {svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITENOSNPFULL};
                  if (chi0_rn_seq[0].output_xacts[0].data_size != svt_chi_transaction::SIZE_64BYTE) {
                    seq_xact_type_write == svt_chi_transaction::WRITENOSNPPTL;
                  }
                }
              }
              if (select_rn_i_node || select_rn_d_node) {
                seq_xact_type_write inside {svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITENOSNPFULL};
                if (chi0_rn_seq[0].output_xacts[0].data_size != svt_chi_transaction::SIZE_64BYTE) {
                  seq_xact_type_write == svt_chi_transaction::WRITENOSNPPTL;
                }
              }
              seq_xact_type_excl == svt_chi_rn_exclusive_access_sequence::WR;
            }
          )
              
          // LPID should be the same for Load and store initiated from RN1.      
          if (chi0_rn_seq[0].output_xacts[0].lpid == chi0_rn_seq[1].output_xacts[0].lpid) begin
            // pass
            `svt_xvm_debug("body", $sformatf("LPID match: LPID 'd%0d is same for Load and store initiated from RN1", chi0_rn_seq[0].output_xacts[0].lpid));
          end
          else begin
            // fail
            `svt_xvm_error("body", $sformatf("LPID mismatch: LPID is expected to be the same for Load and store initiated from RN1, but that is not the case. Transaction %0s from rn[%0d] has LPID 'd%0d, transaction %0s from rn[%0d] has LPId 'd%0d ", `SVT_CHI_PRINT_PREFIX(chi0_rn_seq[0].output_xacts[0]), initiating_rn_node_idx_0, chi0_rn_seq[0].output_xacts[0].lpid, `SVT_CHI_PRINT_PREFIX(chi0_rn_seq[1].output_xacts[0]), initiating_rn_node_idx_0, chi0_rn_seq[1].output_xacts[0].lpid));
          end
          // LPID should be the same for Load and store initiated from RN2.      
          if (chi0_rn_seq[2].output_xacts[0].lpid == chi0_rn_seq[2].output_xacts[1].lpid) begin
            // pass
            `svt_xvm_debug("body", $sformatf("LPID match: LPID 'd%0d is same for Load and store initiated from RN2", chi0_rn_seq[2].output_xacts[0].lpid));
          end
          else begin
            // fail
            `svt_xvm_error("body", $sformatf("LPID mismatch: LPID is expected to be the same for Load and store initiated from RN2, but that is not the case. Transaction %0s from rn[%0d] has LPID 'd%0d, transaction %0s from rn[%0d] has LPId 'd%0d ", `SVT_CHI_PRINT_PREFIX(chi0_rn_seq[2].output_xacts[0]), initiating_rn_node_idx_1, chi0_rn_seq[2].output_xacts[0].lpid, `SVT_CHI_PRINT_PREFIX(chi0_rn_seq[2].output_xacts[1]), initiating_rn_node_idx_1, chi0_rn_seq[2].output_xacts[1].lpid));
          end
          
          //The exclusive sequence from RN1 should fail
          check_exclusive_sequence_validity(select_transaction_type, chi0_rn_seq[1].output_xacts[0], 0);

          //The exclusive sequence from RN2 should pass
          check_exclusive_sequence_validity(select_transaction_type, chi0_rn_seq[2].output_xacts[1], 1);
        end
        
        //This feature is applicable only for non coherent transaction.
        EXCLUSIVE_LOAD_FOLLOWED_BY_EXCLUSIVE_SEQ_DIFF_LPID_FOLLOWED_BY_EXCLUSIVE_STORE: begin
          `svt_xvm_do_on_with(chi0_rn_seq[0], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
            {
              sequence_length == 1;
              seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
              if (perform_cache_initialization) {
                hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                min_addr == addr1;
                max_addr == addr1;
                seq_snp_attr_snp_domain_type == vir_seq_snp_attr_snp_domain_type;
                seq_mem_attr_allocate_hint == vir_seq_mem_attr_allocate_hint;
                seq_is_non_secure_access == vir_seq_is_non_secure_access;
                use_seq_is_non_secure_access == 1;
                data_in_cache == temp_data_1;
                by_pass_read_data_check == 0;
              }
              else {
                hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
                seq_hn_node_idx == target_hn_node_idx_0;
                by_pass_read_data_check == 1;
                use_seq_is_non_secure_access == 0;
              }
              if (select_rn_f_node) {
                if (select_transaction_type == COHERENT) {
                 // `ifdef SVT_CHI_ISSUE_B_ENABLE
                 // if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type_read != svt_chi_transaction::READNOTSHAREDDIRTY;
                 // `endif
                  seq_xact_type_read != svt_chi_transaction::READNOSNP;
                } 
                else if (select_transaction_type == NON_COHERENT){
                  seq_xact_type_read == svt_chi_transaction::READNOSNP;
                }  
              }
              if (select_rn_i_node || select_rn_d_node) {
                seq_xact_type_read == svt_chi_transaction::READNOSNP;  
              }
              seq_xact_type_excl == svt_chi_rn_exclusive_access_sequence::RD;
            }
          )
          
          chi0_rn_seq[0].output_xacts[0].wait_end();
          
          `svt_xvm_do_on_with(chi0_rn_seq[2], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
            {
              sequence_length == 1;
              seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
              seq_lpid != chi0_rn_seq[0].output_xacts[0].lpid;
              if (perform_cache_initialization) {
                hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                min_addr == addr1;
                max_addr == addr1;
                seq_snp_attr_snp_domain_type == vir_seq_snp_attr_snp_domain_type;
                seq_mem_attr_allocate_hint == vir_seq_mem_attr_allocate_hint;
                seq_is_non_secure_access == vir_seq_is_non_secure_access;
                use_seq_is_non_secure_access == 1;
                data_in_cache == temp_data_1;
                by_pass_read_data_check == 0;
              }
              else {
                hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                min_addr == chi0_rn_seq[0].output_xacts[0].addr;
                max_addr == chi0_rn_seq[0].output_xacts[0].addr;
                if (select_transaction_type == COHERENT) {
                  seq_snp_attr_snp_domain_type         == chi0_rn_seq[0].output_xacts[0].snp_attr_snp_domain_type;
                  seq_mem_attr_allocate_hint           == chi0_rn_seq[0].output_xacts[0].mem_attr_allocate_hint;  
                  seq_is_non_secure_access             == chi0_rn_seq[0].output_xacts[0].is_non_secure_access;
                  use_seq_is_non_secure_access == 1;
                }
                else if (select_transaction_type == NON_COHERENT) {
                  seq_mem_attr_is_early_wr_ack_allowed == chi0_rn_seq[0].output_xacts[0].mem_attr_is_early_wr_ack_allowed;  
                  seq_mem_attr_mem_type                == chi0_rn_seq[0].output_xacts[0].mem_attr_mem_type;  
                  seq_mem_attr_is_cacheable            == chi0_rn_seq[0].output_xacts[0].mem_attr_is_cacheable;  
                  seq_mem_attr_allocate_hint           == chi0_rn_seq[0].output_xacts[0].mem_attr_allocate_hint;  
                  seq_snp_attr_is_snoopable            == chi0_rn_seq[0].output_xacts[0].snp_attr_is_snoopable;  
                  seq_snp_attr_snp_domain_type         == chi0_rn_seq[0].output_xacts[0].snp_attr_snp_domain_type;
                  seq_is_non_secure_access             == chi0_rn_seq[0].output_xacts[0].is_non_secure_access;
                  use_seq_is_non_secure_access == 1;
                }

                by_pass_read_data_check == 1;
              }
              if (select_rn_f_node) {
                if (select_transaction_type == COHERENT) {
                  // `ifdef SVT_CHI_ISSUE_B_ENABLE
                  // if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type_read != svt_chi_transaction::READNOTSHAREDDIRTY;
                  // `endif
                  seq_xact_type_read != svt_chi_transaction::READNOSNP;
                  seq_xact_type_write == svt_chi_transaction::CLEANUNIQUE;
                }
                else if (select_transaction_type == NON_COHERENT){
                  seq_xact_type_read == svt_chi_transaction::READNOSNP;
                  seq_xact_type_write inside {svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITENOSNPFULL};
                }
              }
              if (select_rn_i_node || select_rn_d_node) {
                seq_xact_type_read == svt_chi_transaction::READNOSNP;  
                seq_xact_type_write inside {svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITENOSNPFULL};
              }
              seq_xact_type_excl == svt_chi_rn_exclusive_access_sequence::RD_WR;
            }
          )
          chi0_rn_seq[2].output_xacts[0].wait_end();
          chi0_rn_seq[2].output_xacts[1].wait_end();
          
          `svt_xvm_do_on_with(chi0_rn_seq[1], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
            {
              sequence_length == 1;
              seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;    
              seq_lpid == chi0_rn_seq[0].output_xacts[0].lpid;
              if (perform_cache_initialization) {
                hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                min_addr == addr1;
                max_addr == addr1;
                seq_snp_attr_snp_domain_type == vir_seq_snp_attr_snp_domain_type;
                seq_mem_attr_allocate_hint == vir_seq_mem_attr_allocate_hint;
                seq_is_non_secure_access == vir_seq_is_non_secure_access;
                use_seq_is_non_secure_access == 1;
                data_in_cache == temp_data_1;
                by_pass_read_data_check == 0;
              }
              else {
                hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                min_addr == chi0_rn_seq[0].output_xacts[0].addr;
                max_addr == chi0_rn_seq[0].output_xacts[0].addr;
                if (select_transaction_type == COHERENT) {
                  seq_snp_attr_snp_domain_type         == chi0_rn_seq[0].output_xacts[0].snp_attr_snp_domain_type;
                  seq_mem_attr_allocate_hint           == chi0_rn_seq[0].output_xacts[0].mem_attr_allocate_hint;  
                  seq_is_non_secure_access             == chi0_rn_seq[0].output_xacts[0].is_non_secure_access;
                  use_seq_is_non_secure_access == 1;
                }
                else if (select_transaction_type == NON_COHERENT) {
                  seq_mem_attr_is_early_wr_ack_allowed == chi0_rn_seq[0].output_xacts[0].mem_attr_is_early_wr_ack_allowed;  
                  seq_mem_attr_mem_type                == chi0_rn_seq[0].output_xacts[0].mem_attr_mem_type;  
                  seq_mem_attr_is_cacheable            == chi0_rn_seq[0].output_xacts[0].mem_attr_is_cacheable;  
                  seq_mem_attr_allocate_hint           == chi0_rn_seq[0].output_xacts[0].mem_attr_allocate_hint;  
                  seq_snp_attr_is_snoopable            == chi0_rn_seq[0].output_xacts[0].snp_attr_is_snoopable;  
                  seq_snp_attr_snp_domain_type         == chi0_rn_seq[0].output_xacts[0].snp_attr_snp_domain_type;
                  seq_is_non_secure_access             == chi0_rn_seq[0].output_xacts[0].is_non_secure_access;
                  use_seq_is_non_secure_access == 1;
                  seq_data_size                        == chi0_rn_seq[0].output_xacts[0].data_size;
                }
                by_pass_read_data_check == 1;
              }
              if (select_rn_f_node) {
                if (select_transaction_type == COHERENT) {
                  seq_xact_type_write == svt_chi_transaction::CLEANUNIQUE;
                }
                if (select_transaction_type == NON_COHERENT) {
                  seq_xact_type_write inside {svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITENOSNPFULL};
                  if (chi0_rn_seq[0].output_xacts[0].data_size != svt_chi_transaction::SIZE_64BYTE) {
                    seq_xact_type_write == svt_chi_transaction::WRITENOSNPPTL;
                  }
                }
              }
              if (select_rn_i_node || select_rn_d_node) {
                seq_xact_type_write inside {svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITENOSNPFULL};
                if (chi0_rn_seq[0].output_xacts[0].data_size != svt_chi_transaction::SIZE_64BYTE) {
                  seq_xact_type_write == svt_chi_transaction::WRITENOSNPPTL;
                }
              }
              seq_xact_type_excl == svt_chi_rn_exclusive_access_sequence::WR;
            }
          )
              
          // LPID should be the same for Load and store initiated from RN1.      
          if (chi0_rn_seq[0].output_xacts[0].lpid == chi0_rn_seq[1].output_xacts[0].lpid) begin
            // pass
            `svt_xvm_debug("body", $sformatf("LPID match: LPID 'd%0d is same for Load and store initiated from RN1", chi0_rn_seq[0].output_xacts[0].lpid));
          end
          else begin
            // fail
            `svt_xvm_error("body", $sformatf("LPID mismatch: LPID is expected to be the same for Load and store initiated from RN1, but that is not the case. Transaction %0s from rn[%0d] has LPID 'd%0d, transaction %0s from rn[%0d] has LPId 'd%0d ", `SVT_CHI_PRINT_PREFIX(chi0_rn_seq[0].output_xacts[0]), initiating_rn_node_idx_0, chi0_rn_seq[0].output_xacts[0].lpid, `SVT_CHI_PRINT_PREFIX(chi0_rn_seq[1].output_xacts[0]), initiating_rn_node_idx_0, chi0_rn_seq[1].output_xacts[0].lpid));
          end
          // LPID should be the same for Load and store initiated from RN2.      
          if (chi0_rn_seq[2].output_xacts[0].lpid == chi0_rn_seq[2].output_xacts[1].lpid) begin
            // pass
            `svt_xvm_debug("body", $sformatf("LPID match: LPID 'd%0d is same for Load and store initiated from RN1", chi0_rn_seq[2].output_xacts[0].lpid));
          end
          else begin
            // fail
            `svt_xvm_error("body", $sformatf("LPID mismatch: LPID is expected to be the same for Load and store initiated from RN1, but that is not the case. Transaction %0s from rn[%0d] has LPID 'd%0d, transaction %0s from rn[%0d] has LPId 'd%0d ", `SVT_CHI_PRINT_PREFIX(chi0_rn_seq[2].output_xacts[0]), initiating_rn_node_idx_1, chi0_rn_seq[2].output_xacts[0].lpid, `SVT_CHI_PRINT_PREFIX(chi0_rn_seq[2].output_xacts[1]), initiating_rn_node_idx_1, chi0_rn_seq[2].output_xacts[1].lpid));
          end
          
          //The exclusive sequence from RN1 should fail
          check_exclusive_sequence_validity(select_transaction_type, chi0_rn_seq[1].output_xacts[0], 0);

          //The exclusive sequence from RN2 should pass
          check_exclusive_sequence_validity(select_transaction_type, chi0_rn_seq[2].output_xacts[1], 1);
        end

        EXCLUSIVE_LOAD_FOLLOWED_BY_NORMAL_STORE_FROM_DIFF_LPID_FOLLOWED_BY_EXCLUSIVE_STORE :  begin
          `svt_xvm_do_on_with(chi0_rn_seq[0], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
                {
                  sequence_length == 1;
                  seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
                  if (perform_cache_initialization) {
                    hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                    min_addr == addr1;
                    max_addr == addr1;
                    seq_snp_attr_snp_domain_type == vir_seq_snp_attr_snp_domain_type;
                    seq_mem_attr_allocate_hint == vir_seq_mem_attr_allocate_hint;
                    seq_is_non_secure_access == vir_seq_is_non_secure_access;
                    use_seq_is_non_secure_access == 1;
                    data_in_cache == temp_data_1;
                    by_pass_read_data_check == 0;
                  }
                  else {
                    hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
                    seq_hn_node_idx == target_hn_node_idx_0;
                    by_pass_read_data_check == 1;
                    use_seq_is_non_secure_access == 0;
                  }
                  if (select_rn_f_node) {
                    if (select_transaction_type == COHERENT) {
                      `ifdef SVT_CHI_ISSUE_B_ENABLE
                      if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type_read != svt_chi_transaction::READNOTSHAREDDIRTY;
                      `endif
                      `ifdef SVT_CHI_ISSUE_E_ENABLE
                      if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision <= svt_chi_node_configuration::ISSUE_D) seq_xact_type_read != svt_chi_transaction::READPREFERUNIQUE;
                      `endif
                      seq_xact_type_read != svt_chi_transaction::READNOSNP;
                    } 
                    else if (select_transaction_type == NON_COHERENT){
                      seq_xact_type_read == svt_chi_transaction::READNOSNP;
                    }  
                  }
                  if (select_rn_i_node || select_rn_d_node) {
                    seq_xact_type_read == svt_chi_transaction::READNOSNP;  
                  }
                  seq_xact_type_excl == svt_chi_rn_exclusive_access_sequence::RD;
                }
          )
          chi0_rn_seq[0].output_xacts[0].wait_end();
          
          `svt_xvm_create_on(chi0_rn_seq[1], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr)
          chi0_rn_seq[1].seq_is_exclusive = 0;
          void'(chi0_rn_seq[1].randomize() with
                {
                  sequence_length == 1;
                  seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
                  if (perform_cache_initialization) {
                    hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                    min_addr == addr1;
                    max_addr == addr1;
                    seq_snp_attr_snp_domain_type == vir_seq_snp_attr_snp_domain_type;
                    seq_mem_attr_allocate_hint == vir_seq_mem_attr_allocate_hint;
                    seq_is_non_secure_access == vir_seq_is_non_secure_access;
                    use_seq_is_non_secure_access == 1;
                    data_in_cache == temp_data_1;
                    by_pass_read_data_check == 0;
                  }
                  else {
                    hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                    min_addr == chi0_rn_seq[0].output_xacts[0].addr;
                    max_addr == chi0_rn_seq[0].output_xacts[0].addr;
                    if (select_transaction_type == COHERENT) {
                      seq_snp_attr_snp_domain_type         == chi0_rn_seq[0].output_xacts[0].snp_attr_snp_domain_type;
                      seq_mem_attr_allocate_hint           == chi0_rn_seq[0].output_xacts[0].mem_attr_allocate_hint;  
                      seq_is_non_secure_access             == chi0_rn_seq[0].output_xacts[0].is_non_secure_access;
                      use_seq_is_non_secure_access == 1;
                    }
                    else if (select_transaction_type == NON_COHERENT) {
                      seq_mem_attr_is_early_wr_ack_allowed == chi0_rn_seq[0].output_xacts[0].mem_attr_is_early_wr_ack_allowed;  
                      seq_mem_attr_mem_type                == chi0_rn_seq[0].output_xacts[0].mem_attr_mem_type;  
                      seq_mem_attr_is_cacheable            == chi0_rn_seq[0].output_xacts[0].mem_attr_is_cacheable;  
                      seq_mem_attr_allocate_hint           == chi0_rn_seq[0].output_xacts[0].mem_attr_allocate_hint;  
                      seq_snp_attr_is_snoopable            == chi0_rn_seq[0].output_xacts[0].snp_attr_is_snoopable;  
                      seq_snp_attr_snp_domain_type         == chi0_rn_seq[0].output_xacts[0].snp_attr_snp_domain_type;
                      seq_is_non_secure_access             == chi0_rn_seq[0].output_xacts[0].is_non_secure_access;
                      use_seq_is_non_secure_access == 1;
                    }
                    by_pass_read_data_check == 1;
                  }
                  if (select_transaction_type == NON_COHERENT) {
                    seq_data_size == chi0_rn_seq[0].output_xacts[0].data_size;
                  }
                  if (select_rn_f_node) {
                    if (select_transaction_type == COHERENT) {
                      seq_xact_type_write == svt_chi_transaction::CLEANUNIQUE;
                    } 
                    else if (select_transaction_type == NON_COHERENT){
                      seq_xact_type_write inside {svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITENOSNPFULL};
                      if(chi0_rn_seq[0].output_xacts[0].data_size != svt_chi_transaction::SIZE_64BYTE){
                        seq_xact_type_write == svt_chi_transaction::WRITENOSNPPTL;
                      }
                    }  
                  }
                  if (select_rn_i_node || select_rn_d_node) {
                    seq_xact_type_write inside {svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITENOSNPFULL};
                    if(chi0_rn_seq[0].output_xacts[0].data_size != svt_chi_transaction::SIZE_64BYTE){
                      seq_xact_type_write == svt_chi_transaction::WRITENOSNPPTL;
                    }
                  }
                  seq_xact_type_excl == svt_chi_rn_exclusive_access_sequence::WR;
                }
          );
          chi0_rn_seq[1].start(p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr);
          chi0_rn_seq[1].output_xacts[0].wait_end();
          
          `svt_xvm_do_on_with(chi0_rn_seq[2], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
                {
                  sequence_length == 1;
                  seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;    
                  seq_lpid == chi0_rn_seq[0].output_xacts[0].lpid;
                  if (perform_cache_initialization) {
                    hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                    min_addr == addr1;
                    max_addr == addr1;
                    seq_snp_attr_snp_domain_type == vir_seq_snp_attr_snp_domain_type;
                    seq_mem_attr_allocate_hint == vir_seq_mem_attr_allocate_hint;
                    seq_is_non_secure_access == vir_seq_is_non_secure_access;
                    use_seq_is_non_secure_access == 1;
                    data_in_cache == temp_data_1;
                    by_pass_read_data_check == 0;
                  }
                  else {
                    hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                    min_addr == chi0_rn_seq[0].output_xacts[0].addr;
                    max_addr == chi0_rn_seq[0].output_xacts[0].addr;
                    if (select_transaction_type == COHERENT) {
                      seq_snp_attr_snp_domain_type         == chi0_rn_seq[0].output_xacts[0].snp_attr_snp_domain_type;
                      seq_mem_attr_allocate_hint           == chi0_rn_seq[0].output_xacts[0].mem_attr_allocate_hint;  
                      seq_is_non_secure_access             == chi0_rn_seq[0].output_xacts[0].is_non_secure_access;
                      use_seq_is_non_secure_access == 1;
                    }
                    else if (select_transaction_type == NON_COHERENT) {
                      seq_mem_attr_is_early_wr_ack_allowed == chi0_rn_seq[0].output_xacts[0].mem_attr_is_early_wr_ack_allowed;  
                      seq_mem_attr_mem_type                == chi0_rn_seq[0].output_xacts[0].mem_attr_mem_type;  
                      seq_mem_attr_is_cacheable            == chi0_rn_seq[0].output_xacts[0].mem_attr_is_cacheable;  
                      seq_mem_attr_allocate_hint           == chi0_rn_seq[0].output_xacts[0].mem_attr_allocate_hint;  
                      seq_snp_attr_is_snoopable            == chi0_rn_seq[0].output_xacts[0].snp_attr_is_snoopable;  
                      seq_snp_attr_snp_domain_type         == chi0_rn_seq[0].output_xacts[0].snp_attr_snp_domain_type;
                      seq_is_non_secure_access             == chi0_rn_seq[0].output_xacts[0].is_non_secure_access;
                      use_seq_is_non_secure_access == 1;
                      seq_data_size                        == chi0_rn_seq[0].output_xacts[0].data_size;
                    }
                    by_pass_read_data_check == 1;
                  }
                  if (select_rn_f_node) {
                    if (select_transaction_type == COHERENT) {
                      seq_xact_type_write == svt_chi_transaction::CLEANUNIQUE;
                    }
                    if (select_transaction_type == NON_COHERENT) {
                      seq_xact_type_write inside {svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITENOSNPFULL};
                      if (chi0_rn_seq[0].output_xacts[0].data_size != svt_chi_transaction::SIZE_64BYTE) {
                        seq_xact_type_write == svt_chi_transaction::WRITENOSNPPTL;
                      }
                    }
                  }
                  if (select_rn_i_node || select_rn_d_node) {
                    seq_xact_type_write inside {svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITENOSNPFULL};
                    if (chi0_rn_seq[0].output_xacts[0].data_size != svt_chi_transaction::SIZE_64BYTE) {
                      seq_xact_type_write == svt_chi_transaction::WRITENOSNPPTL;
                    }
                  }
                  seq_xact_type_excl == svt_chi_rn_exclusive_access_sequence::WR;
                }
           )
          // LPID should be the same for Load and store initiated from RN1.      
          if (chi0_rn_seq[0].output_xacts[0].lpid == chi0_rn_seq[2].output_xacts[0].lpid) begin
            // pass
            `svt_xvm_debug("body", $sformatf("LPID match: LPID 'd%0d is same for Load and store initiated from RN1", chi0_rn_seq[0].output_xacts[0].lpid));
          end
          else begin
            // fail
            `svt_xvm_error("body", $sformatf("LPID mismatch: LPID is expected to be the same for Load and store initiated from RN1, but that is not the case. Transaction %0s from rn[%0d] has LPID 'd%0d, transaction %0s from rn[%0d] has LPId 'd%0d ", `SVT_CHI_PRINT_PREFIX(chi0_rn_seq[0].output_xacts[0]), initiating_rn_node_idx_0, chi0_rn_seq[0].output_xacts[0].lpid, `SVT_CHI_PRINT_PREFIX(chi0_rn_seq[2].output_xacts[0]), initiating_rn_node_idx_0, chi0_rn_seq[2].output_xacts[0].lpid));
          end
          //If svt_chi_node_configuration::allow_exclusive_store_without_exclusive_load is set to O then the exclusive store will be dropped and resp_err_status check should not be perfomed.
          //If svt_chi_node_configuration::allow_exclusive_store_without_exclusive_load is set to 1 then the exclusive store should pass with EXCLUSIVE_OKAY response.
          if(!chi0_rn_seq[2].output_xacts[0].is_xact_dropped && select_transaction_type == COHERENT)begin
            chi0_rn_seq[2].output_xacts[0].wait_end();
            if(chi0_rn_seq[2].output_xacts[0].response_resp_err_status == svt_chi_transaction::EXCLUSIVE_OKAY) begin
              // pass
              `svt_xvm_debug("body", $sformatf("RespErr is %s which is as expected", chi0_rn_seq[2].output_xacts[0].response_resp_err_status));
            end
            else begin
              // fail
              `svt_xvm_error("body", $sformatf("RespErr is %s for transaction %0s however it should be EXCLUSIVE_OKAY", chi0_rn_seq[2].output_xacts[0].response_resp_err_status, `SVT_CHI_PRINT_PREFIX(chi0_rn_seq[2].output_xacts[0])));
            end
          end
          if(!chi0_rn_seq[2].output_xacts[0].is_xact_dropped && select_transaction_type == NON_COHERENT)begin
            chi0_rn_seq[2].output_xacts[0].wait_end();
            if(chi0_rn_seq[2].output_xacts[0].response_resp_err_status == svt_chi_transaction::NORMAL_OKAY) begin
              // pass
              `svt_xvm_debug("body", $sformatf("RespErr is %s which is as expected", chi0_rn_seq[2].output_xacts[0].response_resp_err_status));
            end
            else begin
              // fail
              `svt_xvm_error("body", $sformatf("RespErr is %s for transaction %0s however it should be NORMAL_OKAY", chi0_rn_seq[2].output_xacts[0].response_resp_err_status, `SVT_CHI_PRINT_PREFIX(chi0_rn_seq[2].output_xacts[0])));
            end
          end
        end
        
        //This feature is applicable only for non coherent transaction.
        EXCLUSIVE_LOAD_FOLLOWED_BY_NORMAL_STORE_FROM_SAME_LPID_FOLLOWED_BY_EXCLUSIVE_STORE :  begin
          `svt_xvm_do_on_with(chi0_rn_seq[0], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
                {
                  sequence_length == 1;
                  seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
                  if (perform_cache_initialization) {
                    hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                    min_addr == addr1;
                    max_addr == addr1;
                    seq_snp_attr_snp_domain_type == vir_seq_snp_attr_snp_domain_type;
                    seq_mem_attr_allocate_hint == vir_seq_mem_attr_allocate_hint;
                    seq_is_non_secure_access == vir_seq_is_non_secure_access;
                    use_seq_is_non_secure_access == 1;
                    data_in_cache == temp_data_1;
                    by_pass_read_data_check == 0;
                  }
                  else {
                    hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
                    seq_hn_node_idx == target_hn_node_idx_0;
                    by_pass_read_data_check == 1;
                    use_seq_is_non_secure_access == 0;
                  }
                  if (select_rn_f_node) {
                    if (select_transaction_type == COHERENT) {
                      `ifdef SVT_CHI_ISSUE_B_ENABLE
                      if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type_read != svt_chi_transaction::READNOTSHAREDDIRTY;
                      `endif
                      `ifdef SVT_CHI_ISSUE_E_ENABLE
                      if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision <= svt_chi_node_configuration::ISSUE_D) seq_xact_type_read != svt_chi_transaction::READPREFERUNIQUE;
                      `endif
                      seq_xact_type_read != svt_chi_transaction::READNOSNP;
                    } 
                    else if (select_transaction_type == NON_COHERENT){
                      seq_xact_type_read == svt_chi_transaction::READNOSNP;
                    }  
                  }
                  if (select_rn_i_node || select_rn_d_node) {
                    seq_xact_type_read == svt_chi_transaction::READNOSNP;  
                  }
                  seq_xact_type_excl == svt_chi_rn_exclusive_access_sequence::RD;
                }
          )
          chi0_rn_seq[0].output_xacts[0].wait_end();
          
          `svt_xvm_create_on(chi0_rn_seq[1], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr)
          chi0_rn_seq[1].seq_is_exclusive = 0;
          void'(chi0_rn_seq[1].randomize() with
                {
                  sequence_length == 1;
                  seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
                  seq_lpid == chi0_rn_seq[0].output_xacts[0].lpid;
                  if (perform_cache_initialization) {
                    hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                    min_addr == addr1;
                    max_addr == addr1;
                    seq_snp_attr_snp_domain_type == vir_seq_snp_attr_snp_domain_type;
                    seq_mem_attr_allocate_hint == vir_seq_mem_attr_allocate_hint;
                    seq_is_non_secure_access == vir_seq_is_non_secure_access;
                    use_seq_is_non_secure_access == 1;
                    data_in_cache == temp_data_1;
                    by_pass_read_data_check == 0;
                  }
                  else {
                    hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                    min_addr == chi0_rn_seq[0].output_xacts[0].addr;
                    max_addr == chi0_rn_seq[0].output_xacts[0].addr;
                    if (select_transaction_type == COHERENT) {
                      seq_snp_attr_snp_domain_type         == chi0_rn_seq[0].output_xacts[0].snp_attr_snp_domain_type;
                      seq_mem_attr_allocate_hint           == chi0_rn_seq[0].output_xacts[0].mem_attr_allocate_hint;  
                      seq_is_non_secure_access             == chi0_rn_seq[0].output_xacts[0].is_non_secure_access;
                      use_seq_is_non_secure_access == 1;
                    }
                    else if (select_transaction_type == NON_COHERENT) {
                      seq_mem_attr_is_early_wr_ack_allowed == chi0_rn_seq[0].output_xacts[0].mem_attr_is_early_wr_ack_allowed;  
                      seq_mem_attr_mem_type                == chi0_rn_seq[0].output_xacts[0].mem_attr_mem_type;  
                      seq_mem_attr_is_cacheable            == chi0_rn_seq[0].output_xacts[0].mem_attr_is_cacheable;  
                      seq_mem_attr_allocate_hint           == chi0_rn_seq[0].output_xacts[0].mem_attr_allocate_hint;  
                      seq_snp_attr_is_snoopable            == chi0_rn_seq[0].output_xacts[0].snp_attr_is_snoopable;  
                      seq_snp_attr_snp_domain_type         == chi0_rn_seq[0].output_xacts[0].snp_attr_snp_domain_type;
                      seq_is_non_secure_access             == chi0_rn_seq[0].output_xacts[0].is_non_secure_access;
                      use_seq_is_non_secure_access == 1;
                    }
                    by_pass_read_data_check == 1;
                  }
                  if (select_transaction_type == NON_COHERENT) {
                    seq_data_size == chi0_rn_seq[0].output_xacts[0].data_size;
                  }
                  if (select_rn_f_node) {
                    if (select_transaction_type == COHERENT) {
                      seq_xact_type_write == svt_chi_transaction::CLEANUNIQUE;
                    } 
                    else if (select_transaction_type == NON_COHERENT){
                      seq_xact_type_write inside {svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITENOSNPFULL};
                      if(chi0_rn_seq[0].output_xacts[0].data_size != svt_chi_transaction::SIZE_64BYTE){
                        seq_xact_type_write == svt_chi_transaction::WRITENOSNPPTL;
                      }
                    }  
                  }
                  if (select_rn_i_node || select_rn_d_node) {
                    seq_xact_type_write inside {svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITENOSNPFULL};
                    if(chi0_rn_seq[0].output_xacts[0].data_size != svt_chi_transaction::SIZE_64BYTE){
                      seq_xact_type_write == svt_chi_transaction::WRITENOSNPPTL;
                    }
                  }
                  seq_xact_type_excl == svt_chi_rn_exclusive_access_sequence::WR;
                }
          );
          chi0_rn_seq[1].start(p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr);
          chi0_rn_seq[1].output_xacts[0].wait_end();
          
          `svt_xvm_do_on_with(chi0_rn_seq[2], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
                {
                  sequence_length == 1;
                  seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;    
                  seq_lpid == chi0_rn_seq[0].output_xacts[0].lpid;
                  if (perform_cache_initialization) {
                    hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                    min_addr == addr1;
                    max_addr == addr1;
                    seq_snp_attr_snp_domain_type == vir_seq_snp_attr_snp_domain_type;
                    seq_mem_attr_allocate_hint == vir_seq_mem_attr_allocate_hint;
                    seq_is_non_secure_access == vir_seq_is_non_secure_access;
                    use_seq_is_non_secure_access == 1;
                    data_in_cache == temp_data_1;
                    by_pass_read_data_check == 0;
                  }
                  else {
                    hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                    min_addr == chi0_rn_seq[0].output_xacts[0].addr;
                    max_addr == chi0_rn_seq[0].output_xacts[0].addr;
                    if (select_transaction_type == COHERENT) {
                      seq_snp_attr_snp_domain_type         == chi0_rn_seq[0].output_xacts[0].snp_attr_snp_domain_type;
                      seq_mem_attr_allocate_hint           == chi0_rn_seq[0].output_xacts[0].mem_attr_allocate_hint;  
                      seq_is_non_secure_access             == chi0_rn_seq[0].output_xacts[0].is_non_secure_access;
                      use_seq_is_non_secure_access == 1;
                    }
                    else if (select_transaction_type == NON_COHERENT) {
                      seq_mem_attr_is_early_wr_ack_allowed == chi0_rn_seq[0].output_xacts[0].mem_attr_is_early_wr_ack_allowed;  
                      seq_mem_attr_mem_type                == chi0_rn_seq[0].output_xacts[0].mem_attr_mem_type;  
                      seq_mem_attr_is_cacheable            == chi0_rn_seq[0].output_xacts[0].mem_attr_is_cacheable;  
                      seq_mem_attr_allocate_hint           == chi0_rn_seq[0].output_xacts[0].mem_attr_allocate_hint;  
                      seq_snp_attr_is_snoopable            == chi0_rn_seq[0].output_xacts[0].snp_attr_is_snoopable;  
                      seq_snp_attr_snp_domain_type         == chi0_rn_seq[0].output_xacts[0].snp_attr_snp_domain_type;
                      seq_is_non_secure_access             == chi0_rn_seq[0].output_xacts[0].is_non_secure_access;
                      use_seq_is_non_secure_access == 1;
                      seq_data_size                        == chi0_rn_seq[0].output_xacts[0].data_size;
                    }
                    by_pass_read_data_check == 1;
                  }
                  if (select_rn_f_node) {
                    if (select_transaction_type == COHERENT) {
                      seq_xact_type_write == svt_chi_transaction::CLEANUNIQUE;
                    }
                    if (select_transaction_type == NON_COHERENT) {
                      seq_xact_type_write inside {svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITENOSNPFULL};
                      if (chi0_rn_seq[0].output_xacts[0].data_size != svt_chi_transaction::SIZE_64BYTE) {
                        seq_xact_type_write == svt_chi_transaction::WRITENOSNPPTL;
                      }
                    }
                  }
                  if (select_rn_i_node || select_rn_d_node) {
                    seq_xact_type_write inside {svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITENOSNPFULL};
                    if (chi0_rn_seq[0].output_xacts[0].data_size != svt_chi_transaction::SIZE_64BYTE) {
                      seq_xact_type_write == svt_chi_transaction::WRITENOSNPPTL;
                    }
                  }
                  seq_xact_type_excl == svt_chi_rn_exclusive_access_sequence::WR;
                }
           )
          // LPID should be the same for Load and store initiated from RN1.      
          if (chi0_rn_seq[0].output_xacts[0].lpid == chi0_rn_seq[2].output_xacts[0].lpid) begin
            // pass
            `svt_xvm_debug("body", $sformatf("LPID match: LPID 'd%0d is same for Load and store initiated from RN1", chi0_rn_seq[0].output_xacts[0].lpid));
          end
          else begin
            // fail
            `svt_xvm_error("body", $sformatf("LPID mismatch: LPID is expected to be the same for Load and store initiated from RN1, but that is not the case. Transaction %0s from rn[%0d] has LPID 'd%0d, transaction %0s from rn[%0d] has LPId 'd%0d ", `SVT_CHI_PRINT_PREFIX(chi0_rn_seq[0].output_xacts[0]), initiating_rn_node_idx_0, chi0_rn_seq[0].output_xacts[0].lpid, `SVT_CHI_PRINT_PREFIX(chi0_rn_seq[2].output_xacts[0]), initiating_rn_node_idx_0, chi0_rn_seq[2].output_xacts[0].lpid));
          end
          //If svt_chi_node_configuration::allow_exclusive_store_without_exclusive_load is set to O then the exclusive store will be dropped and resp_err_status check should not be perfomed.
          //If svt_chi_node_configuration::allow_exclusive_store_without_exclusive_load is set to 1 then the exclusive store should pass with EXCLUSIVE_OKAY response.
          if(!chi0_rn_seq[2].output_xacts[0].is_xact_dropped)begin
            chi0_rn_seq[2].output_xacts[0].wait_end();
            if(chi0_rn_seq[2].output_xacts[0].response_resp_err_status == svt_chi_transaction::EXCLUSIVE_OKAY) begin
              // pass
              `svt_xvm_debug("body", $sformatf("RespErr is %s which is as expected", chi0_rn_seq[2].output_xacts[0].response_resp_err_status));
            end
            else begin
              // fail
              `svt_xvm_error("body", $sformatf("RespErr is %s for transaction %0s however it should be EXCLUSIVE_OKAY", chi0_rn_seq[2].output_xacts[0].response_resp_err_status, `SVT_CHI_PRINT_PREFIX(chi0_rn_seq[2].output_xacts[0])));
            end
          end
        end
        
        MAX_NUM_OF_EXCLUSIVE_ACCESS_SATURATION : begin
          for (int i = 0; i < `SVT_CHI_MAX_NUM_EXCLUSIVE_ACCESS; i++) begin
            automatic int j;
            j = i;
            fork
              begin
                if (select_transaction_type == COHERENT) begin
                  if(perform_cache_initialization) begin
                   /** 
                    * Write data into Cache of Randomly selected first RN with address of randomly
                    * selected first HN Node.
                    */
                   `svt_xvm_do_on_with(makeunique_seq[j], p_sequencer.rn_virt_seqr[cache_line_init_rn_f_node_index].rn_xact_seqr,
                                                         {sequence_length    == 1;
                                                          hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
                                                          seq_hn_node_idx    == target_hn_node_idx_0;
                                                          use_seq_is_non_secure_access == 0;
                                                         })
                    /** Wait for MakeUnique transactions to finish */ 
                    makeunique_seq[j].write_tran.wait_end();
                    addr1 = makeunique_seq[j].output_xacts[0].addr;
                    vir_seq_snp_attr_snp_domain_type = makeunique_seq[j].output_xacts[0].snp_attr_snp_domain_type;
                    vir_seq_mem_attr_allocate_hint = makeunique_seq[j].output_xacts[0].mem_attr_allocate_hint;
                    vir_seq_is_non_secure_access = makeunique_seq[j].output_xacts[0].is_non_secure_access;
                    temp_data_1 = makeunique_seq[j].output_xacts[0].data;
                   
                   `svt_xvm_debug("exclusive_sequence_cache_init", $sformatf("addr: %0xh, txn_id: %0d",addr1, makeunique_seq[j].output_xacts[0].txn_id));
                  end
                end

                `svt_xvm_do_on_with(chi0_rn_seq[j], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
                 {
                   sequence_length == 1;
                   seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
                   seq_lpid == j;
                   if (perform_cache_initialization) {
                     hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                     min_addr == addr1;
                     max_addr == addr1;
                     seq_snp_attr_snp_domain_type == vir_seq_snp_attr_snp_domain_type;
                     seq_mem_attr_allocate_hint == vir_seq_mem_attr_allocate_hint;
                     use_seq_is_non_secure_access == 1;
                     seq_is_non_secure_access == vir_seq_is_non_secure_access;
                     data_in_cache == temp_data_1;
                     by_pass_read_data_check == 0;
                   }
                   else {
                     hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
                     seq_hn_node_idx == target_hn_node_idx_0;
                     by_pass_read_data_check == 1;
                     use_seq_is_non_secure_access == 0;
                   }
                   if (select_rn_f_node) {
                     if (select_transaction_type == COHERENT) {
                      `ifdef SVT_CHI_ISSUE_B_ENABLE
                      if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type_read != svt_chi_transaction::READNOTSHAREDDIRTY;
                      `endif
                      `ifdef SVT_CHI_ISSUE_E_ENABLE
                      if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision <= svt_chi_node_configuration::ISSUE_D) seq_xact_type_read != svt_chi_transaction::READPREFERUNIQUE;
                      `endif
                       seq_xact_type_read != svt_chi_transaction::READNOSNP;
                     }
                     else if (select_transaction_type == NON_COHERENT){
                       seq_xact_type_read == svt_chi_transaction::READNOSNP;
                     }
                   }
                   if (select_rn_i_node || select_rn_d_node) {
                     seq_xact_type_read == svt_chi_transaction::READNOSNP;  
                   }
                   seq_xact_type_excl == svt_chi_rn_exclusive_access_sequence::RD;
                 }
               )
             end
             join_none
          end //for loop
          wait fork;
          //Wait for all the load to complete
          foreach(chi0_rn_seq[i])begin
            chi0_rn_seq[i].output_xacts[0].wait_end();
          end
          
          `svt_xvm_create_on(chi0_rn_seq[`SVT_CHI_MAX_NUM_EXCLUSIVE_ACCESS], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr)
          chi0_rn_seq[`SVT_CHI_MAX_NUM_EXCLUSIVE_ACCESS].enable_outstanding = 1;
          void'(chi0_rn_seq[`SVT_CHI_MAX_NUM_EXCLUSIVE_ACCESS].randomize() with
                 {
                   sequence_length == 1;
                   seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
                   seq_lpid == `SVT_CHI_MAX_NUM_EXCLUSIVE_ACCESS;
                   hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
                   use_seq_is_non_secure_access == 0;
                   seq_hn_node_idx    == target_hn_node_idx_0; 
                   by_pass_read_data_check == 1;
                   if (select_rn_f_node) {
                     if (select_transaction_type == COHERENT) {
                      `ifdef SVT_CHI_ISSUE_B_ENABLE
                      if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type_read != svt_chi_transaction::READNOTSHAREDDIRTY;
                      `endif
                      `ifdef SVT_CHI_ISSUE_E_ENABLE
                      if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision <= svt_chi_node_configuration::ISSUE_D) seq_xact_type_read != svt_chi_transaction::READPREFERUNIQUE;
                      `endif
                       seq_xact_type_read != svt_chi_transaction::READNOSNP;
                     }
                     else if (select_transaction_type == NON_COHERENT){
                       seq_xact_type_read == svt_chi_transaction::READNOSNP;
                     }
                   }
                   if (select_rn_i_node || select_rn_d_node) {
                     seq_xact_type_read == svt_chi_transaction::READNOSNP;  
                   }
                   seq_xact_type_excl == svt_chi_rn_exclusive_access_sequence::RD;
                 }
          );
          chi0_rn_seq[`SVT_CHI_MAX_NUM_EXCLUSIVE_ACCESS].start(p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr);
          // Issue store with same LPID and Addr as corresponding to the load 
          for (int i = 0; i < `SVT_CHI_MAX_NUM_EXCLUSIVE_ACCESS; i++) begin
            automatic int j;
            j = i;
            fork
              begin
                `svt_xvm_do_on_with(chi_rn_seq_write[j], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
                  {
                    sequence_length == 1;
                    seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;    
                    seq_lpid == chi0_rn_seq[j].output_xacts[0].lpid;
                    if (perform_cache_initialization) {
                      hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                      min_addr == chi0_rn_seq[j].output_xacts[0].addr;
                      max_addr == chi0_rn_seq[j].output_xacts[0].addr;
                      seq_snp_attr_snp_domain_type         == chi0_rn_seq[j].output_xacts[0].snp_attr_snp_domain_type;
                      seq_mem_attr_allocate_hint           == chi0_rn_seq[j].output_xacts[0].mem_attr_allocate_hint;  
                      seq_is_non_secure_access             == chi0_rn_seq[j].output_xacts[0].is_non_secure_access;
                      use_seq_is_non_secure_access == 1;
                      data_in_cache == temp_data_1;
                      by_pass_read_data_check == 0;
                    }
                    else {
                      hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                      min_addr == chi0_rn_seq[j].output_xacts[0].addr;
                      max_addr == chi0_rn_seq[j].output_xacts[0].addr;
                      if (select_transaction_type == COHERENT) {
                        seq_snp_attr_snp_domain_type         == chi0_rn_seq[j].output_xacts[0].snp_attr_snp_domain_type;
                        seq_mem_attr_allocate_hint           == chi0_rn_seq[j].output_xacts[0].mem_attr_allocate_hint;  
                        seq_is_non_secure_access             == chi0_rn_seq[j].output_xacts[0].is_non_secure_access;
                        use_seq_is_non_secure_access == 1;
                      }
                      else if (select_transaction_type == NON_COHERENT) {
                        seq_mem_attr_is_early_wr_ack_allowed == chi0_rn_seq[j].output_xacts[0].mem_attr_is_early_wr_ack_allowed;  
                        seq_mem_attr_mem_type                == chi0_rn_seq[j].output_xacts[0].mem_attr_mem_type;  
                        seq_mem_attr_is_cacheable            == chi0_rn_seq[j].output_xacts[0].mem_attr_is_cacheable;  
                        seq_mem_attr_allocate_hint           == chi0_rn_seq[j].output_xacts[0].mem_attr_allocate_hint;  
                        seq_snp_attr_is_snoopable            == chi0_rn_seq[j].output_xacts[0].snp_attr_is_snoopable;  
                        seq_snp_attr_snp_domain_type         == chi0_rn_seq[j].output_xacts[0].snp_attr_snp_domain_type;
                        seq_is_non_secure_access             == chi0_rn_seq[j].output_xacts[0].is_non_secure_access;
                        use_seq_is_non_secure_access == 1;
                        seq_data_size                        == chi0_rn_seq[j].output_xacts[0].data_size;
                      }
                      by_pass_read_data_check == 1;
                    }
                    if (select_rn_f_node) {
                      if (select_transaction_type == COHERENT) {
                      !(seq_xact_type_write inside {svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITENOSNPFULL});
                      `ifdef SVT_CHI_ISSUE_E_ENABLE
                      if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision <= svt_chi_node_configuration::ISSUE_D) seq_xact_type_write != svt_chi_transaction::MAKEREADUNIQUE;
                      `endif
                      }
                      if (select_transaction_type == NON_COHERENT) {
                        seq_xact_type_write inside {svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITENOSNPFULL};
                        if (chi0_rn_seq[j].output_xacts[0].data_size != svt_chi_transaction::SIZE_64BYTE) {
                          seq_xact_type_write == svt_chi_transaction::WRITENOSNPPTL;
                        }
                      }
                    }
                    if (select_rn_i_node || select_rn_d_node) {
                      seq_xact_type_write inside {svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITENOSNPFULL};
                      if (chi0_rn_seq[j].output_xacts[0].data_size != svt_chi_transaction::SIZE_64BYTE) {
                        seq_xact_type_write == svt_chi_transaction::WRITENOSNPPTL;
                      }
                    }
                    seq_xact_type_excl == svt_chi_rn_exclusive_access_sequence::WR;
                  }
                )
              end
              join_none
          end //for loop
          wait fork;

          for (int i = 0; i < `SVT_CHI_MAX_NUM_EXCLUSIVE_ACCESS; i++) begin
            // LPID should be the same for each pair of load and store.      
            if (chi0_rn_seq[i].output_xacts[0].lpid == chi_rn_seq_write[i].output_xacts[0].lpid) begin
              // pass
              `svt_xvm_debug("body", $sformatf("LPID match: LPID 'd%0d is same for Load and store initiated from RN1", chi0_rn_seq[i].output_xacts[0].lpid));
            end
            else begin
              // fail
              `svt_xvm_error("body", $sformatf("LPID mismatch: LPID is expected to be the same for Load and store initiated from RN1, but that is not the case. Transaction %0s from rn[%0d] has LPID 'd%0d, transaction %0s from rn[%0d] has LPId 'd%0d ", `SVT_CHI_PRINT_PREFIX(chi0_rn_seq[i].output_xacts[0]), initiating_rn_node_idx_0, chi0_rn_seq[i].output_xacts[0].lpid, `SVT_CHI_PRINT_PREFIX(chi_rn_seq_write[i].output_xacts[0]), initiating_rn_node_idx_0, chi_rn_seq_write[i].output_xacts[0].lpid));
            end
            
            //All the exclusive sequence should pass
            check_exclusive_sequence_validity(select_transaction_type, chi_rn_seq_write[i].output_xacts[0], 1);
          end //for loop
        end
        
        //This feature is supported only for coherent transaction.
        EXCLUSIVE_LOAD_FOLLOWED_BY_NORMAL_STORE_FROM_SAME_RN_BUT_DIFF_LPID_FOLLOWED_BY_EXCLUSIVE_STORE : begin
          `svt_xvm_do_on_with(chi0_rn_seq[0], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
                {
                  sequence_length == 1;
                  seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
                  if (perform_cache_initialization) {
                    hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                    min_addr == addr1;
                    max_addr == addr1;
                    seq_snp_attr_snp_domain_type == vir_seq_snp_attr_snp_domain_type;
                    seq_mem_attr_allocate_hint == vir_seq_mem_attr_allocate_hint;
                    seq_is_non_secure_access == vir_seq_is_non_secure_access;
                    use_seq_is_non_secure_access == 1;
                    data_in_cache == temp_data_1;
                    by_pass_read_data_check == 0;
                  }
                  else {
                    hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
                    seq_hn_node_idx == target_hn_node_idx_0;
                    by_pass_read_data_check == 1;
                    use_seq_is_non_secure_access == 0;
                  }
                  if (select_rn_f_node) {
                    `ifdef SVT_CHI_ISSUE_B_ENABLE
                    if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type_read != svt_chi_transaction::READNOTSHAREDDIRTY;
                    `endif
                    `ifdef SVT_CHI_ISSUE_E_ENABLE
                    if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision <= svt_chi_node_configuration::ISSUE_D) seq_xact_type_read != svt_chi_transaction::READPREFERUNIQUE;
                    `endif
                    seq_xact_type_read != svt_chi_transaction::READNOSNP;
                  }
                  seq_xact_type_excl == svt_chi_rn_exclusive_access_sequence::RD;
                }
          )
          chi0_rn_seq[0].output_xacts[0].wait_end();
          
          `svt_xvm_create_on(chi0_rn_seq[1], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr)
          chi0_rn_seq[1].seq_is_exclusive = 0;
          void'(chi0_rn_seq[1].randomize() with
                {
                  sequence_length == 1;
                  seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
                  seq_lpid != chi0_rn_seq[0].output_xacts[0].lpid;
                  if (perform_cache_initialization) {
                    hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                    min_addr == addr1;
                    max_addr == addr1;
                    seq_snp_attr_snp_domain_type == vir_seq_snp_attr_snp_domain_type;
                    seq_mem_attr_allocate_hint == vir_seq_mem_attr_allocate_hint;
                    seq_is_non_secure_access == vir_seq_is_non_secure_access;
                    use_seq_is_non_secure_access == 1;
                    data_in_cache == temp_data_1;
                    by_pass_read_data_check == 0;
                  }
                  else {
                    hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                    min_addr == chi0_rn_seq[0].output_xacts[0].addr;
                    max_addr == chi0_rn_seq[0].output_xacts[0].addr;
                    seq_snp_attr_snp_domain_type         == chi0_rn_seq[0].output_xacts[0].snp_attr_snp_domain_type;
                    seq_mem_attr_allocate_hint           == chi0_rn_seq[0].output_xacts[0].mem_attr_allocate_hint;  
                    seq_is_non_secure_access             == chi0_rn_seq[0].output_xacts[0].is_non_secure_access;
                    use_seq_is_non_secure_access == 1;
                    by_pass_read_data_check == 1;
                  }
                  if (select_rn_f_node) {
                    !(seq_xact_type_write inside {svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITENOSNPFULL});
                    `ifdef SVT_CHI_ISSUE_E_ENABLE
                    if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision <= svt_chi_node_configuration::ISSUE_D) seq_xact_type_write != svt_chi_transaction::MAKEREADUNIQUE;
                    `endif
                  }
                  seq_xact_type_excl == svt_chi_rn_exclusive_access_sequence::WR;
                }
          );
          chi0_rn_seq[1].start(p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr);
          chi0_rn_seq[1].output_xacts[0].wait_end();
          
          `svt_xvm_create_on(chi0_rn_seq[2], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr)
          chi0_rn_seq[2].enable_outstanding = 1;
          void'(chi0_rn_seq[2].randomize() with
                {
                  sequence_length == 1;
                  seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;    
                  seq_lpid == chi0_rn_seq[0].output_xacts[0].lpid;
                  if (perform_cache_initialization) {
                    hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                    min_addr == addr1;
                    max_addr == addr1;
                    seq_snp_attr_snp_domain_type == vir_seq_snp_attr_snp_domain_type;
                    seq_mem_attr_allocate_hint == vir_seq_mem_attr_allocate_hint;
                    seq_is_non_secure_access == vir_seq_is_non_secure_access;
                    use_seq_is_non_secure_access == 1;
                    data_in_cache == temp_data_1;
                    by_pass_read_data_check == 0;
                  }
                  else {
                    hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                    min_addr == chi0_rn_seq[0].output_xacts[0].addr;
                    max_addr == chi0_rn_seq[0].output_xacts[0].addr;
                    seq_snp_attr_snp_domain_type         == chi0_rn_seq[0].output_xacts[0].snp_attr_snp_domain_type;
                    seq_mem_attr_allocate_hint           == chi0_rn_seq[0].output_xacts[0].mem_attr_allocate_hint;  
                    seq_is_non_secure_access             == chi0_rn_seq[0].output_xacts[0].is_non_secure_access;
                    use_seq_is_non_secure_access == 1;
                    by_pass_read_data_check == 1;
                  }
                  if (select_rn_f_node) {
                    !(seq_xact_type_write inside {svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITENOSNPFULL});
                    `ifdef SVT_CHI_ISSUE_E_ENABLE
                    if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision <= svt_chi_node_configuration::ISSUE_D) seq_xact_type_write != svt_chi_transaction::MAKEREADUNIQUE;
                    `endif
                  }
                  seq_xact_type_excl == svt_chi_rn_exclusive_access_sequence::WR;
                }
           );
           chi0_rn_seq[2].start(p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr);
           
          // LPID should be the same for Load and store initiated from RN1.      
          if (chi0_rn_seq[0].output_xacts[0].lpid == chi0_rn_seq[2].output_xacts[0].lpid) begin
            // pass
            `svt_xvm_debug("body", $sformatf("LPID match: LPID 'd%0d is same for Load and store initiated from RN1", chi0_rn_seq[0].output_xacts[0].lpid));
          end
          else begin
            // fail
            `svt_xvm_error("body", $sformatf("LPID mismatch: LPID is expected to be the same for Load and store initiated from RN1, but that is not the case. Transaction %0s from rn[%0d] has LPID 'd%0d, transaction %0s from rn[%0d] has LPId 'd%0d ", `SVT_CHI_PRINT_PREFIX(chi0_rn_seq[0].output_xacts[0]), initiating_rn_node_idx_0, chi0_rn_seq[0].output_xacts[0].lpid, `SVT_CHI_PRINT_PREFIX(chi0_rn_seq[2].output_xacts[0]), initiating_rn_node_idx_0, chi0_rn_seq[2].output_xacts[0].lpid));
          end
          chi0_rn_seq[2].output_xacts[0].wait_end();
        end
        NON_COHERENT_EXCLUSIVE_LOAD_STORE_WITH_MISMATCHED_ATTRIBUTE: begin
          `svt_xvm_do_on_with(chi0_rn_seq[0], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
                {
                  sequence_length == 1;
                  seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
                  hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
                  use_seq_is_non_secure_access == 0;
                  seq_hn_node_idx == target_hn_node_idx_0;
                  by_pass_read_data_check == 1;
                  seq_xact_type_read == svt_chi_transaction::READNOSNP;
                  seq_xact_type_excl == svt_chi_rn_exclusive_access_sequence::RD;
                }
          )
          chi0_rn_seq[0].transaction.wait_end();
          
          // Issue a excluisve store with mismatched attribute parameters.
          `svt_xvm_create_on(chi0_rn_seq[1], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr)
          chi0_rn_seq[1].bypass_mapping_of_attr = 1;
          void'(chi0_rn_seq[1].randomize() with
                {
                  sequence_length == 1;
                  seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;    
                  seq_lpid == chi0_rn_seq[0].output_xacts[0].lpid;
                  hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                  min_addr == chi0_rn_seq[0].output_xacts[0].addr;
                  max_addr == chi0_rn_seq[0].output_xacts[0].addr;
                  by_pass_read_data_check == 1;
                  seq_is_non_secure_access == chi0_rn_seq[0].output_xacts[0].is_non_secure_access;
                  use_seq_is_non_secure_access == 1;
                  seq_data_size == chi0_rn_seq[0].output_xacts[0].data_size;
                  
                  seq_xact_type_write inside {svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITENOSNPFULL};
                  if (chi0_rn_seq[0].output_xacts[0].data_size != svt_chi_transaction::SIZE_64BYTE) {
                    seq_xact_type_write == svt_chi_transaction::WRITENOSNPPTL;
                  }
                  
                  seq_xact_type_excl == svt_chi_rn_exclusive_access_sequence::WR;
                }
           );
          chi0_rn_seq[1].start(p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr);
          chi0_rn_seq[1].transaction.wait_end();
          
          // Issue a excluisve store with matched attribute parameters.
          `svt_xvm_do_on_with(chi0_rn_seq[2], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
                {
                  sequence_length == 1;
                  seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;    
                  seq_lpid == chi0_rn_seq[0].output_xacts[0].lpid;
                  hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                  min_addr == chi0_rn_seq[0].output_xacts[0].addr;
                  max_addr == chi0_rn_seq[0].output_xacts[0].addr;
                  by_pass_read_data_check == 1;
                  seq_mem_attr_is_early_wr_ack_allowed == chi0_rn_seq[0].output_xacts[0].mem_attr_is_early_wr_ack_allowed;  
                  seq_mem_attr_mem_type                == chi0_rn_seq[0].output_xacts[0].mem_attr_mem_type;  
                  seq_mem_attr_is_cacheable            == chi0_rn_seq[0].output_xacts[0].mem_attr_is_cacheable;  
                  seq_mem_attr_allocate_hint           == chi0_rn_seq[0].output_xacts[0].mem_attr_allocate_hint;  
                  seq_snp_attr_is_snoopable            == chi0_rn_seq[0].output_xacts[0].snp_attr_is_snoopable;  
                  seq_snp_attr_snp_domain_type         == chi0_rn_seq[0].output_xacts[0].snp_attr_snp_domain_type;
                  seq_is_non_secure_access             == chi0_rn_seq[0].output_xacts[0].is_non_secure_access;
                  use_seq_is_non_secure_access == 1;
                  seq_data_size                        == chi0_rn_seq[0].output_xacts[0].data_size;
                  
                  seq_xact_type_write inside {svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITENOSNPFULL};
                  if (chi0_rn_seq[0].output_xacts[0].data_size != svt_chi_transaction::SIZE_64BYTE) {
                    seq_xact_type_write == svt_chi_transaction::WRITENOSNPPTL;
                  }
                  
                  seq_xact_type_excl == svt_chi_rn_exclusive_access_sequence::WR;
                }
           )
          chi0_rn_seq[2].transaction.wait_end();
          if((chi0_rn_seq[0].output_xacts[0].mem_attr_is_early_wr_ack_allowed != chi0_rn_seq[1].output_xacts[0].mem_attr_is_early_wr_ack_allowed)||
             (chi0_rn_seq[0].output_xacts[0].mem_attr_mem_type != chi0_rn_seq[1].output_xacts[0].mem_attr_mem_type)||
             (chi0_rn_seq[0].output_xacts[0].mem_attr_is_cacheable != chi0_rn_seq[1].output_xacts[0].mem_attr_is_cacheable)||
             (chi0_rn_seq[0].output_xacts[0].mem_attr_allocate_hint != chi0_rn_seq[1].output_xacts[0].mem_attr_allocate_hint)) begin
            // LPID should be the same for Load and store pair initiated from RN1.      
            if (chi0_rn_seq[0].output_xacts[0].lpid == chi0_rn_seq[2].output_xacts[0].lpid) begin
              // pass
              `svt_xvm_debug("body", $sformatf("LPID match: LPID 'd%0d is same for Load and store initiated from RN1", chi0_rn_seq[0].output_xacts[0].lpid));
            end
            else begin
              // fail
              `svt_xvm_error("body", $sformatf("LPID mismatch: LPID is expected to be the same for Load and store initiated from RN1, but that is not the case. Transaction %0s from rn[%0d] has LPID 'd%0d, transaction %0s from rn[%0d] has LPId 'd%0d ", `SVT_CHI_PRINT_PREFIX(chi0_rn_seq[0].output_xacts[0]), initiating_rn_node_idx_0, chi0_rn_seq[0].output_xacts[0].lpid, `SVT_CHI_PRINT_PREFIX(chi0_rn_seq[2].output_xacts[0]), initiating_rn_node_idx_0, chi0_rn_seq[2].output_xacts[0].lpid));
            end
            //The exclusive sequence is should pass with RespErr field equal to EXCLUSIVE_OKAY
            check_exclusive_sequence_validity(NON_COHERENT, chi0_rn_seq[2].output_xacts[0], 1);
          end
          else begin
            // LPID should be the same for Load and store pair initiated from RN1.      
            if (chi0_rn_seq[0].output_xacts[0].lpid == chi0_rn_seq[1].output_xacts[0].lpid) begin
              // pass
              `svt_xvm_debug("body", $sformatf("LPID match: LPID 'd%0d is same for Load and store initiated from RN1", chi0_rn_seq[0].output_xacts[0].lpid));
            end
            else begin
              // fail
              `svt_xvm_error("body", $sformatf("LPID mismatch: LPID is expected to be the same for Load and store initiated from RN1, but that is not the case. Transaction %0s from rn[%0d] has LPID 'd%0d, transaction %0s from rn[%0d] has LPId 'd%0d ", `SVT_CHI_PRINT_PREFIX(chi0_rn_seq[0].output_xacts[0]), initiating_rn_node_idx_0, chi0_rn_seq[0].output_xacts[0].lpid, `SVT_CHI_PRINT_PREFIX(chi0_rn_seq[1].output_xacts[0]), initiating_rn_node_idx_0, chi0_rn_seq[1].output_xacts[0].lpid));
            end
            //The exclusive sequence is should pass with RespErr field equal to EXCLUSIVE_OKAY
            check_exclusive_sequence_validity(NON_COHERENT, chi0_rn_seq[1].output_xacts[0], 1);
          end
        end
        
        //This feature is applicable only for non coherent transaction.
        CONSECUTIVE_EXCLUSIVE_LOAD_FOLLOWED_BY_CONSECUTIVE_EXCLUSIVE_STORES: begin
          `svt_xvm_do_on_with(chi0_rn_seq[0], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
                {
                  sequence_length == 1;
                  seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
                  seq_lpid == 1;
                  hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
                  seq_hn_node_idx == target_hn_node_idx_0;
                  use_seq_is_non_secure_access == 0;
                  by_pass_read_data_check == 1;
                  seq_xact_type_read == svt_chi_transaction::READNOSNP;
                  seq_xact_type_excl == svt_chi_rn_exclusive_access_sequence::RD;
                }
          )
          chi0_rn_seq[0].transaction.wait_end();
          
          `svt_xvm_do_on_with(chi0_rn_seq[1], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
                {
                  sequence_length == 1;
                  seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
                  seq_lpid == 2;
                  hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                  min_addr == chi0_rn_seq[0].output_xacts[0].addr;
                  max_addr == chi0_rn_seq[0].output_xacts[0].addr;
                  seq_mem_attr_is_early_wr_ack_allowed == chi0_rn_seq[0].output_xacts[0].mem_attr_is_early_wr_ack_allowed;  
                  seq_mem_attr_mem_type                == chi0_rn_seq[0].output_xacts[0].mem_attr_mem_type;  
                  seq_mem_attr_is_cacheable            == chi0_rn_seq[0].output_xacts[0].mem_attr_is_cacheable;  
                  seq_mem_attr_allocate_hint           == chi0_rn_seq[0].output_xacts[0].mem_attr_allocate_hint;  
                  seq_snp_attr_is_snoopable            == chi0_rn_seq[0].output_xacts[0].snp_attr_is_snoopable;  
                  seq_snp_attr_snp_domain_type         == chi0_rn_seq[0].output_xacts[0].snp_attr_snp_domain_type;
                  seq_is_non_secure_access             == chi0_rn_seq[0].output_xacts[0].is_non_secure_access;
                  use_seq_is_non_secure_access == 1;
                  by_pass_read_data_check == 1;
                  seq_xact_type_read == svt_chi_transaction::READNOSNP;
                  seq_xact_type_excl == svt_chi_rn_exclusive_access_sequence::RD;
                }
          )
          chi0_rn_seq[1].transaction.wait_end();
                          
          `svt_xvm_do_on_with(chi0_rn_seq[2], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
                {
                  sequence_length == 1;
                  seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
                  seq_lpid == 3;
                  hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                  min_addr == chi0_rn_seq[0].output_xacts[0].addr;
                  max_addr == chi0_rn_seq[0].output_xacts[0].addr;
                  seq_mem_attr_is_early_wr_ack_allowed == chi0_rn_seq[0].output_xacts[0].mem_attr_is_early_wr_ack_allowed;  
                  seq_mem_attr_mem_type                == chi0_rn_seq[0].output_xacts[0].mem_attr_mem_type;  
                  seq_mem_attr_is_cacheable            == chi0_rn_seq[0].output_xacts[0].mem_attr_is_cacheable;  
                  seq_mem_attr_allocate_hint           == chi0_rn_seq[0].output_xacts[0].mem_attr_allocate_hint;  
                  seq_snp_attr_is_snoopable            == chi0_rn_seq[0].output_xacts[0].snp_attr_is_snoopable;  
                  seq_snp_attr_snp_domain_type         == chi0_rn_seq[0].output_xacts[0].snp_attr_snp_domain_type;
                  seq_is_non_secure_access             == chi0_rn_seq[0].output_xacts[0].is_non_secure_access;
                  use_seq_is_non_secure_access == 1;
                  by_pass_read_data_check == 1;
                  seq_xact_type_read == svt_chi_transaction::READNOSNP;
                  seq_xact_type_excl == svt_chi_rn_exclusive_access_sequence::RD;
                }
          )
          chi0_rn_seq[2].transaction.wait_end();
          
          `svt_xvm_create_on(chi0_rn_seq[3], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr)
              chi0_rn_seq[3].enable_outstanding = 1;
              chi0_rn_seq[3].seq_suspend_wr_data = 1;
              void'(chi0_rn_seq[3].randomize() with
                {
                  sequence_length == 1;
                  seq_order_type == svt_chi_transaction::REQ_ORDERING_REQUIRED;    
                  seq_lpid == chi0_rn_seq[0].output_xacts[0].lpid;
                  hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                  min_addr == chi0_rn_seq[0].output_xacts[0].addr;
                  max_addr == chi0_rn_seq[0].output_xacts[0].addr;
                  by_pass_read_data_check == 1;
                  
                  seq_mem_attr_is_early_wr_ack_allowed == chi0_rn_seq[0].output_xacts[0].mem_attr_is_early_wr_ack_allowed;  
                  seq_mem_attr_mem_type                == chi0_rn_seq[0].output_xacts[0].mem_attr_mem_type;  
                  seq_mem_attr_is_cacheable            == chi0_rn_seq[0].output_xacts[0].mem_attr_is_cacheable;  
                  seq_mem_attr_allocate_hint           == chi0_rn_seq[0].output_xacts[0].mem_attr_allocate_hint;  
                  seq_snp_attr_is_snoopable            == chi0_rn_seq[0].output_xacts[0].snp_attr_is_snoopable;  
                  seq_snp_attr_snp_domain_type         == chi0_rn_seq[0].output_xacts[0].snp_attr_snp_domain_type;
                  seq_is_non_secure_access             == chi0_rn_seq[0].output_xacts[0].is_non_secure_access;
                  use_seq_is_non_secure_access == 1;
                  seq_data_size                        == chi0_rn_seq[0].output_xacts[0].data_size;
                  
                  seq_xact_type_write inside {svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITENOSNPFULL};
                  if (chi0_rn_seq[0].output_xacts[0].data_size != svt_chi_transaction::SIZE_64BYTE) {
                    seq_xact_type_write == svt_chi_transaction::WRITENOSNPPTL;
                  }
                  
                  seq_xact_type_excl == svt_chi_rn_exclusive_access_sequence::WR;
                }
           );
          
           chi0_rn_seq[3].start(p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr);
                          
           `svt_xvm_create_on(chi0_rn_seq[4], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr)
           chi0_rn_seq[4].enable_outstanding = 1;
           chi0_rn_seq[4].seq_suspend_wr_data = 1;
           void'(chi0_rn_seq[4].randomize() with
                {
                  sequence_length == 1;
                  seq_order_type == svt_chi_transaction::REQ_ORDERING_REQUIRED;    
                  seq_lpid == chi0_rn_seq[1].output_xacts[0].lpid;
                  hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                  min_addr == chi0_rn_seq[0].output_xacts[0].addr;
                  max_addr == chi0_rn_seq[0].output_xacts[0].addr;
                  by_pass_read_data_check == 1;
                  
                  seq_mem_attr_is_early_wr_ack_allowed == chi0_rn_seq[1].output_xacts[0].mem_attr_is_early_wr_ack_allowed;  
                  seq_mem_attr_mem_type                == chi0_rn_seq[1].output_xacts[0].mem_attr_mem_type;  
                  seq_mem_attr_is_cacheable            == chi0_rn_seq[1].output_xacts[0].mem_attr_is_cacheable;  
                  seq_mem_attr_allocate_hint           == chi0_rn_seq[1].output_xacts[0].mem_attr_allocate_hint;  
                  seq_snp_attr_is_snoopable            == chi0_rn_seq[1].output_xacts[0].snp_attr_is_snoopable;  
                  seq_snp_attr_snp_domain_type         == chi0_rn_seq[1].output_xacts[0].snp_attr_snp_domain_type;
                  seq_is_non_secure_access             == chi0_rn_seq[1].output_xacts[0].is_non_secure_access;
                  use_seq_is_non_secure_access == 1;
                  seq_data_size                        == chi0_rn_seq[1].output_xacts[0].data_size;
                  
                  seq_xact_type_write inside {svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITENOSNPFULL};
                  if (chi0_rn_seq[1].output_xacts[0].data_size != svt_chi_transaction::SIZE_64BYTE) {
                    seq_xact_type_write == svt_chi_transaction::WRITENOSNPPTL;
                  }
                  
                  seq_xact_type_excl == svt_chi_rn_exclusive_access_sequence::WR;
                }
           );
          
           chi0_rn_seq[4].start(p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr);
                          
           `svt_xvm_create_on(chi0_rn_seq[5], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr)
           chi0_rn_seq[5].enable_outstanding = 1;
           chi0_rn_seq[5].seq_suspend_wr_data = 1;
           void'(chi0_rn_seq[5].randomize() with
                {
                  sequence_length == 1;
                  seq_order_type == svt_chi_transaction::REQ_ORDERING_REQUIRED;    
                  seq_lpid == chi0_rn_seq[2].output_xacts[0].lpid;
                  hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                  min_addr == chi0_rn_seq[0].output_xacts[0].addr;
                  max_addr == chi0_rn_seq[0].output_xacts[0].addr;
                  by_pass_read_data_check == 1;
                  
                  seq_mem_attr_is_early_wr_ack_allowed == chi0_rn_seq[2].output_xacts[0].mem_attr_is_early_wr_ack_allowed;  
                  seq_mem_attr_mem_type                == chi0_rn_seq[2].output_xacts[0].mem_attr_mem_type;  
                  seq_mem_attr_is_cacheable            == chi0_rn_seq[2].output_xacts[0].mem_attr_is_cacheable;  
                  seq_mem_attr_allocate_hint           == chi0_rn_seq[2].output_xacts[0].mem_attr_allocate_hint;  
                  seq_snp_attr_is_snoopable            == chi0_rn_seq[2].output_xacts[0].snp_attr_is_snoopable;  
                  seq_snp_attr_snp_domain_type         == chi0_rn_seq[2].output_xacts[0].snp_attr_snp_domain_type;
                  seq_is_non_secure_access             == chi0_rn_seq[2].output_xacts[0].is_non_secure_access;
                  use_seq_is_non_secure_access == 1;
                  seq_data_size                        == chi0_rn_seq[2].output_xacts[0].data_size;
                  
                  seq_xact_type_write inside {svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITENOSNPFULL};
                  if (chi0_rn_seq[2].output_xacts[0].data_size != svt_chi_transaction::SIZE_64BYTE) {
                    seq_xact_type_write == svt_chi_transaction::WRITENOSNPPTL;
                  }
                  
                  seq_xact_type_excl == svt_chi_rn_exclusive_access_sequence::WR;
                }
           );
          
           chi0_rn_seq[5].start(p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr);

          //Wait till the DBID/DBIDRESPORD is received for the first store and then resume the write transaction.
          `ifdef SVT_CHI_ISSUE_E_ENABLE
           wait (chi0_rn_seq[3].output_xacts[0].is_dbid_received == 1 || chi0_rn_seq[3].output_xacts[0].is_dbidrespord_received == 1);
          `else
           wait (chi0_rn_seq[3].output_xacts[0].is_dbid_received == 1)
          `endif
          chi0_rn_seq[3].output_xacts[0].suspend_wr_data = 0;

          //Wait till the DBID/DBIDRESPORD is received for the second store and then resume the write transaction.
          `ifdef SVT_CHI_ISSUE_E_ENABLE
           wait (chi0_rn_seq[4].output_xacts[0].is_dbid_received == 1 || chi0_rn_seq[4].output_xacts[0].is_dbidrespord_received == 1);
          `else
           wait (chi0_rn_seq[4].output_xacts[0].is_dbid_received == 1)
          `endif

          chi0_rn_seq[4].output_xacts[0].suspend_wr_data = 0;

          //Wait till the DBID/DBIDRESPORD is received for the  third store and then resume the write transaction.
          `ifdef SVT_CHI_ISSUE_E_ENABLE
          wait (chi0_rn_seq[5].output_xacts[0].is_dbid_received == 1 || chi0_rn_seq[5].output_xacts[0].is_dbidrespord_received == 1);
          `else
           wait (chi0_rn_seq[5].output_xacts[0].is_dbid_received == 1 )
          `endif
          chi0_rn_seq[5].output_xacts[0].suspend_wr_data = 0;
          
          //The first store should Pass with RespErr field equal to EXCLUSIVE_OKAY
          check_exclusive_sequence_validity(NON_COHERENT, chi0_rn_seq[3].output_xacts[0], 1);
          
          //The second store should fail with RespErr field equal to NORMAL_OKAY
          check_exclusive_sequence_validity(NON_COHERENT, chi0_rn_seq[4].output_xacts[0], 0);
          
          //The third store should fail with RespErr field equal to NORMAL_OKAY
          check_exclusive_sequence_validity(NON_COHERENT, chi0_rn_seq[5].output_xacts[0], 0);
        end
        
        CONSECUTIVE_EXCLUSIVE_LOAD_FOLLOWED_BY_CONSECUTIVE_ORDERED_EXCLUSIVE_STORES: begin
          `svt_xvm_do_on_with(chi0_rn_seq[0], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
                {
                  sequence_length == 1;
                  seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
                  seq_lpid == 1;
                  hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
                  seq_hn_node_idx == target_hn_node_idx_0;
                  use_seq_is_non_secure_access == 0;
                  by_pass_read_data_check == 1;
                  seq_xact_type_read == svt_chi_transaction::READNOSNP;
                  seq_xact_type_excl == svt_chi_rn_exclusive_access_sequence::RD;
                }
          )
          chi0_rn_seq[0].transaction.wait_end();
          
          `svt_xvm_do_on_with(chi0_rn_seq[1], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
                {
                  sequence_length == 1;
                  seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
                  seq_lpid == 2;
                  hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                  min_addr == chi0_rn_seq[0].output_xacts[0].addr;
                  max_addr == chi0_rn_seq[0].output_xacts[0].addr;
                  seq_mem_attr_is_early_wr_ack_allowed == chi0_rn_seq[0].output_xacts[0].mem_attr_is_early_wr_ack_allowed;  
                  seq_mem_attr_mem_type                == chi0_rn_seq[0].output_xacts[0].mem_attr_mem_type;  
                  seq_mem_attr_is_cacheable            == chi0_rn_seq[0].output_xacts[0].mem_attr_is_cacheable;  
                  seq_mem_attr_allocate_hint           == chi0_rn_seq[0].output_xacts[0].mem_attr_allocate_hint;  
                  seq_snp_attr_is_snoopable            == chi0_rn_seq[0].output_xacts[0].snp_attr_is_snoopable;  
                  seq_snp_attr_snp_domain_type         == chi0_rn_seq[0].output_xacts[0].snp_attr_snp_domain_type;
                  seq_is_non_secure_access             == chi0_rn_seq[0].output_xacts[0].is_non_secure_access;
                  use_seq_is_non_secure_access == 1;
                  by_pass_read_data_check == 1;
                  seq_xact_type_read == svt_chi_transaction::READNOSNP;
                  seq_xact_type_excl == svt_chi_rn_exclusive_access_sequence::RD;
                }
          )
          chi0_rn_seq[1].transaction.wait_end();
                          
          `svt_xvm_do_on_with(chi0_rn_seq[2], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
                {
                  sequence_length == 1;
                  seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
                  seq_lpid == 3;
                  hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                  min_addr == chi0_rn_seq[0].output_xacts[0].addr;
                  max_addr == chi0_rn_seq[0].output_xacts[0].addr;
                  seq_mem_attr_is_early_wr_ack_allowed == chi0_rn_seq[0].output_xacts[0].mem_attr_is_early_wr_ack_allowed;  
                  seq_mem_attr_mem_type                == chi0_rn_seq[0].output_xacts[0].mem_attr_mem_type;  
                  seq_mem_attr_is_cacheable            == chi0_rn_seq[0].output_xacts[0].mem_attr_is_cacheable;  
                  seq_mem_attr_allocate_hint           == chi0_rn_seq[0].output_xacts[0].mem_attr_allocate_hint;  
                  seq_snp_attr_is_snoopable            == chi0_rn_seq[0].output_xacts[0].snp_attr_is_snoopable;  
                  seq_snp_attr_snp_domain_type         == chi0_rn_seq[0].output_xacts[0].snp_attr_snp_domain_type;
                  seq_is_non_secure_access             == chi0_rn_seq[0].output_xacts[0].is_non_secure_access;
                  use_seq_is_non_secure_access == 1;
                  by_pass_read_data_check == 1;
                  seq_xact_type_read == svt_chi_transaction::READNOSNP;
                  seq_xact_type_excl == svt_chi_rn_exclusive_access_sequence::RD;
                }
          )
          chi0_rn_seq[2].transaction.wait_end();
          
          `svt_xvm_create_on(chi0_rn_seq[3], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr)
              chi0_rn_seq[3].enable_outstanding = 1;
              chi0_rn_seq[3].seq_suspend_wr_data = 1;
              void'(chi0_rn_seq[3].randomize() with
                {
                  sequence_length == 1;
                  seq_order_type == svt_chi_transaction::REQ_ORDERING_REQUIRED;    
                  seq_lpid == chi0_rn_seq[0].output_xacts[0].lpid;
                  hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                  min_addr == chi0_rn_seq[0].output_xacts[0].addr;
                  max_addr == chi0_rn_seq[0].output_xacts[0].addr;
                  by_pass_read_data_check == 1;
                  
                  seq_mem_attr_is_early_wr_ack_allowed == chi0_rn_seq[0].output_xacts[0].mem_attr_is_early_wr_ack_allowed;  
                  seq_mem_attr_mem_type                == chi0_rn_seq[0].output_xacts[0].mem_attr_mem_type;  
                  seq_mem_attr_is_cacheable            == chi0_rn_seq[0].output_xacts[0].mem_attr_is_cacheable;  
                  seq_mem_attr_allocate_hint           == chi0_rn_seq[0].output_xacts[0].mem_attr_allocate_hint;  
                  seq_snp_attr_is_snoopable            == chi0_rn_seq[0].output_xacts[0].snp_attr_is_snoopable;  
                  seq_snp_attr_snp_domain_type         == chi0_rn_seq[0].output_xacts[0].snp_attr_snp_domain_type;
                  seq_is_non_secure_access             == chi0_rn_seq[0].output_xacts[0].is_non_secure_access;
                  use_seq_is_non_secure_access == 1;
                  seq_data_size                        == chi0_rn_seq[0].output_xacts[0].data_size;
                  
                  seq_xact_type_write inside {svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITENOSNPFULL};
                  if (chi0_rn_seq[3].output_xacts[0].data_size != svt_chi_transaction::SIZE_64BYTE) {
                    seq_xact_type_write == svt_chi_transaction::WRITENOSNPPTL;
                  }
                  
                  seq_xact_type_excl == svt_chi_rn_exclusive_access_sequence::WR;
                }
           );
          
           chi0_rn_seq[3].start(p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr);
           `svt_xvm_create_on(chi0_rn_seq[4], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr)
           chi0_rn_seq[4].enable_outstanding = 1;
           chi0_rn_seq[4].seq_suspend_wr_data = 1;
           void'(chi0_rn_seq[4].randomize() with
                {
                  sequence_length == 1;
                  seq_order_type == svt_chi_transaction::REQ_ORDERING_REQUIRED;    
                  seq_lpid == chi0_rn_seq[1].output_xacts[0].lpid;
                  hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                  min_addr == chi0_rn_seq[0].output_xacts[0].addr;
                  max_addr == chi0_rn_seq[0].output_xacts[0].addr;
                  use_seq_is_non_secure_access == 1;
                  by_pass_read_data_check == 1;
                  
                  seq_mem_attr_is_early_wr_ack_allowed == chi0_rn_seq[1].output_xacts[0].mem_attr_is_early_wr_ack_allowed;  
                  seq_mem_attr_mem_type                == chi0_rn_seq[1].output_xacts[0].mem_attr_mem_type;  
                  seq_mem_attr_is_cacheable            == chi0_rn_seq[1].output_xacts[0].mem_attr_is_cacheable;  
                  seq_mem_attr_allocate_hint           == chi0_rn_seq[1].output_xacts[0].mem_attr_allocate_hint;  
                  seq_snp_attr_is_snoopable            == chi0_rn_seq[1].output_xacts[0].snp_attr_is_snoopable;  
                  seq_snp_attr_snp_domain_type         == chi0_rn_seq[1].output_xacts[0].snp_attr_snp_domain_type;
                  seq_is_non_secure_access             == chi0_rn_seq[1].output_xacts[0].is_non_secure_access;
                  seq_data_size                        == chi0_rn_seq[1].output_xacts[0].data_size;
                  
                  seq_xact_type_write inside {svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITENOSNPFULL};
                  if (chi0_rn_seq[4].output_xacts[0].data_size != svt_chi_transaction::SIZE_64BYTE) {
                    seq_xact_type_write == svt_chi_transaction::WRITENOSNPPTL;
                  }
                  
                  seq_xact_type_excl == svt_chi_rn_exclusive_access_sequence::WR;
                }
           );
          
           chi0_rn_seq[4].start(p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr);
                          
           `svt_xvm_create_on(chi0_rn_seq[5], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr)
           chi0_rn_seq[5].enable_outstanding = 1;
           chi0_rn_seq[5].seq_suspend_wr_data = 1;
           void'(chi0_rn_seq[5].randomize() with
                {
                  sequence_length == 1;
                  seq_order_type == svt_chi_transaction::REQ_ORDERING_REQUIRED;    
                  seq_lpid == chi0_rn_seq[2].output_xacts[0].lpid;
                  hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                  min_addr == chi0_rn_seq[0].output_xacts[0].addr;
                  max_addr == chi0_rn_seq[0].output_xacts[0].addr;
                  use_seq_is_non_secure_access == 1;
                  by_pass_read_data_check == 1;
                  
                  seq_mem_attr_is_early_wr_ack_allowed == chi0_rn_seq[2].output_xacts[0].mem_attr_is_early_wr_ack_allowed;  
                  seq_mem_attr_mem_type                == chi0_rn_seq[2].output_xacts[0].mem_attr_mem_type;  
                  seq_mem_attr_is_cacheable            == chi0_rn_seq[2].output_xacts[0].mem_attr_is_cacheable;  
                  seq_mem_attr_allocate_hint           == chi0_rn_seq[2].output_xacts[0].mem_attr_allocate_hint;  
                  seq_snp_attr_is_snoopable            == chi0_rn_seq[2].output_xacts[0].snp_attr_is_snoopable;  
                  seq_snp_attr_snp_domain_type         == chi0_rn_seq[2].output_xacts[0].snp_attr_snp_domain_type;
                  seq_is_non_secure_access             == chi0_rn_seq[2].output_xacts[0].is_non_secure_access;
                  seq_data_size                        == chi0_rn_seq[2].output_xacts[0].data_size;
                  
                  seq_xact_type_write inside {svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITENOSNPFULL};
                  if (chi0_rn_seq[5].output_xacts[0].data_size != svt_chi_transaction::SIZE_64BYTE) {
                    seq_xact_type_write == svt_chi_transaction::WRITENOSNPPTL;
                  }
                  
                  seq_xact_type_excl == svt_chi_rn_exclusive_access_sequence::WR;
                }
           );
          
           chi0_rn_seq[5].start(p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr);

           //Wait till the DBID is recieved for all the stores.
           `ifdef SVT_CHI_ISSUE_E_ENABLE
           wait (chi0_rn_seq[3].output_xacts[0].is_dbid_received == 1 || chi0_rn_seq[3].output_xacts[0].is_dbidrespord_received == 1);
           wait (chi0_rn_seq[4].output_xacts[0].is_dbid_received == 1 || chi0_rn_seq[4].output_xacts[0].is_dbidrespord_received == 1);
           wait (chi0_rn_seq[5].output_xacts[0].is_dbid_received == 1 || chi0_rn_seq[5].output_xacts[0].is_dbidrespord_received == 1);
           `else
           wait (chi0_rn_seq[3].output_xacts[0].is_dbid_received == 1 );
           wait (chi0_rn_seq[4].output_xacts[0].is_dbid_received == 1 );
           wait (chi0_rn_seq[5].output_xacts[0].is_dbid_received == 1 );
           `endif
          
           //Resume the first store transaction and wait for it to complete.
           chi0_rn_seq[3].output_xacts[0].suspend_wr_data = 0;
           chi0_rn_seq[3].transaction.wait_end();

          //Resume the second store transaction and wait for it to complete.
          chi0_rn_seq[4].output_xacts[0].suspend_wr_data = 0;
          chi0_rn_seq[4].transaction.wait_end();

          //Resume the third store transaction and wait for it to complete.
          chi0_rn_seq[5].output_xacts[0].suspend_wr_data = 0;
          chi0_rn_seq[5].transaction.wait_end();
          
          //The first store should pass with RespErr field equal to EXCLUSIVE_OKAY
          check_exclusive_sequence_validity(select_transaction_type, chi0_rn_seq[3].output_xacts[0], 1);
          
          //The second store should fail with RespErr field equal to NORMAL_OKAY
          check_exclusive_sequence_validity(select_transaction_type, chi0_rn_seq[4].output_xacts[0], 0);
          
          //The third store should fail with RespErr field equal to NORMAL_OKAY
          check_exclusive_sequence_validity(select_transaction_type, chi0_rn_seq[5].output_xacts[0], 0);
        end
        EXCLUSIVE_LOAD_FOLLOWED_BY_MULTIPLE_EXCLUSIVE_STORE: begin
          `svt_xvm_do_on_with(chi0_rn_seq[0], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
            {
              sequence_length == 1;
              seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
              if (perform_cache_initialization) {
                hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                min_addr == addr1;
                max_addr == addr1;
                seq_snp_attr_snp_domain_type == vir_seq_snp_attr_snp_domain_type;
                seq_mem_attr_allocate_hint == vir_seq_mem_attr_allocate_hint;
                seq_is_non_secure_access == vir_seq_is_non_secure_access;
                use_seq_is_non_secure_access == 1;
                data_in_cache == temp_data_1;
                by_pass_read_data_check == 0;
              }
              else {
                hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
                seq_hn_node_idx == target_hn_node_idx_0;
                by_pass_read_data_check == 1;
                use_seq_is_non_secure_access == 0;
              }
              if (select_rn_f_node) {
                if (select_transaction_type == COHERENT) {
                  `ifdef SVT_CHI_ISSUE_B_ENABLE
                  if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type_read != svt_chi_transaction::READNOTSHAREDDIRTY;
                  `endif
                  `ifdef SVT_CHI_ISSUE_E_ENABLE
                  if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision <= svt_chi_node_configuration::ISSUE_D) seq_xact_type_read != svt_chi_transaction::READPREFERUNIQUE;
                  `endif
                  seq_xact_type_read != svt_chi_transaction::READNOSNP;
                } 
              }
              seq_xact_type_excl == svt_chi_rn_exclusive_access_sequence::RD;
            }
          )
          chi0_rn_seq[0].output_xacts[0].wait_end();
           
          rand_subsequent_store = $urandom_range(2,5);
          
          for (int i = 1; i <= rand_subsequent_store; i++) begin
            `svt_xvm_do_on_with(chi0_rn_seq[i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
              {
                sequence_length == 1;
                seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;    
                seq_lpid == chi0_rn_seq[0].output_xacts[0].lpid;
                if (perform_cache_initialization) {
                  hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                  min_addr == addr1;
                  max_addr == addr1;
                  seq_snp_attr_snp_domain_type == vir_seq_snp_attr_snp_domain_type;
                  seq_mem_attr_allocate_hint == vir_seq_mem_attr_allocate_hint;
                  seq_is_non_secure_access == vir_seq_is_non_secure_access;
                  use_seq_is_non_secure_access == 1;
                  data_in_cache == temp_data_1;
                  by_pass_read_data_check == 0;
                }
                else {
                  hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                  min_addr == chi0_rn_seq[0].output_xacts[0].addr;
                  max_addr == chi0_rn_seq[0].output_xacts[0].addr;
                  if (select_transaction_type == COHERENT) {
                    seq_snp_attr_snp_domain_type         == chi0_rn_seq[0].output_xacts[0].snp_attr_snp_domain_type;
                    seq_mem_attr_allocate_hint           == chi0_rn_seq[0].output_xacts[0].mem_attr_allocate_hint;  
                    seq_is_non_secure_access             == chi0_rn_seq[0].output_xacts[0].is_non_secure_access;
                    use_seq_is_non_secure_access == 1;
                  }
                  by_pass_read_data_check == 1;
                }
                if (select_rn_f_node) {
                  if (select_transaction_type == COHERENT) {
                    !(seq_xact_type_write inside {svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITENOSNPFULL});
                    `ifdef SVT_CHI_ISSUE_E_ENABLE
                    if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision <= svt_chi_node_configuration::ISSUE_D) seq_xact_type_write != svt_chi_transaction::MAKEREADUNIQUE;
                    `endif
                  }
                }
                seq_xact_type_excl == svt_chi_rn_exclusive_access_sequence::WR;
              }
            )
            chi0_rn_seq[i].output_xacts[0].wait_end();
            cache_status = my_cache.get_status(chi0_rn_seq[0].output_xacts[0].get_aligned_addr_to_cache_line_size(1),is_unique,is_clean);
            if(cache_status == 1 && is_unique ==1) begin
              cache_status = my_cache.update_status(chi0_rn_seq[0].output_xacts[0].get_aligned_addr_to_cache_line_size(1),0,-1);
              if(!cache_status) begin
                //`svt_xvm_error("body",$psprintf("Backdoor update for moving the cachestate to shared state failed for address - %h", chi0_rn_seq[0].output_xacts[0].addr));
              end
              else begin
                `svt_xvm_debug("body",$psprintf("Backdoor update for moving the cachestate to shared state is successful for address - %h", chi0_rn_seq[0].output_xacts[0].addr));
              end
            end
          end
          for (int i = 1; i <= rand_subsequent_store; i++) begin
            // LPID should be the same for load and store.      
            if (chi0_rn_seq[0].output_xacts[0].lpid == chi0_rn_seq[i].output_xacts[0].lpid) begin
              // pass
              `svt_xvm_debug("body", $sformatf("LPID match: LPID 'd%0d is same for Load and store initiated from RN1", chi0_rn_seq[0].output_xacts[0].lpid));
            end
            else begin
              // fail
              `svt_xvm_error("body", $sformatf("LPID mismatch: LPID is expected to be the same for Load and store initiated from RN1, but that is not the case. Transaction %0s from rn[%0d] has LPID 'd%0d, transaction %0s from rn[%0d] has LPId 'd%0d ", `SVT_CHI_PRINT_PREFIX(chi0_rn_seq[0].output_xacts[0]), initiating_rn_node_idx_0, chi0_rn_seq[0].output_xacts[0].lpid, `SVT_CHI_PRINT_PREFIX(chi0_rn_seq[i].output_xacts[0]), initiating_rn_node_idx_0, chi0_rn_seq[i].output_xacts[0].lpid));
            end
            //All the exclusive store should pass
            check_exclusive_sequence_validity(select_transaction_type, chi0_rn_seq[i].output_xacts[0], 1);
          end
        end
        EXCLUSIVE_STORE_WITHOUT_LOAD: begin
          `svt_xvm_create_on(chi0_rn_seq[0], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr)
          chi0_rn_seq[0].bypass_mapping_of_attr = 1;
          void'(chi0_rn_seq[0].randomize() with
            {
              sequence_length == 1;
              seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
              if (perform_cache_initialization) {
                hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                min_addr == addr1;
                max_addr == addr1;
                seq_snp_attr_snp_domain_type == vir_seq_snp_attr_snp_domain_type;
                seq_mem_attr_allocate_hint == vir_seq_mem_attr_allocate_hint;
                seq_is_non_secure_access == vir_seq_is_non_secure_access;
                use_seq_is_non_secure_access == 0;
                data_in_cache == temp_data_1;
                by_pass_read_data_check == 0;
              }
              else {
                hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
                seq_hn_node_idx == target_hn_node_idx_0;
                by_pass_read_data_check == 1;
                use_seq_is_non_secure_access == 0;
              }
              if (select_rn_f_node) {
                if (select_transaction_type == COHERENT) {
                  !(seq_xact_type_write inside {svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITENOSNPFULL});
                  `ifdef SVT_CHI_ISSUE_E_ENABLE
                  if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision <= svt_chi_node_configuration::ISSUE_D) seq_xact_type_write != svt_chi_transaction::MAKEREADUNIQUE;
                  `endif
                }
              }
              seq_xact_type_excl == svt_chi_rn_exclusive_access_sequence::WR;
            }
          );
          chi0_rn_seq[0].start(p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr);
          chi0_rn_seq[0].transaction.wait_end();
          
          cache_status = my_cache.get_status(chi0_rn_seq[0].output_xacts[0].get_aligned_addr_to_cache_line_size(1),is_unique,is_clean);
          if(cache_status == 1 && is_unique == 1) begin
            cache_status = my_cache.update_status(chi0_rn_seq[0].output_xacts[0].get_aligned_addr_to_cache_line_size(1),0,-1);
            if(!cache_status) begin
              //`svt_xvm_error("body",$psprintf("Backdoor update for moving the cachestate to shared state failed for address - %h", chi0_rn_seq[0].output_xacts[0].addr));
            end
            else begin
              `svt_xvm_debug("body",$psprintf("Backdoor update for moving the cachestate to shared state is successful for address - %h", chi0_rn_seq[0].output_xacts[0].addr));
            end
          end
          
          //The exclusive store should pass
          check_exclusive_sequence_validity(select_transaction_type, chi0_rn_seq[0].output_xacts[0], 1);
        end
                
        EXCLUSIVE_LOAD_FOLLOWED_BY_EXCLUSIVE_SECURE_SEQ_FOLLOWED_BY_EXCLUSIVE_STORE: begin
          `svt_xvm_do_on_with(chi0_rn_seq[0], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
            {
              sequence_length == 1;
              seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
              if (perform_cache_initialization) {
                hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                min_addr == addr1;
                max_addr == addr1;
                seq_snp_attr_snp_domain_type == vir_seq_snp_attr_snp_domain_type;
                seq_mem_attr_allocate_hint == vir_seq_mem_attr_allocate_hint;
                seq_is_non_secure_access == vir_seq_is_non_secure_access;
                use_seq_is_non_secure_access == 1;
                data_in_cache == temp_data_1;
                by_pass_read_data_check == 0;
              }
              else {
                hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
                seq_hn_node_idx == target_hn_node_idx_0;
                by_pass_read_data_check == 1;
                use_seq_is_non_secure_access == 0;
              }
              if (select_rn_f_node) {
                if (select_transaction_type == COHERENT) {
                  `ifdef SVT_CHI_ISSUE_B_ENABLE
                  if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type_read != svt_chi_transaction::READNOTSHAREDDIRTY;
                  `endif
                  `ifdef SVT_CHI_ISSUE_E_ENABLE
                  if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision <= svt_chi_node_configuration::ISSUE_D) seq_xact_type_read != svt_chi_transaction::READPREFERUNIQUE;
                  `endif
                  seq_xact_type_read != svt_chi_transaction::READNOSNP;
                } 
                else if (select_transaction_type == NON_COHERENT){
                  seq_xact_type_read == svt_chi_transaction::READNOSNP;
                }  
              }
              if (select_rn_i_node || select_rn_d_node) {
                seq_xact_type_read == svt_chi_transaction::READNOSNP;  
              }
              seq_xact_type_excl == svt_chi_rn_exclusive_access_sequence::RD;
            }
          )
          
          chi0_rn_seq[0].output_xacts[0].wait_end();
          
          `svt_xvm_do_on_with(chi0_rn_seq[2], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
            {
              sequence_length == 1;
              seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
              if (perform_cache_initialization) {
                hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                min_addr == addr1;
                max_addr == addr1;
                seq_snp_attr_snp_domain_type == vir_seq_snp_attr_snp_domain_type;
                seq_mem_attr_allocate_hint == vir_seq_mem_attr_allocate_hint;
                seq_is_non_secure_access == (!chi0_rn_seq[0].output_xacts[0].is_non_secure_access);
                use_seq_is_non_secure_access == 1;
                data_in_cache == temp_data_1;
                by_pass_read_data_check == 1;
              }
              else {
                hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
                seq_hn_node_idx == target_hn_node_idx_0;
                by_pass_read_data_check == 1;
                use_seq_is_non_secure_access == 0;
              }
              if (select_rn_f_node) {
                if (select_transaction_type == COHERENT) {
                  `ifdef SVT_CHI_ISSUE_B_ENABLE
                  if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type_read != svt_chi_transaction::READNOTSHAREDDIRTY;
                  `endif
                  `ifdef SVT_CHI_ISSUE_E_ENABLE
                  if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision <= svt_chi_node_configuration::ISSUE_D) seq_xact_type_read != svt_chi_transaction::READPREFERUNIQUE;
                  `endif
                  seq_xact_type_read != svt_chi_transaction::READNOSNP;
                } 
                else if (select_transaction_type == NON_COHERENT){
                  seq_xact_type_read == svt_chi_transaction::READNOSNP;
                }  
              }
              if (select_rn_i_node || select_rn_d_node) {
                seq_xact_type_read == svt_chi_transaction::READNOSNP;  
              }
              seq_xact_type_excl == svt_chi_rn_exclusive_access_sequence::RD;
            }
          )
          
          chi0_rn_seq[2].output_xacts[0].wait_end();
          
          cache_status = my_cache.get_status(chi0_rn_seq[2].output_xacts[0].get_aligned_addr_to_cache_line_size(1),is_unique,is_clean);
          if(cache_status == 1 && is_unique == 1) begin
            cache_status = my_cache.update_status(chi0_rn_seq[2].output_xacts[0].get_aligned_addr_to_cache_line_size(1),0,-1);
            if(!cache_status) begin
              //`svt_xvm_error("body",$psprintf("Backdoor update for moving the cachestate to shared state failed for address - %h", chi0_rn_seq[2].output_xacts[0].addr));
            end
            else begin
              `svt_xvm_debug("body",$psprintf("Backdoor update for moving the cachestate to shared state is successful for address - %h", chi0_rn_seq[2].output_xacts[0].addr));
            end
          end
          
          `svt_xvm_do_on_with(chi0_rn_seq[3], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
            {
              sequence_length == 1;
              seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;    
              seq_lpid == chi0_rn_seq[2].output_xacts[0].lpid;
              if (perform_cache_initialization) {
                hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                min_addr == addr1;
                max_addr == addr1;
                seq_snp_attr_snp_domain_type == vir_seq_snp_attr_snp_domain_type;
                seq_mem_attr_allocate_hint == vir_seq_mem_attr_allocate_hint;
                seq_is_non_secure_access == chi0_rn_seq[2].output_xacts[0].is_non_secure_access;
                use_seq_is_non_secure_access == 1;
                data_in_cache == temp_data_1;
                by_pass_read_data_check == 1;
              }
              else {
                hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                min_addr == chi0_rn_seq[2].output_xacts[0].addr;
                max_addr == chi0_rn_seq[2].output_xacts[0].addr;
                if (select_transaction_type == COHERENT) {
                  seq_snp_attr_snp_domain_type         == chi0_rn_seq[2].output_xacts[0].snp_attr_snp_domain_type;
                  seq_mem_attr_allocate_hint           == chi0_rn_seq[2].output_xacts[0].mem_attr_allocate_hint;  
                  seq_is_non_secure_access             == chi0_rn_seq[2].output_xacts[0].is_non_secure_access;
                  use_seq_is_non_secure_access == 1;
                }
                else if (select_transaction_type == NON_COHERENT) {
                  seq_mem_attr_is_early_wr_ack_allowed == chi0_rn_seq[2].output_xacts[0].mem_attr_is_early_wr_ack_allowed;  
                  seq_mem_attr_mem_type                == chi0_rn_seq[2].output_xacts[0].mem_attr_mem_type;  
                  seq_mem_attr_is_cacheable            == chi0_rn_seq[2].output_xacts[0].mem_attr_is_cacheable;  
                  seq_mem_attr_allocate_hint           == chi0_rn_seq[2].output_xacts[0].mem_attr_allocate_hint;  
                  seq_snp_attr_is_snoopable            == chi0_rn_seq[2].output_xacts[0].snp_attr_is_snoopable;  
                  seq_snp_attr_snp_domain_type         == chi0_rn_seq[2].output_xacts[0].snp_attr_snp_domain_type;
                  seq_is_non_secure_access             == chi0_rn_seq[2].output_xacts[0].is_non_secure_access;
                  use_seq_is_non_secure_access == 1;
                  seq_data_size                        == chi0_rn_seq[2].output_xacts[0].data_size;
                }
                by_pass_read_data_check == 1;
              }
              if (select_rn_f_node) {
                if (select_transaction_type == COHERENT) {
                  !(seq_xact_type_write inside {svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITENOSNPFULL});
                  `ifdef SVT_CHI_ISSUE_E_ENABLE
                  if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision <= svt_chi_node_configuration::ISSUE_D) seq_xact_type_write != svt_chi_transaction::MAKEREADUNIQUE;
                  `endif
                }
                if (select_transaction_type == NON_COHERENT) {
                  seq_xact_type_write inside {svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITENOSNPFULL};
                  if (chi0_rn_seq[2].output_xacts[0].data_size != svt_chi_transaction::SIZE_64BYTE) {
                    seq_xact_type_write == svt_chi_transaction::WRITENOSNPPTL;
                  }
                }
              }
              if (select_rn_i_node || select_rn_d_node) {
                seq_xact_type_write inside {svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITENOSNPFULL};
                if (chi0_rn_seq[2].output_xacts[0].data_size != svt_chi_transaction::SIZE_64BYTE) {
                  seq_xact_type_write == svt_chi_transaction::WRITENOSNPPTL;
                }
              }
              seq_xact_type_excl == svt_chi_rn_exclusive_access_sequence::WR;
            }
          )
          
          chi0_rn_seq[3].output_xacts[0].wait_end();
          
          `svt_xvm_do_on_with(chi0_rn_seq[1], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
            {
              sequence_length == 1;
              seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;    
              seq_lpid == chi0_rn_seq[0].output_xacts[0].lpid;
              if (perform_cache_initialization) {
                hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                min_addr == addr1;
                max_addr == addr1;
                seq_snp_attr_snp_domain_type == vir_seq_snp_attr_snp_domain_type;
                seq_mem_attr_allocate_hint == vir_seq_mem_attr_allocate_hint;
                use_seq_is_non_secure_access == 1;
                seq_is_non_secure_access == chi0_rn_seq[0].output_xacts[0].is_non_secure_access;
                data_in_cache == temp_data_1;
                by_pass_read_data_check == 0;
              }
              else {
                hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                min_addr == chi0_rn_seq[0].output_xacts[0].addr;
                max_addr == chi0_rn_seq[0].output_xacts[0].addr;
                if (select_transaction_type == COHERENT) {
                  seq_snp_attr_snp_domain_type         == chi0_rn_seq[0].output_xacts[0].snp_attr_snp_domain_type;
                  seq_mem_attr_allocate_hint           == chi0_rn_seq[0].output_xacts[0].mem_attr_allocate_hint;  
                  seq_is_non_secure_access             == chi0_rn_seq[0].output_xacts[0].is_non_secure_access;
                  use_seq_is_non_secure_access == 1;
                }
                else if (select_transaction_type == NON_COHERENT) {
                  seq_mem_attr_is_early_wr_ack_allowed == chi0_rn_seq[0].output_xacts[0].mem_attr_is_early_wr_ack_allowed;  
                  seq_mem_attr_mem_type                == chi0_rn_seq[0].output_xacts[0].mem_attr_mem_type;  
                  seq_mem_attr_is_cacheable            == chi0_rn_seq[0].output_xacts[0].mem_attr_is_cacheable;  
                  seq_mem_attr_allocate_hint           == chi0_rn_seq[0].output_xacts[0].mem_attr_allocate_hint;  
                  seq_snp_attr_is_snoopable            == chi0_rn_seq[0].output_xacts[0].snp_attr_is_snoopable;  
                  seq_snp_attr_snp_domain_type         == chi0_rn_seq[0].output_xacts[0].snp_attr_snp_domain_type;
                  seq_is_non_secure_access             == chi0_rn_seq[0].output_xacts[0].is_non_secure_access;
                  use_seq_is_non_secure_access == 1;
                  seq_data_size                        == chi0_rn_seq[0].output_xacts[0].data_size;
                }
                by_pass_read_data_check == 1;
              }
              if (select_rn_f_node) {
                if (select_transaction_type == COHERENT) {
                  !(seq_xact_type_write inside {svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITENOSNPFULL});
                  `ifdef SVT_CHI_ISSUE_E_ENABLE
                  if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision <= svt_chi_node_configuration::ISSUE_D) seq_xact_type_write != svt_chi_transaction::MAKEREADUNIQUE;
                  `endif
                }
                if (select_transaction_type == NON_COHERENT) {
                  seq_xact_type_write inside {svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITENOSNPFULL};
                  if (chi0_rn_seq[0].output_xacts[0].data_size != svt_chi_transaction::SIZE_64BYTE) {
                    seq_xact_type_write == svt_chi_transaction::WRITENOSNPPTL;
                  }
                }
              }
              if (select_rn_i_node || select_rn_d_node) {
                seq_xact_type_write inside {svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITENOSNPFULL};
                if (chi0_rn_seq[0].output_xacts[0].data_size != svt_chi_transaction::SIZE_64BYTE) {
                  seq_xact_type_write == svt_chi_transaction::WRITENOSNPPTL;
                }
              }
              seq_xact_type_excl == svt_chi_rn_exclusive_access_sequence::WR;
            }
          )
          
          chi0_rn_seq[1].output_xacts[0].wait_end();
              
          // LPID should be the same for Load and store initiated from RN1.      
          if (chi0_rn_seq[0].output_xacts[0].lpid == chi0_rn_seq[1].output_xacts[0].lpid) begin
            // pass
            `svt_xvm_debug("body", $sformatf("LPID match: LPID 'd%0d is same for Load and store initiated from RN1", chi0_rn_seq[0].output_xacts[0].lpid));
          end
          else begin
            // fail
            `svt_xvm_error("body", $sformatf("LPID mismatch: LPID is expected to be the same for Load and store initiated from RN1, but that is not the case. Transaction %0s from rn[%0d] has LPID 'd%0d, transaction %0s from rn[%0d] has LPId 'd%0d ", `SVT_CHI_PRINT_PREFIX(chi0_rn_seq[0].output_xacts[0]), initiating_rn_node_idx_0, chi0_rn_seq[0].output_xacts[0].lpid, `SVT_CHI_PRINT_PREFIX(chi0_rn_seq[1].output_xacts[0]), initiating_rn_node_idx_0, chi0_rn_seq[1].output_xacts[0].lpid));
          end
          // LPID should be the same for Load and store initiated from RN2.      
          if (chi0_rn_seq[2].output_xacts[0].lpid == chi0_rn_seq[3].output_xacts[0].lpid) begin
            // pass
            `svt_xvm_debug("body", $sformatf("LPID match: LPID 'd%0d is same for Load and store initiated from RN1", chi0_rn_seq[2].output_xacts[0].lpid));
          end
          else begin
            // fail
            `svt_xvm_error("body", $sformatf("LPID mismatch: LPID is expected to be the same for Load and store initiated from RN1, but that is not the case. Transaction %0s from rn[%0d] has LPID 'd%0d, transaction %0s from rn[%0d] has LPId 'd%0d ", `SVT_CHI_PRINT_PREFIX(chi0_rn_seq[2].output_xacts[0]), initiating_rn_node_idx_1, chi0_rn_seq[2].output_xacts[0].lpid, `SVT_CHI_PRINT_PREFIX(chi0_rn_seq[3].output_xacts[0]), initiating_rn_node_idx_1, chi0_rn_seq[3].output_xacts[0].lpid));
          end
          
          //The exclusive sequence from RN with same NS should pass
          check_exclusive_sequence_validity(select_transaction_type, chi0_rn_seq[1].output_xacts[0], 1);
          
          //The exclusive sequence from RN from same NS should pass
          check_exclusive_sequence_validity(select_transaction_type, chi0_rn_seq[3].output_xacts[0], 1);
        end
        
        DIRECTED_EXCLUSIVE_SEQUENCE_WITH_LOAD_STORE_RETRIED: begin
          `svt_xvm_create_on(chi0_rn_seq[0], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr)
          case (p_crd_return_for_load)
            LOAD_RETRIED: begin
              chi0_rn_seq[0].p_crd_return_on_retry_ack_load = 0;
            end
            LOAD_RETRIED_AND_CANCELLED: begin
              chi0_rn_seq[0].p_crd_return_on_retry_ack_load = 1;
            end
          endcase
          void'(chi0_rn_seq[0].randomize() with
                 {
                   sequence_length == 1;
                   seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
                   if (perform_cache_initialization) {
                     hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                     min_addr == addr1;
                     max_addr == addr1;
                     seq_snp_attr_snp_domain_type == vir_seq_snp_attr_snp_domain_type;
                     seq_mem_attr_allocate_hint == vir_seq_mem_attr_allocate_hint;
                     seq_is_non_secure_access == vir_seq_is_non_secure_access;
                     use_seq_is_non_secure_access == 1;
                     data_in_cache == temp_data_1;
                     by_pass_read_data_check == 0;
                   }
                   else {
                     hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
                     seq_hn_node_idx == target_hn_node_idx_0;
                     by_pass_read_data_check == 1;
                     use_seq_is_non_secure_access == 0;
                   }
                   if (select_rn_f_node) {
                     if (select_transaction_type == COHERENT) {
                       `ifdef SVT_CHI_ISSUE_B_ENABLE
                       if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type_read != svt_chi_transaction::READNOTSHAREDDIRTY;
                       `endif
                       `ifdef SVT_CHI_ISSUE_E_ENABLE
                       if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision <= svt_chi_node_configuration::ISSUE_D) seq_xact_type_read != svt_chi_transaction::READPREFERUNIQUE;
                       `endif
                       seq_xact_type_read != svt_chi_transaction::READNOSNP;
                     } 
                     else if (select_transaction_type == NON_COHERENT){
                       seq_xact_type_read == svt_chi_transaction::READNOSNP;
                     }  
                   }
                   if (select_rn_i_node || select_rn_d_node) {
                     seq_xact_type_read == svt_chi_transaction::READNOSNP;  
                   }
                   seq_xact_type_excl == svt_chi_rn_exclusive_access_sequence::RD;
                 }
               );
          chi0_rn_seq[0].start(p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr);
          chi0_rn_seq[0].output_xacts[0].wait_end();
          
          if(chi0_rn_seq[0].output_xacts[0].req_status == svt_chi_transaction::RETRY) begin
            chi0_rn_seq[0].output_xacts[0].wait_end();
          end

          cache_status = my_cache.get_status(chi0_rn_seq[0].output_xacts[0].get_aligned_addr_to_cache_line_size(1),is_unique,is_clean);
          if(cache_status == 1 && is_unique == 1) begin
            cache_status = my_cache.update_status(chi0_rn_seq[0].output_xacts[0].get_aligned_addr_to_cache_line_size(1),0,-1);
            if(!cache_status) begin
              //`svt_xvm_error("body",$psprintf("Backdoor update for moving the cachestate to shared state failed for address - %h", chi0_rn_seq[0].output_xacts[0].addr));
            end
            else begin
              `svt_xvm_debug("body",$psprintf("Backdoor update for moving the cachestate to shared state is successful for address - %h", chi0_rn_seq[0].output_xacts[0].addr));
            end
          end
          
          `svt_xvm_create_on(chi0_rn_seq[1], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr)
          case (p_crd_return_for_store)
            STORE_RETRIED: begin
              chi0_rn_seq[1].p_crd_return_on_retry_ack_store = 0;
            end
            STORE_RETRIED_AND_CANCELLED: begin
              chi0_rn_seq[1].p_crd_return_on_retry_ack_store = 1;
            end
          endcase
          void'(chi0_rn_seq[1].randomize() with
                 {
                    sequence_length == 1;
                    seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;    
                    seq_lpid == chi0_rn_seq[0].output_xacts[0].lpid;
                    if (perform_cache_initialization) {
                      hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                      min_addr == addr1;
                      max_addr == addr1;
                      seq_snp_attr_snp_domain_type == vir_seq_snp_attr_snp_domain_type;
                      seq_mem_attr_allocate_hint == vir_seq_mem_attr_allocate_hint;
                      seq_is_non_secure_access == vir_seq_is_non_secure_access;
                      use_seq_is_non_secure_access == 1;
                      data_in_cache == temp_data_1;
                      by_pass_read_data_check == 0;
                    }
                    else {
                      hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                      min_addr == chi0_rn_seq[0].output_xacts[0].addr;
                      max_addr == chi0_rn_seq[0].output_xacts[0].addr;
                      if (select_transaction_type == COHERENT) {
                        seq_snp_attr_snp_domain_type         == chi0_rn_seq[0].output_xacts[0].snp_attr_snp_domain_type;
                        seq_mem_attr_allocate_hint           == chi0_rn_seq[0].output_xacts[0].mem_attr_allocate_hint;  
                        seq_is_non_secure_access             == chi0_rn_seq[0].output_xacts[0].is_non_secure_access;
                        use_seq_is_non_secure_access == 1;
                      }
                      else if (select_transaction_type == NON_COHERENT) {
                        seq_mem_attr_is_early_wr_ack_allowed == chi0_rn_seq[0].output_xacts[0].mem_attr_is_early_wr_ack_allowed;  
                        seq_mem_attr_mem_type                == chi0_rn_seq[0].output_xacts[0].mem_attr_mem_type;  
                        seq_mem_attr_is_cacheable            == chi0_rn_seq[0].output_xacts[0].mem_attr_is_cacheable;  
                        seq_mem_attr_allocate_hint           == chi0_rn_seq[0].output_xacts[0].mem_attr_allocate_hint;  
                        seq_snp_attr_is_snoopable            == chi0_rn_seq[0].output_xacts[0].snp_attr_is_snoopable;  
                        seq_snp_attr_snp_domain_type         == chi0_rn_seq[0].output_xacts[0].snp_attr_snp_domain_type;
                        seq_is_non_secure_access             == chi0_rn_seq[0].output_xacts[0].is_non_secure_access;
                        use_seq_is_non_secure_access == 1;
                        seq_data_size                        == chi0_rn_seq[0].output_xacts[0].data_size;
                      }
                      by_pass_read_data_check == 1;
                    }
                    if (select_rn_f_node) {
                      if (select_transaction_type == COHERENT) {
                        !(seq_xact_type_write inside {svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITENOSNPFULL});
                        `ifdef SVT_CHI_ISSUE_E_ENABLE
                        if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision <= svt_chi_node_configuration::ISSUE_D) seq_xact_type_write != svt_chi_transaction::MAKEREADUNIQUE;
                        `endif
                      }
                      if (select_transaction_type == NON_COHERENT) {
                        seq_xact_type_write inside {svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITENOSNPFULL};
                        if (chi0_rn_seq[0].output_xacts[0].data_size != svt_chi_transaction::SIZE_64BYTE) {
                          seq_xact_type_write == svt_chi_transaction::WRITENOSNPPTL;
                        }
                      }
                    }
                    if (select_rn_i_node || select_rn_d_node) {
                      seq_xact_type_write inside {svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITENOSNPFULL};
                      if (chi0_rn_seq[0].output_xacts[0].data_size != svt_chi_transaction::SIZE_64BYTE) {
                        seq_xact_type_write == svt_chi_transaction::WRITENOSNPPTL;
                      }
                    }
                    seq_xact_type_excl == svt_chi_rn_exclusive_access_sequence::WR;
                 }
              );
              
          chi0_rn_seq[1].start(p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr);
          chi0_rn_seq[1].output_xacts[0].wait_end();
          
          if(chi0_rn_seq[1].output_xacts[0].req_status == svt_chi_transaction::RETRY) begin
            chi0_rn_seq[1].output_xacts[0].wait_end();
          end
          
          // LPID should be the same for Load and store initaited from LP1.      
          if (chi0_rn_seq[0].output_xacts[0].lpid == chi0_rn_seq[1].output_xacts[0].lpid) begin
            // pass
            `svt_xvm_debug("body", $sformatf("LPID match: LPID 'd%0d is same for Load and store initiated from RN1", chi0_rn_seq[0].output_xacts[0].lpid));
          end
          else begin
            // fail
            `svt_xvm_error("body", $sformatf("LPID mismatch: LPID is expected to be the same for Load and store initiated from RN1, but that is not the case. Transaction %0s has LPID 'd%0d, transaction %0s has LPId 'd%0d ", `SVT_CHI_PRINT_PREFIX(chi0_rn_seq[0].output_xacts[0]), chi0_rn_seq[0].output_xacts[0].lpid, `SVT_CHI_PRINT_PREFIX(chi0_rn_seq[1].output_xacts[0]), chi0_rn_seq[1].output_xacts[0].lpid));
          end
          
          //If any of the exclusive load or store are retired and cancelled we should not check for resp_err_status of store, else the exclusive should pass
          if (!((chi0_rn_seq[0].output_xacts[0].req_status == svt_chi_transaction::CANCELLED) || (chi0_rn_seq[1].output_xacts[0].req_status == svt_chi_transaction::CANCELLED))) begin  
            check_exclusive_sequence_validity(select_transaction_type, chi0_rn_seq[1].output_xacts[0], 1);
          end
        end
        
        //Currently Not supported
        NON_COHERENT_EXCLUSIVE_LOAD1_FOLLOWED_BY_EXCLUSIVE_LOAD2_FROM_SAME_LPID_BUT_TO_DIFF_ADDR_FOLLOWED_BY_EXCLUSIVE_STORE1_FOLLOWED_BY_EXCLUSIVE_STORE2: begin
          `svt_xvm_do_on_with(chi0_rn_seq[0], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
                {
                  sequence_length == 1;
                  seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
                  hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
                  seq_hn_node_idx == target_hn_node_idx_0;
                  use_seq_is_non_secure_access == 1;
                  by_pass_read_data_check == 1;
                  seq_xact_type_read == svt_chi_transaction::READNOSNP;
                  seq_xact_type_excl == svt_chi_rn_exclusive_access_sequence::RD;
                }
          )
          chi0_rn_seq[0].output_xacts[0].wait_end();
          
          `svt_xvm_do_on_with(chi0_rn_seq[1], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
                {
                  sequence_length == 1;
                  seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
                  seq_lpid == chi0_rn_seq[0].output_xacts[0].lpid;
                  hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
                  seq_hn_node_idx == target_hn_node_idx_0;
                  use_seq_is_non_secure_access == 1;
                  by_pass_read_data_check == 1;
                  seq_xact_type_read == svt_chi_transaction::READNOSNP;
                  seq_xact_type_excl == svt_chi_rn_exclusive_access_sequence::RD;
                }
          )
          chi0_rn_seq[1].output_xacts[0].wait_end();
          
          `svt_xvm_do_on_with(chi0_rn_seq[2], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
                {
                  sequence_length == 1;
                  seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
                  seq_lpid == chi0_rn_seq[0].output_xacts[0].lpid;
                  hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                  min_addr == chi0_rn_seq[0].output_xacts[0].addr;
                  max_addr == chi0_rn_seq[0].output_xacts[0].addr;
                  seq_mem_attr_is_early_wr_ack_allowed == chi0_rn_seq[0].output_xacts[0].mem_attr_is_early_wr_ack_allowed;  
                  seq_mem_attr_mem_type                == chi0_rn_seq[0].output_xacts[0].mem_attr_mem_type;  
                  seq_mem_attr_is_cacheable            == chi0_rn_seq[0].output_xacts[0].mem_attr_is_cacheable;  
                  seq_mem_attr_allocate_hint           == chi0_rn_seq[0].output_xacts[0].mem_attr_allocate_hint;  
                  seq_snp_attr_is_snoopable            == chi0_rn_seq[0].output_xacts[0].snp_attr_is_snoopable;  
                  seq_snp_attr_snp_domain_type         == chi0_rn_seq[0].output_xacts[0].snp_attr_snp_domain_type;
                  seq_is_non_secure_access             == chi0_rn_seq[0].output_xacts[0].is_non_secure_access;
                  use_seq_is_non_secure_access         == 1;
                  seq_data_size                        == chi0_rn_seq[0].output_xacts[0].data_size;
                  by_pass_read_data_check              == 1;
                  seq_xact_type_write inside {svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITENOSNPFULL};
                  if (chi0_rn_seq[0].output_xacts[0].data_size != svt_chi_transaction::SIZE_64BYTE) {
                    seq_xact_type_write == svt_chi_transaction::WRITENOSNPPTL;
                  }
                  seq_xact_type_excl == svt_chi_rn_exclusive_access_sequence::WR;
                }
          )
          chi0_rn_seq[2].output_xacts[0].wait_end();
          
          `svt_xvm_do_on_with(chi0_rn_seq[3], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
                {
                  sequence_length == 1;
                  seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
                  seq_lpid == chi0_rn_seq[0].output_xacts[0].lpid;
                  hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                  min_addr == chi0_rn_seq[1].output_xacts[0].addr;
                  max_addr == chi0_rn_seq[1].output_xacts[0].addr;
                  seq_mem_attr_is_early_wr_ack_allowed == chi0_rn_seq[1].output_xacts[0].mem_attr_is_early_wr_ack_allowed;  
                  seq_mem_attr_mem_type                == chi0_rn_seq[1].output_xacts[0].mem_attr_mem_type;  
                  seq_mem_attr_is_cacheable            == chi0_rn_seq[1].output_xacts[0].mem_attr_is_cacheable;  
                  seq_mem_attr_allocate_hint           == chi0_rn_seq[1].output_xacts[0].mem_attr_allocate_hint;  
                  seq_snp_attr_is_snoopable            == chi0_rn_seq[1].output_xacts[0].snp_attr_is_snoopable;  
                  seq_snp_attr_snp_domain_type         == chi0_rn_seq[1].output_xacts[0].snp_attr_snp_domain_type;
                  seq_is_non_secure_access             == chi0_rn_seq[1].output_xacts[0].is_non_secure_access;
                  use_seq_is_non_secure_access         == 1;
                  seq_data_size                        == chi0_rn_seq[1].output_xacts[0].data_size;
                  by_pass_read_data_check              == 1;
                  seq_xact_type_write inside {svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITENOSNPFULL};
                  if (chi0_rn_seq[1].output_xacts[0].data_size != svt_chi_transaction::SIZE_64BYTE) {
                    seq_xact_type_write == svt_chi_transaction::WRITENOSNPPTL;
                  }
                  seq_xact_type_excl == svt_chi_rn_exclusive_access_sequence::WR;
                }
          )
          chi0_rn_seq[3].output_xacts[0].wait_end();

          // load2 will reset the exclusive monitor for load1
          // If Store 1 is not dropped then it is expected to fail with NORMAL_OKAY response as load2 has reset the exclusive monitor for load1 
          // also store1 will reset exclusive monitor for load2 and hence store2 will also fail with NORMAL_OKAY response 
          if(!chi0_rn_seq[2].output_xacts[0].is_xact_dropped)begin
            if(chi0_rn_seq[2].output_xacts[0].response_resp_err_status == svt_chi_transaction::NORMAL_OKAY) begin
              // pass
              `svt_xvm_debug("body", $sformatf("RespErr is %s which is as expected", chi0_rn_seq[2].output_xacts[0].response_resp_err_status));
            end
            else begin
              // fail
              `svt_xvm_error("body", $sformatf("RespErr is %s for transaction %0s however it should be NORMAL_OKAY", chi0_rn_seq[2].output_xacts[0].response_resp_err_status, `SVT_CHI_PRINT_PREFIX(chi0_rn_seq[2].output_xacts[0])));
            end
            if(chi0_rn_seq[3].output_xacts[0].response_resp_err_status == svt_chi_transaction::NORMAL_OKAY) begin
              // pass
              `svt_xvm_debug("body", $sformatf("RespErr is %s which is as expected", chi0_rn_seq[3].output_xacts[0].response_resp_err_status));
            end
            else begin
              // fail
              `svt_xvm_error("body", $sformatf("RespErr is %s for transaction %0s however it should be NORMAL_OKAY", chi0_rn_seq[3].output_xacts[0].response_resp_err_status, `SVT_CHI_PRINT_PREFIX(chi0_rn_seq[3].output_xacts[0])));
            end
          end
          
          // load2 will reset the exclusive monitor for load1
          //If Store 1 is dropped then store2 is expected to pass with EXCLUSIVE_OKAY response 
          else if(chi0_rn_seq[2].output_xacts[0].is_xact_dropped)begin
            if(chi0_rn_seq[3].output_xacts[0].response_resp_err_status == svt_chi_transaction::EXCLUSIVE_OKAY) begin
              // pass
              `svt_xvm_debug("body", $sformatf("RespErr is %s which is as expected", chi0_rn_seq[3].output_xacts[0].response_resp_err_status));
            end
            else begin
              // fail
              `svt_xvm_error("body", $sformatf("RespErr is %s for transaction %0s however it should be EXCLUSIVE_OKAY", chi0_rn_seq[3].output_xacts[0].response_resp_err_status, `SVT_CHI_PRINT_PREFIX(chi0_rn_seq[3].output_xacts[0])));
            end
          end
        end
        
        //Custom support    
        CUSTOM_NON_COHERENT_EXCLUSIVE_LOAD_STORE_WITH_MISMATCHED_ATTRIBUTE: begin
          `svt_xvm_do_on_with(chi0_rn_seq[0], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
                {
                  sequence_length == 1;
                  seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
                  hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
                  use_seq_is_non_secure_access == 0;
                  seq_hn_node_idx == target_hn_node_idx_0;
                  by_pass_read_data_check == 1;
                  seq_xact_type_read == svt_chi_transaction::READNOSNP;
                  seq_xact_type_excl == svt_chi_rn_exclusive_access_sequence::RD;
                }
          )
          chi0_rn_seq[0].transaction.wait_end();
          
          // Issue a excluisve store with mismatched attribute parameters.
          `svt_xvm_create_on(chi0_rn_seq[1], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr)
          chi0_rn_seq[1].bypass_mapping_of_attr = 1;
          void'(chi0_rn_seq[1].randomize() with
                {
                  sequence_length == 1;
                  seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;    
                  seq_lpid == chi0_rn_seq[0].output_xacts[0].lpid;
                  hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                  min_addr[`SVT_CHI_MAX_ADDR_WIDTH-1:6] == chi0_rn_seq[0].output_xacts[0].addr[`SVT_CHI_MAX_ADDR_WIDTH-1:6];
                  min_addr[5:0] == 6'b0;
                  max_addr[`SVT_CHI_MAX_ADDR_WIDTH-1:6] == chi0_rn_seq[0].output_xacts[0].addr[`SVT_CHI_MAX_ADDR_WIDTH-1:6];
                  max_addr[5:0] == 6'b1;
                  by_pass_read_data_check == 1;
                  seq_is_non_secure_access == chi0_rn_seq[0].output_xacts[0].is_non_secure_access;
                  use_seq_is_non_secure_access == 1;
                  seq_data_size != 3'b111;
                  
                  seq_xact_type_write inside {svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITENOSNPFULL};
                  if (seq_xact_type_write == svt_chi_transaction::WRITENOSNPFULL) {
                   seq_data_size  == 3'b110;
                  }
                  
                  seq_xact_type_excl == svt_chi_rn_exclusive_access_sequence::WR;
                }
           );
          chi0_rn_seq[1].start(p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr);
          chi0_rn_seq[1].transaction.wait_end();
          
          // LPID should be the same for Load and store pair.      
          if (chi0_rn_seq[0].output_xacts[0].lpid == chi0_rn_seq[1].output_xacts[0].lpid) begin
            // pass
            `svt_xvm_debug("body", $sformatf("LPID match: LPID 'd%0d is same for Load and store initiated from RN1", chi0_rn_seq[0].output_xacts[0].lpid));
          end
          else begin
            // fail
            `svt_xvm_error("body", $sformatf("LPID mismatch: LPID is expected to be the same for Load and store initiated from RN1, but that is not the case. Transaction %0s from rn[%0d] has LPID 'd%0d, transaction %0s from rn[%0d] has LPId 'd%0d ", `SVT_CHI_PRINT_PREFIX(chi0_rn_seq[0].output_xacts[0]), initiating_rn_node_idx_0, chi0_rn_seq[0].output_xacts[0].lpid, `SVT_CHI_PRINT_PREFIX(chi0_rn_seq[2].output_xacts[0]), initiating_rn_node_idx_0, chi0_rn_seq[2].output_xacts[0].lpid));
          end
          //The exclusive sequence is should pass with RespErr field equal to EXCLUSIVE_OKAY
          check_exclusive_sequence_validity(NON_COHERENT, chi0_rn_seq[1].output_xacts[0], 1);
        end

        //Custom support    
        CUSTOM_NON_COHERENT_EXCLUSIVE_LOAD_STORE_WITH_MISMATCHED_ATTRIBUTE_WITH_INTERVENING_STORE: begin
          `svt_xvm_do_on_with(chi0_rn_seq[0], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
                {
                  sequence_length == 1;
                  seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
                  hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
                  use_seq_is_non_secure_access == 0;
                  seq_hn_node_idx == target_hn_node_idx_0;
                  by_pass_read_data_check == 1;
                  seq_xact_type_read == svt_chi_transaction::READNOSNP;
                  seq_xact_type_excl == svt_chi_rn_exclusive_access_sequence::RD;
                }
          )
          chi0_rn_seq[0].transaction.wait_end();

         // Issue an intervening normal store from same RN but from different LPID
          `svt_xvm_create_on(chi0_rn_seq[2], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr)
          chi0_rn_seq[2].seq_is_exclusive = 0;
          chi0_rn_seq[2].bypass_mapping_of_attr = 1;
          void'(chi0_rn_seq[2].randomize() with
                {
                  sequence_length == 1;
                  seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;    
                  seq_lpid != chi0_rn_seq[0].output_xacts[0].lpid;
                  hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                  min_addr[`SVT_CHI_MAX_ADDR_WIDTH-1:6] == chi0_rn_seq[0].output_xacts[0].addr[`SVT_CHI_MAX_ADDR_WIDTH-1:6];
                  min_addr[5:0] == 6'b0;
                  max_addr[`SVT_CHI_MAX_ADDR_WIDTH-1:6] == chi0_rn_seq[0].output_xacts[0].addr[`SVT_CHI_MAX_ADDR_WIDTH-1:6];
                  max_addr[5:0] == 6'b1;
                  by_pass_read_data_check == 1;
                  seq_is_non_secure_access == chi0_rn_seq[0].output_xacts[0].is_non_secure_access;
                  use_seq_is_non_secure_access == 1;
                  seq_data_size != 3'b111;
                  
                  seq_xact_type_write inside {svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITENOSNPFULL};
                  if (seq_xact_type_write == svt_chi_transaction::WRITENOSNPFULL) {
                   seq_data_size  == 3'b110;
                  }
                  
                  seq_xact_type_excl == svt_chi_rn_exclusive_access_sequence::WR;
                }
           );
          chi0_rn_seq[2].start(p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr);
          chi0_rn_seq[2].transaction.wait_end();
 
          
          // Issue a excluisve store with mismatched attribute parameters.
          // This store should be dropped because of prior intervening store to the same cache line
          `svt_xvm_create_on(chi0_rn_seq[1], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr)
          chi0_rn_seq[1].bypass_mapping_of_attr = 1;
          void'(chi0_rn_seq[1].randomize() with
                {
                  sequence_length == 1;
                  seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;    
                  seq_lpid == chi0_rn_seq[0].output_xacts[0].lpid;
                  hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                  min_addr[`SVT_CHI_MAX_ADDR_WIDTH-1:6] == chi0_rn_seq[0].output_xacts[0].addr[`SVT_CHI_MAX_ADDR_WIDTH-1:6];
                  min_addr[5:0] == 6'b0;
                  max_addr[`SVT_CHI_MAX_ADDR_WIDTH-1:6] == chi0_rn_seq[0].output_xacts[0].addr[`SVT_CHI_MAX_ADDR_WIDTH-1:6];
                  max_addr[5:0] == 6'b1;
                  by_pass_read_data_check == 1;
                  seq_is_non_secure_access == chi0_rn_seq[0].output_xacts[0].is_non_secure_access;
                  use_seq_is_non_secure_access == 1;
                  seq_data_size != 3'b111;
                  
                  seq_xact_type_write inside {svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITENOSNPFULL};
                  if (seq_xact_type_write == svt_chi_transaction::WRITENOSNPFULL) {
                   seq_data_size  == 3'b110;
                  }
                  
                  seq_xact_type_excl == svt_chi_rn_exclusive_access_sequence::WR;
                }
           );
          chi0_rn_seq[1].start(p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr);
          chi0_rn_seq[1].transaction.wait_end();
          
        end
        
      endcase
    end
    `svt_xvm_debug("body", "Exiting...");
  endtask: body

  virtual task post_start();
    super.post_start();
    drop_phase_objection();
  endtask

endclass: svt_chi_system_protocol_flow_ctrl_exclusive_access_virtual_sequence

function svt_chi_system_protocol_flow_ctrl_exclusive_access_virtual_sequence::new(string name="svt_chi_system_protocol_flow_ctrl_exclusive_access_virtual_sequence");
  super.new(name);
endfunction

task svt_chi_system_protocol_flow_ctrl_exclusive_access_virtual_sequence::check_exclusive_sequence_validity(select_transaction_type_enum select_transaction_type, svt_chi_transaction xact, bit pass_expectation);
  xact.wait_end();
  if(pass_expectation == 1)begin
    if (select_transaction_type == COHERENT && !xact.is_xact_dropped) begin
      if(xact.xact_type == svt_chi_transaction::CLEANUNIQUE)begin
        //The exclusive sequence should pass with RespErr field equal to EXLCUSIVE_OKAY
        if(xact.response_resp_err_status == svt_chi_transaction::EXCLUSIVE_OKAY) begin
          // pass
          `svt_xvm_debug("check_exclusive_sequence_validity", $sformatf("RespErr is %s which is as expected", xact.response_resp_err_status));
        end
        else begin
          // fail
          `svt_xvm_error("check_exclusive_sequence_validity", $sformatf("RespErr is %s for transaction %0s however it should be EXCLUSIVE_OKAY", xact.response_resp_err_status, `SVT_CHI_PRINT_PREFIX(xact)));
        end
      end
      `ifdef SVT_CHI_ISSUE_E_ENABLE
        else if(xact.xact_type == svt_chi_transaction::MAKEREADUNIQUE)begin
          //The exclusive sequence should pass with final state being UC or UD
          if(xact.final_state == svt_chi_transaction::UC || xact.final_state == svt_chi_transaction::UD) begin
            // pass
            `svt_xvm_debug("check_exclusive_sequence_validity", $sformatf("Final state is %s which is as expected", xact.final_state));
          end
          else begin
            // fail
            `svt_xvm_error("check_exclusive_sequence_validity", $sformatf("Final state is %s for transaction %0s however it should be UC/UD", xact.final_state, `SVT_CHI_PRINT_PREFIX(xact)));
          end
        end
      `endif
    end
    else if (select_transaction_type == NON_COHERENT && !xact.is_xact_dropped) begin
      //The exclusive sequence should pass with RespErr field equal to EXLCUSIVE_OKAY
      if(xact.response_resp_err_status == svt_chi_transaction::EXCLUSIVE_OKAY) begin
        // pass
        `svt_xvm_debug("check_exclusive_sequence_validity", $sformatf("RespErr is %s which is as expected", xact.response_resp_err_status));
      end
      else begin
        // fail
        `svt_xvm_error("check_exclusive_sequence_validity", $sformatf("RespErr is %s for transaction %0s however it should be EXCLUSIVE_OKAY", xact.response_resp_err_status, `SVT_CHI_PRINT_PREFIX(xact)));
      end
    end
  end
  else if(pass_expectation == 0)begin
    if (select_transaction_type == COHERENT && !xact.is_xact_dropped) begin
      if(xact.xact_type == svt_chi_transaction::CLEANUNIQUE)begin
        //The exclusive sequence should fail with RespErr field equal to NORMAL_OKAY
        if(xact.response_resp_err_status == svt_chi_transaction::NORMAL_OKAY) begin
          // pass
          `svt_xvm_debug("check_exclusive_sequence_validity", $sformatf("RespErr is %s which is as expected", xact.response_resp_err_status));
        end
        else begin
          // fail
          `svt_xvm_error("check_exclusive_sequence_validity", $sformatf("RespErr is %s for transaction %0s however it should be NORMAL_OKAY", xact.response_resp_err_status, `SVT_CHI_PRINT_PREFIX(xact)));
        end
      end
      `ifdef SVT_CHI_ISSUE_E_ENABLE
        else if(xact.xact_type == svt_chi_transaction::MAKEREADUNIQUE)begin
          //The exclusive sequence should fail with final state being SC
          if(xact.final_state == svt_chi_transaction::SC) begin
            // pass
            `svt_xvm_debug("check_exclusive_sequence_validity", $sformatf("Final state is %s which is as expected", xact.final_state));
          end
          else begin
            // fail
            `svt_xvm_error("check_exclusive_sequence_validity", $sformatf("Final state is %s for transaction %0s however it should be SC", xact.final_state, `SVT_CHI_PRINT_PREFIX(xact)));
          end
        end
      `endif
    end
    else if (select_transaction_type == NON_COHERENT && !xact.is_xact_dropped) begin
      //The exclusive sequence should fail with RespErr field equal to NORMAL_OKAY
      if(xact.response_resp_err_status == svt_chi_transaction::NORMAL_OKAY) begin
        // pass
        `svt_xvm_debug("check_exclusive_sequence_validity", $sformatf("RespErr is %s which is as expected", xact.response_resp_err_status));
      end
      else begin
        // fail
        `svt_xvm_error("check_exclusive_sequence_validity", $sformatf("RespErr is %s for transaction %0s however it should be NORMAL_OKAY", xact.response_resp_err_status, `SVT_CHI_PRINT_PREFIX(xact)));
      end
    end
  end
endtask

//====================================================================================
/**
 * @groupname CHI_FLOW_CTRL_RD_TYPE  
 *    #- Optionally program a randomly selected RN to send two MAKEUNIQUE transaction targeted to<br> 
 *       randomly selected same target IDs when number of RN_F is 3 or more incase of RN_F test<br>
 *       or number of RN_F is atleast 1 incase of RN_I test.<br>
 *    #- Program other two randomly selected RNs to send a read type coherent transaction<br>
 *       with same TxnID simultaneously to above selected same target IDs of MAKEUNIQUE 
 *       transactions if MAKEQNIQUE transaction is sent for initilization.<br>
 *    #- If MAKEQNIQUE transaction is not sent for initilization program two randomly<br> 
 *       selected different RNs to send a read type coherent transaction with same TxnID simultaneously<br>
 *       to randomly selected same target IDs.<br> 
 *    #- Check that the HN's responds with same TxnId to respective RNs.<br>
 *    .
 */


class svt_chi_system_protocol_flow_ctrl_read_resp_same_txnid_diff_rn_same_hn_virtual_sequence extends svt_chi_system_base_virtual_sequence;
  
  /** Represents the RN-F node for which the sequence will be initiated */ 
  int select_rn_f_node = 0;  
  
  /** Represents the RN-I node for which the sequence will be initiated */ 
  int select_rn_i_node = 0;
  
  /** Represents the RN-D node for which the sequence will be initiated */ 
  int select_rn_d_node = 0;

  /** Status filed for capturing config DB get status for select_rn_f_node */
  bit select_rn_f_node_status = 0;
  
  /** Status filed for capturing config DB get status for select_rn_i_node */
  bit select_rn_i_node_status = 0;

  /** Status filed for capturing config DB get status for select_rn_d_node */
  bit select_rn_d_node_status = 0;

  /** To display contents of Active Participating nodes */
  string str_node_info;

  /** Sub Read type transaction directed sequences initiated from this sequence */
  svt_chi_rn_read_type_transaction_directed_sequence chi0_rn_seq[int];

  /** UVM Object Utility macro */
  `uvm_object_utils(svt_chi_system_protocol_flow_ctrl_read_resp_same_txnid_diff_rn_same_hn_virtual_sequence)

  extern function new(string name="svt_chi_system_protocol_flow_ctrl_read_resp_same_txnid_diff_rn_same_hn_virtual_sequence"); 

  virtual task pre_start();
    super.pre_start();
    raise_phase_objection();
    select_rn_f_node_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(),"select_rn_f_node", select_rn_f_node);
    `svt_xvm_debug("body", $sformatf("select_rn_f_node is %0d as a result of %0s", select_rn_f_node, (select_rn_f_node_status ?"config DB":"Default setting")));
    select_rn_i_node_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(),"select_rn_i_node", select_rn_i_node);
    `svt_xvm_debug("body", $sformatf("select_rn_i_node is %0d as a result of %0s", select_rn_i_node, (select_rn_i_node_status ?"config DB":"Default setting")));
    select_rn_d_node_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(),"select_rn_d_node", select_rn_d_node);
    `svt_xvm_debug("body", $sformatf("select_rn_d_node is %0d as a result of %0s", select_rn_d_node, (select_rn_d_node_status ?"config DB":"Default setting")));
  endtask // pre_start
  
  /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting RN-F Nodes = 2 when select_rn_f_node is programmed to 1
   *  #- minimum supporting RN-I Nodes = 2 when select_rn_i_node is programmed to 1
   *  #- minimum supporting RN-D Nodes = 2 when select_rn_d_node is programmed to 1
   */
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    
    /** local variables */
    int num_supporting_rn_f_nodes;
    int num_supporting_rn_i_nodes;
    int num_supporting_rn_d_nodes;
    string str_is_supported_info_prefix = "";
    string str_is_supported_info = "";

    /** Supporting Request Nodes required */
    int required_num_supporting_rn_f_nodes = 0;
    int required_num_supporting_rn_i_nodes = 0;
    int required_num_supporting_rn_d_nodes = 0;
    int required_num_hn_nodes = 1;
    int num_hn_f_nodes;
    int array_idx;
    string str_idx0_info = "";
    string str_idx1_info = ""; 
    bit    is_rn_idx_0_participating, is_rn_idx_1_participating;   
    `svt_xvm_debug("is_supported",$sformatf("calling is_supported"));

    /** By default is_supported is 0 */
    is_supported = 0;

    /** Check for minimum required HN-F nodes */
    num_hn_f_nodes = hn_f_nodes.size();

    /** Check requirment of number of HN nodes needed */ 
    if (num_hn_f_nodes < required_num_hn_nodes) begin
      issue_is_supported_failure($sformatf("This sequence requires minimum %0d HN-F nodes to be present in the system. Number of HN-F nodes are %0d. Program number of HN nodes using svt_chi_system_configuration::num_hn. Program the HN interface type using svt_chi_system_configuration::chi_addr_cfg.hn_interface_type[].", required_num_hn_nodes, num_hn_f_nodes));
      return 0;      
    end
    
    /** Either of select_rn_d_node, select_rn_i_node, select_rn_f_node needs to be programmed to 1.
     *  More than one flag cannot be 1 or 0 together.
     */
    if (((select_rn_f_node == 0) && (select_rn_i_node == 0) && (select_rn_d_node == 0)) ||
        ((select_rn_f_node == 1) && (select_rn_i_node == 1) && (select_rn_d_node == 1))) begin
      issue_is_supported_failure($sformatf("select_rn_f_node = %0d. select_rn_i_node = %0d. select_rn_d_node = %0d. Programming one of these two variables to 1 through config DB is required for this sequence to be run.", select_rn_f_node, select_rn_i_node, select_rn_d_node));
      return 0;
    end

    /** Set minimum required supporting RN-F, RN-D and RN-I nodes depending on  
     *  select_rn_f_node or select_rn_d_node or select_rn_i_node flags respectively.
     */   
    if(select_rn_f_node)
      required_num_supporting_rn_f_nodes = 2;
    else if(select_rn_i_node) begin
      required_num_supporting_rn_i_nodes = 2;
    end else if (select_rn_d_node)begin
      required_num_supporting_rn_d_nodes = 2;
    end

    /** Check for minimum required RN-F, RN-D and RN-I nodes.
     *  Also check whether the selected RN-F, RN-D and RN-I nodes are part of participating arrays or not.
     */ 
    num_supporting_rn_f_nodes = active_participating_rn_f_nodes.size();
    num_supporting_rn_d_nodes = active_participating_rn_d_nodes.size();
    num_supporting_rn_i_nodes = active_participating_rn_i_nodes.size();

    /** Check the requirements of RN nodes */
    if (num_supporting_rn_f_nodes) begin
      /** Display the contents of Active Participating RN-F Nodes */
      foreach (active_participating_rn_f_nodes[j]) begin
        str_node_info = {str_node_info, $sformatf(" %0d", active_participating_rn_f_nodes[j])};
      end      
      `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_f_nodes are %0s", str_node_info));
    end
    
    /** Display the contents of Active Participating RN-D Nodes */
    str_node_info = "";

    /** Check the requirement of RN-D nodes */ 
    if (num_supporting_rn_d_nodes) begin
      foreach (active_participating_rn_d_nodes[j]) begin
        str_node_info = {str_node_info, $sformatf(" %0d", active_participating_rn_d_nodes[j])};
      end 
      `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_d_nodes are %0s", str_node_info));
    end    

    /** Display the contents of Active Participating RN-I Nodes */
    str_node_info = "";

    /** Check the requirement of RN-I nodes */ 
    if (num_supporting_rn_i_nodes) begin
      foreach (active_participating_rn_i_nodes[j]) begin
        str_node_info = {str_node_info, $sformatf(" %0d", active_participating_rn_i_nodes[j])};
      end 
      `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_i_nodes are %0s", str_node_info));
    end

    /** Check the required supporting Request Nodes */
    if (select_rn_f_node == 1) begin
      
      str_is_supported_info_prefix = $sformatf("select_rn_f_node is set to 1. Number of Supporting RN-F Node(s)  - Minimum Required : %0d Current : %0d", required_num_supporting_rn_f_nodes,num_supporting_rn_f_nodes);

      if ((initiating_rn_node_index_0_status==0)&&(valid_initiating_rn_f_node_index_0==0)) begin
          str_idx0_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN-Fs that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)";
      end
      else begin
        is_rn_idx_0_participating = is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_node_idx_0, array_idx);
        if (!is_rn_idx_0_participating) begin
          str_idx0_info = $sformatf("initiating_rn_node_idx_0 %0d is not valid for this sequence. The RN-F corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)", initiating_rn_node_idx_0, initiating_rn_node_idx_0);
        end
      end

      if ((initiating_rn_node_index_1_status==0)&&(valid_initiating_rn_f_node_index_1==0)) begin
        str_idx1_info = "Valid initiating_rn_node_idx_1 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN-Fs that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)";
      end 
      else begin
        is_rn_idx_1_participating = is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_node_idx_1, array_idx);
        if (!is_rn_idx_1_participating) begin
          str_idx1_info = $sformatf("initiating_rn_node_idx_1 %0d is not valid for this sequence. The RN-F corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)", initiating_rn_node_idx_1, initiating_rn_node_idx_1);
        end
      end    
    end
    else if (select_rn_i_node == 1) begin
      
      str_is_supported_info_prefix = $sformatf("select_rn_i_node is set to 1. Number of Supporting RN-I Node(s)  - Minimum Required : %0d Current : %0d", required_num_supporting_rn_i_nodes,num_supporting_rn_i_nodes);

      if ((initiating_rn_node_index_0_status==0)&&(valid_initiating_rn_i_node_index_0==0)) begin
        str_idx0_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN-Is that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_I)";
      end
      else begin
        is_rn_idx_0_participating = is_value_found_in_int_assoc_array(active_participating_rn_i_nodes, initiating_rn_node_idx_0, array_idx);
        if (!is_rn_idx_0_participating) begin
         
          str_idx0_info = $sformatf("initiating_rn_node_idx_0 %0d is not valid for this sequence. The RN-I corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_I)", initiating_rn_node_idx_0, initiating_rn_node_idx_0);
        end  
      end

      if ((initiating_rn_node_index_1_status==0)&&(valid_initiating_rn_i_node_index_1==0)) begin
        str_idx1_info = "Valid initiating_rn_i_node_index_1 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN-Is that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_I)";
      end
      else begin
        is_rn_idx_1_participating = is_value_found_in_int_assoc_array(active_participating_rn_i_nodes, initiating_rn_i_node_index_1, array_idx);
        if (!is_rn_idx_1_participating) begin
          str_idx1_info = $sformatf("initiating_rn_i_node_index_1 %0d is not valid for this sequence. The RN-I corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_I)", initiating_rn_i_node_index_1, initiating_rn_i_node_index_1);
        end 
      end
    end
    else if (select_rn_d_node == 1) begin
      str_is_supported_info_prefix = $sformatf("select_rn_d_node is set to 1. Number of Supporting RN-D Node(s)  - Minimum Required : %0d Current : %0d", required_num_supporting_rn_d_nodes,num_supporting_rn_d_nodes);

      if ((initiating_rn_node_index_0_status==0)&&(valid_initiating_rn_d_node_index_0==0)) begin
        str_idx0_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN-Ds that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_D)";
      end
      else begin
        is_rn_idx_0_participating = is_value_found_in_int_assoc_array(active_participating_rn_d_nodes, initiating_rn_node_idx_0, array_idx);
        if (!is_rn_idx_0_participating) begin
         
          str_idx0_info = $sformatf("initiating_rn_node_idx_0 %0d is not valid for this sequence. The RN-D corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_D)", initiating_rn_node_idx_0, initiating_rn_node_idx_0);
        end  
      end

      if ((initiating_rn_node_index_1_status==0)&&(valid_initiating_rn_d_node_index_1==0)) begin
        str_idx1_info = "Valid initiating_rn_node_idx_1 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN-Ds that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_D)";
      end
      else begin
        is_rn_idx_1_participating = is_value_found_in_int_assoc_array(active_participating_rn_d_nodes, initiating_rn_node_idx_1, array_idx);
        if (!is_rn_idx_1_participating) begin
          str_idx1_info = $sformatf("initiating_rn_node_idx_1 %0d is not valid for this sequence. The RN-D corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_D)", initiating_rn_node_idx_1, initiating_rn_node_idx_1);
        end 
      end
    end

    if (is_rn_idx_0_participating && is_rn_idx_1_participating) begin
      is_supported = 1;
    end
    
    if (!is_supported) begin
      str_is_supported_info = $sformatf("%0s%0s",str_idx0_info, str_idx1_info);
      issue_is_supported_failure($sformatf("This sequence cannot be run based on the current system configuration.\n\
                                            %0s\n\
                                            %0s \n\
                                            Modify configurations through \n\
                                            svt_chi_system_configuration::num_rn,\n\
                                            svt_chi_node_configuration::is_active,\n\
                                            svt_chi_system_configuration::participating_rn_nodes[]\n\
                                            ", str_is_supported_info_prefix, str_is_supported_info));
    end

    if (!is_target_hn_idx_valid_for_curr_cfg()) begin
      is_supported = 0;
      `svt_xvm_note("is_supported", "not a valid hn_idx based on random_tgt_id_enable for current cfg");
    end
  endfunction : is_supported
  
  virtual task body();
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0]                    addr1;
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0]                    addr2;
    int                                                   array_idx;
    bit [`SVT_CHI_MAX_DATA_WIDTH -1:0]                    temp_data_1,temp_data_2;
    bit txn1_is_non_secure_access;
    bit txn2_is_non_secure_access;
    bit perform_cache_initialization;
    string str_node_types = "";
    int unsigned sel_initiating_rn_node_index_0,sel_initiating_rn_node_index_1;
    
    /** Sub sequences initiated from this sequence */
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq[int];

    `svt_xvm_debug("body", "Entering ...");
    super.body();

    if (select_rn_f_node) begin
      str_node_types = "Iniating nodes are of RN-F type.";
      // If the initiating_rn_f_node_index_2 is part of active_participating_rn_f_nodes array, and
      // it is not equal to initiating_rn_f_node_index_0, initiating_rn_f_node_index_1; then we can
      // perform cache initialization from the RN[cache_line_init_rn_f_node_index].
      if ((is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_f_node_index_2, array_idx)) &&
          (initiating_rn_f_node_index_2 != initiating_rn_f_node_index_0) &&
          (initiating_rn_f_node_index_2 != initiating_rn_f_node_index_1)) begin
        perform_cache_initialization = 1;
        cache_line_init_rn_f_node_index = initiating_rn_f_node_index_2;          
      end
      sel_initiating_rn_node_index_0 = initiating_rn_f_node_index_0;
      sel_initiating_rn_node_index_1 = initiating_rn_f_node_index_1;
    end
    else if (select_rn_i_node) begin
      str_node_types = "Iniating nodes are of RN-I type.";        
      // If the initiating_rn_f_node_index_0 is part of active_participating_rn_f_nodes array
      // then we can perform cache initialization from the RN[cache_line_init_rn_f_node_index].
      if (is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_f_node_index_0, array_idx)) begin
        perform_cache_initialization = 1;
        cache_line_init_rn_f_node_index = initiating_rn_f_node_index_0;          
      end
      sel_initiating_rn_node_index_0 = initiating_rn_i_node_index_0;
      sel_initiating_rn_node_index_1 = initiating_rn_i_node_index_1;
    end
    else if (select_rn_d_node) begin
      str_node_types = "Initiating nodes are of RN-D type.";
      // If the initiating_rn_f_node_index_0 is part of active_participating_rn_f_nodes array
      // then we can perform cache initialization from the RN[cache_line_init_rn_f_node_index].
      if (is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_f_node_index_0, array_idx)) begin
        perform_cache_initialization = 1;
        cache_line_init_rn_f_node_index = initiating_rn_f_node_index_0;          
      end
      sel_initiating_rn_node_index_0 = initiating_rn_d_node_index_0;
      sel_initiating_rn_node_index_1 = initiating_rn_d_node_index_1;
    end

    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :sel_initiating_rn_node_index_0;
    initiating_rn_node_idx_1 = initiating_rn_node_index_1_status ? initiating_rn_node_index_1_from_config_db :sel_initiating_rn_node_index_1;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_f_node_index_0;

    `svt_xvm_debug("body", $sformatf("initiating_rn_node_idx_0 is %0d as a result of %0s.", initiating_rn_node_idx_0, initiating_rn_node_index_0_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("initiating_rn_node_idx_1 is %0d as a result of %0s.", initiating_rn_node_idx_1, initiating_rn_node_index_1_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("target_hn_node_idx_0 is %0d as a result of %0s.", target_hn_node_idx_0, target_hn_node_index_0_status ? "config DB" : "Randomization"));

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /**
     * If the cache_line_init_rn_f_node_index is same as any of the RN node indices 
     * which are passed through config i.e initiating_rn_node_idx_0,initiating_rn_node_idx_1,
     * then re-assign the cache_line_init_rn_f_node_index with RN node index ,which is active,
     * participating and not equal to initiating_rn_node_idx_0, initiating_rn_node_idx_1.
     */
    if(initiating_rn_node_index_0_status||initiating_rn_node_index_1_status)begin  
      if((cache_line_init_rn_f_node_index == initiating_rn_node_idx_0)||(cache_line_init_rn_f_node_index == initiating_rn_node_idx_1))begin  
        int active_participating_q [$];
        `svt_chi_xxm_debug("body",$sformatf("cache_line_init_rn_f_node_index= %0d is same as initiating_rn_node_idx_0=%0d or initiating_rn_node_idx_1=%0d and active_participating_rn_f_nodes.size()= %0d",cache_line_init_rn_f_node_index,initiating_rn_node_idx_0,initiating_rn_node_idx_1,active_participating_rn_f_nodes.size()));
        if(active_participating_rn_f_nodes.size()>2)begin
          active_participating_q = active_participating_rn_f_nodes.find with ((item != initiating_rn_node_idx_0) && (item != initiating_rn_node_idx_1));
          cache_line_init_rn_f_node_index = active_participating_q.pop_back();
          `svt_chi_xxm_debug("body", $sformatf("active_participating_q.size() is %0d and Selected different cache_line_init_rn_f_node_index=%0d", active_participating_q.size(),cache_line_init_rn_f_node_index));
          active_participating_q.delete();
        end else begin
          perform_cache_initialization=0;
          `svt_chi_xxm_debug("body",$sformatf("BYPASSING Cache Initialization as selected cache_line_init_rn_f_node_index= %0d is same as initiating_rn_node_index_0_from_config_db=%0d or initiating_rn_node_index_1_from_config_db=%0d and active_participating_rn_f_nodes.size()= %0d",cache_line_init_rn_f_node_index,initiating_rn_node_index_0_from_config_db,initiating_rn_node_index_1_from_config_db,active_participating_rn_f_nodes.size()));
        end
      end  
    end 

    /**
     * If the cache_line_init_rn_f_node_index is part of active_participating_rn_f_nodes array, and
     * it is not equal to initiating_rn_node_idx_0, initiating_rn_node_idx_1; then we can
     * perform cache initialization from the RN[cache_line_init_rn_f_node_index].
     */
    if ((is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, cache_line_init_rn_f_node_index, array_idx)) &&
        (cache_line_init_rn_f_node_index != initiating_rn_node_idx_0) &&
        (cache_line_init_rn_f_node_index != initiating_rn_node_idx_1)) begin
      perform_cache_initialization = 1;
    end

    `svt_xvm_debug("body", $sformatf("%0s perform_cache_initialization = %0b. cache_line_init_rn_f_node_index = %0d. initiating_rn_node_idx_0 = %0d. initiating_rn_node_idx_1 = %0d.", str_node_types, perform_cache_initialization, cache_line_init_rn_f_node_index, initiating_rn_node_idx_0, initiating_rn_node_idx_1));
    
    for(int i = 0; i < sequence_length; i++) begin
      if(perform_cache_initialization) begin
        /** 
         * Write data into Cache of Randomly selected first RN with address of randomly
         * selected first HN Node.
         */
        `svt_xvm_do_on_with(makeunique_seq[0], p_sequencer.rn_virt_seqr[cache_line_init_rn_f_node_index].rn_xact_seqr,
                                              {sequence_length    == 1;
                                               hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
                                               seq_hn_node_idx    == target_hn_node_idx_0;
                                               use_seq_is_non_secure_access == 0;
                                              })
         /** Wait for MakeUnique transactions to finish */ 
         makeunique_seq[0].write_tran.wait_end();
         txn1_is_non_secure_access = makeunique_seq[0].output_xacts[0].is_non_secure_access;
        
        /** Write data into Cache of Randomly selected first RN with address of randomly 
         *  selected second HN Node.
         */
        `svt_xvm_do_on_with(makeunique_seq[1], p_sequencer.rn_virt_seqr[cache_line_init_rn_f_node_index].rn_xact_seqr,
                                              {sequence_length    == 1;
                                               hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
                                               seq_hn_node_idx    == target_hn_node_idx_0;
                                               use_seq_is_non_secure_access == 0;
                                              })

        /** Wait for MakeUnique transactions to finish */ 
        makeunique_seq[1].write_tran.wait_end();

        txn2_is_non_secure_access = makeunique_seq[1].output_xacts[0].is_non_secure_access;                 
        /** Retrieving address from output transactions generated by the above MakeUnique sequences */
        addr1 = makeunique_seq[0].output_xacts[0].addr;
        addr2 = makeunique_seq[1].output_xacts[0].addr;
        temp_data_1 = makeunique_seq[0].output_xacts[0].data;
        temp_data_2 = makeunique_seq[1].output_xacts[0].data;
      end

      fork
        begin: rn_0_thread
          /** Randomly selected first RN-F fires a read transaction with MAKEUNIQUE 
           *  transaction address of randomly selected second HN Node.
           */
          `svt_xvm_do_on_with(chi0_rn_seq[0], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
          {
            sequence_length == 1;
            seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
            if (perform_cache_initialization) {
              hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
              min_addr == addr1;
              max_addr == addr1;
              data_in_cache == temp_data_1;
              by_pass_read_data_check == 0;
              seq_is_non_secure_access == txn1_is_non_secure_access; 
              use_seq_is_non_secure_access == 1;       
              
            }
            else {
              hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
              seq_hn_node_idx    == target_hn_node_idx_0; 
              by_pass_read_data_check == 1;
              use_seq_is_non_secure_access == 0;
            }
            if (select_rn_f_node) seq_xact_type != svt_chi_transaction::READNOSNP;
            if (select_rn_i_node || select_rn_d_node) seq_xact_type == svt_chi_transaction::READONCE;
            `ifdef SVT_CHI_ISSUE_B_ENABLE
              if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type != svt_chi_transaction::READNOTSHAREDDIRTY;
              if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A || sys_cfg.readspec_enable == 0) seq_xact_type != svt_chi_transaction::READSPEC;
              if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type != svt_chi_transaction::READONCECLEANINVALID;
              if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type != svt_chi_transaction::READONCEMAKEINVALID;
            `endif
            `ifdef SVT_CHI_ISSUE_E_ENABLE
              if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision <= svt_chi_node_configuration::ISSUE_D) seq_xact_type != svt_chi_transaction::READPREFERUNIQUE;
            `endif
          }
          )
        end: rn_0_thread
        begin: rn_1_thread
          /** Randomly selected first RN-F fires a read transaction with MAKEUNIQUE 
           *  transaction address of randomly selected second HN Node.
           */
          `svt_xvm_do_on_with(chi0_rn_seq[1], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,
          {
            sequence_length == 1;
            seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;    
            seq_txn_id == chi0_rn_seq[0].seq_txn_id;
            if (perform_cache_initialization) {
              hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
              min_addr == addr2;
              max_addr == addr2;
              data_in_cache == temp_data_2;
              by_pass_read_data_check == 0;
              seq_is_non_secure_access == txn2_is_non_secure_access;
              use_seq_is_non_secure_access == 1;
            }
            else {
              hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
              seq_hn_node_idx    == target_hn_node_idx_0; 
              by_pass_read_data_check == 1;
              use_seq_is_non_secure_access == 0;
            }
            if (select_rn_f_node) {
              seq_xact_type != svt_chi_transaction::READNOSNP;
              seq_xact_type != chi0_rn_seq[0].seq_xact_type;
            }
            if (select_rn_i_node || select_rn_d_node) seq_xact_type == svt_chi_transaction::READONCE;
            `ifdef SVT_CHI_ISSUE_B_ENABLE
              if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type != svt_chi_transaction::READNOTSHAREDDIRTY;
              if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision == svt_chi_node_configuration::ISSUE_A || sys_cfg.readspec_enable == 0) seq_xact_type != svt_chi_transaction::READSPEC;
              if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type != svt_chi_transaction::READONCECLEANINVALID;
              if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type != svt_chi_transaction::READONCEMAKEINVALID;
            `endif
            `ifdef SVT_CHI_ISSUE_E_ENABLE
              if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision <= svt_chi_node_configuration::ISSUE_D) seq_xact_type != svt_chi_transaction::READPREFERUNIQUE;
            `endif

          }
          )
        end: rn_1_thread
      join

      // TxnID should be the same from both the RNs      
      if (chi0_rn_seq[0].output_xacts[0].txn_id == chi0_rn_seq[1].output_xacts[0].txn_id) begin
        // pass
        `svt_xvm_debug("body", $sformatf("TxnID match: TxnID 'd%0d is the same from both the RNs", chi0_rn_seq[0].output_xacts[0].txn_id));
      end
      else begin
        // fail
        `svt_xvm_error("body", $sformatf("TxnID mismatch: TxnID is expected to be the same from both the RNs, but that is not the case. Transaction %0s from rn[%0d] has TxnID 'd%0d, transaction %0s from rn[%0d] has TxnId 'd%0d ", 
                                         `SVT_CHI_PRINT_PREFIX( chi0_rn_seq[0].output_xacts[0]),initiating_rn_node_idx_0, chi0_rn_seq[0].output_xacts[0].txn_id, `SVT_CHI_PRINT_PREFIX( chi0_rn_seq[1].output_xacts[0]), initiating_rn_node_idx_1, chi0_rn_seq[1].output_xacts[0].txn_id));
      end

      // Targetted HN IDs from both RNs should be same
      begin
        int hn_idx_0, hn_idx_1;
        hn_idx_0 = sys_cfg.get_hn_idx(chi0_rn_seq[0].output_xacts[0].addr);
        hn_idx_1 = sys_cfg.get_hn_idx(chi0_rn_seq[1].output_xacts[0].addr);
        if (hn_idx_0 == hn_idx_1) begin
          // pass
          `svt_xvm_debug("body", $sformatf("Targeted HN Index from both RNs is same as expected.  rn[%0d] to hn_idx[%0d], rn[%0d] to hn_idx[%0d]", initiating_rn_node_idx_0, hn_idx_0, initiating_rn_node_idx_1, hn_idx_1));
        end
        else begin
          // fail
          `svt_xvm_error("body", $sformatf("Targeted HN Index from both RNs is different, which is unexpected.  rn[%0d] %0s transaction to hn_idx[%0d], rn[%0d] %0s transaction to hn_idx[%0d]", 
                                           initiating_rn_node_idx_0, `SVT_CHI_PRINT_PREFIX( chi0_rn_seq[0].output_xacts[0]), hn_idx_0, initiating_rn_node_idx_1, `SVT_CHI_PRINT_PREFIX( chi0_rn_seq[1].output_xacts[0]), hn_idx_1));
        end
      end
    end
    /** 
     * To check the Interconnect HN's shall responds with same TxnID to 
     * respective RN's.<br>
     * Check done by System monitor(List of checkers)<br>
     *  #- read_data_integrity_check
     *  #- coherent_and_snoop_data_match_check
     *  .
     */

    `svt_xvm_debug("body", "Exiting...");
  endtask: body

  virtual task post_start();
    drop_phase_objection();
  endtask

endclass: svt_chi_system_protocol_flow_ctrl_read_resp_same_txnid_diff_rn_same_hn_virtual_sequence

function svt_chi_system_protocol_flow_ctrl_read_resp_same_txnid_diff_rn_same_hn_virtual_sequence::new(string name="svt_chi_system_protocol_flow_ctrl_read_resp_same_txnid_diff_rn_same_hn_virtual_sequence");
  super.new(name);
endfunction

/////////////////////////////
// Write type
/////////////////////////////
/**
 * @groupname CHI_FLOW_CTRL_WR_TYPE  
 *   #- Program two MAKEUNIQUE transaction from one randomly selected RN targeted to different HN.<br>
 *   #- Program two randomly selected different RN VIP to drive a write transaction with same <br> 
 *      Txnid simultaneously to randomly selected different HN Nodes of<br>
 *      MAKEUNIQUE transactions.<br>
 *   #- Check the HN responds with same Txnid to respective RN's.<br>
 *   .
 */
class svt_chi_system_protocol_flow_ctrl_write_resp_same_txnid_diff_rn_diff_hn_virtual_sequence extends svt_chi_system_base_virtual_sequence;

  bit enable_outstanding = 0;

  bit enable_outstanding_status = 0;

  /** To display contents of Active Participating RN's node */
  string str_rn_node;

  /** To display contents of Active Participating RN_F's node */
  string str_rn_f_node;

  /** UVM Object Utility macro */
  `uvm_object_utils(svt_chi_system_protocol_flow_ctrl_write_resp_same_txnid_diff_rn_diff_hn_virtual_sequence)

  extern function new(string name="svt_chi_system_protocol_flow_ctrl_write_resp_same_txnid_diff_rn_diff_hn_virtual_sequence");

 /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting any type of Request Nodes = 2
   *  .
   */
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    
    /** local variables */
    int num_supporting_request_nodes;
    int num_hn_f_nodes;   
    int array_idx;
    bit is_rn_idx_0_participating, is_rn_idx_1_participating;
    string str_is_supported_info_prefix = "";
    string str_is_supported_info = "";
    string str_idx0_info = "";
    string str_idx1_info = "";    

    /** Supporting any type of Request Nodes required */
    int required_num_supporting_request_nodes = 2;
    int required_num_hn_nodes = 2;

    /** By default is_supported is 0 */
    is_supported = 0;

    /** Check for minimum required HN-F nodes */
    num_hn_f_nodes = hn_f_nodes.size();

    /** Check requirment of number of HN nodes needed */    
    if (num_hn_f_nodes < required_num_hn_nodes) begin
      issue_is_supported_failure($sformatf("This sequence requires minimum %0d HN-F nodes to be present in the system. Number of HN-F nodes are %0d. Program number of HN nodes using svt_chi_system_configuration::num_hn. Program the HN interface type using svt_chi_system_configuration::chi_addr_cfg.hn_interface_type[].", required_num_hn_nodes, num_hn_f_nodes));
      return 0;      
    end

    /** Check for minimum required RN nodes.
     *  Also check whether the selected RN nodes are part of participating arrays or not.
     */ 
    num_supporting_request_nodes = active_participating_rn_nodes.size();

    /** Check the requirements of RN nodes */
    if (num_supporting_request_nodes) begin
      /** Display the contents of Active Participating RN Nodes */
      foreach (active_participating_rn_nodes[j]) begin
        str_rn_node = {str_rn_node, $sformatf(" %0d", active_participating_rn_nodes[j])};
      end 
      `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_nodes are %0s", str_rn_node));
    end

    str_is_supported_info_prefix = $sformatf("Number of Supporting RN Node(s)  - Minimum Required : %0d Current : %0d", required_num_supporting_request_nodes, num_supporting_request_nodes);
    
    if ((initiating_rn_node_index_0_status==0)&&(valid_initiating_rn_node_index_0==0)) begin
        str_idx0_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN's that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F or RN_I)";
    end
    else begin
      is_rn_idx_0_participating = is_value_found_in_int_assoc_array(active_participating_rn_nodes, initiating_rn_node_idx_0, array_idx);
      if (!is_rn_idx_0_participating) begin
        str_idx0_info = $sformatf("initiating_rn_node_idx_0 %0d is not valid for this sequence. The RN corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuration::participating_rn_nodes[])", initiating_rn_node_idx_0, initiating_rn_node_idx_0);
      end
    end
    if ((initiating_rn_node_index_1_status==0)&&(valid_initiating_rn_node_index_1==0)) begin
        str_idx1_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN's that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F or RN_I)";
    end
    else begin
      is_rn_idx_1_participating = is_value_found_in_int_assoc_array(active_participating_rn_nodes, initiating_rn_node_idx_1, array_idx);
      if (!is_rn_idx_1_participating) begin
        str_idx1_info = $sformatf("initiating_rn_node_idx_1 %0d is not valid for this sequence. The RN corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuration::participating_rn_nodes[])", initiating_rn_node_idx_1, initiating_rn_node_idx_1);
      end
    end

    if (is_rn_idx_0_participating && is_rn_idx_1_participating) begin
      is_supported = 1;
    end
    
    if (!is_supported) begin
      str_is_supported_info = $sformatf("%0s%0s",str_idx0_info, str_idx1_info);
      issue_is_supported_failure($sformatf("This sequence cannot be run based on the current system configuration.\n\
                                            %0s \n\
                                            %0s \n\
                                            Modify configurations through \n\
                                            svt_chi_system_configuration::num_rn,\n\
                                            svt_chi_node_configuration::is_active,\n\
                                            svt_chi_system_configuration::participating_request_nodes\n\
                                            ", str_is_supported_info_prefix, str_is_supported_info));
    end      
    if (!is_target_hn_idx_valid_for_curr_cfg()) begin
      is_supported = 0;
      `svt_xvm_note("is_supported", "not a valid hn_idx based on random_tgt_id_enable for current cfg");
    end
  endfunction : is_supported

  virtual task pre_start();
    super.pre_start();
    raise_phase_objection();
    enable_outstanding_status = uvm_config_db#(bit)::get(m_sequencer, get_type_name(), "enable_outstanding", enable_outstanding);
    `svt_xvm_debug("body", $sformatf("enable_outstanding is %0b as a result of %0s", enable_outstanding, (enable_outstanding_status?"config DB":"default setting")));
  endtask

  virtual task body();
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0] addr1;
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0] addr2;
    bit                                perform_cache_initialization;
    int                                array_idx;
    bit txn1_is_non_secure_access;
    bit txn2_is_non_secure_access;

    /** CHI RN directed sequence */
    svt_chi_rn_write_type_transaction_directed_sequence write_seq[int];
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq[int];

    `svt_xvm_debug("body", "Entering ...")
   super.body();

    // Default
    enable_outstanding = 0;
    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :initiating_rn_node_index_0;
    initiating_rn_node_idx_1 = initiating_rn_node_index_1_status ? initiating_rn_node_index_1_from_config_db :initiating_rn_node_index_1;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_node_index_0;
    target_hn_node_idx_1 = target_hn_node_index_1_status ? target_hn_node_index_1_from_config_db :target_hn_node_index_1;

    `svt_xvm_debug("body", $sformatf("initiating_rn_node_idx_0 is %0d as a result of %0s.", initiating_rn_node_idx_0, initiating_rn_node_index_0_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("initiating_rn_node_idx_1 is %0d as a result of %0s.", initiating_rn_node_idx_1, initiating_rn_node_index_1_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("target_hn_node_idx_0 is %0d as a result of %0s.", target_hn_node_idx_0, target_hn_node_index_0_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("target_hn_node_idx_1 is %0d as a result of %0s.", target_hn_node_idx_1, target_hn_node_index_1_status ? "config DB" : "Randomization"));  

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /**
     * If the cache_line_init_rn_f_node_index is same as any of the RN node indices 
     * which are passed through config i.e initiating_rn_f_node_index_0,initiating_rn_f_node_index_1,
     * then re-assign the cache_line_init_rn_f_node_index with RN node index ,which is active,
     * participating and not equal to initiating_rn_node_idx_0, initiating_rn_node_idx_1.
     */
    if(initiating_rn_node_index_0_status||initiating_rn_node_index_1_status)begin  
      if((cache_line_init_rn_f_node_index == initiating_rn_node_idx_0)||(cache_line_init_rn_f_node_index == initiating_rn_node_idx_1))begin  
        int active_participating_q [$];
        `svt_chi_xxm_debug("body",$sformatf("cache_line_init_rn_f_node_index= %0d is same as initiating_rn_node_idx_0=%0d or initiating_rn_node_idx_1=%0d and active_participating_rn_f_nodes.size()= %0d",cache_line_init_rn_f_node_index,initiating_rn_node_idx_0,initiating_rn_node_idx_1,active_participating_rn_f_nodes.size()));
        if(active_participating_rn_f_nodes.size()>2)begin
          active_participating_q = active_participating_rn_f_nodes.find with ((item != initiating_rn_node_idx_0) && (item != initiating_rn_node_idx_1));
          cache_line_init_rn_f_node_index = active_participating_q.pop_back();
          `svt_chi_xxm_debug("body", $sformatf("active_participating_q.size() is %0d and Selected different cache_line_init_rn_f_node_index=%0d", active_participating_q.size(),cache_line_init_rn_f_node_index));
          active_participating_q.delete();
        end else begin
          perform_cache_initialization=0;
          `svt_chi_xxm_debug("body",$sformatf("BYPASSING Cache Initialization as selected cache_line_init_rn_f_node_index= %0d is same as initiating_rn_node_index_0_from_config_db=%0d or initiating_rn_node_index_1_from_config_db=%0d and active_participating_rn_f_nodes.size()= %0d",cache_line_init_rn_f_node_index,initiating_rn_node_index_0_from_config_db,initiating_rn_node_index_1_from_config_db,active_participating_rn_f_nodes.size()));
        end
      end  
    end 

    // If the cache_line_init_rn_f_node_index is part of active_participating_rn_f_nodes array, and
    // it is not equal to initiating_rn_node_idx_0, initiating_rn_node_idx_1; then we can
    // perform cache initialization from the RN[cache_line_init_rn_f_node_index].
    if ((is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, cache_line_init_rn_f_node_index, array_idx)) &&
        (cache_line_init_rn_f_node_index != initiating_rn_node_idx_0) &&
        (cache_line_init_rn_f_node_index != initiating_rn_node_idx_1)) begin
      perform_cache_initialization = 1;
    end

    for(int i = 0; i < sequence_length; i++) begin
      if(perform_cache_initialization) begin

        /** Write data into Cache of Randomly selected third RN with address of randomly selected HN Node */
        `svt_xvm_do_on_with(makeunique_seq[0], p_sequencer.rn_virt_seqr[cache_line_init_rn_f_node_index].rn_xact_seqr,{
          sequence_length   == 1;
          hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
          seq_hn_node_idx   == target_hn_node_idx_0;
          use_seq_is_non_secure_access == 0;
        })

        /** Write data into Cache of third RN with address of randomly selected another HN Node */
        `svt_xvm_do_on_with(makeunique_seq[1], p_sequencer.rn_virt_seqr[cache_line_init_rn_f_node_index].rn_xact_seqr,{
          sequence_length   == 1;
          hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
          seq_hn_node_idx   == target_hn_node_idx_1;
          use_seq_is_non_secure_access == 0;
        })

      `svt_xvm_debug("body",$sformatf("FOR ITERATION =%0d : makeunique_seq[0].write_tran.hn_node_idx %0d. makeunique_seq[1].write_tran.hn_node_idx %0d.",
                                      i,makeunique_seq[0].write_tran.hn_node_idx,makeunique_seq[1].write_tran.hn_node_idx ));
        
        /** Waiting for above MakeUnique transactions to complete */
        foreach(makeunique_seq[j]) begin
          makeunique_seq[j].write_tran.wait_end();
        end

        /** Retrieving address from output transactions generated by the sequence */
        addr1 = makeunique_seq[0].output_xacts[0].addr;
        addr2 = makeunique_seq[1].output_xacts[0].addr;
        txn1_is_non_secure_access = makeunique_seq[0].output_xacts[0].is_non_secure_access;                 
        txn2_is_non_secure_access = makeunique_seq[1].output_xacts[0].is_non_secure_access;                 
      end // if (perform_cache_initialization)

      fork
        begin
          /** 
           * Do a Write type transaction from different first two Random RN to two MAKEUNIQUE 
           * transaction address of different HN node */ 
          `svt_xvm_do_on_with(write_seq[0], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,{
            sequence_length    == 1;
            `ifdef SVT_CHI_ISSUE_E_ENABLE
             if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A ){
               seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL};
             }            
             else if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision >= svt_chi_node_configuration::ISSUE_E ) {
               if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0) {
                  !(seq_xact_type inside {svt_chi_transaction::WRITENOSNPFULL_CLEANSHAREDPERSISTSEP, svt_chi_transaction::WRITENOSNPPTL_CLEANSHAREDPERSISTSEP, svt_chi_transaction::WRITENOSNPFULL_CLEANSHARED, svt_chi_transaction::WRITENOSNPFULL_CLEANINVALID, svt_chi_transaction::WRITENOSNPPTL_CLEANSHARED, svt_chi_transaction::WRITENOSNPPTL_CLEANINVALID, svt_chi_transaction::WRITENOSNPZERO, svt_chi_transaction::WRITENOSNPFULL, svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITEUNIQUEFULLSTASH, svt_chi_transaction::WRITEUNIQUEPTLSTASH});
               }   
               else if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 1){
                  !(seq_xact_type inside {svt_chi_transaction::WRITENOSNPFULL_CLEANSHAREDPERSISTSEP, svt_chi_transaction::WRITENOSNPPTL_CLEANSHAREDPERSISTSEP, svt_chi_transaction::WRITENOSNPFULL_CLEANSHARED, svt_chi_transaction::WRITENOSNPFULL_CLEANINVALID, svt_chi_transaction::WRITENOSNPPTL_CLEANSHARED, svt_chi_transaction::WRITENOSNPPTL_CLEANINVALID, svt_chi_transaction::WRITENOSNPZERO,svt_chi_transaction::WRITENOSNPFULL, svt_chi_transaction::WRITENOSNPPTL});
               }        
             }
             else if ((sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision < svt_chi_node_configuration::ISSUE_E ) && (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision > svt_chi_node_configuration::ISSUE_A )){
               if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0) {
                   seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL};
               }
               else if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 1) {
                   seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL, svt_chi_transaction::WRITEUNIQUEFULLSTASH, svt_chi_transaction::WRITEUNIQUEPTLSTASH};
               }
             }            
            `elsif SVT_CHI_ISSUE_B_ENABLE
             if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A || sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0) {
               !(seq_xact_type inside {svt_chi_transaction::WRITENOSNPFULL, svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITEUNIQUEFULLSTASH, svt_chi_transaction::WRITEUNIQUEPTLSTASH});
             }
             else{
               !(seq_xact_type inside {svt_chi_transaction::WRITENOSNPFULL, svt_chi_transaction::WRITENOSNPPTL});
             }
            `else
               !(seq_xact_type inside {svt_chi_transaction::WRITENOSNPFULL, svt_chi_transaction::WRITENOSNPPTL});
            `endif
            //seq_xact_type != svt_chi_transaction::WRITENOSNPFULL;
            //seq_xact_type != svt_chi_transaction::WRITENOSNPPTL;
            if (perform_cache_initialization)
            {
              hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
              min_addr == addr1;
              max_addr == addr1;
              seq_is_non_secure_access == txn1_is_non_secure_access; 
              use_seq_is_non_secure_access == 1;
            }
            else
            {
              hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
              seq_hn_node_idx   == target_hn_node_idx_0;
              use_seq_is_non_secure_access == 0;
            }                                                                                                  
          })
        end
        begin
          `svt_xvm_do_on_with(write_seq[1], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,{
            sequence_length    == 1;
            `ifdef SVT_CHI_ISSUE_E_ENABLE
             if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision == svt_chi_node_configuration::ISSUE_A ){
               seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL};
             }            
             else if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision >= svt_chi_node_configuration::ISSUE_E ) {
               if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 0) {
                  !(seq_xact_type inside {svt_chi_transaction::WRITENOSNPFULL_CLEANSHAREDPERSISTSEP, svt_chi_transaction::WRITENOSNPPTL_CLEANSHAREDPERSISTSEP, svt_chi_transaction::WRITENOSNPFULL_CLEANSHARED, svt_chi_transaction::WRITENOSNPFULL_CLEANINVALID, svt_chi_transaction::WRITENOSNPPTL_CLEANSHARED, svt_chi_transaction::WRITENOSNPPTL_CLEANINVALID, svt_chi_transaction::WRITENOSNPZERO, svt_chi_transaction::WRITENOSNPFULL, svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITEUNIQUEFULLSTASH, svt_chi_transaction::WRITEUNIQUEPTLSTASH});
               }   
               else if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 1){
                  !(seq_xact_type inside {svt_chi_transaction::WRITENOSNPFULL_CLEANSHAREDPERSISTSEP, svt_chi_transaction::WRITENOSNPPTL_CLEANSHAREDPERSISTSEP, svt_chi_transaction::WRITENOSNPFULL_CLEANSHARED, svt_chi_transaction::WRITENOSNPFULL_CLEANINVALID, svt_chi_transaction::WRITENOSNPPTL_CLEANSHARED, svt_chi_transaction::WRITENOSNPPTL_CLEANINVALID, svt_chi_transaction::WRITENOSNPZERO,svt_chi_transaction::WRITENOSNPFULL, svt_chi_transaction::WRITENOSNPPTL});
               }        
             }
             else if ((sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision < svt_chi_node_configuration::ISSUE_E ) && (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision > svt_chi_node_configuration::ISSUE_A )){
               if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 0) {
                   seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL};
               }
               else if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 1) {
                   seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL, svt_chi_transaction::WRITEUNIQUEFULLSTASH, svt_chi_transaction::WRITEUNIQUEPTLSTASH};
               }
             }            
            `elsif SVT_CHI_ISSUE_B_ENABLE
             if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision == svt_chi_node_configuration::ISSUE_A || sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 0) {
               !(seq_xact_type inside {svt_chi_transaction::WRITENOSNPFULL, svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITEUNIQUEFULLSTASH, svt_chi_transaction::WRITEUNIQUEPTLSTASH});
             }
             else{
               !(seq_xact_type inside {svt_chi_transaction::WRITENOSNPFULL, svt_chi_transaction::WRITENOSNPPTL});
             }
            `else
               !(seq_xact_type inside {svt_chi_transaction::WRITENOSNPFULL, svt_chi_transaction::WRITENOSNPPTL});
            `endif
            //seq_xact_type != svt_chi_transaction::WRITENOSNPFULL;
            //seq_xact_type != svt_chi_transaction::WRITENOSNPPTL;
            seq_txn_id          == write_seq[0].seq_txn_id;
            if (perform_cache_initialization)
            {    
              hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
              min_addr == addr2;
              max_addr == addr2;
              seq_is_non_secure_access == txn2_is_non_secure_access; 
              use_seq_is_non_secure_access == 1;
            }
            else
            {
              hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
              seq_hn_node_idx   == target_hn_node_idx_1;
              use_seq_is_non_secure_access == 0;
            }
          })
        end
      join

      /** Waiting for above Write transactions to complete */
      foreach(write_seq[i]) begin
        `svt_xvm_debug("body",$sformatf("FOR ITERATION =%0d : write_seq[i].write_tran.hn_node_idx %0d",i,write_seq[i].write_tran.hn_node_idx));
        write_seq[i].write_tran.wait_end();
      end

      // TxnID should be the same from both the RNs      
      if (write_seq[0].output_xacts[0].txn_id == write_seq[1].output_xacts[0].txn_id) begin
        // pass
        `svt_xvm_debug("body", $sformatf("TxnID match: TxnID 'd%0d is the same from both the RNs", write_seq[0].output_xacts[0].txn_id));
      end
      else begin
        // fail
        `svt_xvm_error("body", $sformatf("TxnID mismatch: TxnID is expected to be the same from both the RNs, but that is not the case. Transaction %0s from rn[%0d] has TxnID 'd%0d, transaction %0s from rn[%0d] has TxnId 'd%0d ", 
                                         `SVT_CHI_PRINT_PREFIX( write_seq[0].output_xacts[0]),initiating_rn_node_idx_0, write_seq[0].output_xacts[0].txn_id, `SVT_CHI_PRINT_PREFIX( write_seq[1].output_xacts[0]), initiating_rn_node_idx_1, write_seq[1].output_xacts[0].txn_id));
      end

      // Targetted HN IDs from both RNs should be different
      begin
        int hn_idx_0, hn_idx_1;
        hn_idx_0 = sys_cfg.get_hn_idx(write_seq[0].output_xacts[0].addr);
        hn_idx_1 = sys_cfg.get_hn_idx(write_seq[1].output_xacts[0].addr);
        if (hn_idx_0 != hn_idx_1) begin
          // pass
          `svt_xvm_debug("body", $sformatf("Targeted HN Index from both RNs is different as expected.  rn[%0d] to hn_idx[%0d], rn[%0d] to hn_idx[%0d]", initiating_rn_node_idx_0, hn_idx_0, initiating_rn_node_idx_1, hn_idx_1));
        end
        else begin
          // fail
          `svt_xvm_error("body", $sformatf("Targeted HN Index from both RNs is same, which is unexpected.  rn[%0d] %0s transaction to hn_idx[%0d], rn[%0d] %0s transaction to hn_idx[%0d]", 
                                           initiating_rn_node_idx_0, `SVT_CHI_PRINT_PREFIX( write_seq[0].output_xacts[0]), hn_idx_0, initiating_rn_node_idx_1, `SVT_CHI_PRINT_PREFIX( write_seq[1].output_xacts[0]), hn_idx_1));
        end
      end
    end //for sequence_length
    /** 
     * To check the Interconnect HN Node shall responds with same txnid to 
     * respective RN's.<br>
     * Check done by System monitor(List of checkers)<br>
     *  #- snoop_data_integrity_check 
     *  .  
     */
    `svt_xvm_debug("body", "Exiting...")
  endtask: body

  virtual task post_start();
    super.post_start();
    drop_phase_objection();
  endtask

endclass: svt_chi_system_protocol_flow_ctrl_write_resp_same_txnid_diff_rn_diff_hn_virtual_sequence

function svt_chi_system_protocol_flow_ctrl_write_resp_same_txnid_diff_rn_diff_hn_virtual_sequence::new(string name="svt_chi_system_protocol_flow_ctrl_write_resp_same_txnid_diff_rn_diff_hn_virtual_sequence");
  super.new(name);
endfunction

/**
 * @groupname CHI_FLOW_CTRL_WR_TYPE   
 *   #- Program two MAKEUNIQUE transaction from one randomly selected RN targeted to same HN.<br>
 *   #- Program two randomly selected different RN VIP to drive a write transaction with same <br> 
 *      Txnid simultaneously to randomly selected same HN Nodes of<br>
 *      MAKEUNIQUE transactions.<br>
 *   #- Check the HN responds with same Txnid to respective RN's.<br>
 *   .
 */
class svt_chi_system_protocol_flow_ctrl_write_resp_same_txnid_diff_rn_same_hn_virtual_sequence extends svt_chi_system_base_virtual_sequence;


  bit enable_outstanding = 0;

  bit enable_outstanding_status = 0;

  /** To display contents of Active Participating RN's node */
  string str_rn_node;

  /** To display contents of Active Participating RN_F's node */
  string str_rn_f_node;

  /** UVM Object Utility macro */
  `uvm_object_utils(svt_chi_system_protocol_flow_ctrl_write_resp_same_txnid_diff_rn_same_hn_virtual_sequence)

  extern function new(string name="svt_chi_system_protocol_flow_ctrl_write_resp_same_txnid_diff_rn_same_hn_virtual_sequence");

 /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting any type of Request Nodes = 2
   *  .
   */
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    
    /** local variables */
    int num_supporting_request_nodes;
    int num_hn_f_nodes;   
    int array_idx;
    bit is_rn_idx_0_participating, is_rn_idx_1_participating;
    string str_is_supported_info_prefix = "";
    string str_is_supported_info = "";
    string str_idx0_info = "";
    string str_idx1_info = "";    

    /** Supporting any type of Request Nodes required */
    int required_num_supporting_request_nodes = 2;
    int required_num_hn_nodes = 1;

    /** By default is_supported is 0 */
    is_supported = 0;

    /** Check for minimum required HN-F nodes */
    num_hn_f_nodes = hn_f_nodes.size();

    /** Check requirment of number of HN nodes needed */ 
    if (num_hn_f_nodes < required_num_hn_nodes) begin
      issue_is_supported_failure($sformatf("This sequence requires minimum %0d HN-F nodes to be present in the system. Number of HN-F nodes are %0d. Program number of HN nodes using svt_chi_system_configuration::num_hn. Program the HN interface type using svt_chi_system_configuration::chi_addr_cfg.hn_interface_type[].", required_num_hn_nodes, num_hn_f_nodes));
      return 0;      
    end

    /** Check for minimum required RN nodes.
     *  Also check whether the selected RN nodes are part of participating arrays or not.
     */ 
    num_supporting_request_nodes = active_participating_rn_nodes.size();

    /** Check the requirements of RN nodes */
    if (num_supporting_request_nodes) begin
      /** Display the contents of Active Participating RN Nodes */
      foreach (active_participating_rn_nodes[j]) begin
        str_rn_node = {str_rn_node, $sformatf(" %0d", active_participating_rn_nodes[j])};
      end 
      `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_nodes are %0s", str_rn_node));
    end

    str_is_supported_info_prefix = $sformatf("Number of Supporting RN Node(s)  - Minimum Required : %0d Current : %0d", required_num_supporting_request_nodes, num_supporting_request_nodes);
    
    if ((initiating_rn_node_index_0_status==0)&&(valid_initiating_rn_node_index_0==0)) begin
        str_idx0_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN's that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F or RN_I)";
    end
    else begin
      is_rn_idx_0_participating = is_value_found_in_int_assoc_array(active_participating_rn_nodes, initiating_rn_node_idx_0, array_idx);
      if (!is_rn_idx_0_participating) begin
        str_idx0_info = $sformatf("initiating_rn_node_idx_0 %0d is not valid for this sequence. The RN corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuration::participating_rn_nodes[])", initiating_rn_node_idx_0, initiating_rn_node_idx_0);
      end
    end
    if ((initiating_rn_node_index_1_status==0)&&(valid_initiating_rn_node_index_1==0)) begin
        str_idx1_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN's that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F or RN_I)";
    end
    else begin
      is_rn_idx_1_participating = is_value_found_in_int_assoc_array(active_participating_rn_nodes, initiating_rn_node_idx_1, array_idx);
      if (!is_rn_idx_1_participating) begin
        str_idx1_info = $sformatf("initiating_rn_node_idx_1 %0d is not valid for this sequence. The RN corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuration::participating_rn_nodes[])", initiating_rn_node_idx_1, initiating_rn_node_idx_1);
      end
    end

    if (is_rn_idx_0_participating && is_rn_idx_1_participating) begin
      is_supported = 1;
    end
    
    if (!is_supported) begin
      str_is_supported_info = $sformatf("%0s%0s",str_idx0_info, str_idx1_info);
      issue_is_supported_failure($sformatf("This sequence cannot be run based on the current system configuration.\n\
                                            %0s \n\
                                            %0s \n\
                                            Modify configurations through \n\
                                            svt_chi_system_configuration::num_rn,\n\
                                            svt_chi_node_configuration::is_active,\n\
                                            svt_chi_system_configuration::participating_request_nodes\n\
                                            ", str_is_supported_info_prefix, str_is_supported_info));
    end      
    if (!is_target_hn_idx_valid_for_curr_cfg()) begin
      is_supported = 0;
      `svt_xvm_note("is_supported", "not a valid hn_idx based on random_tgt_id_enable for current cfg");
    end
  endfunction : is_supported

  virtual task pre_start();
    super.pre_start();
    raise_phase_objection();
    enable_outstanding_status = uvm_config_db#(bit)::get(m_sequencer, get_type_name(), "enable_outstanding", enable_outstanding);
    `svt_xvm_debug("body", $sformatf("enable_outstanding is %0b as a result of %0s", enable_outstanding, (enable_outstanding_status?"config DB":"default setting")));
  endtask

  virtual task body();
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0] addr1;
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0] addr2;
    bit txn1_is_non_secure_access, txn2_is_non_secure_access;
    bit                                perform_cache_initialization;
    int                                array_idx;
    /** CHI RN directed sequence */
    svt_chi_rn_write_type_transaction_directed_sequence write_seq[int];
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq[int];

    `svt_xvm_debug("body", "Entering ...")
    super.body();
    // Default
    enable_outstanding = 0;

    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :initiating_rn_node_index_0;
    initiating_rn_node_idx_1 = initiating_rn_node_index_1_status ? initiating_rn_node_index_1_from_config_db :initiating_rn_node_index_1;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_node_index_0;

    `svt_xvm_debug("body", $sformatf("initiating_rn_node_idx_0 is %0d as a result of %0s.", initiating_rn_node_idx_0, initiating_rn_node_index_0_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("initiating_rn_node_idx_1 is %0d as a result of %0s.", initiating_rn_node_idx_1, initiating_rn_node_index_1_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("target_hn_node_idx_0 is %0d as a result of %0s.", target_hn_node_idx_0, target_hn_node_index_0_status ? "config DB" : "Randomization"));

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /**
     * If the cache_line_init_rn_f_node_index is same as any of the RN node indices 
     * which are passed through config i.e initiating_rn_node_idx_0,initiating_rn_node_idx_1,
     * then re-assign the cache_line_init_rn_f_node_index with RN node index ,which is active,
     * participating and not equal to initiating_rn_node_idx_0, initiating_rn_node_idx_1.
     */
    if(initiating_rn_node_index_0_status||initiating_rn_node_index_1_status)begin  
      if((cache_line_init_rn_f_node_index == initiating_rn_node_idx_0)||(cache_line_init_rn_f_node_index == initiating_rn_node_idx_1))begin  
        int active_participating_q [$];
        `svt_chi_xxm_debug("body",$sformatf("cache_line_init_rn_f_node_index= %0d is same as initiating_rn_node_idx_0=%0d or initiating_rn_node_idx_1=%0d and active_participating_rn_f_nodes.size()= %0d",cache_line_init_rn_f_node_index,initiating_rn_node_idx_0,initiating_rn_node_idx_1,active_participating_rn_f_nodes.size()));
        if(active_participating_rn_f_nodes.size()>2)begin
          active_participating_q = active_participating_rn_f_nodes.find with ((item != initiating_rn_node_idx_0) && (item != initiating_rn_node_idx_1));
          cache_line_init_rn_f_node_index = active_participating_q.pop_back();
          `svt_chi_xxm_debug("body", $sformatf("active_participating_q.size() is %0d and Selected different cache_line_init_rn_f_node_index=%0d", active_participating_q.size(),cache_line_init_rn_f_node_index));
          active_participating_q.delete();
        end else begin
          perform_cache_initialization=0;
          `svt_chi_xxm_debug("body",$sformatf("BYPASSING Cache Initialization as selected cache_line_init_rn_f_node_index= %0d is same as initiating_rn_node_index_0_from_config_db=%0d or initiating_rn_node_index_1_from_config_db=%0d and active_participating_rn_f_nodes.size()= %0d",cache_line_init_rn_f_node_index,initiating_rn_node_index_0_from_config_db,initiating_rn_node_index_1_from_config_db,active_participating_rn_f_nodes.size()));
        end
      end  
    end 
    
    // If the cache_line_init_rn_f_node_index is part of active_participating_rn_f_nodes array, and
    // it is not equal to initiating_rn_node_idx_0, initiating_rn_node_idx_1; then we can
    // perform cache initialization from the RN[cache_line_init_rn_f_node_index].
    if ((is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, cache_line_init_rn_f_node_index, array_idx)) &&
        (cache_line_init_rn_f_node_index != initiating_rn_node_idx_0) &&
        (cache_line_init_rn_f_node_index != initiating_rn_node_idx_1)) begin
      perform_cache_initialization = 1;
    end
    
    `svt_xvm_debug("body", $sformatf("perform_cache_initialization is %0b, cache_line_init_rn_f_node_index is %0d, initiating_rn_node_idx_0 is %0d, initiating_rn_node_idx_1 is %0d", perform_cache_initialization, cache_line_init_rn_f_node_index, initiating_rn_node_idx_0, initiating_rn_node_idx_1));    

    for(int i = 0; i < sequence_length; i++) begin

      if(perform_cache_initialization) begin

        /** Write data into Cache of Randomly selected third RN with address of randomly selected HN Node */
        `svt_xvm_do_on_with(makeunique_seq[0], p_sequencer.rn_virt_seqr[cache_line_init_rn_f_node_index].rn_xact_seqr,{
          sequence_length   == 1;
          hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
          seq_hn_node_idx   == target_hn_node_idx_0;
          use_seq_is_non_secure_access == 0;
        })

        /** Write data into Cache of third RN with address of randomly selected another HN Node */
        `svt_xvm_do_on_with(makeunique_seq[1], p_sequencer.rn_virt_seqr[cache_line_init_rn_f_node_index].rn_xact_seqr,{
          sequence_length   == 1;
          hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
          seq_hn_node_idx   == target_hn_node_idx_0;
          use_seq_is_non_secure_access == 0;
        })

        `svt_xvm_debug("body",$sformatf("FOR ITERATION =%0d : makeunique_seq[0].write_tran.hn_node_idx %0d. makeunique_seq[1].write_tran.hn_node_idx %0d.",
                                        i,makeunique_seq[0].write_tran.hn_node_idx,makeunique_seq[1].write_tran.hn_node_idx ));
        
        /** Waiting for above MakeUnique transactions to complete */
        foreach(makeunique_seq[j]) begin
          makeunique_seq[j].write_tran.wait_end();
        end

        /** Retrieving address from output transactions generated by the sequence */
        addr1 = makeunique_seq[0].output_xacts[0].addr;
        addr2 = makeunique_seq[1].output_xacts[0].addr;
        txn1_is_non_secure_access = makeunique_seq[0].output_xacts[0].is_non_secure_access;                 
        txn2_is_non_secure_access = makeunique_seq[1].output_xacts[0].is_non_secure_access;                 
      end // if (perform_cache_initialization)

      fork
        begin
          /** 
           * Do a Write type transaction from different first two Random RN to two MAKEUNIQUE 
           * transaction address of different HN node */ 
          `svt_xvm_do_on_with(write_seq[0], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,{
            sequence_length    == 1;
            `ifdef SVT_CHI_ISSUE_E_ENABLE
             if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A ){
               seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL};
             }            
             else if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision >= svt_chi_node_configuration::ISSUE_E ) {
               if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0) {
                  !(seq_xact_type inside {svt_chi_transaction::WRITENOSNPFULL_CLEANSHAREDPERSISTSEP, svt_chi_transaction::WRITENOSNPPTL_CLEANSHAREDPERSISTSEP, svt_chi_transaction::WRITENOSNPFULL_CLEANSHARED, svt_chi_transaction::WRITENOSNPFULL_CLEANINVALID, svt_chi_transaction::WRITENOSNPPTL_CLEANSHARED,  svt_chi_transaction::WRITENOSNPPTL_CLEANINVALID, svt_chi_transaction::WRITENOSNPZERO, svt_chi_transaction::WRITENOSNPFULL, svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITEUNIQUEFULLSTASH, svt_chi_transaction::WRITEUNIQUEPTLSTASH});
               }   
               else if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 1){
                  !(seq_xact_type inside {svt_chi_transaction::WRITENOSNPFULL_CLEANSHAREDPERSISTSEP, svt_chi_transaction::WRITENOSNPPTL_CLEANSHAREDPERSISTSEP, svt_chi_transaction::WRITENOSNPFULL_CLEANSHARED, svt_chi_transaction::WRITENOSNPFULL_CLEANINVALID, svt_chi_transaction::WRITENOSNPPTL_CLEANSHARED, svt_chi_transaction::WRITENOSNPPTL_CLEANINVALID, svt_chi_transaction::WRITENOSNPZERO,svt_chi_transaction::WRITENOSNPFULL, svt_chi_transaction::WRITENOSNPPTL});
               }        
             }
             else if ((sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision < svt_chi_node_configuration::ISSUE_E ) && (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision > svt_chi_node_configuration::ISSUE_A )){
               if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0) {
                   seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL};
               }
               else if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 1) {
                   seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL, svt_chi_transaction::WRITEUNIQUEFULLSTASH, svt_chi_transaction::WRITEUNIQUEPTLSTASH};
               }
             }  
            `elsif SVT_CHI_ISSUE_B_ENABLE
             if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A || sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0) {
               !(seq_xact_type inside {svt_chi_transaction::WRITENOSNPFULL, svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITEUNIQUEFULLSTASH, svt_chi_transaction::WRITEUNIQUEPTLSTASH});
             }
             else{
               !(seq_xact_type inside {svt_chi_transaction::WRITENOSNPFULL, svt_chi_transaction::WRITENOSNPPTL});
             }
            `else
               !(seq_xact_type inside {svt_chi_transaction::WRITENOSNPFULL, svt_chi_transaction::WRITENOSNPPTL});
            `endif
            //seq_xact_type != svt_chi_transaction::WRITENOSNPFULL;
            //seq_xact_type != svt_chi_transaction::WRITENOSNPPTL;
            if (perform_cache_initialization)
            {
              hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
              min_addr == addr1;
              max_addr == addr1;
              seq_is_non_secure_access == txn1_is_non_secure_access; 
              use_seq_is_non_secure_access == 1;
            }
            else
            {
              hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
              seq_hn_node_idx   == target_hn_node_idx_0;
              use_seq_is_non_secure_access == 0;
            }                                                                                                  
          })
        end
        begin
          `svt_xvm_do_on_with(write_seq[1], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,{
            sequence_length    == 1;
            `ifdef SVT_CHI_ISSUE_E_ENABLE
             if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision == svt_chi_node_configuration::ISSUE_A ){
               seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL};
             }            
             else if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision >= svt_chi_node_configuration::ISSUE_E ) {
               if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 0) {
                  !(seq_xact_type inside {svt_chi_transaction::WRITENOSNPFULL_CLEANSHAREDPERSISTSEP, svt_chi_transaction::WRITENOSNPPTL_CLEANSHAREDPERSISTSEP, svt_chi_transaction::WRITENOSNPFULL_CLEANSHARED, svt_chi_transaction::WRITENOSNPFULL_CLEANINVALID, svt_chi_transaction::WRITENOSNPPTL_CLEANSHARED, svt_chi_transaction::WRITENOSNPPTL_CLEANINVALID, svt_chi_transaction::WRITENOSNPZERO, svt_chi_transaction::WRITENOSNPFULL, svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITEUNIQUEFULLSTASH, svt_chi_transaction::WRITEUNIQUEPTLSTASH});
               }   
               else if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 1){
                  !(seq_xact_type inside {svt_chi_transaction::WRITENOSNPFULL_CLEANSHAREDPERSISTSEP, svt_chi_transaction::WRITENOSNPPTL_CLEANSHAREDPERSISTSEP, svt_chi_transaction::WRITENOSNPFULL_CLEANSHARED, svt_chi_transaction::WRITENOSNPFULL_CLEANINVALID, svt_chi_transaction::WRITENOSNPPTL_CLEANSHARED, svt_chi_transaction::WRITENOSNPPTL_CLEANINVALID, svt_chi_transaction::WRITENOSNPZERO,svt_chi_transaction::WRITENOSNPFULL, svt_chi_transaction::WRITENOSNPPTL});
               }        
             }
             else if ((sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision < svt_chi_node_configuration::ISSUE_E ) && (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision > svt_chi_node_configuration::ISSUE_A )){
               if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 0) {
                   seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL};
               }
               else if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 1) {
                   seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL, svt_chi_transaction::WRITEUNIQUEFULLSTASH, svt_chi_transaction::WRITEUNIQUEPTLSTASH};
               }
             }            
            `elsif SVT_CHI_ISSUE_B_ENABLE
             if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision == svt_chi_node_configuration::ISSUE_A || sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 0) {
               !(seq_xact_type inside {svt_chi_transaction::WRITENOSNPFULL, svt_chi_transaction::WRITENOSNPPTL, svt_chi_transaction::WRITEUNIQUEFULLSTASH, svt_chi_transaction::WRITEUNIQUEPTLSTASH});
             }
             else{
               !(seq_xact_type inside {svt_chi_transaction::WRITENOSNPFULL, svt_chi_transaction::WRITENOSNPPTL});
             }
            `else
               !(seq_xact_type inside {svt_chi_transaction::WRITENOSNPFULL, svt_chi_transaction::WRITENOSNPPTL});
            `endif
            //seq_xact_type != svt_chi_transaction::WRITENOSNPFULL;
            //seq_xact_type != svt_chi_transaction::WRITENOSNPPTL;
            seq_txn_id          == write_seq[0].seq_txn_id;
            if (perform_cache_initialization)
            {    
              hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
              min_addr == addr2;
              max_addr == addr2;
              seq_is_non_secure_access == txn2_is_non_secure_access; 
              use_seq_is_non_secure_access == 1;
            }
            else
            {
              hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
              seq_hn_node_idx   == target_hn_node_idx_0;
              use_seq_is_non_secure_access == 0;
            }
          })
        end
      join

      /** Waiting for above Write transactions to complete */
      foreach(write_seq[i]) begin
        `svt_xvm_debug("body",$sformatf("FOR ITERATION =%0d : write_seq[i].write_tran.hn_node_idx %0d",i,write_seq[i].write_tran.hn_node_idx));
        write_seq[i].write_tran.wait_end();
      end

      // TxnID should be the same from both the RNs      
      if (write_seq[0].output_xacts[0].txn_id == write_seq[1].output_xacts[0].txn_id) begin
        // pass
        `svt_xvm_debug("body", $sformatf("TxnID match: TxnID 'd%0d is the same from both the RNs", write_seq[0].output_xacts[0].txn_id));
      end
      else begin
        // fail
        `svt_xvm_error("body", $sformatf("TxnID mismatch: TxnID is expected to be the same from both the RNs, but that is not the case. Transaction %0s from rn[%0d] has TxnID 'd%0d, transaction %0s from rn[%0d] has TxnId 'd%0d ", 
                                         `SVT_CHI_PRINT_PREFIX( write_seq[0].output_xacts[0]),initiating_rn_node_idx_0, write_seq[0].output_xacts[0].txn_id, `SVT_CHI_PRINT_PREFIX( write_seq[1].output_xacts[0]), initiating_rn_node_idx_1, write_seq[1].output_xacts[0].txn_id));
      end

      // Targetted HN IDs from both RNs should be same
      begin
        int hn_idx_0, hn_idx_1;
        hn_idx_0 = sys_cfg.get_hn_idx(write_seq[0].output_xacts[0].addr);
        hn_idx_1 = sys_cfg.get_hn_idx(write_seq[1].output_xacts[0].addr);
        if (hn_idx_0 == hn_idx_1) begin
          // pass
          `svt_xvm_debug("body", $sformatf("Targeted HN Index from both RNs is same as expected.  rn[%0d] to hn_idx[%0d], rn[%0d] to hn_idx[%0d]", initiating_rn_node_idx_0, hn_idx_0, initiating_rn_node_idx_1, hn_idx_1));
        end
        else begin
          // fail
          `svt_xvm_error("body", $sformatf("Targeted HN Index from both RNs is different, which is unexpected.  rn[%0d] %0s transaction to hn_idx[%0d], rn[%0d] %0s transaction to hn_idx[%0d]", 
                                           initiating_rn_node_idx_0, `SVT_CHI_PRINT_PREFIX( write_seq[0].output_xacts[0]), hn_idx_0, initiating_rn_node_idx_0, `SVT_CHI_PRINT_PREFIX( write_seq[1].output_xacts[0]), hn_idx_1));
        end
      end
      
    end //for sequence_length
    /** 
     * To check the Interconnect HN Node shall responds with same txnid to 
     * respective RN's.<br>
     * Check done by System monitor(List of checkers)<br>
     *  #- snoop_data_integrity_check 
     *  .  
     */
    `svt_xvm_debug("body", "Exiting...")
  endtask: body

  virtual task post_start();
    super.post_start();
    drop_phase_objection();
  endtask


endclass: svt_chi_system_protocol_flow_ctrl_write_resp_same_txnid_diff_rn_same_hn_virtual_sequence

function svt_chi_system_protocol_flow_ctrl_write_resp_same_txnid_diff_rn_same_hn_virtual_sequence::new(string name="svt_chi_system_protocol_flow_ctrl_write_resp_same_txnid_diff_rn_same_hn_virtual_sequence");
  super.new(name);
endfunction

/////////////////////////////
// CopyBack type
/////////////////////////////
/**
 * @groupname CHI_FLOW_CTRL_CPBK_TYPE    
 *    #- Program the any two randomly selected RNs to drive a MakeUnique transaction targeted<br> 
 *       to randomly selected different HN.<br>
 *    #- Program the above selected RNs to drive a CopyBack transactions simultaneously with<br>
 *       same TxnId and address same as of MakeUnique transactions.<br>
 *    #- Check the HN responds with same Txnid to respective RN's.<br>
 *    #- Program a randomly selected RN to drive a ReadShared transaction to verify CopyBack<br>
 *       transaction.<br>
 *    .
 *    #- This sequence does not support EVICT and WRITEEVICTFULL transactions.<br>
 */
class svt_chi_system_protocol_flow_ctrl_copyback_resp_same_txnid_diff_rn_diff_hn_virtual_sequence extends svt_chi_system_base_virtual_sequence;
  /** @cond PRIVATE */
  /** Represents the active participating RN-F node that initiates ReadShared for self check */
  rand int unsigned self_check_init_rn_f_node_index; 

  /** To display contents of Active Participating RN_F's node */
  string str_rn_f_node;
  
  bit enable_outstanding = 0;

  constraint self_check_init_rn_f_node_index_c {
    if(active_participating_rn_f_nodes.size() > 2) {
      self_check_init_rn_f_node_index inside {active_participating_rn_f_nodes};
      self_check_init_rn_f_node_index != initiating_rn_f_node_index_0;
      self_check_init_rn_f_node_index != initiating_rn_f_node_index_1;
    }
  }
  /** @endcond */

  /** UVM Object Utility macro */
  `uvm_object_utils(svt_chi_system_protocol_flow_ctrl_copyback_resp_same_txnid_diff_rn_diff_hn_virtual_sequence)

  extern function new(string name="svt_chi_system_protocol_flow_ctrl_copyback_resp_same_txnid_diff_rn_diff_hn_virtual_sequence"); 

  /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting Request Nodes = 2
   */
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    
    /** local variables */
    int num_supporting_request_nodes;
    int num_hn_f_nodes;   
    int array_idx;
    bit is_rn_idx_0_participating, is_rn_idx_1_participating;
    string str_is_supported_info_prefix = "";
    string str_is_supported_info = "";
    string str_idx0_info = "";
    string str_idx1_info = "";    

    /** Supporting any type of Request Nodes required */
    int required_num_supporting_request_nodes = 2;
    int required_num_hn_nodes = 2;
    
    `svt_xvm_debug("is_supported",$sformatf("calling is_supported"));

    /** By default is_supported is 0 */
    is_supported = 0;

    /** Check for minimum required HN-F nodes */
    num_hn_f_nodes = hn_f_nodes.size();

    /** Check requirment of number of HN-F nodes needed */   
    if (num_hn_f_nodes < required_num_hn_nodes) begin
      issue_is_supported_failure($sformatf("This sequence requires minimum %0d HN-F nodes to be present in the system. Number of HN-F nodes are %0d. Program number of HN nodes using svt_chi_system_configuration::num_hn. Program the HN interface type using svt_chi_system_configuration::chi_addr_cfg.hn_interface_type[].", required_num_hn_nodes, num_hn_f_nodes));
      return 0;      
    end

    /** Check for minimum required RN-F nodes.
     *  Also check whether the selected RN-F nodes are part of participating arrays or not.
     */ 
    num_supporting_request_nodes = active_participating_rn_f_nodes.size();

    /** Check the requirements of RN nodes */
    if (num_supporting_request_nodes) begin
      /** Display the contents of Active Participating RN_F Nodes */
      foreach (active_participating_rn_f_nodes[j]) begin
        str_rn_f_node = {str_rn_f_node, $sformatf(" %0d", active_participating_rn_f_nodes[j])};
      end 
      `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_f_nodes are %0s", str_rn_f_node));
    end

    str_is_supported_info_prefix = $sformatf("Number of Supporting RN-F Node(s)  - Minimum Required : %0d Current : %0d", required_num_supporting_request_nodes, num_supporting_request_nodes);
    
    if ((initiating_rn_node_index_0_status==0)&&(valid_initiating_rn_f_node_index_0==0)) begin
        str_idx0_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN-Fs that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)";
    end
    else begin
      is_rn_idx_0_participating = is_value_found_in_int_assoc_array(active_participating_rn_nodes, initiating_rn_node_idx_0, array_idx);
      if (!is_rn_idx_0_participating) begin
        str_idx0_info = $sformatf("initiating_rn_node_idx_0 %0d is not valid for this sequence. The RN-F corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)", initiating_rn_node_idx_0, initiating_rn_node_idx_0);
      end
    end

    if ((initiating_rn_node_index_1_status==0)&&(valid_initiating_rn_f_node_index_1==0)) begin
      str_idx1_info = "Valid initiating_rn_node_idx_1 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN-Fs that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)";
    end 
    else begin
      is_rn_idx_1_participating = is_value_found_in_int_assoc_array(active_participating_rn_nodes, initiating_rn_node_idx_1, array_idx);
      if (!is_rn_idx_1_participating) begin
        str_idx1_info = $sformatf("initiating_rn_node_idx_1 %0d is not valid for this sequence. The RN-F corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)", initiating_rn_node_idx_1, initiating_rn_node_idx_1);
      end
    end  

    if (is_rn_idx_0_participating && is_rn_idx_1_participating) begin
      is_supported = 1;
    end
    
    if (!is_supported) begin
      str_is_supported_info = $sformatf("%0s%0s",str_idx0_info, str_idx1_info);
      issue_is_supported_failure($sformatf("This sequence cannot be run based on the current system configuration.\n\
                                            %0s \n\
                                            %0s \n\
                                            Modify configurations through \n\
                                            svt_chi_system_configuration::num_rn,\n\
                                            svt_chi_node_configuration::is_active,\n\
                                            svt_chi_system_configuration::participating_request_nodes\n\
                                            ", str_is_supported_info_prefix, str_is_supported_info));
    end      
    if (!is_target_hn_idx_valid_for_curr_cfg()) begin
      is_supported = 0;
      `svt_xvm_note("is_supported", "not a valid hn_idx based on random_tgt_id_enable for current cfg");
    end
  endfunction : is_supported

  virtual task pre_start();
    bit enable_outstanding_status;
    super.pre_start();
    raise_phase_objection();
    enable_outstanding_status = uvm_config_db#(bit)::get(m_sequencer, get_type_name(), "enable_outstanding", enable_outstanding);
    `svt_xvm_debug("body", $sformatf("enable_outstanding is %0b as a result of %0s", enable_outstanding, (enable_outstanding_status?"config DB":"default setting")));
  endtask

  virtual task body();
    bit _enable_outstanding;                                  
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0] addr1;
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0] addr2;
    bit [`SVT_CHI_MAX_DATA_WIDTH -1:0] data1,data2; 
    bit                                perform_data_selfcheck;
    int                                array_idx;
    bit txn1_is_non_secure_access;
    bit txn2_is_non_secure_access;
    
    /** CHI RN directed sequence */
    svt_chi_rn_copyback_type_transaction_directed_sequence copyback_seq[int];
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq[int];
    svt_chi_rn_read_type_transaction_directed_sequence readshared_seq[int];
  
    `svt_xvm_debug("body", "Entering ...")
    super.body();
    _enable_outstanding = enable_outstanding;

    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :initiating_rn_f_node_index_0;
    initiating_rn_node_idx_1 = initiating_rn_node_index_1_status ? initiating_rn_node_index_1_from_config_db :initiating_rn_f_node_index_1;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_node_index_0;
    target_hn_node_idx_1 = target_hn_node_index_1_status ? target_hn_node_index_1_from_config_db :target_hn_node_index_1;

    `svt_xvm_debug("body", $sformatf("max_num_outstanding_xacts_at_hn is %0d as a result of %0s.", max_num_outstanding_xacts_at_hn, max_num_outstanding_xacts_at_hn_status ? "config DB" : "default"));
    `svt_xvm_debug("body", $sformatf("max_num_outstanding_read_xacts_at_hn is %0d as a result of %0s.", max_num_outstanding_read_xacts_at_hn, max_num_outstanding_read_xacts_at_hn_status ? "config DB" : "default"));
    `svt_xvm_debug("body", $sformatf("max_num_outstanding_write_xacts_at_hn is %0d as a result of %0s.", max_num_outstanding_write_xacts_at_hn, max_num_outstanding_write_xacts_at_hn_status ? "config DB" : "default"));
    `svt_xvm_debug("body", $sformatf("max_num_outstanding_atomic_xacts_at_hn is %0d as a result of %0s.", max_num_outstanding_atomic_xacts_at_hn, max_num_outstanding_atomic_xacts_at_hn_status ? "config DB" : "default"));
    `svt_xvm_debug("body", $sformatf("max_num_outstanding_cmo_xacts_at_hn is %0d as a result of %0s.", max_num_outstanding_cmo_xacts_at_hn, max_num_outstanding_cmo_xacts_at_hn_status ? "config DB" : "default"));
    `svt_xvm_debug("body", $sformatf("max_num_outstanding_control_xacts_at_hn is %0d as a result of %0s.", max_num_outstanding_control_xacts_at_hn, max_num_outstanding_control_xacts_at_hn_status ? "config DB" : "default"));
    `svt_xvm_debug("body", $sformatf("initiating_rn_node_idx_0 is %0d as a result of %0s.", initiating_rn_node_idx_0, initiating_rn_node_index_0_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("initiating_rn_node_idx_1 is %0d as a result of %0s.", initiating_rn_node_idx_1, initiating_rn_node_index_1_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("target_hn_node_idx_0 is %0d as a result of %0s.", target_hn_node_idx_0, target_hn_node_index_0_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("target_hn_node_idx_1 is %0d as a result of %0s.", target_hn_node_idx_1, target_hn_node_index_1_status ? "config DB" : "Randomization")); 

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /**
     * If the self_check_init_rn_f_node_index is same as any of the RN node indices 
     * which are passed through config i.e initiating_rn_node_idx_0,initiating_rn_node_idx_1,
     * then re-assign the self_check_init_rn_f_node_index with RN node index ,which is active,
     * participating and not equal to initiating_rn_node_idx_0, initiating_rn_node_idx_1.
     */
    if(initiating_rn_node_index_0_status||initiating_rn_node_index_1_status)begin  
      if((self_check_init_rn_f_node_index == initiating_rn_node_idx_0)||(self_check_init_rn_f_node_index == initiating_rn_node_idx_1))begin  
        int active_participating_q [$];
        `svt_chi_xxm_debug("body",$sformatf("self_check_init_rn_f_node_index= %0d is same as initiating_rn_node_idx_0=%0d or initiating_rn_node_idx_1=%0d and active_participating_rn_f_nodes.size()= %0d",self_check_init_rn_f_node_index,initiating_rn_node_idx_0,initiating_rn_node_idx_1,active_participating_rn_f_nodes.size()));
        if(active_participating_rn_f_nodes.size()>2)begin
          active_participating_q = active_participating_rn_f_nodes.find with ((item != initiating_rn_node_idx_0) && (item != initiating_rn_node_idx_1));
          self_check_init_rn_f_node_index = active_participating_q.pop_back();
          `svt_chi_xxm_debug("body", $sformatf("active_participating_q.size() is %0d and Selected different self_check_init_rn_f_node_index=%0d", active_participating_q.size(),self_check_init_rn_f_node_index));
          active_participating_q.delete();
        end else begin
          perform_data_selfcheck=0;
          `svt_chi_xxm_debug("body",$sformatf("BYPASSING Self Data check as selected self_check_init_rn_f_node_index= %0d is same as initiating_rn_node_index_0_from_config_db=%0d or initiating_rn_node_index_1_from_config_db=%0d and active_participating_rn_f_nodes.size()= %0d",self_check_init_rn_f_node_index,initiating_rn_node_index_0_from_config_db,initiating_rn_node_index_1_from_config_db,active_participating_rn_f_nodes.size()));
        end
      end  
    end 

    // If the self_check_init_rn_f_node_index is part of active_participating_rn_f_nodes array, and
    // it is not equal to initiating_rn_node_idx_0, initiating_rn_node_idx_1; then we can
    // perform data self check from the RN[self_check_init_rn_f_node_index].
    if ((is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, self_check_init_rn_f_node_index, array_idx)) &&
        (self_check_init_rn_f_node_index != initiating_rn_node_idx_0) &&
        (self_check_init_rn_f_node_index != initiating_rn_node_idx_1)) begin
      perform_data_selfcheck = 1;
    end

    `svt_xvm_debug("body", $sformatf("perform_data_selfcheck is %0b, self_check_init_rn_f_node_index is %0d, initiating_rn_node_idx_0 is %0d, initiating_rn_node_idx_1 is %0d", perform_data_selfcheck, self_check_init_rn_f_node_index, initiating_rn_node_idx_0, initiating_rn_node_idx_1));    
    
    for(int i = 0; i < sequence_length; i++) begin

      /** Firing a MakeUnique transaction to initialise the cache line state to 
       *  UD state for below transactions.  
       *   svt_chi_transaction::WRITEBACKFULL, 
       *   svt_chi_transaction::WRITEBACKPTL, 
       *   svt_chi_transaction::WRITECLEANFULL, 
       *   svt_chi_transaction::WRITECLEANPTL,
       */
       `svt_xvm_do_on_with(makeunique_seq[0], p_sequencer.rn_virt_seqr[initiating_rn_f_node_index_0].rn_xact_seqr,{
         sequence_length   == 1;
         hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
         seq_hn_node_idx   == target_hn_node_idx_0;
         use_seq_is_non_secure_access == 0; 
       })

       `svt_xvm_do_on_with(makeunique_seq[1], p_sequencer.rn_virt_seqr[initiating_rn_f_node_index_1].rn_xact_seqr,{
         sequence_length   == 1;
         hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
         seq_hn_node_idx   == target_hn_node_idx_1;
         use_seq_is_non_secure_access == 0; 
       })

      /** Waiting for above MakeUnique transactions to complete */ 
      foreach(makeunique_seq[mu]) begin
        `svt_xvm_debug("body", "Waiting for above MakeUnique transactions to end");
        makeunique_seq[mu].write_tran.wait_end(); 
      end 

      /** Collecting the address from MakeUnique transactions */ 
      addr1 = makeunique_seq[0].write_tran.addr;
      txn1_is_non_secure_access = makeunique_seq[0].write_tran.is_non_secure_access;
      addr2 = makeunique_seq[1].write_tran.addr;
      txn2_is_non_secure_access = makeunique_seq[1].write_tran.is_non_secure_access;

      fork
        begin
          /** Firing CopyBack transaction from a Random RN   
           *    svt_chi_transaction::WRITEBACKFULL, 
           *    svt_chi_transaction::WRITEBACKPTL, 
           *    svt_chi_transaction::WRITECLEANFULL, 
           *    svt_chi_transaction::WRITECLEANPTL,
           */
          `svt_xvm_do_on_with(copyback_seq[0], p_sequencer.rn_virt_seqr[initiating_rn_f_node_index_0].rn_xact_seqr,{
            sequence_length == 1;
            seq_order_type  == svt_chi_transaction::NO_ORDERING_REQUIRED;
            seq_copyback_req_order_enable == 0;                                          
            enable_outstanding == _enable_outstanding;
            seq_is_non_secure_access == txn1_is_non_secure_access;
            use_seq_is_non_secure_access == 1;
            seq_xact_type != svt_chi_transaction::EVICT;
            seq_xact_type != svt_chi_transaction::WRITEEVICTFULL;
            hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
            min_addr           == addr1;
            max_addr           == addr1;
            })
          `svt_xvm_debug("body", $sformatf(" Sending Transaction %0s",`SVT_CHI_PRINT_PREFIX(copyback_seq[0].copyback_tran)));
        end
        begin
          /** Firing CopyBack transaction from other Random RN   
           *    svt_chi_transaction::WRITEBACKFULL, 
           *    svt_chi_transaction::WRITEBACKPTL, 
           *    svt_chi_transaction::WRITECLEANFULL, 
           *    svt_chi_transaction::WRITECLEANPTL,
           */
          `svt_xvm_do_on_with(copyback_seq[1], p_sequencer.rn_virt_seqr[initiating_rn_f_node_index_1].rn_xact_seqr,{
            sequence_length == 1;
            seq_txn_id == copyback_seq[0].seq_txn_id;
            seq_order_type  == svt_chi_transaction::NO_ORDERING_REQUIRED;
            seq_copyback_req_order_enable == 0;                                          
            enable_outstanding == _enable_outstanding;
            seq_is_non_secure_access == txn2_is_non_secure_access;
            use_seq_is_non_secure_access == 1;
            seq_xact_type != svt_chi_transaction::EVICT;
            seq_xact_type != svt_chi_transaction::WRITEEVICTFULL;
            hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
            min_addr           == addr2;
            max_addr           == addr2;
            })
          `svt_xvm_debug("body", $sformatf(" Sending Transaction %0s",`SVT_CHI_PRINT_PREFIX(copyback_seq[1].copyback_tran)));
        end
      join

      /** Waiting for above CopyBack transactions to complete */ 
      foreach(copyback_seq[wr]) begin
        `svt_xvm_debug("body", $sformatf(" Waiting for Copyback_seq[%0d] to end %0s",wr,`SVT_CHI_PRINT_PREFIX(copyback_seq[wr].copyback_tran)));
        copyback_seq[wr].copyback_tran.wait_end(); 
      end
      `svt_xvm_debug("body", "CopyBack transactions are now ended");
   
      addr1 = copyback_seq[0].output_xacts[0].addr;
      data1 = copyback_seq[0].output_xacts[0].data;
      txn1_is_non_secure_access = copyback_seq[0].output_xacts[0].is_non_secure_access;
      addr2 = copyback_seq[1].output_xacts[0].addr;
      data2 = copyback_seq[1].output_xacts[0].data;
      txn2_is_non_secure_access = copyback_seq[1].output_xacts[0].is_non_secure_access;

      // TxnID should be the same from both the RNs      
      if (copyback_seq[0].output_xacts[0].txn_id == copyback_seq[1].output_xacts[0].txn_id) begin
        // pass
        `svt_xvm_debug("body", $sformatf("TxnID match: TxnID 'd%0d is the same from both the RNs", copyback_seq[0].output_xacts[0].txn_id));
      end
      else begin
        // fail
        `svt_xvm_error("body", $sformatf("TxnID mismatch: TxnID is expected to be the same from both the RNs, but that is not the case. Transaction %0s from rn[%0d] has TxnID 'd%0d, transaction %0s from rn[%0d] has TxnId 'd%0d ", 
                                         `SVT_CHI_PRINT_PREFIX( copyback_seq[0].output_xacts[0]),initiating_rn_node_idx_0, copyback_seq[0].output_xacts[0].txn_id, `SVT_CHI_PRINT_PREFIX( copyback_seq[1].output_xacts[0]), initiating_rn_node_idx_1, copyback_seq[1].output_xacts[0].txn_id));
      end

      // Targetted HN IDs from both RNs should be different
      begin
        int hn_idx_0, hn_idx_1;
        hn_idx_0 = sys_cfg.get_hn_idx(copyback_seq[0].output_xacts[0].addr);
        hn_idx_1 = sys_cfg.get_hn_idx(copyback_seq[1].output_xacts[0].addr);
        if (hn_idx_0 != hn_idx_1) begin
          // pass
          `svt_xvm_debug("body", $sformatf("Targeted HN Index from both RNs is different as expected.  rn[%0d] to hn_idx[%0d], rn[%0d] to hn_idx[%0d]", initiating_rn_node_idx_0, hn_idx_0, initiating_rn_node_idx_1, hn_idx_1));
        end
        else begin
          // fail
          `svt_xvm_error("body", $sformatf("Targeted HN Index from both RNs is same, which is unexpected.  rn[%0d] %0s transaction to hn_idx[%0d], rn[%0d] %0s transaction to hn_idx[%0d]", 
                                           initiating_rn_node_idx_0, `SVT_CHI_PRINT_PREFIX( copyback_seq[0].output_xacts[0]), hn_idx_0, initiating_rn_node_idx_1, `SVT_CHI_PRINT_PREFIX( copyback_seq[1].output_xacts[0]), hn_idx_1));
        end
      end
    
      if (perform_data_selfcheck) begin
        /** Firing ReadShared transaction to verify CopyBack transaction */
        `svt_xvm_do_on_with(readshared_seq[0], p_sequencer.rn_virt_seqr[self_check_init_rn_f_node_index].rn_xact_seqr,{
          sequence_length == 1;
          seq_xact_type == svt_chi_transaction::READSHARED;
          data_in_cache == data1;                                             
          min_addr == addr1;
          max_addr == addr1;
          hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
          enable_outstanding == _enable_outstanding;
          seq_is_non_secure_access == txn1_is_non_secure_access;
          use_seq_is_non_secure_access == 1;       
          seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
        })

        /** Waiting for ReadShared transaction to complete */ 
        readshared_seq[0].read_tran.wait_end(); 

        /** Firing ReadShared transaction to verify CopyBack transaction */
        `svt_xvm_do_on_with(readshared_seq[1], p_sequencer.rn_virt_seqr[self_check_init_rn_f_node_index].rn_xact_seqr,{
          sequence_length == 1;
          seq_xact_type == svt_chi_transaction::READSHARED;
          data_in_cache == data2;                                         
          min_addr == addr2;
          max_addr == addr2;
          hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
          enable_outstanding == _enable_outstanding;
          seq_is_non_secure_access == txn2_is_non_secure_access;
          use_seq_is_non_secure_access == 1;       
          seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
        })

        /** Waiting for ReadShared transaction to complete */ 
        readshared_seq[1].read_tran.wait_end(); 
      end
    end    
  endtask: body

  virtual task post_start();
    super.post_start();
    drop_phase_objection();
  endtask
endclass: svt_chi_system_protocol_flow_ctrl_copyback_resp_same_txnid_diff_rn_diff_hn_virtual_sequence

function svt_chi_system_protocol_flow_ctrl_copyback_resp_same_txnid_diff_rn_diff_hn_virtual_sequence::new(string name="svt_chi_system_protocol_flow_ctrl_copyback_resp_same_txnid_diff_rn_diff_hn_virtual_sequence");
  super.new(name);
endfunction

/**
 * @groupname CHI_FLOW_CTRL_CPBK_TYPE     
 *    #- Program the any two randomly selected RNs to drive a MakeUnique transaction targeted<br>
 *       to randomly selected same HN.<br>
 *    #- Program the above selected RNs to drive a CopyBack transactions simultaneously with <br>
 *       same TxnId and address same as of MakeUnique transactions.<br>
 *    #- Check the HN responds with same Txnid to respective RN's.<br>
 *    #- Program a randomly selected RN to drive a ReadShared transaction to verify CopyBack<br>
 *       transaction.<br>
 *    .
 *    #- This sequence does not support EVICT and WRITEEVICTFULL transactions.<br>
 */
class svt_chi_system_protocol_flow_ctrl_copyback_resp_same_txnid_diff_rn_same_hn_virtual_sequence extends svt_chi_system_base_virtual_sequence;
  /** @cond PRIVATE */
  /** Represents the active participating RN-F node that initiates ReadShared for self check */
  rand int unsigned self_check_init_rn_f_node_index; 

  /** To display contents of Active Participating RN_F's node */
  string str_rn_f_node;
  
  bit enable_outstanding = 0;

  constraint self_check_init_rn_f_node_index_c {
    if(active_participating_rn_f_nodes.size() > 2) {
      self_check_init_rn_f_node_index inside {active_participating_rn_f_nodes};
      self_check_init_rn_f_node_index != initiating_rn_f_node_index_0;
      self_check_init_rn_f_node_index != initiating_rn_f_node_index_1;
    }
  }
  /** @endcond */

  /** UVM Object Utility macro */
  `uvm_object_utils(svt_chi_system_protocol_flow_ctrl_copyback_resp_same_txnid_diff_rn_same_hn_virtual_sequence)

  extern function new(string name="svt_chi_system_protocol_flow_ctrl_copyback_resp_same_txnid_diff_rn_same_hn_virtual_sequence"); 

  /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting Request Nodes = 2
   */
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    
    /** local variables */
    int num_supporting_request_nodes;
    int num_hn_f_nodes;   
    int array_idx;
    bit is_rn_idx_0_participating, is_rn_idx_1_participating;
    string str_is_supported_info_prefix = "";
    string str_is_supported_info = "";
    string str_idx0_info = "";
    string str_idx1_info = "";    

    /** Supporting Request Nodes required */
    int required_num_supporting_request_nodes = 2;
    int required_num_hn_nodes = 1;
    
    `svt_xvm_debug("is_supported",$sformatf("calling is_supported"));

    /** By default is_supported is 0 */
    is_supported = 0;

    /** Check for minimum required HN-F nodes */
    num_hn_f_nodes = hn_f_nodes.size();

    /** Check requirment of number of HN nodes needed */    
    if (num_hn_f_nodes < required_num_hn_nodes) begin
      issue_is_supported_failure($sformatf("This sequence requires minimum %0d HN-F nodes to be present in the system. Number of HN-F nodes are %0d. Program number of HN nodes using svt_chi_system_configuration::num_hn. Program the HN interface type using svt_chi_system_configuration::chi_addr_cfg.hn_interface_type[].", required_num_hn_nodes, num_hn_f_nodes));
      return 0;      
    end

    /** Check for minimum required RN nodes.
     *  Also check whether the selected RN nodes are part of participating arrays or not.
     */ 
    num_supporting_request_nodes = active_participating_rn_f_nodes.size();

    /** Check the requirements of RN nodes */
    if (num_supporting_request_nodes) begin
      /** Display the contents of Active Participating RN_F Nodes */
      foreach (active_participating_rn_f_nodes[j]) begin
        str_rn_f_node = {str_rn_f_node, $sformatf(" %0d", active_participating_rn_f_nodes[j])};
      end 
      `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_f_nodes are %0s", str_rn_f_node));
    end

    str_is_supported_info_prefix = $sformatf("Number of Supporting RN-F Node(s)  - Minimum Required : %0d Current : %0d", required_num_supporting_request_nodes, num_supporting_request_nodes);
    
    if ((initiating_rn_node_index_0_status==0)&&(valid_initiating_rn_f_node_index_0==0)) begin
        str_idx0_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN-Fs that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)";
    end
    else begin
      is_rn_idx_0_participating = is_value_found_in_int_assoc_array(active_participating_rn_nodes, initiating_rn_node_idx_0, array_idx);
      if (!is_rn_idx_0_participating) begin
        str_idx0_info = $sformatf("initiating_rn_node_idx_0 %0d is not valid for this sequence. The RN-F corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)", initiating_rn_node_idx_0, initiating_rn_node_idx_0);
      end
    end

    if ((initiating_rn_node_index_1_status==0)&&(valid_initiating_rn_f_node_index_1==0)) begin
      str_idx1_info = "Valid initiating_rn_node_idx_1 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN-Fs that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)";
    end 
    else begin
      is_rn_idx_1_participating = is_value_found_in_int_assoc_array(active_participating_rn_nodes, initiating_rn_node_idx_1, array_idx);
      if (!is_rn_idx_1_participating) begin
        str_idx1_info = $sformatf("initiating_rn_node_idx_1 %0d is not valid for this sequence. The RN-F corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)", initiating_rn_node_idx_1, initiating_rn_node_idx_1);
      end
    end  

    if (is_rn_idx_0_participating && is_rn_idx_1_participating) begin
      is_supported = 1;
    end
    
    if (!is_supported) begin
      str_is_supported_info = $sformatf("%0s%0s",str_idx0_info, str_idx1_info);
      issue_is_supported_failure($sformatf("This sequence cannot be run based on the current system configuration.\n\
                                            %0s \n\
                                            %0s \n\
                                            Modify configurations through \n\
                                            svt_chi_system_configuration::num_rn,\n\
                                            svt_chi_node_configuration::is_active,\n\
                                            svt_chi_system_configuration::participating_request_nodes\n\
                                            ", str_is_supported_info_prefix, str_is_supported_info));
    end      
    if (!is_target_hn_idx_valid_for_curr_cfg()) begin
      is_supported = 0;
      `svt_xvm_note("is_supported", "not a valid hn_idx based on random_tgt_id_enable for current cfg");
    end
  endfunction : is_supported

  virtual task pre_start();
    bit enable_outstanding_status;
    super.pre_start();
    raise_phase_objection();
    enable_outstanding_status = uvm_config_db#(bit)::get(m_sequencer, get_type_name(), "enable_outstanding", enable_outstanding);
    `svt_xvm_debug("body", $sformatf("enable_outstanding is %0b as a result of %0s", enable_outstanding, (enable_outstanding_status?"config DB":"default setting")));
  endtask

  virtual task body();
    bit _enable_outstanding;                                  
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0] addr1;
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0] addr2;
    bit [`SVT_CHI_MAX_DATA_WIDTH -1:0] data1,data2; 
    bit                                perform_data_selfcheck;
    int                                array_idx;
    bit txn1_is_non_secure_access;
    bit txn2_is_non_secure_access;

    /** CHI RN directed sequence */
    svt_chi_rn_copyback_type_transaction_directed_sequence copyback_seq[int];
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq[int];
    svt_chi_rn_read_type_transaction_directed_sequence readshared_seq[int];
  
    `svt_xvm_debug("body", "Entering ...")
    super.body();

    _enable_outstanding = enable_outstanding;

    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :initiating_rn_f_node_index_0;
    initiating_rn_node_idx_1 = initiating_rn_node_index_1_status ? initiating_rn_node_index_1_from_config_db :initiating_rn_f_node_index_1;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_node_index_0;
    `svt_xvm_debug("body", $sformatf("initiating_rn_node_idx_0 is %0d as a result of %0s.", initiating_rn_node_idx_0, initiating_rn_node_index_0_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("initiating_rn_node_idx_1 is %0d as a result of %0s.", initiating_rn_node_idx_1, initiating_rn_node_index_1_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("target_hn_node_idx_0 is %0d as a result of %0s.", target_hn_node_idx_0, target_hn_node_index_0_status ? "config DB" : "Randomization"));
 
    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /**
     * If the self_check_init_rn_f_node_index is same as any of the RN node indices 
     * which are passed through config i.e initiating_rn_node_idx_0,initiating_rn_node_idx_1,
     * then re-assign the self_check_init_rn_f_node_index with RN node index ,which is active,
     * participating and not equal to initiating_rn_node_idx_0, initiating_rn_node_idx_1.
     */
    if(initiating_rn_node_index_0_status||initiating_rn_node_index_1_status)begin  
      if((self_check_init_rn_f_node_index == initiating_rn_node_idx_0)||(self_check_init_rn_f_node_index == initiating_rn_node_idx_1))begin  
        int active_participating_q [$];
        `svt_chi_xxm_debug("body",$sformatf("self_check_init_rn_f_node_index= %0d is same as initiating_rn_node_idx_0=%0d or initiating_rn_node_idx_1=%0d and active_participating_rn_f_nodes.size()= %0d",self_check_init_rn_f_node_index,initiating_rn_node_idx_0,initiating_rn_node_idx_1,active_participating_rn_f_nodes.size()));
        if(active_participating_rn_f_nodes.size()>2)begin
          active_participating_q = active_participating_rn_f_nodes.find with ((item != initiating_rn_node_idx_0) && (item != initiating_rn_node_idx_1));
          self_check_init_rn_f_node_index = active_participating_q.pop_back();
          `svt_chi_xxm_debug("body", $sformatf("active_participating_q.size() is %0d and Selected different self_check_init_rn_f_node_index=%0d", active_participating_q.size(),self_check_init_rn_f_node_index));
          active_participating_q.delete();
        end else begin
          perform_data_selfcheck=0;
          `svt_chi_xxm_debug("body",$sformatf("BYPASSING Self Data check as selected self_check_init_rn_f_node_index= %0d is same as initiating_rn_node_index_0_from_config_db=%0d or initiating_rn_node_index_1_from_config_db=%0d and active_participating_rn_f_nodes.size()= %0d",self_check_init_rn_f_node_index,initiating_rn_node_index_0_from_config_db,initiating_rn_node_index_1_from_config_db,active_participating_rn_f_nodes.size()));
        end
      end  
    end 

    // If the self_check_init_rn_f_node_index is part of active_participating_rn_f_nodes array, and
    // it is not equal to initiating_rn_f_node_index_0, initiating_rn_f_node_index_1; then we can
    // perform data self check from the RN[self_check_init_rn_f_node_index].
    if ((is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, self_check_init_rn_f_node_index, array_idx)) &&
        (self_check_init_rn_f_node_index != initiating_rn_f_node_index_0) &&
        (self_check_init_rn_f_node_index != initiating_rn_f_node_index_1)) begin
      perform_data_selfcheck = 1;
    end
    
    `svt_xvm_debug("body", $sformatf("perform_data_selfcheck is %0b, self_check_init_rn_f_node_index is %0d, initiating_rn_node_idx_0 is %0d, initiating_rn_node_idx_1 is %0d", perform_data_selfcheck, self_check_init_rn_f_node_index, initiating_rn_node_idx_0, initiating_rn_node_idx_1));    
    
    for(int i = 0; i < sequence_length; i++) begin

      /** Firing a MakeUnique transaction to initialise the cache line state to 
       *  UD state for below transactions.  
       *   svt_chi_transaction::WRITEBACKFULL, 
       *   svt_chi_transaction::WRITEBACKPTL, 
       *   svt_chi_transaction::WRITECLEANFULL, 
       *   svt_chi_transaction::WRITECLEANPTL,
       */
       `svt_xvm_do_on_with(makeunique_seq[0], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,{
         sequence_length   == 1;
         hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
         seq_hn_node_idx   == target_hn_node_idx_0;
         use_seq_is_non_secure_access == 0; 
       })

       `svt_xvm_do_on_with(makeunique_seq[1], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,{
         sequence_length   == 1;
         hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
         seq_hn_node_idx   == target_hn_node_idx_0;
         use_seq_is_non_secure_access == 0;        
       })

      /** Waiting for above MakeUnique transactions to complete */ 
      foreach(makeunique_seq[mu]) begin
        `svt_xvm_debug("body", "Waiting for above MakeUnique transactions to end");
        makeunique_seq[mu].write_tran.wait_end(); 
      end 

      /** Collecting the address from MakeUnique transactions */ 
      addr1 = makeunique_seq[0].write_tran.addr;
      txn1_is_non_secure_access = makeunique_seq[0].write_tran.is_non_secure_access;
      addr2 = makeunique_seq[1].write_tran.addr;
      txn2_is_non_secure_access = makeunique_seq[1].write_tran.is_non_secure_access;

      fork
        begin
          /** Firing CopyBack transaction from a Random RN   
           *    svt_chi_transaction::WRITEBACKFULL, 
           *    svt_chi_transaction::WRITEBACKPTL, 
           *    svt_chi_transaction::WRITECLEANFULL, 
           *    svt_chi_transaction::WRITECLEANPTL,
           */
          `svt_xvm_do_on_with(copyback_seq[0], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,{
            sequence_length == 1;
            seq_order_type  == svt_chi_transaction::NO_ORDERING_REQUIRED;
            seq_copyback_req_order_enable == 0;                                          
            enable_outstanding == _enable_outstanding;
            seq_is_non_secure_access == txn1_is_non_secure_access;
            use_seq_is_non_secure_access == 1;
            seq_xact_type != svt_chi_transaction::EVICT;
            seq_xact_type != svt_chi_transaction::WRITEEVICTFULL;
            hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
            min_addr           == addr1;
            max_addr           == addr1;
            })
          `svt_xvm_debug("body", $sformatf(" Sending Transaction %0s",`SVT_CHI_PRINT_PREFIX(copyback_seq[0].copyback_tran)));
        end
        begin
          /** Firing CopyBack transaction from other Random RN   
           *    svt_chi_transaction::WRITEBACKFULL, 
           *    svt_chi_transaction::WRITEBACKPTL, 
           *    svt_chi_transaction::WRITECLEANFULL, 
           *    svt_chi_transaction::WRITECLEANPTL,
           */
          `svt_xvm_do_on_with(copyback_seq[1], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,{
            sequence_length == 1;
            seq_txn_id == copyback_seq[0].seq_txn_id;
            seq_order_type  == svt_chi_transaction::NO_ORDERING_REQUIRED;
            seq_copyback_req_order_enable == 0;                                          
            enable_outstanding == _enable_outstanding;
            seq_is_non_secure_access == txn2_is_non_secure_access;
            use_seq_is_non_secure_access == 1;   
            seq_xact_type != svt_chi_transaction::EVICT;
            seq_xact_type != svt_chi_transaction::WRITEEVICTFULL;
            hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
            min_addr           == addr2;
            max_addr           == addr2;
            })
          `svt_xvm_debug("body", $sformatf(" Sending Transaction %0s",`SVT_CHI_PRINT_PREFIX(copyback_seq[1].copyback_tran)));
        end
      join

      /** Waiting for above CopyBack transactions to complete */ 
      foreach(copyback_seq[wr]) begin
        `svt_xvm_debug("body", $sformatf(" Waiting for Copyback_seq[%0d] to end %0s",wr,`SVT_CHI_PRINT_PREFIX(copyback_seq[wr].copyback_tran)));
        copyback_seq[wr].copyback_tran.wait_end(); 
      end
      `svt_xvm_debug("body", "CopyBack transactions are now ended");
   
      addr1 = copyback_seq[0].output_xacts[0].addr;
      data1 = copyback_seq[0].output_xacts[0].data;
      txn1_is_non_secure_access = copyback_seq[0].output_xacts[0].is_non_secure_access ;   
      addr2 = copyback_seq[1].output_xacts[0].addr;
      data2 = copyback_seq[1].output_xacts[0].data;
      txn2_is_non_secure_access = copyback_seq[1].output_xacts[0].is_non_secure_access ;   

      // TxnID should be the same from both the RNs      
      if (copyback_seq[0].output_xacts[0].txn_id == copyback_seq[1].output_xacts[0].txn_id) begin
        // pass
        `svt_xvm_debug("body", $sformatf("TxnID match: TxnID 'd%0d is the same from both the RNs", copyback_seq[0].output_xacts[0].txn_id));
      end
      else begin
        // fail
        `svt_xvm_error("body", $sformatf("TxnID mismatch: TxnID is expected to be the same from both the RNs, but that is not the case. Transaction %0s from rn[%0d] has TxnID 'd%0d, transaction %0s from rn[%0d] has TxnId 'd%0d ", 
                                         `SVT_CHI_PRINT_PREFIX( copyback_seq[0].output_xacts[0]),initiating_rn_node_idx_0, copyback_seq[0].output_xacts[0].txn_id, `SVT_CHI_PRINT_PREFIX( copyback_seq[1].output_xacts[0]), initiating_rn_node_idx_1, copyback_seq[1].output_xacts[0].txn_id));
      end

      // Targetted HN IDs from both RNs should be same
      begin
        int hn_idx_0, hn_idx_1;
        hn_idx_0 = sys_cfg.get_hn_idx(copyback_seq[0].output_xacts[0].addr);
        hn_idx_1 = sys_cfg.get_hn_idx(copyback_seq[1].output_xacts[0].addr);
        if (hn_idx_0 == hn_idx_1) begin
          // pass
          `svt_xvm_debug("body", $sformatf("Targeted HN Index from both RNs is same as expected.  rn[%0d] to hn_idx[%0d], rn[%0d] to hn_idx[%0d]", initiating_rn_node_idx_0, hn_idx_0, initiating_rn_node_idx_1, hn_idx_1));
        end
        else begin
          // fail
          `svt_xvm_error("body", $sformatf("Targeted HN Index from both RNs is different, which is unexpected.  rn[%0d] %0s transaction to hn_idx[%0d], rn[%0d] %0s transaction to hn_idx[%0d]",initiating_rn_node_idx_0, `SVT_CHI_PRINT_PREFIX( copyback_seq[0].output_xacts[0]), hn_idx_0, initiating_rn_node_idx_1, `SVT_CHI_PRINT_PREFIX( copyback_seq[1].output_xacts[0]), hn_idx_1));
        end
      end    
    
      if (perform_data_selfcheck) begin
        /** Firing ReadShared transaction to verify CopyBack transaction */
        `svt_xvm_do_on_with(readshared_seq[0], p_sequencer.rn_virt_seqr[self_check_init_rn_f_node_index].rn_xact_seqr,{
          sequence_length == 1;
          seq_xact_type == svt_chi_transaction::READSHARED;
          data_in_cache == data1;                                             
          min_addr == addr1;
          max_addr == addr1;
          hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
          enable_outstanding == _enable_outstanding;
          seq_is_non_secure_access == txn1_is_non_secure_access;
          use_seq_is_non_secure_access == 1;              
          seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
        })

        /** Waiting for ReadShared transaction to complete */ 
        readshared_seq[0].read_tran.wait_end(); 

        /** Firing ReadShared transaction to verify CopyBack transaction */
        `svt_xvm_do_on_with(readshared_seq[1], p_sequencer.rn_virt_seqr[self_check_init_rn_f_node_index].rn_xact_seqr,{
          sequence_length == 1;
          seq_xact_type == svt_chi_transaction::READSHARED;
          data_in_cache == data2;                                         
          min_addr == addr2;
          max_addr == addr2;
          hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
          enable_outstanding == _enable_outstanding;
          seq_is_non_secure_access == txn2_is_non_secure_access;
          use_seq_is_non_secure_access == 1;                     
          seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
        })

        /** Waiting for ReadShared transaction to complete */ 
        readshared_seq[1].read_tran.wait_end(); 
      end
    end    
  endtask: body

  virtual task post_start();
    super.post_start();
    drop_phase_objection();
  endtask
endclass: svt_chi_system_protocol_flow_ctrl_copyback_resp_same_txnid_diff_rn_same_hn_virtual_sequence

function svt_chi_system_protocol_flow_ctrl_copyback_resp_same_txnid_diff_rn_same_hn_virtual_sequence::new(string name="svt_chi_system_protocol_flow_ctrl_copyback_resp_same_txnid_diff_rn_same_hn_virtual_sequence");
  super.new(name);
endfunction

/////////////////////////////
// CMO type
/////////////////////////////
/** 
 * @groupname CHI_FLOW_CTRL_CMO_TYPE     
 *   #- Program two MakeUnique transactions from one randomly selected RN_F targeted to<br>
 *      different HN Nodes.<br>
 *   #- Program two randomly selected different RN VIP to drive any CMO type transaction<br> 
 *      with same Txnid simultaneously to above selected same HN Nodes of<br>
 *      MakeUnique transactions.<br>
 *   #- Check the HN's respond with same Txnid to respective RN's.<br>
 *   #- For CleanShared, CleanInvalid transactions, Program Read transactions from<br>
 *      above first selected RN_F to compare Read data with data of above MakeUnique<br>
 *      transactions<br>
 *   .
 */
class svt_chi_system_protocol_flow_ctrl_cmo_resp_same_txnid_diff_rn_diff_hn_virtual_sequence extends svt_chi_system_base_virtual_sequence;

  bit enable_outstanding = 0;

  bit enable_outstanding_status = 0;

  /** To display contents of Active Participating RN's node */
  string str_rn_node;

  /** To display contents of Active Participating RN_F's node */
  string str_rn_f_node;

  /** UVM Object Utility macro */
  `uvm_object_utils(svt_chi_system_protocol_flow_ctrl_cmo_resp_same_txnid_diff_rn_diff_hn_virtual_sequence)

  extern function new(string name="svt_chi_system_protocol_flow_ctrl_cmo_resp_same_txnid_diff_rn_diff_hn_virtual_sequence");

  /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting any type of Request Nodes = 2
   */
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    /** local variables */
    int num_supporting_request_nodes;
    int num_hn_f_nodes;   
    int array_idx;
    bit is_rn_idx_0_participating, is_rn_idx_1_participating;
    string str_is_supported_info_prefix = "";
    string str_is_supported_info = "";
    string str_idx0_info = "";
    string str_idx1_info = "";    
    /** Supporting any type of Request Nodes required */
    int required_num_supporting_request_nodes = 2;
    int required_num_hn_nodes = 2;
    
    `svt_xvm_debug("is_supported",$sformatf("calling is_supported"));

    /** By default is_supported is 0 */
    is_supported = 0;

    /** Check for minimum required HN-F nodes */
    num_hn_f_nodes = hn_f_nodes.size();
    
    /** Check requirment of number of HN nodes needed */
    if (num_hn_f_nodes < required_num_hn_nodes) begin
      issue_is_supported_failure($sformatf("This sequence requires minimum %0d HN-F nodes to be present in the system. Number of HN-F nodes are %0d. Program number of HN nodes using svt_chi_system_configuration::num_hn. Program the HN interface type using svt_chi_system_configuration::chi_addr_cfg.hn_interface_type[].", required_num_hn_nodes, num_hn_f_nodes));
      return 0;      
    end
    
    /** Check for minimum required RN nodes.
     *  Also check whether the selected RN nodes are part of participating arrays or not.
     */ 
    num_supporting_request_nodes = active_participating_rn_nodes.size();

    /** Check the requirements of RN nodes */
    if (num_supporting_request_nodes) begin
      /** Display the contents of Active Participating RN Nodes */
      foreach (active_participating_rn_nodes[j]) begin
        str_rn_node = {str_rn_node, $sformatf(" %0d", active_participating_rn_nodes[j])};
      end 
      `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_nodes are %0s", str_rn_node));
    end

    /** Display the contents of Active Participating RN_F Nodes */
    foreach (active_participating_rn_f_nodes[j]) begin
      str_rn_f_node = {str_rn_f_node, $sformatf(" %0d", active_participating_rn_f_nodes[j])};
    end 
    `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_f_nodes are %0s", str_rn_f_node));

    str_is_supported_info_prefix = $sformatf("Number of Supporting RN Node(s)  - Minimum Required : %0d Current : %0d", required_num_supporting_request_nodes, num_supporting_request_nodes);
    
    if ((initiating_rn_node_index_0_status==0)&&(valid_initiating_rn_node_index_0==0)) begin
        str_idx0_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN's that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F or RN_I)";
    end
    else begin
      is_rn_idx_0_participating = is_value_found_in_int_assoc_array(active_participating_rn_nodes, initiating_rn_node_idx_0, array_idx);
      if (!is_rn_idx_0_participating) begin
        str_idx0_info = $sformatf("initiating_rn_node_idx_0 %0d is not valid for this sequence. The RN corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuration::participating_rn_nodes[])", initiating_rn_node_idx_0, initiating_rn_node_idx_0);
      end
    end
    if ((initiating_rn_node_index_1_status==0)&&(valid_initiating_rn_node_index_1==0)) begin
        str_idx1_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN's that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F or RN_I)";
    end
    else begin
      is_rn_idx_1_participating = is_value_found_in_int_assoc_array(active_participating_rn_nodes, initiating_rn_node_idx_1, array_idx);
      if (!is_rn_idx_1_participating) begin
        str_idx1_info = $sformatf("initiating_rn_node_idx_1 %0d is not valid for this sequence. The RN corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuration::participating_rn_nodes[])", initiating_rn_node_idx_1, initiating_rn_node_idx_1);
      end
    end

    if (is_rn_idx_0_participating && is_rn_idx_1_participating) begin
      is_supported = 1;
    end
    
    if (!is_supported) begin
      str_is_supported_info = $sformatf("%0s%0s",str_idx0_info, str_idx1_info);
      issue_is_supported_failure($sformatf("This sequence cannot be run based on the current system configuration.\n\
                                            %0s \n\
                                            %0s \n\
                                            Modify configurations through \n\
                                            svt_chi_system_configuration::num_rn,\n\
                                            svt_chi_node_configuration::is_active,\n\
                                            svt_chi_system_configuration::participating_request_nodes\n\
                                            ", str_is_supported_info_prefix, str_is_supported_info));

    end      
    if (!is_target_hn_idx_valid_for_curr_cfg()) begin
      is_supported = 0;
      `svt_xvm_note("is_supported", "not a valid hn_idx based on random_tgt_id_enable for current cfg");
    end
  endfunction : is_supported

  virtual task pre_start();
    super.pre_start();
    raise_phase_objection();
    enable_outstanding_status = uvm_config_db#(bit)::get(m_sequencer, get_type_name(), "enable_outstanding", enable_outstanding);
    `svt_xvm_debug("body", $sformatf("enable_outstanding is %0b as a result of %0s", enable_outstanding, (enable_outstanding_status?"config DB":"default setting")));
  endtask

  virtual task body();
    bit[`SVT_CHI_MAX_ADDR_WIDTH -1:0] addr1;
    bit[`SVT_CHI_MAX_ADDR_WIDTH -1:0] addr2;
    bit                                perform_cache_initialization;
    int                                array_idx;
    bit txn1_is_non_secure_access;
    bit txn2_is_non_secure_access;

    /** CHI RN directed sequence */
    svt_chi_rn_cmo_type_transaction_directed_sequence cmo_seq[int];
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq[int];
    svt_chi_rn_read_type_transaction_directed_sequence read_seq[int];

    `svt_xvm_debug("body", "Entering ...");
    super.body();

    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :initiating_rn_node_index_0;
    initiating_rn_node_idx_1 = initiating_rn_node_index_1_status ? initiating_rn_node_index_1_from_config_db :initiating_rn_node_index_1;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_node_index_0;
    target_hn_node_idx_1 = target_hn_node_index_1_status ? target_hn_node_index_1_from_config_db :target_hn_node_index_1;

    `svt_xvm_debug("body", $sformatf("initiating_rn_node_idx_0 is %0d as a result of %0s.", initiating_rn_node_idx_0, initiating_rn_node_index_0_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("initiating_rn_node_idx_1 is %0d as a result of %0s.", initiating_rn_node_idx_1, initiating_rn_node_index_1_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("target_hn_node_idx_0 is %0d as a result of %0s.", target_hn_node_idx_0, target_hn_node_index_0_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("target_hn_node_idx_1 is %0d as a result of %0s.", target_hn_node_idx_1, target_hn_node_index_1_status ? "config DB" : "Randomization"));  
    `svt_xvm_debug("body", $sformatf("perform_cache_initialization is %0b, cache_line_init_rn_f_node_index is %0d, initiating_rn_node_idx_0 is %0d, initiating_rn_node_idx_1 is %0d", perform_cache_initialization, cache_line_init_rn_f_node_index, initiating_rn_node_idx_0, initiating_rn_node_idx_1));    

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /**
     * If the cache_line_init_rn_f_node_index is same as any of the RN node indices 
     * which are passed through config i.e initiating_rn_node_idx_0,initiating_rn_node_idx_1,
     * then re-assign the cache_line_init_rn_f_node_index with RN node index ,which is active,
     * participating and not equal to initiating_rn_node_idx_0, initiating_rn_node_idx_1.
     */
    if(initiating_rn_node_index_0_status||initiating_rn_node_index_1_status)begin  
      if((cache_line_init_rn_f_node_index == initiating_rn_node_idx_0)||(cache_line_init_rn_f_node_index == initiating_rn_node_idx_1))begin  
        int active_participating_q [$];
        `svt_chi_xxm_debug("body",$sformatf("cache_line_init_rn_f_node_index= %0d is same as initiating_rn_node_idx_0=%0d or initiating_rn_node_idx_1=%0d and active_participating_rn_f_nodes.size()= %0d",cache_line_init_rn_f_node_index,initiating_rn_node_idx_0,initiating_rn_node_idx_1,active_participating_rn_f_nodes.size()));
        if(active_participating_rn_f_nodes.size()>2)begin
          active_participating_q = active_participating_rn_f_nodes.find with ((item != initiating_rn_node_idx_0) && (item != initiating_rn_node_idx_1));
          cache_line_init_rn_f_node_index = active_participating_q.pop_back();
          `svt_chi_xxm_debug("body", $sformatf("active_participating_q.size() is %0d and Selected different cache_line_init_rn_f_node_index=%0d", active_participating_q.size(),cache_line_init_rn_f_node_index));
          active_participating_q.delete();
        end else begin
          perform_cache_initialization=0;
          `svt_chi_xxm_debug("body",$sformatf("BYPASSING Cache Initialization as selected cache_line_init_rn_f_node_index= %0d is same as initiating_rn_node_index_0_from_config_db=%0d or initiating_rn_node_index_1_from_config_db=%0d and active_participating_rn_f_nodes.size()= %0d",cache_line_init_rn_f_node_index,initiating_rn_node_index_0_from_config_db,initiating_rn_node_index_1_from_config_db,active_participating_rn_f_nodes.size()));
        end
      end  
    end 

    // If the cache_line_init_rn_f_node_index is part of active_participating_rn_f_nodes array, and
    // it is not equal to initiating_rn_node_idx_0, initiating_rn_node_idx_1; then we can
    // perform cache initialization from the RN[cache_line_init_rn_f_node_index].
    if ((is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, cache_line_init_rn_f_node_index, array_idx)) &&
        (cache_line_init_rn_f_node_index != initiating_rn_node_idx_0) &&
        (cache_line_init_rn_f_node_index != initiating_rn_node_idx_1)) begin
      perform_cache_initialization = 1;
    end
     
    `svt_chi_xxm_debug("body",$sformatf("Selected RN indices are cache_line_init_rn_f_node_index= %0d initiating_rn_node_idx_0=%0d initiating_rn_node_idx_1=%0d and perform_cache_initialization= %0d",cache_line_init_rn_f_node_index,initiating_rn_node_idx_0,initiating_rn_node_idx_1,perform_cache_initialization));   
    
    for(int i = 0; i < sequence_length; i++) begin
      
      bit _enable_outstanding = this.enable_outstanding;

      /** Following sequences will be executed based on configuration of RN Nodes */
      if(perform_cache_initialization) begin
        /** 
         * Write data into Cache of Randomly selected Third Request Node i.e RN_F with address of randomly
         * selected HN Node
         */
        `svt_xvm_do_on_with(makeunique_seq[0], p_sequencer.rn_virt_seqr[cache_line_init_rn_f_node_index].rn_xact_seqr,{
          sequence_length   == 1;
          hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
          seq_hn_node_idx   == target_hn_node_idx_0;
          use_seq_is_non_secure_access == 0;
        })
        
        /** Waiting for above MakeUnique transactions to complete */
        makeunique_seq[0].write_tran.wait_end();
        `svt_xvm_debug("body", $sformatf("makeunique_seq[0] xact type is %0s", makeunique_seq[0].write_tran.xact_type.name()));

        /** 
         * Write data into Cache of Third Request Node i.e RN_F with address of randomly selected another
         * HN Node
         */
        `svt_xvm_do_on_with(makeunique_seq[1], p_sequencer.rn_virt_seqr[cache_line_init_rn_f_node_index].rn_xact_seqr,{
          sequence_length   == 1;
          hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
          seq_hn_node_idx   == target_hn_node_idx_1;
          use_seq_is_non_secure_access == 0;
        })
        
        /** Waiting for above MakeUnique transactions to complete */
        makeunique_seq[1].write_tran.wait_end();
        `svt_xvm_debug("body", $sformatf("makeunique_seq[1] xact type is %0s", makeunique_seq[1].write_tran.xact_type.name()));

        /** Retrieving address from output transactions generated by the sequence */
        addr1 = makeunique_seq[0].output_xacts[0].addr;
        addr2 = makeunique_seq[1].output_xacts[0].addr;
        txn1_is_non_secure_access = makeunique_seq[0].output_xacts[0].is_non_secure_access;
        txn2_is_non_secure_access = makeunique_seq[1].output_xacts[0].is_non_secure_access;
      end // if (perform_cache_initialization)
      
      fork
        begin
          /** 
           * Randomly selected First RN fires any CMO transaction with above MakeUnique
           * transaction address/randomly selected HN node, depending on whetehr cache
             * initialization is done or not
           */
          `svt_xvm_do_on_with(cmo_seq[0], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,{
            sequence_length    == 1;
            if (perform_cache_initialization)
              {
              min_addr           == addr1;
              max_addr           == addr1;
              hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
              seq_is_non_secure_access == txn1_is_non_secure_access; 
              use_seq_is_non_secure_access == 1;
            }
            else
            {
              hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
              seq_hn_node_idx   == target_hn_node_idx_0;
              use_seq_is_non_secure_access == 0;
            }
            `ifdef SVT_CHI_ISSUE_B_ENABLE
              if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) 
                {
                  !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSIST, svt_chi_transaction::STASHONCEUNIQUE,svt_chi_transaction::STASHONCESHARED});
                }
              `ifdef SVT_CHI_ISSUE_E_ENABLE
              else if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision < svt_chi_node_configuration::ISSUE_E){
                !(seq_xact_type inside {svt_chi_transaction::STASHONCESEPUNIQUE, svt_chi_transaction::STASHONCESEPSHARED});
                if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision < svt_chi_node_configuration::ISSUE_D){
                  !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                  if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0)
                    !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                }
                else if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision >= svt_chi_node_configuration::ISSUE_D){
                  if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].cleansharedpersistsep_xact_enable ==0)
                    !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                  if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0)
                    !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                }
              }
              else if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision >= svt_chi_node_configuration::ISSUE_E){
                if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].cleansharedpersistsep_xact_enable == 0)
                  !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0)
                  !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED,svt_chi_transaction::STASHONCESEPUNIQUE, svt_chi_transaction::STASHONCESEPSHARED});
              }
              `elsif SVT_CHI_ISSUE_D_ENABLE
              else if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision < svt_chi_node_configuration::ISSUE_D){
                !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0){
                  !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                }
              }
              else if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision >= svt_chi_node_configuration::ISSUE_D){
                if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].cleansharedpersistsep_xact_enable ==0)
                  !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0){
                  !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                }
              }
              `endif
              else if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0){
                  !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                }
            `endif
          })
        end
        begin
          /** 
           * Randomly selected Second RN fires any CMO transaction with above another 
           * MakeUnique transaction address 
           */
          `svt_xvm_do_on_with(cmo_seq[1], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,{
            sequence_length    == 1;
            seq_txn_id         == cmo_seq[0].seq_txn_id;
            if (perform_cache_initialization)
              {
              min_addr           == addr2;
              max_addr           == addr2;
              hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
              seq_is_non_secure_access == txn2_is_non_secure_access; 
              use_seq_is_non_secure_access == 1;
            }
            else
            {
              hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
              seq_hn_node_idx   == target_hn_node_idx_1;
              use_seq_is_non_secure_access == 0;
            }
            `ifdef SVT_CHI_ISSUE_B_ENABLE
              if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) 
                {
                  !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSIST, svt_chi_transaction::STASHONCEUNIQUE,svt_chi_transaction::STASHONCESHARED});
                }
              `ifdef SVT_CHI_ISSUE_E_ENABLE
              else if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision < svt_chi_node_configuration::ISSUE_E){
                !(seq_xact_type inside {svt_chi_transaction::STASHONCESEPUNIQUE, svt_chi_transaction::STASHONCESEPSHARED});
                if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision < svt_chi_node_configuration::ISSUE_D){
                  !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                  if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 0)
                    !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                }
                else if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision >= svt_chi_node_configuration::ISSUE_D){
                  if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].cleansharedpersistsep_xact_enable ==0)
                    !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                  if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 0)
                    !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                }
              }
              else if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision >= svt_chi_node_configuration::ISSUE_E){
                if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].cleansharedpersistsep_xact_enable == 0)
                  !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 0)
                  !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED,svt_chi_transaction::STASHONCESEPUNIQUE, svt_chi_transaction::STASHONCESEPSHARED});
              }
              `elsif SVT_CHI_ISSUE_D_ENABLE
              else if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision < svt_chi_node_configuration::ISSUE_D){
                !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 0){
                  !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                }
              }
              else if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision >= svt_chi_node_configuration::ISSUE_D){
                if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].cleansharedpersistsep_xact_enable ==0)
                  !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 0){
                  !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                }
              }
              `endif
              else if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 0){
                  !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                }
            `endif
          })
        end
      join
        
      `svt_xvm_debug("body", $sformatf("cmo_seq[0] xact type is %0s",cmo_seq[0].cmo_tran.xact_type.name())); 
      `svt_xvm_debug("body", $sformatf("cmo_seq[1] xact type is %0s",cmo_seq[1].cmo_tran.xact_type.name())); 
      
      /** Waiting for above CMO transactions to complete */
      foreach(cmo_seq[cm]) begin
        `svt_xvm_debug("body",$sformatf("FOR ITERATION =%0d : cmo_seq[%0d].cmo_tran.hn_node_idx %0d",cm,cm,cmo_seq[cm].cmo_tran.hn_node_idx));
        cmo_seq[cm].cmo_tran.wait_end();
      end

      // TxnID should be the same from both the RNs      
      if (cmo_seq[0].output_xacts[0].txn_id == cmo_seq[1].output_xacts[0].txn_id) begin
        // pass
        `svt_xvm_debug("body", $sformatf("TxnID match: TxnID 'd%0d is the same from both the RNs", cmo_seq[0].output_xacts[0].txn_id));
      end
      else begin
        // fail
        `svt_xvm_error("body", $sformatf("TxnID mismatch: TxnID is expected to be the same from both the RNs, but that is not the case. Transaction %0s from rn[%0d] has TxnID 'd%0d, transaction %0s from rn[%0d] has TxnId 'd%0d ", 
                                         `SVT_CHI_PRINT_PREFIX( cmo_seq[0].output_xacts[0]),initiating_rn_node_idx_0, cmo_seq[0].output_xacts[0].txn_id, `SVT_CHI_PRINT_PREFIX( cmo_seq[1].output_xacts[0]), initiating_rn_node_idx_1, cmo_seq[1].output_xacts[0].txn_id));
      end

      // Targetted HN IDs from both RNs should be different
      begin
        int hn_idx_0, hn_idx_1;
        hn_idx_0 = sys_cfg.get_hn_idx(cmo_seq[0].output_xacts[0].addr);
        hn_idx_1 = sys_cfg.get_hn_idx(cmo_seq[1].output_xacts[0].addr);
        if (hn_idx_0 != hn_idx_1) begin
          // pass
          `svt_xvm_debug("body", $sformatf("Targeted HN Index from both RNs is different as expected.  rn[%0d] to hn_idx[%0d], rn[%0d] to hn_idx[%0d]", initiating_rn_node_idx_0, hn_idx_0, initiating_rn_node_idx_1, hn_idx_1));
        end
        else begin
          // fail
          `svt_xvm_error("body", $sformatf("Targeted HN Index from both RNs is same, which is unexpected.  rn[%0d] %0s transaction to hn_idx[%0d], rn[%0d] %0s transaction to hn_idx[%0d]", 
                                           initiating_rn_node_idx_0, `SVT_CHI_PRINT_PREFIX( cmo_seq[0].output_xacts[0]), hn_idx_0, initiating_rn_node_idx_1, `SVT_CHI_PRINT_PREFIX( cmo_seq[1].output_xacts[0]), hn_idx_1));
        end
      end
      
      if (perform_cache_initialization) begin
      /** Compare Read Data with data of above MakeUnique transaction */
        if(cmo_seq[0].cmo_tran.xact_type != svt_chi_transaction::MAKEINVALID) begin
          /** 
           * The above Third Request Node i.e RN_F fires any Read transaction with above MakeUnique
           * transaction address
           */
          `svt_xvm_do_on_with(read_seq[0], p_sequencer.rn_virt_seqr[cache_line_init_rn_f_node_index].rn_xact_seqr, {
            sequence_length    == 1;
            data_in_cache      == makeunique_seq[0].write_tran.data;
            min_addr           == addr1;
            max_addr           == addr1;
            hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
            enable_outstanding ==_enable_outstanding;
            seq_order_type         == svt_chi_transaction::NO_ORDERING_REQUIRED;
            seq_xact_type  inside {svt_chi_transaction::READUNIQUE};
            seq_is_non_secure_access == txn1_is_non_secure_access;
            use_seq_is_non_secure_access == 1;
            by_pass_read_data_check ==0;
          })
          `svt_xvm_debug("body", $sformatf("read_seq[0] xact type is %0s",read_seq[0].read_tran.xact_type.name())); 
          
          /** Waiting for above Read transaction to complete */
          read_seq[0].read_tran.wait_end();
        end
        
        /** Compare Read Data with data of above another MakeUnique transaction */
        if(cmo_seq[1].cmo_tran.xact_type != svt_chi_transaction::MAKEINVALID) begin
          /** 
           * The above Third Request Node i.e RN_F fires any Read transaction with above another MakeUnique
           * transaction address
           */
          `svt_xvm_do_on_with(read_seq[1], p_sequencer.rn_virt_seqr[cache_line_init_rn_f_node_index].rn_xact_seqr, {
            sequence_length    == 1;
            data_in_cache      == makeunique_seq[1].write_tran.data;
            min_addr           == addr2;
            max_addr           == addr2;
            hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
            enable_outstanding ==_enable_outstanding;
            seq_order_type         == svt_chi_transaction::NO_ORDERING_REQUIRED;
            seq_xact_type  inside {svt_chi_transaction::READUNIQUE};
            seq_is_non_secure_access == txn2_is_non_secure_access;
            use_seq_is_non_secure_access == 1;
            by_pass_read_data_check ==0;
          })
         `svt_xvm_debug("body", $sformatf("read_seq[1] xact type is %0s", read_seq[1].read_tran.xact_type.name())); 
         
          /** Waiting for above Read transaction to complete */
          read_seq[1].read_tran.wait_end();
        end
      end // if (perform_cache_initialization)
    end //for sequence_length
    /** 
     * To check the Interconnect HN's shall responds with same txnid to 
     * respective RN's.<br>
     * Check done by System monitor(List of checkers)<br>
     *  #- snoop_data_integrity_check 
     *  .  
     */
    `svt_xvm_debug("body", "Exiting...");
  endtask: body

  virtual task post_start();
    super.post_start();
    drop_phase_objection();
  endtask

endclass: svt_chi_system_protocol_flow_ctrl_cmo_resp_same_txnid_diff_rn_diff_hn_virtual_sequence

function svt_chi_system_protocol_flow_ctrl_cmo_resp_same_txnid_diff_rn_diff_hn_virtual_sequence::new(string name="svt_chi_system_protocol_flow_ctrl_cmo_resp_same_txnid_diff_rn_diff_hn_virtual_sequence");
  super.new(name);
endfunction

/** 
 * @groupname CHI_FLOW_CTRL_CMO_TYPE   
 *   #- Program two MakeUnique transactions from one randomly selected RN_F targeted to<br>
 *      same HN Node.<br>
 *   #- Program two randomly selected different RN VIP to drive any CMO type transaction<br> 
 *      with same Txnid simultaneously to above selected same HN Node of MakeUnique<br>
 *      transactions.<br>
 *   #- Check the HN responds with same Txnid to respective RN's.<br>
 *   #- For CleanShared, CleanInvalid transactions, Program Read transactions from<br>
 *      above first selected RN_F to compare Read data with data of above MakeUnique<br>
 *      transactions<br>
 *   .
 */
class svt_chi_system_protocol_flow_ctrl_cmo_resp_same_txnid_diff_rn_same_hn_virtual_sequence extends svt_chi_system_base_virtual_sequence;

  bit enable_outstanding = 0;

  bit enable_outstanding_status = 0;

  /** To display contents of Active Participating RN's node */
  string str_rn_node;

  /** To display contents of Active Participating RN_F's node */
  string str_rn_f_node;

  /** UVM Object Utility macro */
  `uvm_object_utils(svt_chi_system_protocol_flow_ctrl_cmo_resp_same_txnid_diff_rn_same_hn_virtual_sequence)

  extern function new(string name="svt_chi_system_protocol_flow_ctrl_cmo_resp_same_txnid_diff_rn_same_hn_virtual_sequence");

  /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting any type of Request Nodes = 2
   */
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    /** local variables */
    int num_supporting_request_nodes;
    int num_hn_f_nodes;   
    int array_idx;
    bit is_rn_idx_0_participating, is_rn_idx_1_participating;
    string str_is_supported_info_prefix = "";
    string str_is_supported_info = "";
    string str_idx0_info = "";
    string str_idx1_info = "";    
    /** Supporting any type of Request Nodes required */
    int required_num_supporting_request_nodes = 2;
    int required_num_hn_nodes = 1;
    
    `svt_xvm_debug("is_supported",$sformatf("calling is_supported"));

    /** By default is_supported is 0 */
    is_supported = 0;

    /** Check for minimum required HN-F nodes */
    num_hn_f_nodes = hn_f_nodes.size();
    
    /** Check requirment of number of HN nodes needed */
    if (num_hn_f_nodes < required_num_hn_nodes) begin
      issue_is_supported_failure($sformatf("This sequence requires minimum %0d HN-F nodes to be present in the system. Number of HN-F nodes are %0d. Program number of HN nodes using svt_chi_system_configuration::num_hn. Program the HN interface type using svt_chi_system_configuration::chi_addr_cfg.hn_interface_type[].", required_num_hn_nodes, num_hn_f_nodes));
      return 0;      
    end
    
    /** Check for minimum required RN nodes.
     *  Also check whether the selected RN nodes are part of participating arrays or not.
     */ 
    num_supporting_request_nodes = active_participating_rn_nodes.size();

    /** Check the requirements of RN nodes */
    if (num_supporting_request_nodes) begin
      /** Display the contents of Active Participating RN Nodes */
      foreach (active_participating_rn_nodes[j]) begin
        str_rn_node = {str_rn_node, $sformatf(" %0d", active_participating_rn_nodes[j])};
      end 
      `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_nodes are %0s", str_rn_node));
    end

    /** Display the contents of Active Participating RN_F Nodes */
    foreach (active_participating_rn_f_nodes[j]) begin
      str_rn_f_node = {str_rn_f_node, $sformatf(" %0d", active_participating_rn_f_nodes[j])};
    end 
    `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_f_nodes are %0s", str_rn_f_node));

    str_is_supported_info_prefix = $sformatf("Number of Supporting RN Node(s)  - Minimum Required : %0d Current : %0d", required_num_supporting_request_nodes, num_supporting_request_nodes);
    
    if ((initiating_rn_node_index_0_status==0)&&(valid_initiating_rn_node_index_0==0)) begin
        str_idx0_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN's that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F or RN_I)";
    end
    else begin
      is_rn_idx_0_participating = is_value_found_in_int_assoc_array(active_participating_rn_nodes, initiating_rn_node_idx_0, array_idx);
      if (!is_rn_idx_0_participating) begin
        str_idx0_info = $sformatf("initiating_rn_node_idx_0 %0d is not valid for this sequence. The RN corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuration::participating_rn_nodes[])", initiating_rn_node_idx_0, initiating_rn_node_idx_0);
      end
    end
    if ((initiating_rn_node_index_1_status==0)&&(valid_initiating_rn_node_index_1==0)) begin
        str_idx1_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN's that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F or RN_I)";
    end
    else begin
      is_rn_idx_1_participating = is_value_found_in_int_assoc_array(active_participating_rn_nodes, initiating_rn_node_idx_1, array_idx);
      if (!is_rn_idx_1_participating) begin
        str_idx1_info = $sformatf("initiating_rn_node_idx_1 %0d is not valid for this sequence. The RN corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuration::participating_rn_nodes[])", initiating_rn_node_idx_1, initiating_rn_node_idx_1);
      end
    end

    if (is_rn_idx_0_participating && is_rn_idx_1_participating) begin
      is_supported = 1;
    end
    
    if (!is_supported) begin
      str_is_supported_info = $sformatf("%0s%0s",str_idx0_info, str_idx1_info);
      issue_is_supported_failure($sformatf("This sequence cannot be run based on the current system configuration.\n\
                                            %0s \n\
                                            %0s \n\
                                            Modify configurations through \n\
                                            svt_chi_system_configuration::num_rn,\n\
                                            svt_chi_node_configuration::is_active,\n\
                                            svt_chi_system_configuration::participating_request_nodes\n\
                                            ", str_is_supported_info_prefix, str_is_supported_info));
    end      
    if (!is_target_hn_idx_valid_for_curr_cfg()) begin
      is_supported = 0;
      `svt_xvm_note("is_supported", "not a valid hn_idx based on random_tgt_id_enable for current cfg");
    end    
  endfunction : is_supported

  virtual task pre_start();
    super.pre_start();
    raise_phase_objection();
    enable_outstanding_status = uvm_config_db#(bit)::get(m_sequencer, get_type_name(), "enable_outstanding", enable_outstanding);
    `svt_xvm_debug("body", $sformatf("enable_outstanding is %0b as a result of %0s", enable_outstanding, (enable_outstanding_status?"config DB":"default setting")));
  endtask

  virtual task body();
    bit[`SVT_CHI_MAX_ADDR_WIDTH -1:0] addr1;
    bit[`SVT_CHI_MAX_ADDR_WIDTH -1:0] addr2;
    bit                                perform_cache_initialization;
    int                                array_idx;
    bit txn1_is_non_secure_access;
    bit txn2_is_non_secure_access;

    /** CHI RN directed sequence */
    svt_chi_rn_cmo_type_transaction_directed_sequence cmo_seq[int];
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq[int];
    svt_chi_rn_read_type_transaction_directed_sequence read_seq[int];

    `svt_xvm_debug("body", "Entering ...");
    super.body();

    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :initiating_rn_node_index_0;
    initiating_rn_node_idx_1 = initiating_rn_node_index_1_status ? initiating_rn_node_index_1_from_config_db :initiating_rn_node_index_1;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_node_index_0;

    `svt_xvm_debug("body", $sformatf("initiating_rn_node_idx_0 is %0d as a result of %0s.", initiating_rn_node_idx_0, initiating_rn_node_index_0_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("initiating_rn_node_idx_1 is %0d as a result of %0s.", initiating_rn_node_idx_1, initiating_rn_node_index_1_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("target_hn_node_idx_0 is %0d as a result of %0s.", target_hn_node_idx_0, target_hn_node_index_0_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("perform_cache_initialization is %0b, cache_line_init_rn_f_node_index is %0d, initiating_rn_node_idx_0 is %0d, initiating_rn_node_idx_1 is %0d", perform_cache_initialization, cache_line_init_rn_f_node_index, initiating_rn_node_idx_0, initiating_rn_node_idx_1));   

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /**
     * If the cache_line_init_rn_f_node_index is same as any of the RN node indices 
     * which are passed through config i.e initiating_rn_node_idx_0,initiating_rn_node_idx_1,
     * then re-assign the cache_line_init_rn_f_node_index with RN node index ,which is active,
     * participating and not equal to initiating_rn_node_idx_0, initiating_rn_node_idx_1.
     */
    if(initiating_rn_node_index_0_status||initiating_rn_node_index_1_status)begin  
      if((cache_line_init_rn_f_node_index == initiating_rn_node_idx_0)||(cache_line_init_rn_f_node_index == initiating_rn_node_idx_1))begin  
        int active_participating_q [$];
        `svt_chi_xxm_debug("body",$sformatf("cache_line_init_rn_f_node_index= %0d is same as initiating_rn_node_idx_0=%0d or initiating_rn_node_idx_1=%0d and active_participating_rn_f_nodes.size()= %0d",cache_line_init_rn_f_node_index,initiating_rn_node_idx_0,initiating_rn_node_idx_1,active_participating_rn_f_nodes.size()));
        if(active_participating_rn_f_nodes.size()>2)begin
          active_participating_q = active_participating_rn_f_nodes.find with ((item != initiating_rn_node_idx_0) && (item != initiating_rn_node_idx_1));
          cache_line_init_rn_f_node_index = active_participating_q.pop_back();
          `svt_chi_xxm_debug("body", $sformatf("active_participating_q.size() is %0d and Selected different cache_line_init_rn_f_node_index=%0d", active_participating_q.size(),cache_line_init_rn_f_node_index));
          active_participating_q.delete();
        end else begin
          perform_cache_initialization=0;
          `svt_chi_xxm_debug("body",$sformatf("BYPASSING Cache Initialization as selected cache_line_init_rn_f_node_index= %0d is same as initiating_rn_node_index_0_from_config_db=%0d or initiating_rn_node_index_1_from_config_db=%0d and active_participating_rn_f_nodes.size()= %0d",cache_line_init_rn_f_node_index,initiating_rn_node_index_0_from_config_db,initiating_rn_node_index_1_from_config_db,active_participating_rn_f_nodes.size()));
        end
      end  
    end 

    // If the cache_line_init_rn_f_node_index is part of active_participating_rn_f_nodes array, and
    // it is not equal to initiating_rn_node_idx_0, initiating_rn_node_idx_1; then we can
    // perform cache initialization from the RN[cache_line_init_rn_f_node_index].
    if ((is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, cache_line_init_rn_f_node_index, array_idx)) &&
        (cache_line_init_rn_f_node_index != initiating_rn_node_idx_0) &&
        (cache_line_init_rn_f_node_index != initiating_rn_node_idx_1)) begin
      perform_cache_initialization = 1;
    end

    `svt_chi_xxm_debug("body",$sformatf("Selected RN indices are cache_line_init_rn_f_node_index= %0d initiating_rn_node_idx_0=%0d initiating_rn_node_idx_1=%0d and perform_cache_initialization= %0d",cache_line_init_rn_f_node_index,initiating_rn_node_idx_0,initiating_rn_node_idx_1,perform_cache_initialization));
    for(int i = 0; i < sequence_length; i++) begin
      
      bit _enable_outstanding = this.enable_outstanding;

      /** Following sequences will be executed based on configuration of RN Nodes */
      if(perform_cache_initialization) begin
        /** 
         * Write data into Cache of Randomly selected Third Request Node i.e RN_F with address of randomly
         * selected HN Node
         */
        `svt_xvm_do_on_with(makeunique_seq[0], p_sequencer.rn_virt_seqr[cache_line_init_rn_f_node_index].rn_xact_seqr,{
          sequence_length   == 1;
          hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
          seq_hn_node_idx   == target_hn_node_idx_0;
          use_seq_is_non_secure_access == 0;
        })
        
        /** Waiting for above MakeUnique transactions to complete */
        makeunique_seq[0].write_tran.wait_end();
        `svt_xvm_debug("body", $sformatf("makeunique_seq[0] xact type is %0s", makeunique_seq[0].write_tran.xact_type.name()));

        /** 
         * Write data into Cache of Third Request Node i.e RN_F with address of randomly selected another
         * HN Node
         */
        `svt_xvm_do_on_with(makeunique_seq[1], p_sequencer.rn_virt_seqr[cache_line_init_rn_f_node_index].rn_xact_seqr,{
          sequence_length   == 1;
          hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
          seq_hn_node_idx   == target_hn_node_idx_0;
          use_seq_is_non_secure_access == 0;
        })
        
        /** Waiting for above MakeUnique transactions to complete */
        makeunique_seq[1].write_tran.wait_end();
        `svt_xvm_debug("body", $sformatf("makeunique_seq[1] xact type is %0s", makeunique_seq[1].write_tran.xact_type.name()));

        /** Retrieving address from output transactions generated by the sequence */
        addr1 = makeunique_seq[0].output_xacts[0].addr;
        addr2 = makeunique_seq[1].output_xacts[0].addr;
        txn1_is_non_secure_access=makeunique_seq[0].output_xacts[0].is_non_secure_access;
        txn2_is_non_secure_access=makeunique_seq[1].output_xacts[0].is_non_secure_access;
      end // if (perform_cache_initialization)
      
      fork
        begin
          /** 
           * Randomly selected First RN fires any CMO transaction with above MakeUnique
           * transaction address/randomly selected HN node, depending on whetehr cache
             * initialization is done or not
           */
          `svt_xvm_do_on_with(cmo_seq[0], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,{
            sequence_length    == 1;
            if (perform_cache_initialization)
              {
              min_addr           == addr1;
              max_addr           == addr1;
              hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
              seq_is_non_secure_access == txn1_is_non_secure_access; 
              use_seq_is_non_secure_access == 1;
            }
            else
            {
              hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
              seq_hn_node_idx   == target_hn_node_idx_0;
              use_seq_is_non_secure_access == 0;
            }
            `ifdef SVT_CHI_ISSUE_B_ENABLE
              if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) 
                {
                  !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSIST, svt_chi_transaction::STASHONCEUNIQUE,svt_chi_transaction::STASHONCESHARED});
                }
              `ifdef SVT_CHI_ISSUE_E_ENABLE
              else if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision < svt_chi_node_configuration::ISSUE_E){
                !(seq_xact_type inside {svt_chi_transaction::STASHONCESEPUNIQUE, svt_chi_transaction::STASHONCESEPSHARED});
                if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision < svt_chi_node_configuration::ISSUE_D){
                  !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                  if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0)
                    !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                }
                else if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision >= svt_chi_node_configuration::ISSUE_D){
                  if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].cleansharedpersistsep_xact_enable ==0)
                    !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                  if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0)
                    !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                }
              }
              else if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision >= svt_chi_node_configuration::ISSUE_E){
                if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].cleansharedpersistsep_xact_enable == 0)
                  !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0)
                  !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED,svt_chi_transaction::STASHONCESEPUNIQUE, svt_chi_transaction::STASHONCESEPSHARED});
              }
              `elsif SVT_CHI_ISSUE_D_ENABLE
              else if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision < svt_chi_node_configuration::ISSUE_D){
                !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0){
                  !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                }
              }
              else if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision >= svt_chi_node_configuration::ISSUE_D){
                if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].cleansharedpersistsep_xact_enable ==0)
                  !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0){
                  !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                }
              }
              `endif
              else if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0){
                  !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                }
            `endif
          })
        end
        begin
          /** 
           * Randomly selected Second RN fires any CMO transaction with above another 
           * MakeUnique transaction address 
           */
          `svt_xvm_do_on_with(cmo_seq[1], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,{
            sequence_length    == 1;
            seq_txn_id         == cmo_seq[0].seq_txn_id;
            if (perform_cache_initialization)
              {
              min_addr           == addr2;
              max_addr           == addr2;
              hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
              seq_is_non_secure_access == txn2_is_non_secure_access; 
              use_seq_is_non_secure_access == 1;
            }
            else
            {
              hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
              seq_hn_node_idx   == target_hn_node_idx_0;
              use_seq_is_non_secure_access == 0;
            }
            `ifdef SVT_CHI_ISSUE_B_ENABLE
              if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) 
                {
                  !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSIST, svt_chi_transaction::STASHONCEUNIQUE,svt_chi_transaction::STASHONCESHARED});
                }
              `ifdef SVT_CHI_ISSUE_E_ENABLE
              else if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision < svt_chi_node_configuration::ISSUE_E){
                !(seq_xact_type inside {svt_chi_transaction::STASHONCESEPUNIQUE, svt_chi_transaction::STASHONCESEPSHARED});
                if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision < svt_chi_node_configuration::ISSUE_D){
                  !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                  if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 0)
                    !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                }
                else if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision >= svt_chi_node_configuration::ISSUE_D){
                  if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].cleansharedpersistsep_xact_enable ==0)
                    !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                  if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 0)
                    !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                }
              }
              else if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision >= svt_chi_node_configuration::ISSUE_E){
                if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].cleansharedpersistsep_xact_enable == 0)
                  !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 0)
                  !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED,svt_chi_transaction::STASHONCESEPUNIQUE, svt_chi_transaction::STASHONCESEPSHARED});
              }
              `elsif SVT_CHI_ISSUE_D_ENABLE
              else if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision < svt_chi_node_configuration::ISSUE_D){
                !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 0){
                  !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                }
              }
              else if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision >= svt_chi_node_configuration::ISSUE_D){
                if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].cleansharedpersistsep_xact_enable ==0)
                  !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 0){
                  !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                }
              }
              `endif
              else if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 0){
                  !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                }
            `endif
          })
        end
      join
        
      `svt_xvm_debug("body", $sformatf("cmo_seq[0] xact type is %0s",cmo_seq[0].cmo_tran.xact_type.name())); 
      `svt_xvm_debug("body", $sformatf("cmo_seq[1] xact type is %0s",cmo_seq[1].cmo_tran.xact_type.name())); 
      
      /** Waiting for above CMO transactions to complete */
      foreach(cmo_seq[cm]) begin
        `svt_xvm_debug("body",$sformatf("FOR ITERATION =%0d : cmo_seq[%0d].cmo_tran.hn_node_idx %0d",cm,cm,cmo_seq[cm].cmo_tran.hn_node_idx));
        cmo_seq[cm].cmo_tran.wait_end();
      end

      // TxnID should be the same from both the RNs      
      if (cmo_seq[0].output_xacts[0].txn_id == cmo_seq[1].output_xacts[0].txn_id) begin
        // pass
        `svt_xvm_debug("body", $sformatf("TxnID match: TxnID 'd%0d is the same from both the RNs", cmo_seq[0].output_xacts[0].txn_id));
      end
      else begin
        // fail
        `svt_xvm_error("body", $sformatf("TxnID mismatch: TxnID is expected to be the same from both the RNs, but that is not the case. Transaction %0s from rn[%0d] has TxnID 'd%0d, transaction %0s from rn[%0d] has TxnId 'd%0d ", 
                                         `SVT_CHI_PRINT_PREFIX( cmo_seq[0].output_xacts[0]),initiating_rn_node_idx_0, cmo_seq[0].output_xacts[0].txn_id, `SVT_CHI_PRINT_PREFIX( cmo_seq[1].output_xacts[0]), initiating_rn_node_idx_1, cmo_seq[1].output_xacts[0].txn_id));
      end

      // Targetted HN IDs from both RNs should be same
      begin
        int hn_idx_0, hn_idx_1;
        hn_idx_0 = sys_cfg.get_hn_idx(cmo_seq[0].output_xacts[0].addr);
        hn_idx_1 = sys_cfg.get_hn_idx(cmo_seq[1].output_xacts[0].addr);
        if (hn_idx_0 == hn_idx_1) begin
          // pass
          `svt_xvm_debug("body", $sformatf("Targeted HN Index from both RNs is same as expected.  rn[%0d] to hn_idx[%0d], rn[%0d] to hn_idx[%0d]", initiating_rn_node_idx_0, hn_idx_0, initiating_rn_node_idx_1, hn_idx_1));
        end
        else begin
          // fail
          `svt_xvm_error("body", $sformatf("Targeted HN Index from both RNs is different, which is unexpected.  rn[%0d] %0s transaction to hn_idx[%0d], rn[%0d] %0s transaction to hn_idx[%0d]", 
                                           initiating_rn_node_idx_0, `SVT_CHI_PRINT_PREFIX( cmo_seq[0].output_xacts[0]), hn_idx_0, initiating_rn_node_idx_1, `SVT_CHI_PRINT_PREFIX( cmo_seq[1].output_xacts[0]), hn_idx_1));
        end
      end
      
      if (perform_cache_initialization) begin
      /** Compare Read Data with data of above MakeUnique transaction */
        if(cmo_seq[0].cmo_tran.xact_type != svt_chi_transaction::MAKEINVALID) begin
          /** 
           * The above Third Request Node i.e RN_F fires any Read transaction with above MakeUnique
           * transaction address
           */
          `svt_xvm_do_on_with(read_seq[0], p_sequencer.rn_virt_seqr[cache_line_init_rn_f_node_index].rn_xact_seqr, {
            sequence_length    == 1;
            data_in_cache      == makeunique_seq[0].write_tran.data;
            min_addr           == addr1;
            max_addr           == addr1;
            seq_is_non_secure_access== txn1_is_non_secure_access;
            use_seq_is_non_secure_access == 1;
            hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
            enable_outstanding ==_enable_outstanding;
            seq_order_type         == svt_chi_transaction::NO_ORDERING_REQUIRED;
            seq_xact_type  inside {svt_chi_transaction::READUNIQUE};
            by_pass_read_data_check == 0;
          })
          `svt_xvm_debug("body", $sformatf("read_seq[0] xact type is %0s",read_seq[0].read_tran.xact_type.name())); 
          
          /** Waiting for above Read transaction to complete */
          read_seq[0].read_tran.wait_end();
        end
        
        /** Compare Read Data with data of above another MakeUnique transaction */
        if(cmo_seq[1].cmo_tran.xact_type != svt_chi_transaction::MAKEINVALID) begin
          /** 
           * The above Third Request Node i.e RN_F fires any Read transaction with above another MakeUnique
           * transaction address
           */
          `svt_xvm_do_on_with(read_seq[1], p_sequencer.rn_virt_seqr[cache_line_init_rn_f_node_index].rn_xact_seqr, {
            sequence_length    == 1;
            data_in_cache      == makeunique_seq[1].write_tran.data;
            min_addr           == addr2;
            max_addr           == addr2;
            seq_is_non_secure_access== txn2_is_non_secure_access;
            use_seq_is_non_secure_access == 1;
            hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
            enable_outstanding ==_enable_outstanding;
            seq_order_type         == svt_chi_transaction::NO_ORDERING_REQUIRED;
            seq_xact_type  inside {svt_chi_transaction::READUNIQUE};
            by_pass_read_data_check ==0;
          })
         `svt_xvm_debug("body", $sformatf("read_seq[1] xact type is %0s", read_seq[1].read_tran.xact_type.name())); 
         
          /** Waiting for above Read transaction to complete */
          read_seq[1].read_tran.wait_end();
        end
      end // if (perform_cache_initialization)
    end //for sequence_length
    /** 
     * To check the Interconnect HN's shall responds with same txnid to 
     * respective RN's.<br>
     * Check done by System monitor(List of checkers)<br>
     *  #- snoop_data_integrity_check 
     *  .  
     */
    `svt_xvm_debug("body", "Exiting...");
  endtask: body

  virtual task post_start();
    super.post_start();
    drop_phase_objection();
  endtask

endclass: svt_chi_system_protocol_flow_ctrl_cmo_resp_same_txnid_diff_rn_same_hn_virtual_sequence

function svt_chi_system_protocol_flow_ctrl_cmo_resp_same_txnid_diff_rn_same_hn_virtual_sequence::new(string name="svt_chi_system_protocol_flow_ctrl_cmo_resp_same_txnid_diff_rn_same_hn_virtual_sequence");
  super.new(name);
endfunction

//====================================================================================
/** CHI system flow control outstanding transactions virtual sequences */
//====================================================================================

/////////////////////////////
// Read type
/////////////////////////////
//====================================================================================
/**
 * @groupname CHI_OUTSTANDING_RD_TYPE   
 *    #- This sequence requires at least one HN node to be present in the Interconnect.<br>
 *    #- This sequence requires one initiating active and participating RN.<br>
 *    #- If another active and participating RN-F exists, perform cache<br>
 *       initialization to a randomly selected HN.<br>
 *    #- Initiate maximum number of Read type transactions with<br> 
 *       svt_chi_rn_transaction::suspend_comp_ack set  to 1 from initiating RN to randomly<br> 
 *       selected HN in non blocking mode. <br>
 *       - This ensures that the maximum outstanding transaction limit is reached at the HN.<br> 
 *       - Maximum number of outstanding transactions at the HN is as per either #max_num_outstanding_read_xacts_at_hn or
 *         #max_num_outstanding_xacts_at_hn, which can be controlled through config DB.
 *       - Also, the RN will not transmit CompAck corresponding to these transactions<br>
 *       until svt_chi_rn_transaction::suspend_comp_ack is set to 0 from the seqeunce.<br>
 *       .
 *    #- The addresses of these Read transactions are such that:<br>
 *       - Same as initialized cache line addresses if cache initialization is performed<br>
 *       - Otherwise, random addresses targeting the same HN<br>
 *       .
 *    #- Once the RN receives the responses for all the outstanding transactions from<br>
 *       HN, svt_chi_rn_transaction::suspend_comp_ack is set to 0 for all the outstanding<br>
 *       transactions. <br>
 *       This ensures that the CompAck for these transactions can be resumed<br> 
 *       from RN.<br>
 *    #- Check that the HN responds properly for all outstanding Read type transactions<br>
 *       and these are completed successfully.<br>
 *    .
 */

class svt_chi_system_protocol_flow_ctrl_read_outstanding_same_rn_same_hn_virtual_sequence extends svt_chi_system_base_virtual_sequence;

  //-----------------------------------------------------------------------------  
  // Member attributes
  //-----------------------------------------------------------------------------  
  /** Parameter that controls the enabling of transactions in non-blocking mode from the sequence */
  bit enable_outstanding = 0;

  /** Represents the RN-F node for which the sequence will be initiated */ 
  int select_rn_f_node = 0;  
  
  /** Represents the RN-I node for which the sequence will be initiated */ 
  int select_rn_i_node = 0;
  
  /** Represents the RN-D node for which the sequence will be initiated */ 
  int select_rn_d_node = 0; 

  /** Status filed for capturing config DB get status for select_rn_f_node */
  bit select_rn_f_node_status = 0;
  
  /** Status filed for capturing config DB get status for select_rn_i_node */
  bit select_rn_i_node_status = 0;

  /** Status filed for capturing config DB get status for select_rn_d_node */
  bit select_rn_d_node_status = 0;

  /** Represents the received read responses */
  int received_read_responses = 0;

  /** To display contents of Active Participating RN's nodes info. */
  string str_node_info;

  /** UVM/OVM Object Utility macro */
  `svt_xvm_object_utils(svt_chi_system_protocol_flow_ctrl_read_outstanding_same_rn_same_hn_virtual_sequence)
  
  //-----------------------------------------------------------------------------  
  // Methods
  //-----------------------------------------------------------------------------
  /** Constructor */
  extern function new(string name="svt_chi_system_protocol_flow_ctrl_read_outstanding_same_rn_same_hn_virtual_sequence"); 
  
  // -----------------------------------------------------------------------------
  virtual task pre_start();
    bit enable_outstanding_status;
    `svt_xvm_debug("pre_start",$sformatf("Entering ..."));
    super.pre_start();
    raise_phase_objection();
    select_rn_f_node_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(),"select_rn_f_node", select_rn_f_node);
    `svt_xvm_debug("body", $sformatf("select_rn_f_node is %0d as a result of %0s", select_rn_f_node, (select_rn_f_node_status ?"config DB":"Default setting")));
    select_rn_i_node_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(),"select_rn_i_node", select_rn_i_node);
    `svt_xvm_debug("body", $sformatf("select_rn_i_node is %0d as a result of %0s", select_rn_i_node, (select_rn_i_node_status ?"config DB":"Default setting")));
    select_rn_d_node_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(),"select_rn_d_node", select_rn_d_node);
    `svt_xvm_debug("body", $sformatf("select_rn_d_node is %0d as a result of %0s", select_rn_d_node, (select_rn_d_node_status ?"config DB":"Default setting")));
    enable_outstanding_status = uvm_config_db#(bit)::get(m_sequencer, get_type_name(), "enable_outstanding", enable_outstanding);
    `svt_xvm_debug("body", $sformatf("enable_outstanding is %0b as a result of %0s", enable_outstanding, (enable_outstanding_status?"config DB":"default setting")));
    `svt_xvm_debug("pre_start",$sformatf("Exiting ..."));
  endtask // pre_start

  // -----------------------------------------------------------------------------
  /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting RN-F Nodes = 1 when select_rn_f_node is programmed to 1
   *  #- minimum supporting RN-I Nodes = 1 when select_rn_i_node is programmed to 1
   *  #- minimum supporting RN-D Nodes = 1 when select_rn_d_node is programmed to 1
   */
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    
    /** local variables */
    int num_supporting_rn_f_nodes;
    int num_supporting_rn_i_nodes;
    int num_supporting_rn_d_nodes;
    string str_is_supported_info_prefix = "";
    string str_is_supported_info = "";

    /** Supporting Request Nodes required */
    int required_num_supporting_rn_f_nodes = 0;
    int required_num_supporting_rn_i_nodes = 0;
    int required_num_supporting_rn_d_nodes = 0;
    int required_num_hn_nodes = 1;
    int num_hn_f_nodes;
    int array_idx;
    string str_idx0_info = "";
    bit    is_rn_idx_0_participating;   
    `svt_xvm_debug("is_supported",$sformatf("Entering..."));

    /** By default is_supported is 0 */
    is_supported = 0;

    /** Check for minimum required HN-F nodes */
    num_hn_f_nodes = hn_f_nodes.size();
    
    /** Check requirment of number of HN nodes needed */
    if (num_hn_f_nodes < required_num_hn_nodes) begin
      issue_is_supported_failure($sformatf("This sequence requires minimum %0d HN-F nodes to be present in the system. Number of HN-F nodes are %0d. Program number of HN nodes using svt_chi_system_configuration::num_hn. Program the HN interface type using svt_chi_system_configuration::chi_addr_cfg.hn_interface_type[].", required_num_hn_nodes, num_hn_f_nodes));
      return 0;      
    end
    
    /** Either of select_rn_d_node, select_rn_i_node, select_rn_f_node needs to be programmed to 1.
     *  More than one flag cannot be 1 or 0 together.
     */
    if (((select_rn_f_node == 0) && (select_rn_i_node == 0) && (select_rn_d_node == 0)) ||
        ((select_rn_f_node == 1) && (select_rn_i_node == 1) && (select_rn_d_node == 1))) begin
      issue_is_supported_failure($sformatf("select_rn_f_node = %0d. select_rn_i_node = %0d. select_rn_d_node = %0d. Programming one of these two variables to 1 through config DB is required for this sequence to be run.", select_rn_f_node, select_rn_i_node, select_rn_d_node));
      return 0;
    end
   
    /** Set minimum required supporting RN-F, RN-D and RN-I nodes depending on  
     *  select_rn_f_node or select_rn_d_node or select_rn_i_node flags respectively.
     */   
    if(select_rn_f_node)
      required_num_supporting_rn_f_nodes = 1;
    else if(select_rn_i_node) begin
      required_num_supporting_rn_i_nodes = 1;
    end else if (select_rn_d_node)begin
      required_num_supporting_rn_d_nodes = 1;
    end

    /** Check for minimum required RN-F, RN-D and RN-I nodes.
     *  Also check whether the selected RN-F, RN-D and RN-I nodes are part of participating arrays or not.
     */ 
    num_supporting_rn_f_nodes = active_participating_rn_f_nodes.size();
    num_supporting_rn_d_nodes = active_participating_rn_d_nodes.size();
    num_supporting_rn_i_nodes = active_participating_rn_i_nodes.size();

    /** Check the requirement of RN-F nodes */
    if (num_supporting_rn_f_nodes) begin
      /** Display the contents of Active Participating RN-F Nodes */
      foreach (active_participating_rn_f_nodes[j]) begin
        str_node_info = {str_node_info, $sformatf(" %0d", active_participating_rn_f_nodes[j])};
      end      
      `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_f_nodes are %0s", str_node_info));
    end
    
    /** Display the contents of Active Participating RN-D Nodes */
    str_node_info = "";

    /** Check the requirement of RN-D nodes */ 
    if (num_supporting_rn_d_nodes) begin
      foreach (active_participating_rn_d_nodes[j]) begin
        str_node_info = {str_node_info, $sformatf(" %0d", active_participating_rn_d_nodes[j])};
      end 
      `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_d_nodes are %0s", str_node_info));
    end

    /** Display the contents of Active Participating RN-I Nodes */
    str_node_info = "";
    
    /** Check the requirement of RN-I nodes */ 
    if (num_supporting_rn_i_nodes) begin
      foreach (active_participating_rn_i_nodes[j]) begin
        str_node_info = {str_node_info, $sformatf(" %0d", active_participating_rn_i_nodes[j])};
      end 
      `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_i_nodes are %0s", str_node_info));
    end

    /** Check the required supporting Request Nodes */
    if (select_rn_f_node == 1) begin
      
      str_is_supported_info_prefix = $sformatf("select_rn_f_node is set to 1. Number of Supporting RN-F Node(s)  - Minimum Required : %0d Current : %0d", required_num_supporting_rn_f_nodes,num_supporting_rn_f_nodes);
      if ((initiating_rn_node_index_0_status==0)&&(valid_initiating_rn_f_node_index_0==0)) begin
          str_idx0_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN-Fs that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)";
      end
      else begin
        is_rn_idx_0_participating = is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_node_idx_0, array_idx);
        if (!is_rn_idx_0_participating) begin
          str_idx0_info = $sformatf("initiating_rn_node_idx_0 %0d is not valid for this sequence. The RN-F corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)", initiating_rn_node_idx_0, initiating_rn_node_idx_0);
        end
      end
    end
    else if (select_rn_i_node == 1) begin
        
        str_is_supported_info_prefix = $sformatf("select_rn_i_node is set to 1. Number of Supporting RN-I Node(s)  - Minimum Required : %0d Current : %0d", required_num_supporting_rn_i_nodes,num_supporting_rn_i_nodes);
        
        if ((initiating_rn_node_index_0_status==0)&&(valid_initiating_rn_i_node_index_0==0)) begin
          str_idx0_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN-Is that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_I)";
        end
        else begin
          is_rn_idx_0_participating = is_value_found_in_int_assoc_array(active_participating_rn_i_nodes, initiating_rn_node_idx_0, array_idx);
          if (!is_rn_idx_0_participating) begin
           
            str_idx0_info = $sformatf("initiating_rn_node_idx_0 %0d is not valid for this sequence. The RN-I corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_I)", initiating_rn_node_idx_0, initiating_rn_node_idx_0);
          end  
        end
      end
    else if (select_rn_d_node == 1) begin
        
        str_is_supported_info_prefix = $sformatf("select_rn_d_node is set to 1. Number of Supporting RN-D Node(s)  - Minimum Required : %0d Current : %0d", required_num_supporting_rn_d_nodes,num_supporting_rn_d_nodes);

        if ((initiating_rn_node_index_0_status==0)&&(valid_initiating_rn_d_node_index_0==0)) begin
          str_idx0_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN-Ds that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_D)";
        end
        else begin
          is_rn_idx_0_participating = is_value_found_in_int_assoc_array(active_participating_rn_d_nodes, initiating_rn_node_idx_0, array_idx);
          if (!is_rn_idx_0_participating) begin
           
            str_idx0_info = $sformatf("initiating_rn_node_idx_0 %0d is not valid for this sequence. The RN-D corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_D)", initiating_rn_node_idx_0, initiating_rn_node_idx_0);
          end  
        end
      end

    if (is_rn_idx_0_participating) begin
      is_supported = 1;
      //If max_num_outstanding_read_xacts_at_hn is set to a non-default value, it would mean that separate outstanding xact limit is set
      //for each transaction type category, and so we compare the configured num_outstanding_read_xact value of the initiating RN with max_num_outstanding_read_xacts_at_hn
      if(max_num_outstanding_read_xacts_at_hn > 0) begin
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].num_outstanding_read_xact < max_num_outstanding_read_xacts_at_hn) begin
          str_idx0_info = $sformatf("Programmed value of num_outstanding_read_xacts_at_hn_status is %0d. But max_num_outstanding_read_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_read_xact of the initiating RN node must be equal to or greater than max_num_outstanding_read_xacts_at_hn_status of the target HN", max_num_outstanding_read_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_0_participating].num_outstanding_read_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
      //If max_num_outstanding_read_xacts_at_hn is set to 0, it would mean that only one overall outstanding xact limit is set
      //so we compare the configured num_outstanding_xact value of the initiating RN with max_num_outstanding_xacts_at_hn
      end else begin
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].num_outstanding_xact < max_num_outstanding_xacts_at_hn) begin
          str_idx0_info = $sformatf("Programmed value of max_num_outstanding_xacts_at_hn_status is %0d. But num_outstanding_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_xact of the initiating RN node must be equal to or greater than max_num_outstanding_xacts_at_hn of the target HN", max_num_outstanding_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_0_participating].num_outstanding_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
      end
    end
    
    if (!is_supported) begin
      str_is_supported_info = $sformatf("%0s",str_idx0_info);
      
      if (silent) begin
        if (is_rn_idx_0_participating) begin
          `svt_xvm_debug("is_supported",$sformatf("This sequence cannot be run based on the current system configuration.\n\
                                                  %0s\n\
                                                  %0s \n\
                                                  Modify configurations through \n\
                                                  svt_chi_system_configuration::num_rn,\n\
                                                  svt_chi_node_configuration::is_active,\n\
                                                  svt_chi_system_configuration::participating_rn_nodes[]\n\
                                                  ", str_is_supported_info_prefix, str_is_supported_info));
        end
        else begin
          `svt_xvm_debug("is_supported",$sformatf("This sequence cannot be run based on the current node configuration of RN%0d.\n\
                                                  %0s \n\
                                                  Modify configurations through \n\
                                                  svt_chi_node_configuration::num_outstanding_xact,\n\
                                                  svt_chi_node_configuration::num_outstanding_read_xact,\n\
                                                  ", initiating_rn_node_idx_0, str_is_supported_info));
        end
      end
      else begin
        if (is_rn_idx_0_participating) begin
          `svt_xvm_note("is_supported",$sformatf("This sequence cannot be run based on the current system configuration.\n\
                                                 %0s\n\
                                                 %0s \n\
                                                 Modify configurations through \n\
                                                 svt_chi_system_configuration::num_rn,\n\
                                                 svt_chi_node_configuration::is_active,\n\
                                                 svt_chi_system_configuration::participating_rn_nodes[]\n\
                                                 ", str_is_supported_info_prefix, str_is_supported_info));
        end
        else begin
          `svt_xvm_note("is_supported",$sformatf("This sequence cannot be run based on the current node configuration of RN%0d.\n\
                                                  %0s \n\
                                                  Modify configurations through \n\
                                                  svt_chi_node_configuration::num_outstanding_xact,\n\
                                                  svt_chi_node_configuration::num_outstanding_read_xact,\n\
                                                  ", initiating_rn_node_idx_0, str_is_supported_info));
        end
      end // else: !if(silent)
    end
    if (!is_target_hn_idx_valid_for_curr_cfg()) begin
      is_supported = 0;
      `svt_xvm_note("is_supported", "not a valid hn_idx based on random_tgt_id_enable for current cfg");
    end
  endfunction : is_supported  

  // -----------------------------------------------------------------------------
  virtual task body();
    /** Queue of addresses, used by the transactions generated */
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0]                    addr_collection_q[$];
    bit seq_is_non_secure_access_q[$];
    int                                                   array_idx;
    int                                                   num_outstanding_xacts_to_generate;

    /** Sub sequences initiated from this sequence */
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq[int];

    /** Sub Read type transaction directed sequences initiated from this sequence */
    svt_chi_rn_read_type_transaction_directed_sequence read_seq[int];

    /** Flag to track whether cache initialization needs to be performed or not*/
    bit perform_cache_initialization;
    string str_node_types = "";
    int unsigned sel_initiating_rn_node_idx_0; 

    super.body();
    `svt_xvm_debug("body", "Entering ...");

    max_num_outstanding_xacts_at_hn_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(),"max_num_outstanding_xacts_at_hn",max_num_outstanding_xacts_at_hn);
    max_num_outstanding_read_xacts_at_hn_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(),"max_num_outstanding_read_xacts_at_hn",max_num_outstanding_read_xacts_at_hn);
    max_num_outstanding_write_xacts_at_hn_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(),"max_num_outstanding_write_xacts_at_hn",max_num_outstanding_write_xacts_at_hn);
    max_num_outstanding_cmo_xacts_at_hn_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(),"max_num_outstanding_cmo_xacts_at_hn",max_num_outstanding_cmo_xacts_at_hn);

    if (select_rn_f_node) begin
      str_node_types = "Initiating nodes are of RN-F type.";
      // If the initiating_rn_f_node_index_1 is part of active_participating_rn_f_nodes array, and
      // it is not equal to initiating_rn_f_node_index_0;then we can
      // perform cache initialization from the RN[cache_line_init_rn_f_node_index].
      if ((is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_f_node_index_1, array_idx)) &&
          (initiating_rn_f_node_index_1 != initiating_rn_f_node_index_0)) begin 
        perform_cache_initialization = 1;
        cache_line_init_rn_f_node_index = initiating_rn_f_node_index_1;          
      end
      sel_initiating_rn_node_idx_0 = initiating_rn_f_node_index_0;
    end
    else if (select_rn_i_node) begin
      str_node_types = "Initiating nodes are of RN-I type.";
      // If the initiating_rn_f_node_index_0 is part of active_participating_rn_f_nodes array
      // then we can perform cache initialization from the RN[cache_line_init_rn_f_node_index].
      if (is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_f_node_index_0, array_idx)) begin
        perform_cache_initialization = 1;
        cache_line_init_rn_f_node_index = initiating_rn_f_node_index_0;          
      end
      sel_initiating_rn_node_idx_0 = initiating_rn_i_node_index_0;
    end
    else if (select_rn_d_node) begin
      str_node_types = "Initiating nodes are of RN-D type.";
      // If the initiating_rn_f_node_index_0 is part of active_participating_rn_f_nodes array
      // then we can perform cache initialization from the RN[cache_line_init_rn_f_node_index].
      if (is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_f_node_index_0, array_idx)) begin
        perform_cache_initialization = 1;
        cache_line_init_rn_f_node_index = initiating_rn_f_node_index_0;          
      end
      sel_initiating_rn_node_idx_0 = initiating_rn_d_node_index_0;
    end

    `svt_xvm_debug("body", $sformatf("%0s perform_cache_initialization = %0b. cache_line_init_rn_f_node_index = %0d. sel_initiating_rn_node_idx_0 = %0d.", str_node_types, perform_cache_initialization, cache_line_init_rn_f_node_index, sel_initiating_rn_node_idx_0));
    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :sel_initiating_rn_node_idx_0;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_f_node_index_0;
    `svt_xvm_debug("body", $sformatf("max_num_outstanding_xacts_at_hn is %0d as a result of %0s.", max_num_outstanding_xacts_at_hn, max_num_outstanding_xacts_at_hn_status ? "config DB" : "default"));
    `svt_xvm_debug("body", $sformatf("max_num_outstanding_read_xacts_at_hn is %0d as a result of %0s.", max_num_outstanding_read_xacts_at_hn, max_num_outstanding_read_xacts_at_hn_status ? "config DB" : "default"));
    `svt_xvm_debug("body", $sformatf("max_num_outstanding_write_xacts_at_hn is %0d as a result of %0s.", max_num_outstanding_write_xacts_at_hn, max_num_outstanding_write_xacts_at_hn_status ? "config DB" : "default"));
    `svt_xvm_debug("body", $sformatf("max_num_outstanding_cmo_xacts_at_hn is %0d as a result of %0s.", max_num_outstanding_cmo_xacts_at_hn, max_num_outstanding_cmo_xacts_at_hn_status ? "config DB" : "default"));
    `svt_xvm_debug("body", $sformatf("initiating_rn_node_idx_0 is %0d as a result of %0s.", initiating_rn_node_idx_0, initiating_rn_node_index_0_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("target_hn_f_node_index_0 is %0d as a result of %0s.", target_hn_node_idx_0, target_hn_node_index_0_status ? "config DB" : "Randomization")); 

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    //If max outstanding count for Read transactions has been programmed, use that to generate the outstanding Reads
    if(max_num_outstanding_read_xacts_at_hn > 0) begin
      num_outstanding_xacts_to_generate = max_num_outstanding_read_xacts_at_hn;
      `svt_xvm_debug("body",$sformatf("max_num_outstanding_read_xacts_at_hn is set to a non-zero value (%0d). Hence, the value programmed in max_num_outstanding_xacts_at_hn will be ignored. The number of outstanding transactions issued by the sequence will be equal to max_num_outstanding_read_xacts_at_hn", max_num_outstanding_read_xacts_at_hn));
    end
    //If not, use the max outstanding transaction count
    else
      num_outstanding_xacts_to_generate = max_num_outstanding_xacts_at_hn;

    /**
     * If the cache_line_init_rn_f_node_index is same as the RN node index 
     * which are passed through config i.e initiating_rn_node_idx_0,
     * then re-assign the cache_line_init_rn_f_node_index with RN node index ,which is active,
     * participating and not equal to initiating_rn_node_idx_0.
     */
    if(initiating_rn_node_index_0_status)begin  
      if(cache_line_init_rn_f_node_index == initiating_rn_node_idx_0)begin  
        int active_participating_q [$];
        `svt_chi_xxm_debug("body",$sformatf("cache_line_init_rn_f_node_index= %0d is same as initiating_rn_node_idx_0=%0d and active_participating_rn_f_nodes.size()= %0d",cache_line_init_rn_f_node_index,initiating_rn_node_idx_0,active_participating_rn_f_nodes.size()));
        if(active_participating_rn_f_nodes.size()>2)begin
          active_participating_q = active_participating_rn_f_nodes.find with (item != initiating_rn_node_idx_0);
          cache_line_init_rn_f_node_index = active_participating_q.pop_back();
          `svt_chi_xxm_debug("body", $sformatf("active_participating_q.size() is %0d and Selected different cache_line_init_rn_f_node_index=%0d", active_participating_q.size(),cache_line_init_rn_f_node_index));
          active_participating_q.delete();
        end else begin
          perform_cache_initialization=0;
          `svt_chi_xxm_debug("body",$sformatf("BYPASSING Cache Initialization as selected cache_line_init_rn_f_node_index= %0d is same as initiating_rn_node_index_0_from_config_db=%0d and active_participating_rn_f_nodes.size()= %0d",cache_line_init_rn_f_node_index,initiating_rn_node_index_0_from_config_db,active_participating_rn_f_nodes.size()));
        end
      end  
    end 

    /**
     * If the cache_line_init_rn_f_node_index is part of active_participating_rn_f_nodes array, and
     * it is not equal to initiating_rn_node_idx_0 then we can
     * perform cache initialization from the RN[cache_line_init_rn_f_node_index].
     */
    if ((is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, cache_line_init_rn_f_node_index, array_idx)) &&
        (cache_line_init_rn_f_node_index != initiating_rn_node_idx_0)) begin
      perform_cache_initialization = 1;
    end

    for(int i = 0; i < sequence_length; i++) begin

        if(perform_cache_initialization) begin
          `svt_xvm_debug("body",$sformatf("Starting cache initialization for %0d addresses from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d", num_outstanding_xacts_to_generate, cache_line_init_rn_f_node_index, target_hn_node_idx_0));

          for(int k=0; k<num_outstanding_xacts_to_generate; k++) begin
          
            /** Write data into Cache of Randomly selected first RN with address of randomly selected HN Node */
            `svt_xvm_do_on_with(makeunique_seq[k], p_sequencer.rn_virt_seqr[cache_line_init_rn_f_node_index].rn_xact_seqr,
            {
              sequence_length == 1;
              set_unique_addr_value == 1;
              hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
              seq_hn_node_idx == target_hn_node_idx_0;
              use_seq_is_non_secure_access == 0;
            })
            /** Waiting for above MakeUnique transaction to complete */ 
            `svt_xvm_debug("body", $sformatf("%0s Waiting for MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) to end",`SVT_CHI_PRINT_PREFIX(makeunique_seq[k].write_tran),k, makeunique_seq[k].write_tran.hn_node_idx, makeunique_seq[k].write_tran.tgt_id));
             makeunique_seq[k].write_tran.wait_end();
            `svt_xvm_debug("body", $sformatf("%0s MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) ended",`SVT_CHI_PRINT_PREFIX(makeunique_seq[k].write_tran),k, makeunique_seq[k].write_tran.hn_node_idx, makeunique_seq[k].write_tran.tgt_id));

            `svt_xvm_verbose("body", $sformatf("MakeUnique transaction [%0d]  is %0s", k,makeunique_seq[k].write_tran.sprint()));
           end //outstanding loop

          /** Retriving address from the transactions */
          for(int k=0; k<num_outstanding_xacts_to_generate; k++) begin 
             addr_collection_q.push_back(makeunique_seq[k].output_xacts[0].addr);
             seq_is_non_secure_access_q.push_back(makeunique_seq[k].output_xacts[0].is_non_secure_access);
          end

          `svt_xvm_debug("body",$sformatf("Ended cache initialization for %0d addresses from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d",
                                        num_outstanding_xacts_to_generate, cache_line_init_rn_f_node_index, target_hn_node_idx_0));
        
          /** Printing the address from the queue */
          foreach(addr_collection_q[i]) begin
            `svt_xvm_debug("addr_collection_queue", $sformatf("addr_collection_q[%0d] is %0h, with is_non_secure_access %0b",i,addr_collection_q[i], seq_is_non_secure_access_q[i]));
          end
      end //perform_cache_initialization  

      `svt_xvm_debug("body",$sformatf("Starting transmission of Read type transactions for %0d addresses from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d with suspend_comp_ack set to 1",num_outstanding_xacts_to_generate, initiating_rn_node_idx_0, target_hn_node_idx_0));
      
      for(int j=0; j<num_outstanding_xacts_to_generate; j++) begin 
        /** Randomly selected first RN-F fires a read transaction with MAKEUNIQUE 
         *  transaction address of randomly selected HN Node.
         */
        `svt_xvm_do_on_with(read_seq[j], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
        {
          sequence_length == 1;
          seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
          `ifdef SVT_CHI_ISSUE_E_ENABLE
           if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision >= svt_chi_node_configuration::ISSUE_E) {
            seq_txn_id         == (j*3);
           }
           else{
            seq_txn_id         == (j % num_outstanding_xacts_to_generate);
           }
          `else
            seq_txn_id         == (j % num_outstanding_xacts_to_generate);
          `endif
          if (perform_cache_initialization) {
            hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
            min_addr == addr_collection_q[j];
            max_addr == addr_collection_q[j];
            seq_is_non_secure_access == seq_is_non_secure_access_q[i]; 
            use_seq_is_non_secure_access == 1;
            data_in_cache == makeunique_seq[j].data_in_cache;
            by_pass_read_data_check == 0;
          }
          else {
            hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
            seq_hn_node_idx    == target_hn_node_idx_0; 
            by_pass_read_data_check == 1;
            use_seq_is_non_secure_access == 0;
          }
          if (select_rn_f_node) seq_xact_type != svt_chi_transaction::READNOSNP;
          if (select_rn_i_node || select_rn_d_node) seq_xact_type == svt_chi_transaction::READONCE;
          `ifdef SVT_CHI_ISSUE_B_ENABLE
          if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type != svt_chi_transaction::READNOTSHAREDDIRTY;
          if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A || sys_cfg.readspec_enable == 0) seq_xact_type != svt_chi_transaction::READSPEC;
          if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type != svt_chi_transaction::READONCECLEANINVALID;
          if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type != svt_chi_transaction::READONCEMAKEINVALID;
          `endif
          `ifdef SVT_CHI_ISSUE_E_ENABLE
            if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision <= svt_chi_node_configuration::ISSUE_D) seq_xact_type != svt_chi_transaction::READPREFERUNIQUE;
          `endif

        }
        )
        `svt_xvm_debug("body", $sformatf("%0s Transmitting Read Transaction [%0d] targeted to HN (idx %0d, id %0d) ",`SVT_CHI_PRINT_PREFIX(read_seq[j].read_tran),j, read_seq[j].read_tran.hn_node_idx, read_seq[j].read_tran.tgt_id));
        `svt_xvm_verbose("body", $sformatf("Read Transaction [%0d] is %0s",j,read_seq[j].read_tran.sprint()));
      end//outstanding

      /** Event to Resume the Suspended Response of above trasactions */ 
      foreach(read_seq[rd]) begin
        fork
          automatic int _rd = rd;
          begin
            `svt_xvm_debug("body", $sformatf("%0s Read transaction [%0d] targeted to HN (idx %0d, id %0d), suspend_comp_ack %0b: waiting for response from interconnect",`SVT_CHI_PRINT_PREFIX(read_seq[_rd].read_tran),_rd,read_seq[_rd].read_tran.hn_node_idx, read_seq[_rd].read_tran.tgt_id,read_seq[_rd].read_tran.suspend_comp_ack));
            fork
            begin
              fork
                begin
                  read_seq[_rd].read_tran.wait_for_tx_compack_prereqs();// begin
                end
                begin
                  wait(read_seq[_rd].read_tran.req_status == svt_chi_transaction::RETRY);// begin
                end
              join_any
              disable fork;
            end
            join
            received_read_responses++;
            `svt_xvm_debug("body", $sformatf("%0s Read transaction [%0d] targeted to HN (idx %0d, id %0d), suspend_comp_ack %0b: received response from interconnect. Total responses received %0d",`SVT_CHI_PRINT_PREFIX(read_seq[_rd].read_tran),_rd, read_seq[_rd].read_tran.hn_node_idx, read_seq[_rd].read_tran.tgt_id,read_seq[_rd].read_tran.suspend_comp_ack, received_read_responses));       
          end
        join_none  
      end

      /** Wait until All Comp responses are received at RN */
      `svt_xvm_debug("body",$sformatf("Completed initiation of Read type transactions for %0d addresses from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d with suspend_comp_ack set to 1, and waiting to receive responses from interconnect.", num_outstanding_xacts_to_generate, initiating_rn_node_idx_0, target_hn_node_idx_0)); 
      wait(received_read_responses == num_outstanding_xacts_to_generate); 
      outstanding_xact_count_reached = 1;
      `svt_xvm_debug("body",$sformatf("Received responses from interconnect to Read type transactions for %0d addresses from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d with suspend_comp_ack set to 1",num_outstanding_xacts_to_generate, initiating_rn_node_idx_0, target_hn_node_idx_0));
      
      /** Self Check1: To check suspend_comp_ack should not be modified to zero by the VIP
       *  before reseting from test bench
       */
      foreach (read_seq[self_check_idx1]) begin
        if (!read_seq[self_check_idx1].read_tran.is_terminated()) begin
          if (read_seq[self_check_idx1].read_tran.suspend_comp_ack == 0) begin
            `svt_xvm_error("body", $sformatf("%0s suspend_comp_ack should be 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(read_seq[self_check_idx1].read_tran)));
          end
          else begin
            `svt_xvm_debug("body", $sformatf("%0s suspend_comp_ack is 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(read_seq[self_check_idx1].read_tran)));
          end
        end
      end  

      /** Self Check2: To check end_event should not be 1 before resuming the
       *  transaction from test bench
       */
      foreach(read_seq[self_check_idx2]) begin
        if (!read_seq[self_check_idx2].read_tran.is_terminated()) begin
          if (read_seq[self_check_idx2].read_tran.end_event.is_on() == 1) begin
            `svt_xvm_error("body", $sformatf("Unexpected: %0s Transaction's end_event triggered when suspend_comp_ack is still 1.", `SVT_CHI_PRINT_PREFIX(read_seq[self_check_idx2].read_tran)));
          end
          else begin
            `svt_xvm_debug("body", $sformatf("Expected: %0s Transaction's end_event is not triggered when suspend_comp_ack is still 1.", `SVT_CHI_PRINT_PREFIX(read_seq[self_check_idx2].read_tran)));
          end
        end
      end
 
      /** Self Check 3: To check that the current_outstanding_*_xact_count in the RN
       * is as per the transactions inititated by the sequence
       */
      if(read_seq[0].shared_status.prot_status.current_outstanding_xact_count != num_outstanding_xacts_to_generate)
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding transactions from the sequence but the outstanding transaction count in the shared status of RN%0d is %0d", num_outstanding_xacts_to_generate, initiating_rn_node_idx_0, read_seq[0].shared_status.prot_status.current_outstanding_xact_count));
      /** Check if the outstanding Read xact counter is set correctly in the shared status of the RN agent */
      if(read_seq[0].shared_status.prot_status.current_outstanding_read_xact_count != num_outstanding_xacts_to_generate) begin
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding Read transactions from the sequence but the outstanding Read transaction count in the shared status of RN%0d is %0d", num_outstanding_xacts_to_generate, initiating_rn_node_idx_0, read_seq[0].shared_status.prot_status.current_outstanding_read_xact_count));
      end

      `svt_xvm_debug("body", $sformatf("RN%0d: Number of outstanding transactions : %0d, Number of outstanding read xacts : %0d", initiating_rn_node_idx_0, read_seq[0].shared_status.prot_status.current_outstanding_xact_count, read_seq[0].shared_status.prot_status.current_outstanding_read_xact_count));

      if(use_seq_flag_to_resume_response_for_outstanding_xact) begin
        `svt_xvm_debug("body",$sformatf("Waiting for resume_response_for_outstanding_xact to be set to 1"));
        wait(resume_response_for_outstanding_xact == 1);
        `svt_xvm_debug("body",$sformatf("resume_response_for_outstanding_xact is set to 1"));
      end

      /** Resuming all CompAck responses of above Read transactions from RN */
      foreach(read_seq[rd]) begin
        `svt_xvm_debug("body",$sformatf("Received responses for all Read type transactions from interconnect, resuming the transactions by setting svt_chi_rn_transaction::suspend_comp_ack set to 0 %0s",`SVT_CHI_PRINT_PREFIX(read_seq[rd].read_tran)));
        read_seq[rd].read_tran.suspend_comp_ack=0;
        `svt_xvm_debug("body", $sformatf("For iteration %0d, received_read_responses is %0d,suspend_comp_ack is %b and exp_comp_ack is %b After Resume", rd,received_read_responses,read_seq[rd].read_tran.suspend_comp_ack,read_seq[rd].read_tran.exp_comp_ack));
      end

      /** Waiting for above read outstanding transactions to complete */
      `svt_xvm_debug("body",$sformatf("Waiting for completion of all the outstanding Read type transactions")); 
      foreach (read_seq[index_1]) begin
        `svt_xvm_debug("body", $sformatf("Waiting for above read_seq[%0d] transaction %0s to end", index_1, `SVT_CHI_PRINT_PREFIX(read_seq[index_1].read_tran)));
        read_seq[index_1].read_tran.wait_end();
        
        /** Self Check4: To check suspend_comp_ack should not be 1 after reseting from test bench
         *  after the transaction completes
         */
        if (!read_seq[index_1].read_tran.is_terminated()) begin
          if (read_seq[index_1].read_tran.suspend_comp_ack == 1) begin
            `svt_xvm_error("body", $sformatf("%0s suspend_comp_ack should be 0 as it should be reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(read_seq[index_1].read_tran)));
          end
          else begin
            `svt_xvm_debug("body", $sformatf("%0s suspend_comp_ack is 0 as it is reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(read_seq[index_1].read_tran)));
          end
        end
      end 
      `svt_xvm_debug("body",$sformatf("Received completions for all read type outstanding transactions"));
      
      /** Targetted HN IDs from both RNs should be same */
      foreach(read_seq[self_check_idx3]) begin
        int hn_idx_0;
        hn_idx_0 = sys_cfg.get_hn_idx(read_seq[self_check_idx3].read_tran.addr);
        if (target_hn_node_idx_0 == hn_idx_0) begin
          // pass
          `svt_xvm_debug("body", $sformatf("Targeted HN Index from the RN is same as expected.  rn[%0d] to hn_idx[%0d]", initiating_rn_node_idx_0, hn_idx_0));
        end
        else begin
          // fail
          `svt_xvm_error("body", $sformatf("Targeted HN Index from the RN is different, which is unexpected.  rn[%0d] %0s transaction to hn_idx[%0d]", initiating_rn_node_idx_0, `SVT_CHI_PRINT_PREFIX( read_seq[self_check_idx3].output_xacts[0]), hn_idx_0));
        end
      end

      /** Reset received_read_responses to Zero */
      received_read_responses = 0;

      /** Delete the contents of address collection queue */
      addr_collection_q.delete();

    end //sequence_length
    /** 
     * To check the Interconnect HN Node shall responds to all 
     * outstanding read tranactions to RN.<br>
     * Check done by System monitor(List of checkers)<br>
     *  #- read_data_integrity_check
     *  #- coherent_and_snoop_data_match_check
     *  .  
     */

    `uvm_info("body", "Exiting...", UVM_HIGH)
  endtask: body

  virtual task post_start();
    super.post_start();
    drop_phase_objection();
  endtask
  
endclass: svt_chi_system_protocol_flow_ctrl_read_outstanding_same_rn_same_hn_virtual_sequence

function svt_chi_system_protocol_flow_ctrl_read_outstanding_same_rn_same_hn_virtual_sequence::new(string name="svt_chi_system_protocol_flow_ctrl_read_outstanding_same_rn_same_hn_virtual_sequence");
  super.new(name);
endfunction


//====================================================================================

/**
 * @groupname CHI_OUTSTANDING_RD_TYPE  
 *    #- This sequence requires at least one HN node to be present in the Interconnect.<br>
 *    #- This sequence requires two initiating active and participating RN.<br>
 *    #- If another active and participating RN-F exists, perform cache<br>
 *       initialization to a randomly selected HN.<br>
 *    #- Initiate maximum number of Read type transactions with<br> 
 *       svt_chi_rn_transaction::suspend_comp_ack set  to 1 from two initiating RN's to randomly<br> 
 *       selected HN in non blocking mode. <br>
 *       - This ensures that the maximum outstanding transaction limit is reached at the<br> 
 *         same HN.<br> 
 *       - Maximum number of outstanding transactions at the HN is as per either #max_num_outstanding_read_xacts_at_hn or
 *         #max_num_outstanding_xacts_at_hn, which can be controlled through config DB.
 *       - Also, the two different RN will not transmit CompAck corresponding to these transactions<br>
 *       until svt_chi_rn_transaction::suspend_comp_ack is set to 0 from the seqeunce.<br>
 *       .
 *    #- The addresses of these Read transactions are such that:<br>
 *       - Same as initialized cache line addresses if cache initialization is performed<br>
 *       - Otherwise, random addresses targeting the same HN<br>
 *       .
 *    #- Once the RN receives the responses for all the outstanding transactions from<br>
 *       HN, svt_chi_rn_transaction::suspend_comp_ack is set to 0 for all the outstanding<br>
 *       transactions. <br>
 *       This ensures that the CompAck for these transactions can be resumed<br> 
 *       from different RN.<br>
 *    #- Check that the HN responds properly for all outstanding Read type<br>
 *       transactions and these are completed successfully.<br>
 *    .
 */

class svt_chi_system_protocol_flow_ctrl_read_outstanding_diff_rn_same_hn_virtual_sequence extends svt_chi_system_base_virtual_sequence;

  //-----------------------------------------------------------------------------  
  // Member attributes
  //-----------------------------------------------------------------------------  
  /** Parameter that controls the enabling of transactions in non-blocking mode from the sequence */
  bit enable_outstanding = 0;

  /** Represents the RN-F node for which the sequence will be initiated */ 
  int select_rn_f_node = 0;  
  
  /** Represents the RN-I node for which the sequence will be initiated */
  int select_rn_i_node = 0;

  /** Represents the RN-D node for which the sequence will be initiated */ 
  int select_rn_d_node = 0;
  
  /** Status filed for capturing config DB get status for select_rn_f_node */
  bit select_rn_f_node_status = 0;

  /** Status filed for capturing config DB get status for select_rn_i_node */
  bit select_rn_i_node_status = 0;

  /** Status filed for capturing config DB get status for select_rn_d_node */
  bit select_rn_d_node_status = 0;

  /** Represents the received read responses */
  int received_read_responses = 0;
        
  /** UVM/OVM Object Utility macro */
  `svt_xvm_object_utils(svt_chi_system_protocol_flow_ctrl_read_outstanding_diff_rn_same_hn_virtual_sequence) 

  //-----------------------------------------------------------------------------  
  // Methods
  //-----------------------------------------------------------------------------
  /** Constructor */
  extern function new(string name="svt_chi_system_protocol_flow_ctrl_read_outstanding_diff_rn_same_hn_virtual_sequence");  

  //----------------------------------------------------------------------------- 
  virtual task pre_start();
    bit enable_outstanding_status;
    `svt_xvm_debug("pre_start",$sformatf("Entering ..."));
    super.pre_start();
    raise_phase_objection();
    select_rn_f_node_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(),"select_rn_f_node", select_rn_f_node);
    `svt_xvm_debug("body", $sformatf("select_rn_f_node is %0d as a result of %0s", select_rn_f_node, (select_rn_f_node_status ?"config DB":"Default setting")));
    select_rn_i_node_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(),"select_rn_i_node", select_rn_i_node);
    `svt_xvm_debug("body", $sformatf("select_rn_i_node is %0d as a result of %0s", select_rn_i_node, (select_rn_i_node_status ?"config DB":"Default setting")));
    select_rn_d_node_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(),"select_rn_d_node", select_rn_d_node);
    `svt_xvm_debug("body", $sformatf("select_rn_d_node is %0d as a result of %0s", select_rn_d_node, (select_rn_d_node_status ?"config DB":"Default setting")));
    enable_outstanding_status = uvm_config_db#(bit)::get(m_sequencer, get_type_name(), "enable_outstanding", enable_outstanding);
    `svt_xvm_debug("body", $sformatf("enable_outstanding is %0b as a result of %0s", enable_outstanding, (enable_outstanding_status?"config DB":"default setting")));
    `svt_xvm_debug("pre_start",$sformatf("Exiting ..."));
  endtask // pre_start
  
   //----------------------------------------------------------------------------- 
   /** 
    * Function to check if current system configuration meets requirements of this sequence.
    * This sequence requires following configurations
    *  #- minimum supporting RN-F Nodes = 2 when select_rn_f_node is programmed to 1
    *  #- minimum supporting RN-I Nodes = 2 when select_rn_i_node is programmed to 1
    *  #- minimum supporting RN-D Nodes = 2 when select_rn_d_node is programmed to 1
    */  
   virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    
    /** local variables */
    int num_supporting_rn_f_nodes;
    int num_supporting_rn_i_nodes;
    int num_supporting_rn_d_nodes;
    string str_is_supported_info_prefix = "";
    string str_is_supported_info = "";

    /** Supporting Request Nodes required */
    int required_num_supporting_rn_f_nodes = 0;
    int required_num_supporting_rn_i_nodes = 0;
    int required_num_supporting_rn_d_nodes = 0;

    /** Supporting Home Nodes required */
    int required_num_hn_nodes = 1;
    int num_hn_f_nodes;

    int array_idx;
    string str_idx0_info = "";
    string str_idx1_info = ""; 
    bit    is_rn_idx_0_participating, is_rn_idx_1_participating; 
    
    `svt_xvm_debug("is_supported",$sformatf("Entering..."));

    /** By default is_supported is 0 */
    is_supported = 0;

    /** Check for minimum required HN-F nodes */
    num_hn_f_nodes = hn_f_nodes.size();
    
    /** Check the required supporting HN Nodes */
    if (num_hn_f_nodes < required_num_hn_nodes) begin
      issue_is_supported_failure($sformatf("This sequence requires minimum %0d HN-F nodes to be present in the system. Number of HN-F nodes are %0d. Program number of HN nodes using svt_chi_system_configuration::num_hn. Program the HN interface type using svt_chi_system_configuration::chi_addr_cfg.hn_interface_type[].", required_num_hn_nodes, num_hn_f_nodes));
      return 0;      
    end

    /** Either of select_rn_d_node, select_rn_i_node, select_rn_f_node needs to be programmed to 1.
     *  More than one flag cannot be 1 or 0 together.
     */
    if (((select_rn_f_node == 0) && (select_rn_i_node == 0) && (select_rn_d_node == 0)) ||
        ((select_rn_f_node == 1) && (select_rn_i_node == 1) && (select_rn_d_node == 1))) begin
      issue_is_supported_failure($sformatf("select_rn_f_node = %0d. select_rn_i_node = %0d. select_rn_d_node = %0d. Programming one of these two variables to 1 through config DB is required for this sequence to be run.", select_rn_f_node, select_rn_i_node, select_rn_d_node));
      return 0;
    end
   
    /** Set minimum required supporting RN-F, RN-D and RN-I nodes depending on  
     *  select_rn_f_node or select_rn_d_node or select_rn_i_node flags respectively.
     */   
    if(select_rn_f_node)
      required_num_supporting_rn_f_nodes = 2;
    else if(select_rn_i_node) begin
      required_num_supporting_rn_i_nodes = 2;
    end else if (select_rn_d_node)begin
      required_num_supporting_rn_d_nodes = 2;
    end

    /** Check for minimum required RN-F, RN-D and RN-I nodes.
     *  Also check whether the selected RN-F, RN-D and RN-I nodes are part of participating arrays or not.
     */ 
    num_supporting_rn_f_nodes = active_participating_rn_f_nodes.size();
    num_supporting_rn_d_nodes = active_participating_rn_d_nodes.size();
    num_supporting_rn_i_nodes = active_participating_rn_i_nodes.size();

    /** Check the requirements of RN nodes */
    if (num_supporting_rn_f_nodes) begin
      /** Display the contents of Active Participating RN-F Nodes */
      foreach (active_participating_rn_f_nodes[j]) begin
        str_node_info = {str_node_info, $sformatf(" %0d", active_participating_rn_f_nodes[j])};
      end      
      `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_f_nodes are %0s", str_node_info));
    end
    
    /** Display the contents of Active Participating RN-D Nodes */
    str_node_info = "";

    /** Check the requirement of RN-D nodes */ 
    if (num_supporting_rn_d_nodes) begin
      foreach (active_participating_rn_d_nodes[j]) begin
        str_node_info = {str_node_info, $sformatf(" %0d", active_participating_rn_d_nodes[j])};
      end 
      `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_d_nodes are %0s", str_node_info));
    end 

    /** Display the contents of Active Participating RN-I Nodes */
    str_node_info = "";
    
    /** Display the contents of Active Participating RN-I Nodes */
    if (num_supporting_rn_i_nodes) begin
      foreach (active_participating_rn_i_nodes[j]) begin
        str_node_info = {str_node_info, $sformatf(" %0d", active_participating_rn_i_nodes[j])};
      end 
      `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_i_nodes are %0s", str_node_info));
    end

    /** Check the required supporting Request Nodes */
    if (select_rn_f_node == 1) begin
      
      str_is_supported_info_prefix = $sformatf("select_rn_f_node is set to 1. Number of Supporting RN-F Node(s)  - Minimum Required : %0d Current : %0d", required_num_supporting_rn_f_nodes,num_supporting_rn_f_nodes);

      if ((initiating_rn_node_index_0_status==0)&&(valid_initiating_rn_f_node_index_0==0)) begin
          str_idx0_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN-Fs that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)";
      end
      else begin
        is_rn_idx_0_participating = is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_node_idx_0, array_idx);
        if (!is_rn_idx_0_participating) begin
          str_idx0_info = $sformatf("initiating_rn_node_idx_0 %0d is not valid for this sequence. The RN-F corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)", initiating_rn_node_idx_0, initiating_rn_node_idx_0);
        end
      end

      if ((initiating_rn_node_index_1_status==0)&&(valid_initiating_rn_f_node_index_1==0)) begin
        str_idx1_info = "Valid initiating_rn_node_idx_1 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN-Fs that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)";
      end 
      else begin
        is_rn_idx_1_participating = is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_node_idx_1, array_idx);
        if (!is_rn_idx_1_participating) begin
          str_idx1_info = $sformatf("initiating_rn_node_idx_1 %0d is not valid for this sequence. The RN-F corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)", initiating_rn_node_idx_1, initiating_rn_node_idx_1);
        end
      end    
    end
    else if (select_rn_i_node == 1) begin
      
      str_is_supported_info_prefix = $sformatf("select_rn_i_node is set to 1. Number of Supporting RN-I Node(s)  - Minimum Required : %0d Current : %0d", required_num_supporting_rn_i_nodes,num_supporting_rn_i_nodes);

      if ((initiating_rn_node_index_0_status==0)&&(valid_initiating_rn_i_node_index_0==0)) begin
        str_idx0_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN-Is that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_I)";
      end
      else begin
        is_rn_idx_0_participating = is_value_found_in_int_assoc_array(active_participating_rn_i_nodes, initiating_rn_node_idx_0, array_idx);
        if (!is_rn_idx_0_participating) begin
         
          str_idx0_info = $sformatf("initiating_rn_node_idx_0 %0d is not valid for this sequence. The RN-I corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_I)", initiating_rn_node_idx_0, initiating_rn_node_idx_0);
        end  
      end

      if ((initiating_rn_node_index_1_status==0)&&(valid_initiating_rn_i_node_index_1==0)) begin
        str_idx1_info = "Valid initiating_rn_node_idx_1 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN-Is that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_I)";
      end
      else begin
        is_rn_idx_1_participating = is_value_found_in_int_assoc_array(active_participating_rn_i_nodes, initiating_rn_node_idx_1, array_idx);
        if (!is_rn_idx_1_participating) begin
          str_idx1_info = $sformatf("initiating_rn_node_idx_1 %0d is not valid for this sequence. The RN-I corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_I)", initiating_rn_node_idx_1, initiating_rn_node_idx_1);
        end 
      end
    end
    else if (select_rn_d_node == 1) begin
      
      str_is_supported_info_prefix = $sformatf("select_rn_d_node is set to 1. Number of Supporting RN-D Node(s)  - Minimum Required : %0d Current : %0d", required_num_supporting_rn_d_nodes,num_supporting_rn_d_nodes);

      if ((initiating_rn_node_index_0_status==0)&&(valid_initiating_rn_d_node_index_0==0)) begin
        str_idx0_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN-Ds that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_D)";
      end
      else begin
        is_rn_idx_0_participating = is_value_found_in_int_assoc_array(active_participating_rn_d_nodes, initiating_rn_node_idx_0, array_idx);
        if (!is_rn_idx_0_participating) begin
         
          str_idx0_info = $sformatf("initiating_rn_node_idx_0 %0d is not valid for this sequence. The RN-D corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_D)", initiating_rn_node_idx_0, initiating_rn_node_idx_0);
        end  
      end

      if ((initiating_rn_node_index_1_status==0)&&(valid_initiating_rn_d_node_index_1==0)) begin
        str_idx1_info = "Valid initiating_rn_node_idx_1 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN-Ds that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_D)";
      end
      else begin
        is_rn_idx_1_participating = is_value_found_in_int_assoc_array(active_participating_rn_d_nodes, initiating_rn_node_idx_1, array_idx);
        if (!is_rn_idx_1_participating) begin
          str_idx1_info = $sformatf("initiating_rn_node_idx_1 %0d is not valid for this sequence. The RN-D corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_D)", initiating_rn_node_idx_1, initiating_rn_node_idx_1);
        end 
      end
    end

    if (is_rn_idx_0_participating && is_rn_idx_1_participating) begin
      is_supported = 1;
      if(max_num_outstanding_read_xacts_at_hn > 0) begin
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].num_outstanding_read_xact < (max_num_outstanding_read_xacts_at_hn/2)) begin
          str_idx0_info = $sformatf("Programmed value of max_num_outstanding_read_xacts_at_hn_status is %0d. But num_outstanding_read_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_read_xact of the initiating RN node must be equal to or greater than half of max_num_outstanding_read_xacts_at_hn_status of the target HN", max_num_outstanding_read_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_0_participating].num_outstanding_read_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].num_outstanding_read_xact < (max_num_outstanding_read_xacts_at_hn/2)) begin
          str_idx1_info = $sformatf("Programmed value of max_num_outstanding_read_xacts_at_hn_status is %0d. But num_outstanding_read_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_read_xact of the initiating RN node must be equal to or greater than half of max_num_outstanding_read_xacts_at_hn_status of the target HN", max_num_outstanding_read_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_1_participating].num_outstanding_read_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
      end else begin
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].num_outstanding_xact < (max_num_outstanding_xacts_at_hn/2)) begin
          str_idx0_info = $sformatf("Programmed value of max_num_outstanding_xacts_at_hn_status is %0d. But num_outstanding_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_xact of the initiating RN node must be equal to or greater than half of max_num_outstanding_xacts_at_hn of the target HN", max_num_outstanding_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_0_participating].num_outstanding_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].num_outstanding_xact < (max_num_outstanding_xacts_at_hn/2)) begin
          str_idx1_info = $sformatf("Programmed value of max_num_outstanding_xacts_at_hn_status is %0d. But num_outstanding_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_xact of the initiating RN node must be equal to or greater than half of max_num_outstanding_xacts_at_hn of the target HN", max_num_outstanding_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_1_participating].num_outstanding_xact, initiating_rn_node_idx_1);
          is_supported = 0;
        end
      end
    end 
    
    if (!is_supported) begin
      str_is_supported_info = $sformatf("%0s%0s",str_idx0_info, str_idx1_info);
      if (is_rn_idx_0_participating && is_rn_idx_1_participating) begin
        issue_is_supported_failure($sformatf("This sequence cannot be run based on the current system configuration.\n\
                                              %0s\n\
                                              %0s \n\
                                              Modify configurations through \n\
                                              svt_chi_system_configuration::num_rn,\n\
                                              svt_chi_node_configuration::is_active,\n\
                                              svt_chi_system_configuration::participating_rn_nodes[]\n\
                                              ", str_is_supported_info_prefix, str_is_supported_info));
      end
      else begin
        issue_is_supported_failure($sformatf("This sequence cannot be run based on the current node configurations of RN%0d and/or RN%0d.\n\
                                              %0s \n\
                                              Modify configurations through \n\
                                              svt_chi_node_configuration::num_outstanding_xact,\n\
                                              svt_chi_node_configuration::num_outstanding_read_xact,\n\
                                              ",str_is_supported_info, initiating_rn_node_idx_0, initiating_rn_node_idx_1));
      end
    end
    if (!is_target_hn_idx_valid_for_curr_cfg()) begin
      is_supported = 0;
      `svt_xvm_note("is_supported", "not a valid hn_idx based on random_tgt_id_enable for current cfg");
    end
  endfunction : is_supported
  
  //----------------------------------------------------------------------------- 
  virtual task body();
    /** Queue of addresses, used by the transactions generated */
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0]                addr_collection_q[$];
    bit seq_is_non_secure_access_q[$];
    int                                               array_idx;
    int                                               num_outstanding_xacts_to_generate;

    /** Flag to track whether cache initialization needs to be performed or not*/
    bit perform_cache_initialization;
    string str_node_types = "";
    int unsigned sel_initiating_rn_node_index_0,sel_initiating_rn_node_index_1;

    /** Sub sequences initiated from this sequence */
    svt_chi_rn_makeunique_cache_initialization_directed_sequence    makeunique_seq[int];
    /** Sub Read type transaction directed sequences initiated from this sequence */
    svt_chi_rn_read_type_transaction_directed_sequence read_seq[int];

    `svt_xvm_debug("body", "Entering ...");
    super.body();
    max_num_outstanding_xacts_at_hn_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(),"max_num_outstanding_xacts_at_hn",max_num_outstanding_xacts_at_hn);
    max_num_outstanding_read_xacts_at_hn_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(),"max_num_outstanding_read_xacts_at_hn",max_num_outstanding_read_xacts_at_hn);

    if (select_rn_f_node) begin
      str_node_types = "Iniating nodes are of RN-F type.";
      /** If the initiating_rn_f_node_index_2 is part of active_participating_rn_f_nodes array, and
       * it is not equal to initiating_rn_f_node_index_0, initiating_rn_f_node_index_1; then we can
       * perform cache initialization from the RN[cache_line_init_rn_f_node_index].
       */
      if ((is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_f_node_index_2, array_idx)) &&
          (initiating_rn_f_node_index_2 != initiating_rn_f_node_index_0) &&
          (initiating_rn_f_node_index_2 != initiating_rn_f_node_index_1)) begin
        perform_cache_initialization = 1;
        cache_line_init_rn_f_node_index = initiating_rn_f_node_index_2;          
      end else if (is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_f_node_index_1, array_idx)) begin
        perform_cache_initialization = 1;
        cache_line_init_rn_f_node_index = initiating_rn_f_node_index_1;          
      end
      sel_initiating_rn_node_index_0 = initiating_rn_f_node_index_0;
      sel_initiating_rn_node_index_1 = initiating_rn_f_node_index_1;
    end
    else if (select_rn_i_node) begin
      str_node_types = "Iniating nodes are of RN-I type.";        
      /** If the initiating_rn_f_node_index_0 is part of active_participating_rn_f_nodes array
       * then we can perform cache initialization from the RN[cache_line_init_rn_f_node_index]. 
       */
      if (is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_f_node_index_0, array_idx)) begin
        perform_cache_initialization = 1;
        cache_line_init_rn_f_node_index = initiating_rn_f_node_index_0;          
      end
      sel_initiating_rn_node_index_0 = initiating_rn_i_node_index_0;
      sel_initiating_rn_node_index_1 = initiating_rn_i_node_index_1;
    end
    else if (select_rn_d_node) begin
      str_node_types = "Initiating nodes are of RN-D type.";
      // If the initiating_rn_f_node_index_0 is part of active_participating_rn_f_nodes array
      // then we can perform cache initialization from the RN[cache_line_init_rn_f_node_index].
      if (is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_f_node_index_0, array_idx)) begin
        perform_cache_initialization = 1;
        cache_line_init_rn_f_node_index = initiating_rn_f_node_index_0;          
      end
      sel_initiating_rn_node_index_0 = initiating_rn_d_node_index_0;
      sel_initiating_rn_node_index_1 = initiating_rn_d_node_index_1;
    end

    `svt_xvm_debug("body", $sformatf("%0s perform_cache_initialization = %0b. cache_line_init_rn_f_node_index = %0d. sel_initiating_rn_node_index_0 = %0d. sel_initiating_rn_node_index_1 = %0d.", str_node_types, perform_cache_initialization, cache_line_init_rn_f_node_index, sel_initiating_rn_node_index_0, sel_initiating_rn_node_index_1));

    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :sel_initiating_rn_node_index_0;
    initiating_rn_node_idx_1 = initiating_rn_node_index_1_status ? initiating_rn_node_index_1_from_config_db :sel_initiating_rn_node_index_1;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_f_node_index_0;

    `svt_xvm_debug("body", $sformatf("max_num_outstanding_xacts_at_hn is %0d as a result of %0s.", max_num_outstanding_xacts_at_hn, max_num_outstanding_xacts_at_hn_status ? "config DB" : "default"));
    `svt_xvm_debug("body", $sformatf("max_num_outstanding_read_xacts_at_hn is %0d as a result of %0s.", max_num_outstanding_read_xacts_at_hn, max_num_outstanding_read_xacts_at_hn_status ? "config DB" : "default"));
    `svt_xvm_debug("body", $sformatf("initiating_rn_node_idx_0 is %0d as a result of %0s.", initiating_rn_node_idx_0, initiating_rn_node_index_0_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("initiating_rn_node_idx_1 is %0d as a result of %0s.", initiating_rn_node_idx_1, initiating_rn_node_index_1_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("target_hn_node_idx_0 is %0d as a result of %0s.", target_hn_node_idx_0, target_hn_node_index_0_status ? "config DB" : "Randomization"));

     /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /**
     * If the cache_line_init_rn_f_node_index is same as any of the RN node indices 
     * which are passed through config i.e initiating_rn_node_idx_0,initiating_rn_node_idx_1, and the number of RN-F is greater than 2
     * then re-assign the cache_line_init_rn_f_node_index with RN node index ,which is active,
     * participating and not equal to initiating_rn_node_idx_0, initiating_rn_node_idx_1.
     */
    if(initiating_rn_node_index_0_status||initiating_rn_node_index_1_status)begin  
      if((cache_line_init_rn_f_node_index == initiating_rn_node_idx_0)||(cache_line_init_rn_f_node_index == initiating_rn_node_idx_1))begin  
        int active_participating_q [$];
        `svt_chi_xxm_debug("body",$sformatf("cache_line_init_rn_f_node_index= %0d is same as initiating_rn_node_idx_0=%0d or initiating_rn_node_idx_1=%0d and active_participating_rn_f_nodes.size()= %0d",cache_line_init_rn_f_node_index,initiating_rn_node_idx_0,initiating_rn_node_idx_1,active_participating_rn_f_nodes.size()));
        if(active_participating_rn_f_nodes.size()>2)begin
          active_participating_q = active_participating_rn_f_nodes.find with ((item != initiating_rn_node_idx_0) && (item != initiating_rn_node_idx_1));
          cache_line_init_rn_f_node_index = active_participating_q.pop_back();
          `svt_chi_xxm_debug("body", $sformatf("active_participating_q.size() is %0d and Selected different cache_line_init_rn_f_node_index=%0d", active_participating_q.size(),cache_line_init_rn_f_node_index));
          active_participating_q.delete();
        end else begin
          perform_cache_initialization=1;
          `svt_chi_xxm_debug("body",$sformatf("Selected cache_line_init_rn_f_node_index= %0d is same as initiating_rn_node_index_0_from_config_db=%0d or initiating_rn_node_index_1_from_config_db=%0d and active_participating_rn_f_nodes.size()= %0d.",cache_line_init_rn_f_node_index,initiating_rn_node_index_0_from_config_db,initiating_rn_node_index_1_from_config_db,active_participating_rn_f_nodes.size()));
        end
      end  
    end 

    /**
     * If the cache_line_init_rn_f_node_index is part of active_participating_rn_f_nodes array, then we can
     * perform cache initialization from the RN[cache_line_init_rn_f_node_index].
     */
    if (is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, cache_line_init_rn_f_node_index, array_idx)) begin
      perform_cache_initialization = 1;
    end

    `svt_chi_xxm_debug("body",$sformatf("Selected RN indices are cache_line_init_rn_f_node_index= %0d initiating_rn_node_idx_0=%0d initiating_rn_node_idx_1=%0d and perform_cache_initialization= %0d",cache_line_init_rn_f_node_index,initiating_rn_node_idx_0,initiating_rn_node_idx_1,perform_cache_initialization));

    //If max outstanding count for Read transactions has been programmed, use that to generate the outstanding Reads
    if(max_num_outstanding_read_xacts_at_hn > 0) begin
      num_outstanding_xacts_to_generate = max_num_outstanding_read_xacts_at_hn;
      `svt_xvm_debug("body",$sformatf("max_num_outstanding_read_xacts_at_hn is set to a non-zero value (%0d). Hence, the value programmed in max_num_outstanding_xacts_at_hn will be ignored. The number of outstanding transactions issued by the sequence will be equal to max_num_outstanding_read_xacts_at_hn", max_num_outstanding_read_xacts_at_hn));
    end
    //If not, use the max outstanding transaction count
    else
      num_outstanding_xacts_to_generate = max_num_outstanding_xacts_at_hn;

    for(int i = 0; i < sequence_length; i++) begin
      if(perform_cache_initialization) begin
        `svt_xvm_debug("body",$sformatf("Starting cache initialization for %0d addresses from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d",num_outstanding_xacts_to_generate, cache_line_init_rn_f_node_index, target_hn_node_idx_0));
        for(int k=0; k<num_outstanding_xacts_to_generate; k++) begin
          /** Write data into Cache of Randomly selected first RN with address of randomly selected HN Node */
          //cache_line_init_rn_f_node_index will be set to initiating_rn_node_idx_1 or initiating_rn_node_idx_0 only when there are only 2 RN-Fs in the system. In such a case,
          //the cache init transactions must be issued alternately from initiating_rn_node_idx_1 and
          //initiating_rn_node_idx_0 respectively
          if(cache_line_init_rn_f_node_index == initiating_rn_node_idx_1 || cache_line_init_rn_f_node_index == initiating_rn_node_idx_0) begin
            if(k % 2 == 0) 
              cache_line_init_rn_f_node_index = initiating_rn_node_idx_1;
            else
              cache_line_init_rn_f_node_index = initiating_rn_node_idx_0; 
          end
         `svt_xvm_do_on_with(makeunique_seq[k], p_sequencer.rn_virt_seqr[cache_line_init_rn_f_node_index].rn_xact_seqr,
         {
           sequence_length     == 1;
           hn_addr_rand_type   == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
           seq_hn_node_idx     == target_hn_node_idx_0;
           use_seq_is_non_secure_access == 0;
         })
          /** Waiting for above MakeUnique transaction to complete */ 
          `svt_xvm_debug("body", $sformatf("%0s Waiting for MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) to end",`SVT_CHI_PRINT_PREFIX(makeunique_seq[k].write_tran),k, makeunique_seq[k].write_tran.hn_node_idx, makeunique_seq[k].write_tran.tgt_id));
          makeunique_seq[k].write_tran.wait_end();
          `svt_xvm_debug("body", $sformatf("%0s MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) ended",`SVT_CHI_PRINT_PREFIX(makeunique_seq[k].write_tran),k, makeunique_seq[k].write_tran.hn_node_idx, makeunique_seq[k].write_tran.tgt_id));

          `svt_xvm_verbose("body", $sformatf("MakeUnique transaction [%0d]  is %0s", k,makeunique_seq[k].write_tran.sprint()));
          
          /** Retrieving addresses from output transactions generated by the sequence */
          addr_collection_q.push_back(makeunique_seq[k].write_tran.addr); 
          seq_is_non_secure_access_q.push_back(makeunique_seq[k].write_tran.is_non_secure_access); 
          `svt_xvm_debug("body",$sformatf("Ended cache initialization for %0d addresses from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d ",
                                      num_outstanding_xacts_to_generate, cache_line_init_rn_f_node_index, target_hn_node_idx_0)); 
        end  
      end// perform_cache_initialization
      
      //for(int j=0; j<num_outstanding_xacts_to_generate/2; j++) begin 
        fork
          /** 
           * Do 128 transactions from two different RNs to all MAKEUNIQUE 
           * transaction address of same HN node
           */ 
          begin: rn_0_thread
            for(int j=0; j<(num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2); j++) begin 
              `svt_xvm_do_on_with(read_seq[2*j],p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
              {
                sequence_length      == 1;
                seq_order_type           == svt_chi_transaction::NO_ORDERING_REQUIRED;
                if (perform_cache_initialization) 
                {
                  hn_addr_rand_type    == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                  `ifdef SVT_CHI_ISSUE_E_ENABLE
                   if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision >= svt_chi_node_configuration::ISSUE_E) {
                    seq_txn_id         == (j*3);
                   }
                   else{
                    seq_txn_id         == (j % num_outstanding_xacts_to_generate);
                   }
                  `else
                    seq_txn_id         == (j % num_outstanding_xacts_to_generate);
                  `endif
                  min_addr             == addr_collection_q[2*j];
                  max_addr             == addr_collection_q[2*j];
                  seq_is_non_secure_access == seq_is_non_secure_access_q[2*j]; 
                  use_seq_is_non_secure_access == 1;
                  data_in_cache        == makeunique_seq[2*j].write_tran.data;
                  by_pass_read_data_check == 0;
                }
                else {
                hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
                seq_hn_node_idx    == target_hn_node_idx_0; 
                by_pass_read_data_check == 1;
                use_seq_is_non_secure_access == 0;
                }
                if (select_rn_f_node) seq_xact_type != svt_chi_transaction::READNOSNP;
                if (select_rn_i_node || select_rn_d_node) seq_xact_type == svt_chi_transaction::READONCE;
                `ifdef SVT_CHI_ISSUE_B_ENABLE
                if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type != svt_chi_transaction::READNOTSHAREDDIRTY;
                if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A || sys_cfg.readspec_enable == 0) seq_xact_type != svt_chi_transaction::READSPEC;
                if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type != svt_chi_transaction::READONCECLEANINVALID;
                if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type != svt_chi_transaction::READONCEMAKEINVALID;
                `endif
                `ifdef SVT_CHI_ISSUE_E_ENABLE
                  if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision <= svt_chi_node_configuration::ISSUE_D) seq_xact_type != svt_chi_transaction::READPREFERUNIQUE;
                `endif
              })
              `svt_xvm_debug("body", $sformatf("%0s Transmitting Read Transaction [%0d] targeted to HN (idx %0d, id %0d) ",`SVT_CHI_PRINT_PREFIX(read_seq[2*j].read_tran),2*j, read_seq[2*j].read_tran.hn_node_idx,read_seq[2*j].read_tran.tgt_id));
              `svt_xvm_verbose("body", $sformatf("Read Transaction [%0d] is %0s",2*j,read_seq[2*j].read_tran.sprint()));
            end
          end: rn_0_thread
          begin: rn_1_thread
            for(int j=0; j<(num_outstanding_xacts_to_generate/2); j++) begin 
              `svt_xvm_do_on_with(read_seq[2*j + 1],p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,
              {
                sequence_length      == 1;
                seq_order_type           == svt_chi_transaction::NO_ORDERING_REQUIRED;
                if (perform_cache_initialization) 
                {
                hn_addr_rand_type    == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                `ifdef SVT_CHI_ISSUE_E_ENABLE
                 if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision >= svt_chi_node_configuration::ISSUE_E) {
                  seq_txn_id         == (j*3);
                 }
                 else{
                  seq_txn_id         == (j % num_outstanding_xacts_to_generate);
                 }
                `else
                  seq_txn_id         == (j % num_outstanding_xacts_to_generate);
                `endif
                min_addr             == addr_collection_q[2*j + 1];
                max_addr             == addr_collection_q[2*j + 1];
                seq_is_non_secure_access == seq_is_non_secure_access_q[2*j + 1];
                use_seq_is_non_secure_access == 1;
                data_in_cache        == makeunique_seq[2*j + 1].write_tran.data;
                by_pass_read_data_check == 0;
                }
                else {
                hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
                seq_hn_node_idx    == target_hn_node_idx_0; 
                by_pass_read_data_check == 1;
                use_seq_is_non_secure_access == 0;
                }
                if (select_rn_f_node) seq_xact_type != svt_chi_transaction::READNOSNP;
                if (select_rn_i_node || select_rn_d_node) seq_xact_type == svt_chi_transaction::READONCE;
                `ifdef SVT_CHI_ISSUE_B_ENABLE
                if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type != svt_chi_transaction::READNOTSHAREDDIRTY;
                if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision == svt_chi_node_configuration::ISSUE_A || sys_cfg.readspec_enable == 0) seq_xact_type != svt_chi_transaction::READSPEC;
                if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type != svt_chi_transaction::READONCECLEANINVALID;
                if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type != svt_chi_transaction::READONCEMAKEINVALID;
                `endif
                `ifdef SVT_CHI_ISSUE_E_ENABLE
                  if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision <= svt_chi_node_configuration::ISSUE_D) seq_xact_type != svt_chi_transaction::READPREFERUNIQUE;
                `endif
              })
              `svt_xvm_debug("body", $sformatf("%0s Transmitting Read Transaction [%0d] targeted to HN (idx %0d, id %0d) ",`SVT_CHI_PRINT_PREFIX(read_seq[2*j + 1].read_tran),2*j + 1, read_seq[2*j + 1].read_tran.hn_node_idx,read_seq[2*j + 1].read_tran.tgt_id));
              `svt_xvm_verbose("body", $sformatf("Read Transaction [%0d] is %0s",2*j + 1,read_seq[2*j + 1].read_tran.sprint()));
            end           
          end: rn_1_thread           
        join
      //end//outstanding
    
      /** Event to Resume the Suspended Response of above trasactions */ 
      foreach(read_seq[rd]) begin
        fork
          automatic int _rd = rd;
          begin
            `svt_xvm_debug("body", $sformatf("%0s Read transaction [%0d] targeted to HN (idx %0d, id %0d), suspend_comp_ack %0b: waiting for response from interconnect",`SVT_CHI_PRINT_PREFIX(read_seq[_rd].read_tran),_rd,read_seq[_rd].read_tran.hn_node_idx, read_seq[_rd].read_tran.tgt_id,read_seq[_rd].read_tran.suspend_comp_ack));
            fork
            begin
              fork
                begin
                  read_seq[_rd].read_tran.wait_for_tx_compack_prereqs();// begin
                end
                begin
                  wait(read_seq[_rd].read_tran.req_status == svt_chi_transaction::RETRY);// begin
                end
              join_any
              disable fork;
            end
            join
            received_read_responses++;
            `svt_xvm_debug("body", $sformatf("%0s Read transaction [%0d] targeted to HN (idx %0d, id %0d), suspend_comp_ack %0b: received response from interconnect. Total responses received %0d",`SVT_CHI_PRINT_PREFIX(read_seq[_rd].read_tran),_rd, read_seq[_rd].read_tran.hn_node_idx, read_seq[_rd].read_tran.tgt_id,read_seq[_rd].read_tran.suspend_comp_ack, received_read_responses));
          end
        join_none
      end

      /** Wait until All Comp responses are received at each RN's */ 
      `svt_xvm_debug("body",$sformatf("Completed initiation of Read type transactions for %0d addresses from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d with suspend_comp_ack set to 1, and waiting to receive responses from interconnect.",
                                num_outstanding_xacts_to_generate, initiating_rn_node_idx_0, target_hn_node_idx_0));
      wait(received_read_responses == (num_outstanding_xacts_to_generate/2 + num_outstanding_xacts_to_generate/2)); 
      `svt_xvm_debug("body",$sformatf("Received responses from interconnect to Read type transactions for %0d addresses from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d with suspend_comp_ack set to 1",
                            num_outstanding_xacts_to_generate, initiating_rn_node_idx_0, target_hn_node_idx_0));

      /** Self Check1: To check suspend_comp_ack should not be modified to zero by the VIP
       * before reseting from test bench
       */
      foreach (read_seq[self_check_idx1]) begin
        if (!read_seq[self_check_idx1].read_tran.is_terminated()) begin
          if (read_seq[self_check_idx1].read_tran.suspend_comp_ack == 0) begin
            `svt_xvm_error("body", $sformatf("%0s suspend_comp_ack should be 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(read_seq[self_check_idx1].read_tran)));
          end
          else begin
            `svt_xvm_debug("body", $sformatf("%0s suspend_comp_ack is 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(read_seq[self_check_idx1].read_tran)));
          end
        end
      end

      /** Self Check2: To check end_event should not be 1 before resuming the
       * transaction from test bench
       */
      foreach (read_seq[self_check_idx2]) begin
        if (!read_seq[self_check_idx2].read_tran.is_terminated()) begin
          if (read_seq[self_check_idx2].read_tran.end_event.is_on() == 1) begin
            `svt_xvm_error("body", $sformatf("Unexpected: %0s Transaction's end_event triggered when suspend_comp_ack is still 1.",`SVT_CHI_PRINT_PREFIX(read_seq[self_check_idx2].read_tran)));
          end
          else begin 
            `svt_xvm_debug("body", $sformatf("Expected: %0s Transaction's end_event is not triggered when suspend_comp_ack is still 1.",`SVT_CHI_PRINT_PREFIX(read_seq[self_check_idx2].read_tran)));
          end
        end
      end

      /** Self Check 3: To check that the current_outstanding_*_xact_count in the RNs
       * match the number of transactions inititated by the sequence
       */
      /** Check if the total outstanding xact counter is set correctly in the shared status of the RN agent */
      if(read_seq[0].shared_status.prot_status.current_outstanding_xact_count != (num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2))
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding transactions from the sequence but the outstanding transaction count in the shared status of RN%0d is %0d", (num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2), initiating_rn_node_idx_0, read_seq[0].shared_status.prot_status.current_outstanding_xact_count));
      /** Check if the outstanding Read xact counter is set correctly in the shared status of the RN agent */
      if(read_seq[0].shared_status.prot_status.current_outstanding_read_xact_count != (num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2)) begin
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding Read transactions from the sequence but the outstanding Read transaction count in the shared status of RN%0d is %0d", (num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2), initiating_rn_node_idx_0, read_seq[0].shared_status.prot_status.current_outstanding_read_xact_count));
      end

      /** Check if the total outstanding xact counter is set correctly in the shared status of the second RN agent */
      if(read_seq[1].shared_status.prot_status.current_outstanding_xact_count != num_outstanding_xacts_to_generate/2)
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding transactions from the sequence but the outstanding transaction count in the shared status of RN%0d is %0d", num_outstanding_xacts_to_generate/2, initiating_rn_node_idx_1, read_seq[1].shared_status.prot_status.current_outstanding_xact_count));
      /** Check if the outstanding Read xact counter is set correctly in the shared status of the RN agent */
      if(read_seq[1].shared_status.prot_status.current_outstanding_read_xact_count != num_outstanding_xacts_to_generate/2) begin
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding Read transactions from the sequence but the outstanding Read transaction count in the shared status of RN%0d is %0d", num_outstanding_xacts_to_generate/2, initiating_rn_node_idx_1, read_seq[1].shared_status.prot_status.current_outstanding_read_xact_count));
      end

      `svt_xvm_debug("body", $sformatf("RN%0d: Number of outstanding transactions : %0d, Number of outstanding read xacts : %0d", initiating_rn_node_idx_0, read_seq[0].shared_status.prot_status.current_outstanding_xact_count, read_seq[0].shared_status.prot_status.current_outstanding_read_xact_count));
      `svt_xvm_debug("body", $sformatf("RN%0d: Number of outstanding transactions : %0d, Number of outstanding read xacts : %0d", initiating_rn_node_idx_1, read_seq[0].shared_status.prot_status.current_outstanding_xact_count, read_seq[1].shared_status.prot_status.current_outstanding_read_xact_count));

      /** Resuming all CompAck responses of above Read transactions from RN */
      foreach(read_seq[rd]) begin
        `svt_xvm_debug("body",$sformatf("Received responses for all Read type transactions from interconnect, resuming the transactions by setting svt_chi_rn_transaction::suspend_comp_ack set to 0 %0s",`SVT_CHI_PRINT_PREFIX(read_seq[rd].read_tran)));
        read_seq[rd].read_tran.suspend_comp_ack=0;
        `svt_xvm_debug("body", $sformatf("For iteration %0d, received_read_responses is %0d,suspend_comp_ack is %b and exp_comp_ack is %b After Resume", rd,received_read_responses,read_seq[rd].read_tran.suspend_comp_ack,read_seq[rd].read_tran.exp_comp_ack));
      end
      
      /** Waiting for above read outstanding transactions to complete */
      `svt_xvm_debug("body",$sformatf("Waiting for completion of all the outstanding Read type transactions"));
      foreach (read_seq[index1]) begin
        `svt_xvm_debug("body", $sformatf("Waiting for above read_seq[%0d] transaction %0s to end", index1, `SVT_CHI_PRINT_PREFIX(read_seq[index1].read_tran)));
        read_seq[index1].read_tran.wait_end();

        /** Self Check4: To check suspend_comp_ack should not be 1 after reseting from test bench
         * after the transaction completes
         */
        if (!read_seq[index1].read_tran.is_terminated()) begin
          if (read_seq[index1].read_tran.suspend_comp_ack == 1) begin
           `svt_xvm_error("body", $sformatf("%0s suspend_comp_ack should be 0 as it should be reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(read_seq[index1].read_tran)));
          end
          else begin
           `svt_xvm_debug("body", $sformatf("%0s suspend_comp_ack is 0 as it is reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(read_seq[index1].read_tran)));
          end
        end
      end 
      `svt_xvm_debug("body",$sformatf("Received completions for all Read type outstanding transactions"));

      /** To check Targetted HN IDs from both RNs are same
       *  for every transaction
       */
      for(int j=0; j<num_outstanding_xacts_to_generate/2; j++) begin
        int hn_idx_0, hn_idx_1;
        hn_idx_0 = sys_cfg.get_hn_idx(read_seq[2*j].read_tran.addr);
        hn_idx_1 = sys_cfg.get_hn_idx(read_seq[2*j + 1].read_tran.addr);

        if ((hn_idx_0 == hn_idx_1) && (target_hn_node_idx_0 == hn_idx_0)) begin
          `svt_xvm_debug("body", $sformatf("Targeted HN Index from both RNs is same as expected.  rn[%0d] to hn_idx[%0d], rn[%0d] to hn_idx[%0d]", initiating_rn_node_idx_0, hn_idx_0, initiating_rn_node_idx_1, hn_idx_1));
        end
        else begin
        `svt_xvm_error("body", $sformatf("Targeted HN Index from both RNs is different, which is unexpected.  rn[%0d] %0s transaction to hn_idx[%0d], rn[%0d] %0s transaction to hn_idx[%0d]", initiating_rn_node_idx_0,`SVT_CHI_PRINT_PREFIX(read_seq[2*j].read_tran), hn_idx_0,initiating_rn_node_idx_1,`SVT_CHI_PRINT_PREFIX(read_seq[2*j + 1].read_tran), hn_idx_1));
        end
      end   
      
      /** Reset received_read_responses to Zero */
      received_read_responses = 0;

      /** Delete the contents of address collection queue */
      addr_collection_q.delete();

    end //sequence_length
    /** 
     * To check the Interconnect HN Node shall responds to all 
     * outstanding read tranactions to RN.<br>
     * Check done by System monitor(List of checkers)<br>
     *  #- read_data_integrity_check 
     *  #- coherent_and_snoop_data_match_check
     */
 
    `svt_xvm_debug("body", "Exiting...")
  endtask: body

  virtual task post_start();
    super.post_start();
    drop_phase_objection();
  endtask

endclass: svt_chi_system_protocol_flow_ctrl_read_outstanding_diff_rn_same_hn_virtual_sequence

function svt_chi_system_protocol_flow_ctrl_read_outstanding_diff_rn_same_hn_virtual_sequence::new(string name="svt_chi_system_protocol_flow_ctrl_read_outstanding_diff_rn_same_hn_virtual_sequence");
  super.new(name);
endfunction

//====================================================================================
/**
 * @groupname CHI_OUTSTANDING_RD_TYPE  
 *    #- This sequence requires at least two different HN node to be present in the Interconnect.<br>
 *    #- This sequence requires two initiating active and participating RN.<br>
 *    #- If another active and participating RN-F exists, perform cache<br>
 *       initialization to a randomly selected two different HN's.<br>
 *    #- Initiate maximum number of Read type transactions with<br> 
 *       svt_chi_rn_transaction::suspend_comp_ack set  to 1 from two initiating RN's to randomly<br> 
 *       selected different HN's in non blocking mode. <br>
 *       - This ensures that the maximum outstanding transaction limit is reached at the<br> 
 *         two differernt HN's.<br> 
 *       - Maximum number of outstanding transactions at the HN is as per either #max_num_outstanding_read_xacts_at_hn or
 *         #max_num_outstanding_xacts_at_hn, which can be controlled through config DB.  
 *       - Also, the two different RN will not transmit CompAck corresponding to these transactions<br>
 *       until svt_chi_rn_transaction::suspend_comp_ack is set to 0 from the seqeunce.<br>
 *       .
 *    #- The addresses of these Read transactions are such that:<br>
 *       - Same as initialized cache line addresses if cache initialization is performed<br>
 *       - Otherwise, random addresses targeting the different HN's<br>
 *       .
 *    #- Once the RN receives the responses for all the outstanding transactions from<br>
 *       different HN, svt_chi_rn_transaction::suspend_comp_ack is set to 0 for all the outstanding<br>
 *       transactions. <br>
 *       This ensures that the CompAck for these transactions can be resumed<br> 
 *       from different RN.<br>
 *    #- Check that the different HN responds properly for all outstanding Read type<br>
 *       transactions and these are completed successfully.<br>
 *    .
 */

class svt_chi_system_protocol_flow_ctrl_read_outstanding_diff_rn_diff_hn_virtual_sequence extends svt_chi_system_base_virtual_sequence;

  //-----------------------------------------------------------------------------  
  // Member attributes
  //-----------------------------------------------------------------------------  
  /** Parameter that controls the enabling of transactions in non-blocking mode from the sequence */
  bit enable_outstanding = 0;

  /** Represents the RN-F node for which the sequence will be initiated */ 
  int select_rn_f_node = 0;  
  
  /** Represents the RN-I node for which the sequence will be initiated */ 
  int select_rn_i_node = 0;
  
  /** Represents the RN-D node for which the sequence will be initiated */ 
  int select_rn_d_node = 0;

  /** Status filed for capturing config DB get status for select_rn_f_node */
  bit select_rn_f_node_status = 0;
  
  /** Status filed for capturing config DB get status for select_rn_i_node */
  bit select_rn_i_node_status = 0;

  /** Status filed for capturing config DB get status for select_rn_d_node */
  bit select_rn_d_node_status = 0;

  /** Represents the received read sequences responses */
  int received_read_seq1_responses = 0;
  int received_read_seq2_responses = 0;

  /** UVM/OVM Object Utility macro */
  `svt_xvm_object_utils(svt_chi_system_protocol_flow_ctrl_read_outstanding_diff_rn_diff_hn_virtual_sequence) 

  //-----------------------------------------------------------------------------  
  // Methods
  //-----------------------------------------------------------------------------
  /** Constructor */
  extern function new(string name="svt_chi_system_protocol_flow_ctrl_read_outstanding_diff_rn_diff_hn_virtual_sequence");

  virtual task pre_start();
    bit enable_outstanding_status;
    `svt_xvm_debug("pre_start",$sformatf("Entering ..."));
    super.pre_start();
    raise_phase_objection();
    select_rn_f_node_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(),"select_rn_f_node", select_rn_f_node);
    `svt_xvm_debug("body", $sformatf("select_rn_f_node is %0d as a result of %0s", select_rn_f_node, (select_rn_f_node_status ?"config DB":"Default setting")));
    select_rn_i_node_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(),"select_rn_i_node", select_rn_i_node);
    select_rn_d_node_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(),"select_rn_d_node", select_rn_d_node);
    `svt_xvm_debug("body", $sformatf("select_rn_d_node is %0d as a result of %0s", select_rn_d_node, (select_rn_d_node_status ?"config DB":"Default setting")));
    `svt_xvm_debug("body", $sformatf("select_rn_i_node is %0d as a result of %0s", select_rn_i_node, (select_rn_i_node_status ?"config DB":"Default setting")));
    enable_outstanding_status = uvm_config_db#(bit)::get(m_sequencer, get_type_name(), "enable_outstanding", enable_outstanding);
    `svt_xvm_debug("body", $sformatf("enable_outstanding is %0b as a result of %0s", enable_outstanding, (enable_outstanding_status?"config DB":"default setting")));
    `svt_xvm_debug("pre_start",$sformatf("Exiting ..."));
  endtask // pre_start

  // -----------------------------------------------------------------------------
  /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting RN-F Nodes = 2 when select_rn_f_node is programmed to 1
   *  #- minimum supporting RN-I Nodes = 2 when select_rn_i_node is programmed to 1
   *  #- minimum supporting RN-D Nodes = 2 when select_rn_d_node is programmed to 1
   */
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    
    /** local variables */
    int num_supporting_rn_f_nodes;
    int num_supporting_rn_i_nodes;
    int num_supporting_rn_d_nodes;
    string str_is_supported_info_prefix = "";
    string str_is_supported_info = "";

    /** Supporting Request Nodes required */
    int required_num_supporting_rn_f_nodes = 0;
    int required_num_supporting_rn_i_nodes = 0;
    int required_num_supporting_rn_d_nodes = 0;
    int required_num_hn_nodes = 2;
    int num_hn_f_nodes;
    int array_idx;
    string str_idx0_info = "";
    string str_idx1_info = ""; 
    bit    is_rn_idx_0_participating, is_rn_idx_1_participating;   
    `svt_xvm_debug("is_supported",$sformatf("calling is_supported"));
                 
    /** By default is_supported is 0 */
    is_supported = 0;

    /** Check for minimum required HN-F nodes */
    num_hn_f_nodes = hn_f_nodes.size();
    
    /** Check requirment of number of HN nodes needed */
    if (num_hn_f_nodes < required_num_hn_nodes) begin
      issue_is_supported_failure($sformatf("This sequence requires minimum %0d HN-F nodes to be present in the system. Number of HN-F nodes are %0d. Program number of HN nodes using svt_chi_system_configuration::num_hn. Program the HN interface type using svt_chi_system_configuration::chi_addr_cfg.hn_interface_type[].", required_num_hn_nodes, num_hn_f_nodes));
      return 0;      
    end
    
    /** Either of select_rn_d_node, select_rn_i_node, select_rn_f_node needs to be programmed to 1.
     *  More than one flag cannot be 1 or 0 together.
     */
    if (((select_rn_f_node == 0) && (select_rn_i_node == 0) && (select_rn_d_node == 0)) ||
        ((select_rn_f_node == 1) && (select_rn_i_node == 1) && (select_rn_d_node == 1))) begin
      issue_is_supported_failure($sformatf("select_rn_f_node = %0d. select_rn_i_node = %0d. select_rn_d_node = %0d. Programming one of these two variables to 1 through config DB is required for this sequence to be run.", select_rn_f_node, select_rn_i_node, select_rn_d_node));
      return 0;
    end
   
    /** Set minimum required supporting RN-F, RN-D and RN-I nodes depending on  
     *  select_rn_f_node or select_rn_d_node or select_rn_i_node flags respectively.
     */   
    if(select_rn_f_node)
      required_num_supporting_rn_f_nodes = 2;
    else if(select_rn_i_node) begin
      required_num_supporting_rn_i_nodes = 2;
    end else if (select_rn_d_node)begin
      required_num_supporting_rn_d_nodes = 2;
    end

    /** Check for minimum required RN-F, RN-D and RN-I nodes.
     *  Also check whether the selected RN-F, RN-D and RN-I nodes are part of participating arrays or not.
     */ 
    num_supporting_rn_f_nodes = active_participating_rn_f_nodes.size();
    num_supporting_rn_d_nodes = active_participating_rn_d_nodes.size();
    num_supporting_rn_i_nodes = active_participating_rn_i_nodes.size();

    /** Check the requirements of RN nodes */
    if (num_supporting_rn_f_nodes) begin
      /** Display the contents of Active Participating RN-F Nodes */
      foreach (active_participating_rn_f_nodes[j]) begin
        str_node_info = {str_node_info, $sformatf(" %0d", active_participating_rn_f_nodes[j])};
      end      
      `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_f_nodes are %0s", str_node_info));
    end
    
    /** Display the contents of Active Participating RN-D Nodes */
    str_node_info = "";

    /** Check the requirement of RN-D nodes */ 
    if (num_supporting_rn_d_nodes) begin
      foreach (active_participating_rn_d_nodes[j]) begin
        str_node_info = {str_node_info, $sformatf(" %0d", active_participating_rn_d_nodes[j])};
      end 
      `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_d_nodes are %0s", str_node_info));
    end 

    /** Display the contents of Active Participating RN-I Nodes */
    str_node_info = "";
    
    /** Check the requirement of RN-I nodes */ 
    if (num_supporting_rn_i_nodes) begin
      /** Display the contents of Active Participating RN-I Nodes */
      foreach (active_participating_rn_i_nodes[j]) begin
        str_node_info = {str_node_info, $sformatf(" %0d", active_participating_rn_i_nodes[j])};
      end 
      `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_i_nodes are %0s", str_node_info));
    end

    /** Check the required supporting Request Nodes */
    if (select_rn_f_node == 1) begin
      
      str_is_supported_info_prefix = $sformatf("select_rn_f_node is set to 1. Number of Supporting RN-F Node(s)  - Minimum Required : %0d Current : %0d", required_num_supporting_rn_f_nodes,num_supporting_rn_f_nodes);

      if ((initiating_rn_node_index_0_status==0)&&(valid_initiating_rn_f_node_index_0==0)) begin
          str_idx0_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN-Fs that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)";
      end
      else begin
        is_rn_idx_0_participating = is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_node_idx_0, array_idx);
        if (!is_rn_idx_0_participating) begin
          str_idx0_info = $sformatf("initiating_rn_node_idx_0 %0d is not valid for this sequence. The RN-F corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)", initiating_rn_node_idx_0, initiating_rn_node_idx_0);
        end
      end

      if ((initiating_rn_node_index_1_status==0)&&(valid_initiating_rn_f_node_index_1==0)) begin
        str_idx1_info = "Valid initiating_rn_node_idx_1 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN-Fs that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)";
      end 
      else begin
        is_rn_idx_1_participating = is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_node_idx_1, array_idx);
        if (!is_rn_idx_1_participating) begin
          str_idx1_info = $sformatf("initiating_rn_node_idx_1 %0d is not valid for this sequence. The RN-F corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)", initiating_rn_node_idx_1, initiating_rn_node_idx_1);
        end
      end    
    end
    else if (select_rn_i_node == 1) begin
      
      str_is_supported_info_prefix = $sformatf("select_rn_i_node is set to 1. Number of Supporting RN-I Node(s)  - Minimum Required : %0d Current : %0d", required_num_supporting_rn_i_nodes,num_supporting_rn_i_nodes);

      if ((initiating_rn_node_index_0_status==0)&&(valid_initiating_rn_i_node_index_0==0)) begin
        str_idx0_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN-Is that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_I)";
      end
      else begin
        is_rn_idx_0_participating = is_value_found_in_int_assoc_array(active_participating_rn_i_nodes, initiating_rn_node_idx_0, array_idx);
        if (!is_rn_idx_0_participating) begin
         
          str_idx0_info = $sformatf("initiating_rn_node_idx_0 %0d is not valid for this sequence. The RN-I corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_I)", initiating_rn_node_idx_0, initiating_rn_node_idx_0);
        end  
      end

      if ((initiating_rn_node_index_1_status==0)&&(valid_initiating_rn_i_node_index_1==0)) begin
        str_idx1_info = "Valid initiating_rn_node_idx_1 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN-Is that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_I)";
      end
      else begin
        is_rn_idx_1_participating = is_value_found_in_int_assoc_array(active_participating_rn_i_nodes, initiating_rn_node_idx_1, array_idx);
        if (!is_rn_idx_1_participating) begin
          str_idx1_info = $sformatf("initiating_rn_node_idx_1 %0d is not valid for this sequence. The RN-I corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_I)", initiating_rn_node_idx_1, initiating_rn_node_idx_1);
        end 
      end
    end
    else if (select_rn_d_node == 1) begin
      
      str_is_supported_info_prefix = $sformatf("select_rn_d_node is set to 1. Number of Supporting RN-D Node(s)  - Minimum Required : %0d Current : %0d", required_num_supporting_rn_d_nodes,num_supporting_rn_d_nodes);

      if ((initiating_rn_node_index_0_status==0)&&(valid_initiating_rn_d_node_index_0==0)) begin
        str_idx0_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN-Ds that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_D)";
      end
      else begin
        is_rn_idx_0_participating = is_value_found_in_int_assoc_array(active_participating_rn_d_nodes, initiating_rn_node_idx_0, array_idx);
        if (!is_rn_idx_0_participating) begin
         
          str_idx0_info = $sformatf("initiating_rn_node_idx_0 %0d is not valid for this sequence. The RN-D corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_D)", initiating_rn_node_idx_0, initiating_rn_node_idx_0);
        end  
      end

      if ((initiating_rn_node_index_1_status==0)&&(valid_initiating_rn_d_node_index_1==0)) begin
        str_idx1_info = "Valid initiating_rn_node_idx_1 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN-Ds that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_D)";
      end
      else begin
        is_rn_idx_1_participating = is_value_found_in_int_assoc_array(active_participating_rn_d_nodes, initiating_rn_node_idx_1, array_idx);
        if (!is_rn_idx_1_participating) begin
          str_idx1_info = $sformatf("initiating_rn_node_idx_1 %0d is not valid for this sequence. The RN-D corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_D)", initiating_rn_node_idx_1, initiating_rn_node_idx_1);
        end 
      end
    end

    if (is_rn_idx_0_participating && is_rn_idx_1_participating) begin
      is_supported = 1;
      if(max_num_outstanding_read_xacts_at_hn > 0) begin
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].num_outstanding_read_xact < max_num_outstanding_read_xacts_at_hn) begin
          str_idx0_info = $sformatf("Programmed value of max_num_outstanding_read_xacts_at_hn_status is %0d. But num_outstanding_read_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_read_xact of the initiating RN node must be equal to or greater than max_num_outstanding_read_xacts_at_hn_status of the target HN", max_num_outstanding_read_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_0_participating].num_outstanding_read_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].num_outstanding_read_xact < max_num_outstanding_read_xacts_at_hn) begin
          str_idx1_info = $sformatf("Programmed value of max_num_outstanding_read_xacts_at_hn_status is %0d. But num_outstanding_read_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_read_xact of the initiating RN node must be equal to or greater than max_num_outstanding_read_xacts_at_hn_status of the target HN", max_num_outstanding_read_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_1_participating].num_outstanding_read_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
      end else begin
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].num_outstanding_xact < max_num_outstanding_xacts_at_hn) begin
          str_idx0_info = $sformatf("Programmed value of max_num_outstanding_xacts_at_hn_status is %0d. But num_outstanding_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_xact of the initiating RN node must be equal to or greater than max_num_outstanding_xacts_at_hn of the target HN", max_num_outstanding_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_0_participating].num_outstanding_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].num_outstanding_xact < max_num_outstanding_xacts_at_hn) begin
          str_idx1_info = $sformatf("Programmed value of max_num_outstanding_xacts_at_hn_status is %0d. But num_outstanding_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_xact of the initiating RN node must be equal to or greater than max_num_outstanding_xacts_at_hn of the target HN", max_num_outstanding_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_1_participating].num_outstanding_xact, initiating_rn_node_idx_1);
          is_supported = 0;
        end
      end
    end
    
    if (!is_supported) begin
      str_is_supported_info = $sformatf("%0s%0s",str_idx0_info, str_idx1_info);
      if (is_rn_idx_0_participating && is_rn_idx_1_participating) begin
        issue_is_supported_failure($sformatf("This sequence cannot be run based on the current system configuration.\n\
                                              %0s\n\
                                              %0s \n\
                                              Modify configurations through \n\
                                              svt_chi_system_configuration::num_rn,\n\
                                              svt_chi_node_configuration::is_active,\n\
                                              svt_chi_system_configuration::participating_rn_nodes[]\n\
                                              ", str_is_supported_info_prefix, str_is_supported_info));
      end
      else begin
        issue_is_supported_failure($sformatf("This sequence cannot be run based on the current node configurations of RN%0d and/or RN%0d.\n\
                                              %0s \n\
                                              Modify configuration through \n\
                                              svt_chi_node_configuration::num_outstanding_xact,\n\
                                              svt_chi_node_configuration::num_outstanding_read_xact,\n\
                                              ",str_is_supported_info, initiating_rn_node_idx_0, initiating_rn_node_idx_1));
      end
    end
    if (!is_target_hn_idx_valid_for_curr_cfg()) begin
      is_supported = 0;
      `svt_xvm_note("is_supported", "not a valid hn_idx based on random_tgt_id_enable for current cfg");
    end
  endfunction : is_supported

  // ----------------------------------------------------------------------------- 
  virtual task body();
    /** Queue of addresses, used by the transactions generated */
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0]                    addr_collection_queue1[$];
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0]                    addr_collection_queue2[$];
    bit                     seq_is_non_secure_access_queue1[$];
    bit                     seq_is_non_secure_access_queue2[$];

    int                                                   array_idx;
    int                                                   num_outstanding_xacts_to_generate;
    bit perform_cache_initialization;
    int unsigned sel_initiating_rn_node_index_0, sel_initiating_rn_node_index_1;
    string str_node_types;

    /** Sub sequences initiated from this sequence */
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq1[int],makeunique_seq2[int];
    /** Sub Read type transaction directed sequences initiated from this sequence */
    svt_chi_rn_read_type_transaction_directed_sequence read_seq1[int],read_seq2[int];
    /** Flag to track whether cache initialization needs to be performed or not*/
    
    `svt_xvm_debug("body", "Entering ...");
    super.body();

    max_num_outstanding_xacts_at_hn_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(), "max_num_outstanding_xacts_at_hn", max_num_outstanding_xacts_at_hn);
    max_num_outstanding_read_xacts_at_hn_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(),"max_num_outstanding_read_xacts_at_hn",max_num_outstanding_read_xacts_at_hn);

    if (select_rn_f_node) begin
      str_node_types = "Iniating nodes are of RN-F type.";
      /** If the initiating_rn_f_node_index_2 is part of active_participating_rn_f_nodes array, and
       *  it is not equal to initiating_rn_f_node_index_0, initiating_rn_f_node_index_1; then we can
       *  perform cache initialization from the RN[cache_line_init_rn_f_node_index].
       */
      if ((is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_f_node_index_2, array_idx)) &&
          (initiating_rn_f_node_index_2 != initiating_rn_f_node_index_0) &&
          (initiating_rn_f_node_index_2 != initiating_rn_f_node_index_1)) begin
        perform_cache_initialization = 1;
        cache_line_init_rn_f_node_index = initiating_rn_f_node_index_2;          
      end else if(is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_f_node_index_2, array_idx)) begin
        perform_cache_initialization = 1;
        cache_line_init_rn_f_node_index = initiating_rn_f_node_index_1;  
      end
      sel_initiating_rn_node_index_0 = initiating_rn_f_node_index_0;
      sel_initiating_rn_node_index_1 = initiating_rn_f_node_index_1;
    end
    else if (select_rn_i_node) begin
      str_node_types = "Iniating nodes are of RN-I type.";
      /** If the initiating_rn_f_node_index_0 is part of active_participating_rn_f_nodes array
       *   then we can perform cache initialization from the RN[cache_line_init_rn_f_node_index].
       */
      if (is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_f_node_index_0, array_idx)) begin
        perform_cache_initialization = 1;
        cache_line_init_rn_f_node_index = initiating_rn_f_node_index_0;          
      end
      sel_initiating_rn_node_index_0 = initiating_rn_i_node_index_0;
      sel_initiating_rn_node_index_1 = initiating_rn_i_node_index_1;
    end
    else if (select_rn_d_node) begin
      str_node_types = "Initiating nodes are of RN-D type.";
      // If the initiating_rn_f_node_index_0 is part of active_participating_rn_f_nodes array
      // then we can perform cache initialization from the RN[cache_line_init_rn_f_node_index].
      if (is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_f_node_index_0, array_idx)) begin
        perform_cache_initialization = 1;
        cache_line_init_rn_f_node_index = initiating_rn_f_node_index_0;          
      end
      sel_initiating_rn_node_index_0 = initiating_rn_d_node_index_0;
      sel_initiating_rn_node_index_1 = initiating_rn_d_node_index_1;
    end

    `svt_xvm_debug("body", $sformatf("%0s perform_cache_initialization = %0b. cache_line_init_rn_f_node_index = %0d. sel_initiating_rn_node_index_0 = %0d. sel_initiating_rn_node_index_1 = %0d.", str_node_types, perform_cache_initialization, cache_line_init_rn_f_node_index, sel_initiating_rn_node_index_0, sel_initiating_rn_node_index_1));

    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :sel_initiating_rn_node_index_0;
    initiating_rn_node_idx_1 = initiating_rn_node_index_1_status ? initiating_rn_node_index_1_from_config_db :sel_initiating_rn_node_index_1;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_f_node_index_0;
    target_hn_node_idx_1 = target_hn_node_index_1_status ? target_hn_node_index_1_from_config_db :target_hn_f_node_index_1;

    `svt_xvm_debug("body", $sformatf("max_num_outstanding_xacts_at_hn is %0d as a result of %0s.", max_num_outstanding_xacts_at_hn, max_num_outstanding_xacts_at_hn_status ? "config DB" : "default"));
    `svt_xvm_debug("body", $sformatf("max_num_outstanding_read_xacts_at_hn is %0d as a result of %0s.", max_num_outstanding_read_xacts_at_hn, max_num_outstanding_read_xacts_at_hn_status ? "config DB" : "default"));
    `svt_xvm_debug("body", $sformatf("initiating_rn_node_idx_0 is %0d as a result of %0s.", initiating_rn_node_idx_0, initiating_rn_node_index_0_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("initiating_rn_node_idx_1 is %0d as a result of %0s.", initiating_rn_node_idx_1, initiating_rn_node_index_1_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("target_hn_node_idx_0 is %0d as a result of %0s.", target_hn_node_idx_0, target_hn_node_index_0_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("target_hn_node_idx_1 is %0d as a result of %0s.", target_hn_node_idx_1, target_hn_node_index_1_status ? "config DB" : "Randomization"));  
    `svt_xvm_debug("body", $sformatf("perform_cache_initialization is %0b, cache_line_init_rn_f_node_index is %0d, initiating_rn_node_idx_0 is %0d, initiating_rn_node_idx_1 is %0d", perform_cache_initialization, cache_line_init_rn_f_node_index, initiating_rn_node_idx_0, initiating_rn_node_idx_1));    

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /**
     * If the cache_line_init_rn_f_node_index is same as any of the RN node indices 
     * which are passed through config i.e initiating_rn_node_idx_0,initiating_rn_node_idx_1, and num of RN-F is greater than 2
     * then re-assign the cache_line_init_rn_f_node_index with RN node index ,which is active,
     * participating and not equal to initiating_rn_node_idx_0, initiating_rn_node_idx_1.
     */
    if(initiating_rn_node_index_0_status||initiating_rn_node_index_1_status)begin  
      if((cache_line_init_rn_f_node_index == initiating_rn_node_idx_0)||(cache_line_init_rn_f_node_index == initiating_rn_node_idx_1))begin  
        int active_participating_q [$];
        `svt_chi_xxm_debug("body",$sformatf("cache_line_init_rn_f_node_index= %0d is same as initiating_rn_node_idx_0=%0d or initiating_rn_node_idx_1=%0d and active_participating_rn_f_nodes.size()= %0d",cache_line_init_rn_f_node_index,initiating_rn_node_idx_0,initiating_rn_node_idx_1,active_participating_rn_f_nodes.size()));
        if(active_participating_rn_f_nodes.size()>2)begin
          active_participating_q = active_participating_rn_f_nodes.find with ((item != initiating_rn_node_idx_0) && (item != initiating_rn_node_idx_1));
          cache_line_init_rn_f_node_index = active_participating_q.pop_back();
          `svt_chi_xxm_debug("body", $sformatf("active_participating_q.size() is %0d and Selected different cache_line_init_rn_f_node_index=%0d", active_participating_q.size(),cache_line_init_rn_f_node_index));
          active_participating_q.delete();
        end else begin
          perform_cache_initialization=1;
          `svt_chi_xxm_debug("body",$sformatf("Selected cache_line_init_rn_f_node_index= %0d is same as initiating_rn_node_index_0_from_config_db=%0d or initiating_rn_node_index_1_from_config_db=%0d and active_participating_rn_f_nodes.size()= %0d.",cache_line_init_rn_f_node_index,initiating_rn_node_index_0_from_config_db,initiating_rn_node_index_1_from_config_db,active_participating_rn_f_nodes.size()));
        end
      end 
    end 

    /**
     * If the cache_line_init_rn_f_node_index is part of active_participating_rn_f_nodes array, then we can
     * perform cache initialization from the RN[cache_line_init_rn_f_node_index].
     */
    if (is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, cache_line_init_rn_f_node_index, array_idx)) begin
      perform_cache_initialization = 1;
    end

    `svt_chi_xxm_debug("body",$sformatf("Selected RN indices are cache_line_init_rn_f_node_index= %0d initiating_rn_node_idx_0=%0d initiating_rn_node_idx_1=%0d and perform_cache_initialization= %0d",cache_line_init_rn_f_node_index,initiating_rn_node_idx_0,initiating_rn_node_idx_1,perform_cache_initialization));

    //If max outstanding count for Read transactions has been programmed, use that to generate the outstanding Reads
    if(max_num_outstanding_read_xacts_at_hn > 0) begin
      num_outstanding_xacts_to_generate = max_num_outstanding_read_xacts_at_hn;
      `svt_xvm_debug("body",$sformatf("max_num_outstanding_read_xacts_at_hn is set to a non-zero value (%0d). Hence, the value programmed in max_num_outstanding_xacts_at_hn will be ignored. The number of outstanding transactions issued by the sequence will be equal to max_num_outstanding_read_xacts_at_hn", max_num_outstanding_read_xacts_at_hn));
    end
    //If not, use the max outstanding transaction count
    else
      num_outstanding_xacts_to_generate = max_num_outstanding_xacts_at_hn;

    for(int i = 0; i < sequence_length; i++) begin
      
      /** Following sequences will be executed based on configuration of RN Nodes */
      if(perform_cache_initialization) begin
        `svt_xvm_debug("body",$sformatf("Starting cache initialization for %0d addresses from p_sequencer.rn_virt_seqr[%0d] to different HN idxs %0d and %0d ",
                                        2*num_outstanding_xacts_to_generate, cache_line_init_rn_f_node_index, target_hn_node_idx_0,target_hn_node_idx_1));
        /** 
         * Write data into Cache of Randomly selected Third Request Node i.e RN-F with 
         * address of randomly selected different HN Nodes
         */
        for(int j=0; j<num_outstanding_xacts_to_generate; j++) begin
          //If cache_line_init_rn_f_node_index is initiating_rn_node_idx_1 or initiating_rn_node_idx_0, it means that there are only 2 RN-Fs in
          //the system. As the following cache init transactions correspond to the coherent transactions that are to be issued from initiating_rn_node_idx_0, the
          //cache init node index should be set to the other RN-F (initiating_rn_node_idx_1)
          if(cache_line_init_rn_f_node_index == initiating_rn_node_idx_1 || cache_line_init_rn_f_node_index == initiating_rn_node_idx_0)
            cache_line_init_rn_f_node_index = initiating_rn_node_idx_1;
          `svt_xvm_do_on_with(makeunique_seq1[j], p_sequencer.rn_virt_seqr[cache_line_init_rn_f_node_index].rn_xact_seqr,
          { 
            sequence_length    == 1;
            hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
            use_seq_is_non_secure_access == 0;
            if(j%2 == 0) {
              seq_hn_node_idx  == target_hn_node_idx_0;
            }
            else {
              seq_hn_node_idx  == target_hn_node_idx_1;
            }
          })
          /** Waiting for above first set of MakeUnique transaction to complete */ 
          `svt_xvm_debug("body", $sformatf("%0s Waiting for first set of MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) to end",`SVT_CHI_PRINT_PREFIX(makeunique_seq1[j].write_tran),j, makeunique_seq1[j].write_tran.hn_node_idx, makeunique_seq1[j].write_tran.tgt_id));
          makeunique_seq1[j].write_tran.wait_end(); 
  
          if (makeunique_seq1[j].output_xacts[0].is_xact_dropped) begin
            `svt_xvm_debug("body", $sformatf("%0s First set of MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) is Droppped. Re-randomizing the transaction.",`SVT_CHI_PRINT_PREFIX(makeunique_seq1[j].write_tran),j, makeunique_seq1[j].write_tran.hn_node_idx, makeunique_seq1[j].write_tran.tgt_id));
            j--;
          end
          else begin
        
            `svt_xvm_debug("body", $sformatf("%0s First set of MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) ended",`SVT_CHI_PRINT_PREFIX(makeunique_seq1[j].write_tran),j, makeunique_seq1[j].write_tran.hn_node_idx, makeunique_seq1[j].write_tran.tgt_id));

            `svt_xvm_verbose("body", $sformatf("MakeUnique transaction [%0d]  is %0s", j,makeunique_seq1[j].write_tran.sprint())); 

          end //end of else condition of cache state check
        end // forloop of 1st set MakeUnique 

        /** Retrieving addresses from output transactions generated by the sequence */
        foreach(makeunique_seq1[index1]) begin
          addr_collection_queue1.push_back(makeunique_seq1[index1].output_xacts[0].addr);
          seq_is_non_secure_access_queue1.push_back(makeunique_seq1[index1].output_xacts[0].is_non_secure_access);
        end
        
          
        /** 
         * Write data into Cache of Randomly selected Third Request Node i.e RN-F with
         * address of randomly selected above different HN Nodes
         */
        for(int k=0; k<num_outstanding_xacts_to_generate; k++) begin
          //If cache_line_init_rn_f_node_index is initiating_rn_node_idx_1 or initiating_rn_node_idx_0, it means that there are only 2 RN-Fs in
          //the system. As the following cache init transactions correspond to the coherent transactions that are to be issued from initiating_rn_node_idx_1, the
          //cache init node index should be set to the other RN-F (initiating_rn_node_idx_0)
          if(cache_line_init_rn_f_node_index == initiating_rn_node_idx_1 || cache_line_init_rn_f_node_index == initiating_rn_node_idx_0)
            cache_line_init_rn_f_node_index = initiating_rn_node_idx_0;
          `svt_xvm_do_on_with(makeunique_seq2[k], p_sequencer.rn_virt_seqr[cache_line_init_rn_f_node_index].rn_xact_seqr,
          {
            sequence_length    == 1;
            hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
            use_seq_is_non_secure_access == 0;           
            if(k%2 == 0) {
              seq_hn_node_idx  == target_hn_node_idx_0;
            }
            else {
              seq_hn_node_idx  == target_hn_node_idx_1;
            }
          })
          `svt_xvm_debug("body", "Waiting for above second set of MakeUnique transaction to end");
          /** Waiting for above second set of MakeUnique transaction to complete */ 
          `svt_xvm_debug("body", $sformatf("%0s Waiting for second set of MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) to end",`SVT_CHI_PRINT_PREFIX(makeunique_seq2[k].write_tran),k, makeunique_seq2[k].write_tran.hn_node_idx, makeunique_seq2[k].write_tran.tgt_id));
          makeunique_seq2[k].write_tran.wait_end(); 

          if (makeunique_seq2[k].output_xacts[0].is_xact_dropped) begin
            `svt_xvm_debug("body", $sformatf("%0s Waiting for Second set of MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) is Dropped. Re-randomizing the transaction. ",`SVT_CHI_PRINT_PREFIX(makeunique_seq2[k].write_tran),k, makeunique_seq2[k].write_tran.hn_node_idx, makeunique_seq2[k].write_tran.tgt_id));
            k--;
          end
          else begin

            `svt_xvm_debug("body", $sformatf("%0s Second set of MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) ended",`SVT_CHI_PRINT_PREFIX(makeunique_seq2[k].write_tran),k, makeunique_seq2[k].write_tran.hn_node_idx, makeunique_seq2[k].write_tran.tgt_id));
          end //end of else condition of cache state check
        end // forloop of 2nd set of MakeUnique 

        /** Retrieving addresses from output transactions generated by the sequence */
        foreach(makeunique_seq2[index2]) begin
          addr_collection_queue2.push_back(makeunique_seq2[index2].output_xacts[0].addr);
          seq_is_non_secure_access_queue2.push_back(makeunique_seq2[index2].output_xacts[0].is_non_secure_access);
        end
        `svt_xvm_debug("body",$sformatf("Ended cache initialization for %0d addresses from p_sequencer.rn_virt_seqr[%0d] to different HN idxs %0d and %0d ",
                                        2*num_outstanding_xacts_to_generate, cache_line_init_rn_f_node_index, target_hn_node_idx_0,target_hn_node_idx_1));
      end // if (perform_cache_initialization)

      `svt_xvm_debug("body",$sformatf("Starting transmission of Read type transactions for %0d addresses from two different p_sequencer.rn_virt_seqr[%0d] and p_sequencer.rn_virt_seqr[%0d] to different HN idxs %0d and %0d with suspend_comp_ack set to 1",
                                      2*num_outstanding_xacts_to_generate, initiating_rn_node_idx_0, initiating_rn_node_idx_1, target_hn_node_idx_0,target_hn_node_idx_1));
      for(int x=0; x<num_outstanding_xacts_to_generate; x++) begin 
        fork
          begin: rn_0_thread
            /** Randomly selected first RN-F fires a read transaction with MAKEUNIQUE 
             *  transaction address of randomly selected first HN Node.
             */
            `svt_xvm_do_on_with(read_seq1[x], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
            {
              sequence_length == 1;
              seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
              seq_txn_id         == (x % num_outstanding_xacts_to_generate);
              if (perform_cache_initialization) {
                hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                min_addr == addr_collection_queue1[x];
                max_addr == addr_collection_queue1[x];
                seq_is_non_secure_access == seq_is_non_secure_access_queue1[x]; 
                use_seq_is_non_secure_access == 1;
                data_in_cache == makeunique_seq1[x].data_in_cache;
                by_pass_read_data_check == 0;
              }
              else {
                hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
                if(x%2 == 0) {
                  seq_hn_node_idx  == target_hn_node_idx_0;
                }
                else {
                  seq_hn_node_idx  == target_hn_node_idx_1;
                }  
                by_pass_read_data_check == 1;
                use_seq_is_non_secure_access == 0;
              }
              if (select_rn_f_node) seq_xact_type != svt_chi_transaction::READNOSNP;
              if (select_rn_i_node || select_rn_d_node) seq_xact_type == svt_chi_transaction::READONCE;
              `ifdef SVT_CHI_ISSUE_B_ENABLE
                if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type != svt_chi_transaction::READNOTSHAREDDIRTY;
                if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A || sys_cfg.readspec_enable == 0) seq_xact_type != svt_chi_transaction::READSPEC;
                if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type != svt_chi_transaction::READONCECLEANINVALID;
                if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type != svt_chi_transaction::READONCEMAKEINVALID;
              `endif
              `ifdef SVT_CHI_ISSUE_E_ENABLE
                if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision <= svt_chi_node_configuration::ISSUE_D) seq_xact_type != svt_chi_transaction::READPREFERUNIQUE;
              `endif

            }
            )
            `svt_xvm_debug("body", $sformatf("%0s Transmitting Read Transaction [%0d] targeted to HN (idx %0d, id %0d) ",`SVT_CHI_PRINT_PREFIX(read_seq1[x].read_tran),x, read_seq1[x].read_tran.hn_node_idx,read_seq1[x].read_tran.tgt_id));
        `svt_xvm_verbose("body", $sformatf("Read Transaction [%0d] is %0s",x,read_seq1[x].read_tran.sprint()));
          end: rn_0_thread
          begin: rn_1_thread
            /** Randomly selected first RN-F fires a read transaction with MAKEUNIQUE 
             *  transaction address of randomly selected second HN Node.
             */
            `svt_xvm_do_on_with(read_seq2[x], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,
            {
              sequence_length == 1;
              seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;    
              `ifdef SVT_CHI_ISSUE_E_ENABLE
               if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision >= svt_chi_node_configuration::ISSUE_E) {
                seq_txn_id         == (x*3);
               }
               else{
                seq_txn_id         == (x % num_outstanding_xacts_to_generate);
               }
              `else
                seq_txn_id         == (x % num_outstanding_xacts_to_generate);
              `endif
              if (perform_cache_initialization) {
                hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                min_addr == addr_collection_queue2[x];
                max_addr == addr_collection_queue2[x];
                seq_is_non_secure_access == seq_is_non_secure_access_queue2[x]; 
                use_seq_is_non_secure_access == 1;
                data_in_cache == makeunique_seq2[x].data_in_cache;
                by_pass_read_data_check == 0;
              }
              else {
                hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
                if(x%2 == 0) {
                    seq_hn_node_idx  == target_hn_node_idx_0;
                  }
                  else {
                    seq_hn_node_idx  == target_hn_node_idx_1;
                  }  
                by_pass_read_data_check == 1;
                use_seq_is_non_secure_access == 0;
              }
              if (select_rn_f_node) {
                seq_xact_type != svt_chi_transaction::READNOSNP;
              }
              if (select_rn_i_node || select_rn_d_node) seq_xact_type == svt_chi_transaction::READONCE;
              `ifdef SVT_CHI_ISSUE_B_ENABLE
                if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type != svt_chi_transaction::READNOTSHAREDDIRTY;
                if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision == svt_chi_node_configuration::ISSUE_A || sys_cfg.readspec_enable == 0) seq_xact_type != svt_chi_transaction::READSPEC;
                if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type != svt_chi_transaction::READONCECLEANINVALID;
                if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type != svt_chi_transaction::READONCEMAKEINVALID;
              `endif
              `ifdef SVT_CHI_ISSUE_E_ENABLE
                if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision <= svt_chi_node_configuration::ISSUE_D) seq_xact_type != svt_chi_transaction::READPREFERUNIQUE;
              `endif
              
            }
            )
            `svt_xvm_debug("body", $sformatf("%0s Transmitting Read Transaction [%0d] targeted to HN (idx %0d, id %0d) ",`SVT_CHI_PRINT_PREFIX(read_seq2[x].read_tran),x, read_seq2[x].read_tran.hn_node_idx,read_seq2[x].read_tran.tgt_id));
           `svt_xvm_verbose("body", $sformatf("Read Transaction [%0d] is %0s",x,read_seq2[x].read_tran.sprint()));
           end: rn_1_thread
        join
      end//outstanding

      /** Event to Resume the Suspended Response of above trasactions */
      fork
        begin
          foreach(read_seq1[index3]) begin
            automatic int _index3 =index3;
              `svt_xvm_debug("body", $sformatf("%0s Read transaction [%0d] targeted to HN (idx %0d, id %0d), suspend_comp_ack %0b: waiting for response from interconnect",`SVT_CHI_PRINT_PREFIX(read_seq1[_index3].read_tran),_index3,read_seq1[_index3].read_tran.hn_node_idx, read_seq1[_index3].read_tran.tgt_id,read_seq1[_index3].read_tran.suspend_comp_ack));
              fork
              begin
                fork
                  begin
                    read_seq1[_index3].read_tran.wait_for_tx_compack_prereqs();
                  end
                  begin
                    wait(read_seq1[_index3].read_tran.req_status == svt_chi_transaction::RETRY);// begin
                  end
                join_any
                disable fork;
              end
              join
              received_read_seq1_responses++;
              `svt_xvm_debug("body", $sformatf("%0s Read transaction [%0d] targeted to HN (idx %0d, id %0d), suspend_comp_ack %0b: received response from interconnect. Total responses received %0d",`SVT_CHI_PRINT_PREFIX(read_seq1[_index3].read_tran),_index3, read_seq1[_index3].read_tran.hn_node_idx, read_seq1[_index3].read_tran.tgt_id,read_seq1[_index3].read_tran.suspend_comp_ack, received_read_seq1_responses));
          end
        end
        begin
          foreach(read_seq2[index4]) begin
            automatic int _index4 =index4;
              `svt_xvm_debug("body", $sformatf("%0s Read transaction [%0d] targeted to HN (idx %0d, id %0d), suspend_comp_ack %0b: waiting for response from interconnect",`SVT_CHI_PRINT_PREFIX(read_seq2[_index4].read_tran),_index4,read_seq2[_index4].read_tran.hn_node_idx, read_seq2[_index4].read_tran.tgt_id,read_seq2[_index4].read_tran.suspend_comp_ack));
              fork
              begin
                fork
                  begin
                    read_seq2[_index4].read_tran.wait_for_tx_compack_prereqs();
                  end
                  begin
                    wait(read_seq2[index4].read_tran.req_status == svt_chi_transaction::RETRY);// begin
                  end
                join_any
                disable fork;
              end
              join
              received_read_seq2_responses++;
              `svt_xvm_debug("body", $sformatf("%0s Read transaction [%0d] targeted to HN (idx %0d, id %0d), suspend_comp_ack %0b: received response from interconnect. Total responses received %0d",`SVT_CHI_PRINT_PREFIX(read_seq2[_index4].read_tran),_index4, read_seq2[_index4].read_tran.hn_node_idx, read_seq2[_index4].read_tran.tgt_id,read_seq2[_index4].read_tran.suspend_comp_ack, received_read_seq2_responses));
          end
        end  
      join_none

      /** Wait until All Comp responses are received at each RN's */
      `svt_xvm_debug("body",$sformatf("Completed initiation of Read type transactions for %0d addresses from two different p_sequencer.rn_virt_seqr[%0d] and p_sequencer.rn_virt_seqr[%0d] to different HN idxs %0d and %0d with suspend_comp_ack set to 1, and waiting to receive responses from interconnect.",2*num_outstanding_xacts_to_generate, initiating_rn_node_idx_0,initiating_rn_node_idx_1,target_hn_node_idx_0,target_hn_node_idx_1));
      fork
        begin
          wait(received_read_seq1_responses == num_outstanding_xacts_to_generate);  
        end
        begin
          wait(received_read_seq2_responses == num_outstanding_xacts_to_generate);  
        end
      join 
      `svt_xvm_debug("body",$sformatf("Received responses from interconnect to Read type transactions for %0d addresses from two different p_sequencer.rn_virt_seqr[%0d] and p_sequencer.rn_virt_seqr[%0d] to different HN idxs %0d and %0d with suspend_comp_ack set to 1",2*num_outstanding_xacts_to_generate, initiating_rn_node_idx_0,initiating_rn_node_idx_1,target_hn_node_idx_0,target_hn_node_idx_1));

      /** Self Check1: To check suspend_comp_ack should not be modified to zero by the VIP
       *  before reseting from test bench
       */
      fork
        begin
          foreach (read_seq1[self_check_idx1]) begin
            if (!read_seq1[self_check_idx1].read_tran.is_terminated()) begin
              if (read_seq1[self_check_idx1].read_tran.suspend_comp_ack == 0) begin
                `svt_xvm_error("body", $sformatf("%0s suspend_comp_ack should be 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(read_seq1[self_check_idx1].read_tran)));
              end
              else begin
              `svt_xvm_debug("body", $sformatf("%0s suspend_comp_ack is 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(read_seq1[self_check_idx1].read_tran)));
              end
            end  
          end //foreach
        end
        begin
          foreach (read_seq2[self_check_idx2]) begin
            if (!read_seq2[self_check_idx2].read_tran.is_terminated()) begin
              if (read_seq2[self_check_idx2].read_tran.suspend_comp_ack == 0) begin
                `svt_xvm_error("body", $sformatf("%0s suspend_comp_ack should be 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(read_seq2[self_check_idx2].read_tran)));
              end
              else begin
              `svt_xvm_debug("body", $sformatf("%0s suspend_comp_ack is 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(read_seq2[self_check_idx2].read_tran)));
              end
            end  
          end //foreach
        end
      join  

      /** Self Check2: To check end_event should not be 1 before resuming the
       * transaction from test bench
       */
      fork
        begin
          foreach(read_seq1[self_check_idx3]) begin
            if (!read_seq1[self_check_idx3].read_tran.is_terminated()) begin
              if (read_seq1[self_check_idx3].read_tran.end_event.is_on() == 1) begin
                `svt_xvm_error("body", $sformatf("Unexpected: %0s Transaction's end_event triggered when suspend_comp_ack is still 1.", `SVT_CHI_PRINT_PREFIX(read_seq1[self_check_idx3].read_tran)));  
              end
              else begin
                `svt_xvm_debug("body", $sformatf("Expected: %0s Transaction's end_event is not triggered when suspend_comp_ack is still 1.", `SVT_CHI_PRINT_PREFIX(read_seq1[self_check_idx3].read_tran)));
              end
            end  
          end //foreach
        end
        begin
          foreach(read_seq2[self_check_idx4]) begin
            if (!read_seq2[self_check_idx4].read_tran.is_terminated()) begin
              if (read_seq2[self_check_idx4].read_tran.end_event.is_on() == 1) begin
                `svt_xvm_error("body", $sformatf("Unexpected: %0s Transaction's end_event triggered when suspend_comp_ack is still 1.", `SVT_CHI_PRINT_PREFIX(read_seq2[self_check_idx4].read_tran)));
              end
              else begin
                `svt_xvm_debug("body", $sformatf("Expected: %0s Transaction's end_event is not triggered when suspend_comp_ack is still 1.", `SVT_CHI_PRINT_PREFIX(read_seq2[self_check_idx4].read_tran)));
              end
            end  
          end //foreach 
        end
      join  
 
      /** Self Check 3: To check that the current_outstanding_*_xact_count in the RNs
       * are as per the transactions inititated by the sequence
       */
      /** Check if the total outstanding xact counter is set correctly in the shared status of the RN agent */
      if(read_seq1[0].shared_status.prot_status.current_outstanding_xact_count != num_outstanding_xacts_to_generate)
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding transactions from the sequence but the outstanding transaction count in the shared status of RN%0d is %0d", num_outstanding_xacts_to_generate, initiating_rn_node_idx_0, read_seq1[0].shared_status.prot_status.current_outstanding_xact_count));
      /** Check if the outstanding Read xact counter is set correctly in the shared status of the RN agent */
      if(read_seq1[0].shared_status.prot_status.current_outstanding_read_xact_count != num_outstanding_xacts_to_generate) begin
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding Read transactions from the sequence but the outstanding Read transaction count in the shared status of RN%0d is %0d", num_outstanding_xacts_to_generate, initiating_rn_node_idx_0, read_seq1[0].shared_status.prot_status.current_outstanding_read_xact_count));
      end
      /** Check if the total outstanding xact counter is set correctly in the shared status of the second RN agent */
      if(read_seq2[0].shared_status.prot_status.current_outstanding_xact_count != num_outstanding_xacts_to_generate)
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding transactions from the sequence but the outstanding transaction count in the shared status of RN%0d is %0d", num_outstanding_xacts_to_generate, initiating_rn_node_idx_1, read_seq2[0].shared_status.prot_status.current_outstanding_xact_count));
      /** Check if the outstanding Read xact counter is set correctly in the shared status of the RN agent */
      if(read_seq2[0].shared_status.prot_status.current_outstanding_read_xact_count != num_outstanding_xacts_to_generate) begin
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding Read transactions from the sequence but the outstanding Read transaction count in the shared status of RN%0d is %0d", num_outstanding_xacts_to_generate, initiating_rn_node_idx_1, read_seq2[0].shared_status.prot_status.current_outstanding_read_xact_count));
      end

      `svt_xvm_debug("body", $sformatf("RN%0d: Number of outstanding transactions : %0d, Number of outstanding read xacts : %0d", initiating_rn_node_idx_0, read_seq1[0].shared_status.prot_status.current_outstanding_xact_count, read_seq1[0].shared_status.prot_status.current_outstanding_read_xact_count));
      `svt_xvm_debug("body", $sformatf("RN%0d: Number of outstanding transactions : %0d, Number of outstanding read xacts : %0d", initiating_rn_node_idx_1, read_seq2[0].shared_status.prot_status.current_outstanding_xact_count, read_seq2[0].shared_status.prot_status.current_outstanding_read_xact_count));

      /** Resuming all CompAck responses of above Read transactions at each RN */
      fork
        begin
          foreach(read_seq1[index5]) begin
            `svt_xvm_debug("body",$sformatf("Received responses for all Read type transactions from interconnect, resuming the transactions by setting svt_chi_rn_transaction::suspend_comp_ack set to 0 %0s",`SVT_CHI_PRINT_PREFIX(read_seq1[index5].read_tran)));
            read_seq1[index5].read_tran.suspend_comp_ack=0;
            `svt_xvm_debug("body", $sformatf("For iteration %0d, received_read_seq1_responses is %0d,suspend_comp_ack is %b and exp_comp_ack is %b After Resume", index5,received_read_seq1_responses,read_seq1[index5].read_tran.suspend_comp_ack,read_seq1[index5].read_tran.exp_comp_ack));
          end
        end
        begin
          foreach(read_seq2[index6]) begin
            `svt_xvm_debug("body",$sformatf("Received responses for all Read type transactions from interconnect, resuming the transactions by setting svt_chi_rn_transaction::suspend_comp_ack set to 0 %0s",`SVT_CHI_PRINT_PREFIX(read_seq2[index6].read_tran)));
            read_seq2[index6].read_tran.suspend_comp_ack=0;
            `svt_xvm_debug("body", $sformatf("For iteration %0d, received_read_seq2_responses is %0d,suspend_comp_ack is %b and exp_comp_ack is %b After Resume", index6,received_read_seq2_responses,read_seq2[index6].read_tran.suspend_comp_ack,read_seq2[index6].read_tran.exp_comp_ack));
          end
        end
      join  

      /** Waiting for above 512 read outstanding transactions to complete */
      `svt_xvm_debug("body",$sformatf("Waiting for completion of 512 outstanding Read type transactions"));
      fork
        begin
          foreach (read_seq1[index7]) begin
            `svt_xvm_debug("body", $sformatf("Waiting for above read_seq1[%0d] transaction %0s to end", index7, `SVT_CHI_PRINT_PREFIX(read_seq1[index7].read_tran)));
            read_seq1[index7].read_tran.wait_end();
          
            /** Self Check4: To check suspend_comp_ack should not be 1 after reseting from test bench
             *  after the transaction completes
             */
            if (!read_seq1[index7].read_tran.is_terminated()) begin
              if (read_seq1[index7].read_tran.suspend_comp_ack == 1) begin
                `svt_xvm_error("body", $sformatf("%0s suspend_comp_ack should be 0 as it should be reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(read_seq1[index7].read_tran)));
              end
              else begin
                `svt_xvm_debug("body", $sformatf("%0s suspend_comp_ack is 0 as it is reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(read_seq1[index7].read_tran)));
              end
            end  
          end // foreach
        end
        begin
          foreach (read_seq2[index8]) begin
            `svt_xvm_debug("body", $sformatf("Waiting for above read_seq2[%0d] transaction %0s to end", index8, `SVT_CHI_PRINT_PREFIX(read_seq2[index8].read_tran)));
            read_seq2[index8].read_tran.wait_end();
            
            /** Self Check4: To check suspend_comp_ack should not be 1 after reseting from test bench
             *  after the transaction completes
             */
            if (!read_seq2[index8].read_tran.is_terminated()) begin
              if (read_seq2[index8].read_tran.suspend_comp_ack == 1) begin
                `svt_xvm_error("body", $sformatf("%0s suspend_comp_ack should be 0 as it should be reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(read_seq2[index8].read_tran)));
              end
              else begin
                `svt_xvm_debug("body", $sformatf("%0s suspend_comp_ack is 0 as it is reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(read_seq2[index8].read_tran)));
              end
            end  
          end //foreach
        end
      join  
      `svt_xvm_debug("body",$sformatf("Received completions for all read type outstanding transactions"));

      /** Targetted HN IDs from both RNs should be different*/
      begin
        int hn_idx_0, hn_idx_1;
        hn_idx_0 = sys_cfg.get_hn_idx(read_seq1[0].output_xacts[0].addr);
        hn_idx_1 = sys_cfg.get_hn_idx(read_seq2[1].output_xacts[0].addr);
        if (hn_idx_0 != hn_idx_1) begin
          // pass
          `svt_xvm_debug("body", $sformatf("Targeted HN Index from both RNs is different as expected.  rn[%0d] to hn_idx[%0d], rn[%0d] to hn_idx[%0d]", initiating_rn_node_idx_0, hn_idx_0, initiating_rn_node_idx_1, hn_idx_1));
        end
        else begin
          // fail
          `svt_xvm_error("body", $sformatf("Targeted HN Index from both RNs is same, which is unexpected.  rn[%0d] %0s transaction to hn_idx[%0d], rn[%0d] %0s transaction to hn_idx[%0d]",initiating_rn_node_idx_0, `SVT_CHI_PRINT_PREFIX( read_seq1[0].output_xacts[0]), hn_idx_0, initiating_rn_node_idx_1, `SVT_CHI_PRINT_PREFIX( read_seq2[0].output_xacts[0]), hn_idx_1));
        end
      end

      /** Reset received_read_seq1_responses to Zero */
      received_read_seq1_responses = 0;

      /** Reset received_read_seq2_responses to Zero */
      received_read_seq2_responses = 0;

      /** Delete the contents of both address collection queues */
      addr_collection_queue1.delete();
      addr_collection_queue2.delete();

    end //sequence_length
    /** 
     * To check the Interconnect HN Node shall responds to 
     * outstanding tranactions to RN.<br>
     * Check done by System monitor(List of checkers)<br>
     *  #- read_data_integrity_check
     *  #- coherent_and_snoop_data_match_check
     *  .  
     */

    `svt_xvm_debug("body", "Exiting...")
  endtask: body

  virtual task post_start();
    super.post_start();
    drop_phase_objection();
  endtask
  
endclass: svt_chi_system_protocol_flow_ctrl_read_outstanding_diff_rn_diff_hn_virtual_sequence

function svt_chi_system_protocol_flow_ctrl_read_outstanding_diff_rn_diff_hn_virtual_sequence::new(string name="svt_chi_system_protocol_flow_ctrl_read_outstanding_diff_rn_diff_hn_virtual_sequence");
  super.new(name);
endfunction


/////////////////////////////
// Write type
/////////////////////////////

/** 
 * @groupname CHI_OUTSTANDING_WR_TYPE 
 * #- This sequence requires at least one HN node to be present in the Interconnect.
 * #- This sequence requires one initiating active and participating RN.
 * #- If another active and participating RN-F exists, perform cache
 *    initialization to a randomly selected HN.
 * #- Initiate maximum number of Write type transactions with 
 *    svt_chi_rn_transaction::suspend_wr_data set  to 1 from initiating RN to randomly 
 *    selected HN in non blocking mode. <br>
 *    - Maximum number of outstanding transactions at the HN is as per either #max_num_outstanding_write_xacts_at_hn or
 *      #max_num_outstanding_xacts_at_hn, which can be controlled through config DB.   
 *    - This ensures that the maximum outstanding transaction limit is reached at the HN. 
 *    - Also, the RN will not transmit NonCopyBackWrData corresponding to these transactions
 *      until svt_chi_rn_transaction::suspend_wr_data is set to 0 from the seqeunce.
 *    .
 * #- The addresses of these write transactions are such that:
 *    - Same as initialized cache line addresses if cache initialization is performed
 *    - Otherwise, random addresses targeting the same HN
 *    .
 * #- Once the RN receives the responses for all the outstanding transactions from
 *    HN, svt_chi_rn_transaction::suspend_wr_data is set to 0 for all the outstanding
 *    transactions. <br>
 *    This ensures that the NonCopyBackWrData for these transactions can be resumed 
 *    from RN.
 * #- Check that the HN responds properly for all outstanding write type transactions
 *    and these are completed successfully.
 * .
 */ 

class svt_chi_system_protocol_flow_ctrl_write_outstanding_same_rn_same_hn_virtual_sequence extends svt_chi_system_base_virtual_sequence;
  
  //-----------------------------------------------------------------------------  
  // Member attributes
  //-----------------------------------------------------------------------------  

  /** To display contents of Active Participating RN's node info. */
  string str_rn_node;

  /** To display contents of Active Participating RN-F's node info. */
  string str_rn_f_node;

  /** UVM/OVM Object Utility macro */
  `svt_xvm_object_utils(svt_chi_system_protocol_flow_ctrl_write_outstanding_same_rn_same_hn_virtual_sequence)
  
  //-----------------------------------------------------------------------------  
  // Methods
  //-----------------------------------------------------------------------------
  /** Constructor */
  extern function new(string name="svt_chi_system_protocol_flow_ctrl_write_outstanding_same_rn_same_hn_virtual_sequence");

  //-----------------------------------------------------------------------------
  /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting any type of Request Nodes = 1
   *  #- Minimum required number of HN Nodes = 1   
   *  .
   */
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    
    /** local variables */
    int num_supporting_request_nodes;
    int num_hn_f_nodes;   
    int array_idx;
    bit is_rn_idx_0_participating;
    string str_is_supported_info_prefix = "";
    string str_is_supported_info = "";
    string str_idx0_info = "";
    /** Supporting any type of Request Nodes required */
    int required_num_supporting_request_nodes = 1;
    int required_num_hn_nodes = 1;
    
    `svt_xvm_debug("is_supported",$sformatf("Entering ..."));

    /** By default is_supported is 0 */
    is_supported = 0;

    /** Check for minimum required HN nodes */
    num_hn_f_nodes = hn_f_nodes.size();
    
    /** Check requirment of number of HN nodes needed */
    if (num_hn_f_nodes < required_num_hn_nodes) begin
      issue_is_supported_failure($sformatf("This sequence requires minimum %0d HN-F nodes to be present in the system. Number of HN-F nodes are %0d. Program number of HN nodes using svt_chi_system_configuration::num_hn. Program the HN interface type using svt_chi_system_configuration::chi_addr_cfg.hn_interface_type[].", required_num_hn_nodes, num_hn_f_nodes));
      return 0;      
    end
    
    /** Check for minimum required RN nodes.
     *  Also check whether the selected RN nodes are part of participating arrays or not.
     */    
    num_supporting_request_nodes = active_participating_rn_nodes.size();

    /** Check the requirements of RN nodes */
    if (num_supporting_request_nodes) begin
      /** Display the contents of Active Participating RN Nodes */
      foreach (active_participating_rn_nodes[j]) begin
        str_rn_node = {str_rn_node, $sformatf(" %0d", active_participating_rn_nodes[j])};
      end 
      `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_nodes are %0s", str_rn_node));
    end

    str_is_supported_info_prefix = $sformatf("Number of Supporting RN Node(s)  - Minimum Required : %0d Current : %0d", required_num_supporting_request_nodes, num_supporting_request_nodes);
    
    if ((initiating_rn_node_index_0_status==0)&&(valid_initiating_rn_node_index_0==0)) begin
        str_idx0_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN's that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F or RN_I)";
    end
    else begin
      is_rn_idx_0_participating = is_value_found_in_int_assoc_array(active_participating_rn_nodes, initiating_rn_node_idx_0, array_idx);
      if (!is_rn_idx_0_participating) begin
        str_idx0_info = $sformatf("initiating_rn_node_idx_0 %0d is not valid for this sequence. The RN corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuration::participating_rn_nodes[])", initiating_rn_node_idx_0, initiating_rn_node_idx_0);
      end
    end

    if (is_rn_idx_0_participating) begin
      is_supported = 1;
      if(max_num_outstanding_write_xacts_at_hn > 0) begin
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].num_outstanding_write_xact < max_num_outstanding_write_xacts_at_hn) begin
          str_idx0_info = $sformatf("Programmed value of max_num_outstanding_write_xacts_at_hn_status is %0d. But num_outstanding_write_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_write_xact of the initiating RN node must be equal to or greater than max_num_outstanding_write_xacts_at_hn_status of the target HN", max_num_outstanding_write_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_0_participating].num_outstanding_write_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
      end else begin
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].num_outstanding_xact < max_num_outstanding_xacts_at_hn) begin
          str_idx0_info = $sformatf("Programmed value of max_num_outstanding_xacts_at_hn_status is %0d. But num_outstanding_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_xact of the initiating RN node must be equal to or greater than max_num_outstanding_xacts_at_hn of the target HN", max_num_outstanding_xacts_at_hn, sys_cfg.rn_cfg[initiating_rn_node_idx_0].num_outstanding_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
      end
    end
    
    if (!is_supported) begin
      str_is_supported_info = $sformatf("%0s",str_idx0_info);
      if (is_rn_idx_0_participating) begin
        issue_is_supported_failure($sformatf("This sequence cannot be run based on the current system configuration.\n\
                                              %0s\n\
                                              %0s \n\
                                              Modify configurations through \n\
                                              svt_chi_system_configuration::num_rn,\n\
                                              svt_chi_node_configuration::is_active,\n\
                                              svt_chi_system_configuration::participating_rn_nodes[]\n\
                                              ", str_is_supported_info_prefix, str_is_supported_info));
      end
      else begin
        issue_is_supported_failure($sformatf("This sequence cannot be run based on the current node configurations of RN%0d\n\
                                              %0s \n\
                                              Modify configuration through \n\
                                              svt_chi_node_configuration::num_outstanding_xact,\n\
                                              svt_chi_node_configuration::num_outstanding_write_xact,\n\
                                              ",str_is_supported_info, initiating_rn_node_idx_0));
      end
    end      
    `svt_xvm_debug("is_supported",$sformatf("Exiting ..."));
    if (!is_target_hn_idx_valid_for_curr_cfg()) begin
      is_supported = 0;
      `svt_xvm_note("is_supported", "not a valid hn_idx based on random_tgt_id_enable for current cfg");
    end
  endfunction : is_supported

  virtual task pre_start();
    `svt_xvm_debug("pre_start",$sformatf("Entering ..."));
    super.pre_start();
    raise_phase_objection();
  endtask // pre_start

  virtual task body();
    /** Queue of addresses, used by the transactions generated */
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0] addr_q[$];
    bit seq_is_non_secure_access_q[$];
    /** Flag to track whether cache initialization needs to be performed or not*/
    bit                                perform_cache_initialization;
    int                                array_idx;
    int                                num_outstanding_xacts_to_generate;
    /** Metric variables */
    int received_responses = 0;
    
    /** Sub Write type transaction directed sequences initiated from this sequence */
    svt_chi_rn_write_type_transaction_directed_sequence write_seq[int];
    /** Sub Read type transaction cache initialization directed sequences initiated from this sequence */
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq[int];

    `svt_xvm_debug("body", "Entering ...")
    super.body();

    max_num_outstanding_xacts_at_hn_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(), "max_num_outstanding_xacts_at_hn", max_num_outstanding_xacts_at_hn);
    max_num_outstanding_write_xacts_at_hn_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(), "max_num_outstanding_write_xacts_at_hn", max_num_outstanding_write_xacts_at_hn);

    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :initiating_rn_node_idx_0;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_node_index_0;

    `svt_xvm_debug("body", $sformatf("max_num_outstanding_xacts_at_hn is %0d as a result of %0s.", max_num_outstanding_xacts_at_hn, max_num_outstanding_xacts_at_hn_status ? "config DB" : "default"));
    `svt_xvm_debug("body", $sformatf("max_num_outstanding_write_xacts_at_hn is %0d as a result of %0s.", max_num_outstanding_write_xacts_at_hn, max_num_outstanding_write_xacts_at_hn_status ? "config DB" : "default"));
    `svt_xvm_debug("body", $sformatf("initiating_rn_node_idx_0 is %0d as a result of %0s.", initiating_rn_node_idx_0, initiating_rn_node_index_0_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("target_hn_node_idx_0 is %0d as a result of %0s.", target_hn_node_idx_0, target_hn_node_index_0_status ? "config DB" : "Randomization"));

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /**
     * If the cache_line_init_rn_f_node_index is same as the RN node index 
     * which are passed through config i.e initiating_rn_node_idx_0,
     * then re-assign the cache_line_init_rn_f_node_index with RN node index ,which is active,
     * participating and not equal to initiating_rn_node_idx_0.
     */
    if(initiating_rn_node_index_0_status)begin  
      if((cache_line_init_rn_f_node_index == initiating_rn_node_idx_0))begin  
        int active_participating_q [$];
        `svt_chi_xxm_debug("body",$sformatf("cache_line_init_rn_f_node_index= %0d is same as initiating_rn_node_idx_0=%0d and active_participating_rn_f_nodes.size()= %0d",cache_line_init_rn_f_node_index,initiating_rn_node_idx_0,active_participating_rn_f_nodes.size()));
        if(active_participating_rn_f_nodes.size()>1)begin
          active_participating_q = active_participating_rn_f_nodes.find with (item != initiating_rn_node_idx_0);
          cache_line_init_rn_f_node_index = active_participating_q.pop_back();
          `svt_chi_xxm_debug("body", $sformatf("active_participating_q.size() is %0d and Selected different cache_line_init_rn_f_node_index=%0d", active_participating_q.size(),cache_line_init_rn_f_node_index));
          active_participating_q.delete();
        end else begin
          perform_cache_initialization=0;
          `svt_chi_xxm_debug("body",$sformatf("BYPASSING Cache Initialization as selected cache_line_init_rn_f_node_index= %0d is same as initiating_rn_node_index_0_from_config_db=%0d and active_participating_rn_f_nodes.size()= %0d",cache_line_init_rn_f_node_index,initiating_rn_node_index_0_from_config_db,active_participating_rn_f_nodes.size()));
        end
      end  
    end 

    // If the cache_line_init_rn_f_node_index is part of active_participating_rn_f_nodes array, and
    // it is not equal to initiating_rn_node_idx_0; then we can
    // perform cache initialization from the RN[cache_line_init_rn_f_node_index].
    if ((is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, cache_line_init_rn_f_node_index, array_idx)) &&
        (cache_line_init_rn_f_node_index != initiating_rn_node_idx_0)) begin
      perform_cache_initialization = 1;
    end
    
    `svt_xvm_debug("body", $sformatf("perform_cache_initialization is %0b, cache_line_init_rn_f_node_index is %0d, initiating_rn_node_idx_0 is %0d", perform_cache_initialization, cache_line_init_rn_f_node_index, initiating_rn_node_idx_0));    

    //If max outstanding count for Write transactions has been programmed, use that to generate the outstanding Writes
    if(max_num_outstanding_write_xacts_at_hn > 0) begin
      num_outstanding_xacts_to_generate = max_num_outstanding_write_xacts_at_hn;
      `svt_xvm_debug("body",$sformatf("max_num_outstanding_write_xacts_at_hn is set to a non-zero value (%0d). Hence, the value programmed in max_num_outstanding_xacts_at_hn will be ignored. The number of outstanding transactions issued by the sequence will be equal to max_num_outstanding_write_xacts_at_hn", max_num_outstanding_write_xacts_at_hn));
    end
    //If not, use the max outstanding transaction count
    else
      num_outstanding_xacts_to_generate = max_num_outstanding_xacts_at_hn;

    for(int k = 0; k < sequence_length; k++) begin
      
      `svt_xvm_debug("body", $sformatf("cache_line_init_rn_f_node_index is %0d,initiating_rn_node_idx_0 is %0d" ,cache_line_init_rn_f_node_index, initiating_rn_node_idx_0));

      if(perform_cache_initialization) begin
        
        `svt_xvm_debug("body",$sformatf("Starting cache initialization for %0d addresses from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d",num_outstanding_xacts_to_generate, cache_line_init_rn_f_node_index, target_hn_node_idx_0));
      
        for(int i = 0; i < num_outstanding_xacts_to_generate; i++) begin     
          /** Write data into Cache of Randomly selected first RN-F with address of randomly selected HN Node */
          `svt_xvm_do_on_with(makeunique_seq[i],p_sequencer.rn_virt_seqr[cache_line_init_rn_f_node_index].rn_xact_seqr,
          {
            sequence_length   == 1;
            set_unique_addr_value    == 1;
            hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
            seq_hn_node_idx   == target_hn_node_idx_0;
            use_seq_is_non_secure_access == 0;
          })
          
          `svt_xvm_debug("body", $sformatf("%0s Waiting for MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) to end",`SVT_CHI_PRINT_PREFIX(makeunique_seq[i].write_tran),i, makeunique_seq[i].write_tran.hn_node_idx, makeunique_seq[i].write_tran.tgt_id));
          makeunique_seq[i].write_tran.wait_end();
          `svt_xvm_debug("body", $sformatf("%0s MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) ended",`SVT_CHI_PRINT_PREFIX(makeunique_seq[i].write_tran),i, makeunique_seq[i].write_tran.hn_node_idx, makeunique_seq[i].write_tran.tgt_id));
          /** Queue for collecting the address of makeunique transactions */
          addr_q.push_back(makeunique_seq[i].output_xacts[0].addr);
          seq_is_non_secure_access_q.push_back(makeunique_seq[i].output_xacts[0].is_non_secure_access);
          `svt_xvm_verbose("body", $sformatf("MakeUnique transaction [%0d] is %0s", i,makeunique_seq[i].write_tran.sprint()));
        end
        
      end// if (perform_cache_initialization)

      `svt_xvm_debug("body",$sformatf("Starting transmission of Write type transactions for %0d addresses from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d with suspend_wr_data set to 1",
                                      num_outstanding_xacts_to_generate, initiating_rn_node_idx_0, target_hn_node_idx_0));
      
      for(int i = 0; i < num_outstanding_xacts_to_generate; i++) begin 
        `svt_xvm_debug("body", $sformatf("initiating_rn_node_idx_0 is %0d",initiating_rn_node_idx_0));
        /** 
          * Do WRITE transactions from same RN to the MAKEUNIQUE 
          * transaction addresses of same HN-F node in case of 
          * initialization or select the randomly selected HN-F 
          * if initialization is not necessary.  
          */ 
        `svt_xvm_do_on_with(write_seq[i],p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
          {
           `ifdef SVT_CHI_ISSUE_B_ENABLE
            if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A || sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0) {
              seq_xact_type inside {svt_chi_transaction::WRITENOSNPFULL, svt_chi_transaction::WRITENOSNPPTL,svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL};
            }
            else{
              seq_xact_type inside {svt_chi_transaction::WRITENOSNPFULL, svt_chi_transaction::WRITENOSNPPTL,svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL, svt_chi_transaction::WRITEUNIQUEFULLSTASH, svt_chi_transaction::WRITEUNIQUEPTLSTASH};
            }
           `else
              seq_xact_type inside {svt_chi_transaction::WRITENOSNPFULL, svt_chi_transaction::WRITENOSNPPTL,svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL};
           `endif
           sequence_length    == 1;
           `ifdef SVT_CHI_ISSUE_E_ENABLE
            if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision >= svt_chi_node_configuration::ISSUE_E) {
             seq_txn_id         == (i*3);
            }
            else{
             seq_txn_id         == (i % num_outstanding_xacts_to_generate);
            }
           `else
             seq_txn_id         == (i % num_outstanding_xacts_to_generate);
           `endif
           seq_order_type     == svt_chi_transaction::NO_ORDERING_REQUIRED;
           if(perform_cache_initialization) {
             hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
             min_addr         == addr_q[i];
             max_addr         == addr_q[i];
             seq_is_non_secure_access == seq_is_non_secure_access_q[i]; 
             use_seq_is_non_secure_access == 1;
           }
           else {
             hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
             seq_hn_node_idx    == target_hn_node_idx_0;
             use_seq_is_non_secure_access == 0;
           }
          })
           
          `svt_xvm_debug("body", $sformatf("%0s Transmitting Write Transaction [%0d] targeted to HN (idx %0d, id %0d) ",`SVT_CHI_PRINT_PREFIX(write_seq[i].write_tran),i, write_seq[i].write_tran.hn_node_idx, write_seq[i].write_tran.tgt_id));
          `svt_xvm_verbose("body", $sformatf("Write Transaction [%0d] is %0s", i,write_seq[i].write_tran.sprint()));
          
      end

      /** Waiting for the DBIDResp/CompDBDIResp responses from HN for write trasactions */
      foreach(write_seq[wr]) begin
        fork
          automatic int _wr = wr;
          begin
            `svt_xvm_debug("body", $sformatf("%0s Write transaction [%0d] targeted to HN (idx %0d, id %0d), suspend_wr_data %0b: waiting for response from interconnect",`SVT_CHI_PRINT_PREFIX(write_seq[_wr].write_tran),_wr, write_seq[_wr].write_tran.hn_node_idx, write_seq[_wr].write_tran.tgt_id,write_seq[_wr].write_tran.suspend_wr_data));
            fork
            begin
              fork
                begin
                  write_seq[_wr].write_tran.wait_for_tx_data_prereqs();
                end
                begin
                  wait(write_seq[_wr].write_tran.req_status == svt_chi_transaction::RETRY);// begin
                end
              join_any
              disable fork;
            end
            join
            received_responses++;
            `svt_xvm_debug("body", $sformatf("%0s Write transaction [%0d] targeted to HN (idx %0d, id %0d), suspend_wr_data %0b: received response from interconnect. Total responses received %0d",`SVT_CHI_PRINT_PREFIX(write_seq[_wr].write_tran),_wr, write_seq[_wr].write_tran.hn_node_idx, write_seq[_wr].write_tran.tgt_id,write_seq[_wr].write_tran.suspend_wr_data,received_responses));
          end
        join_none
      end

      /** Wait until All DBIDResp/CompDBDIResp responses are received for write transaction */ 
      `svt_xvm_debug("body",$sformatf("Completed initiation of Write type transactions for %0d addresses from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d with suspend_wr_data set to 1, and waiting to receive responses from interconnect.",
                                num_outstanding_xacts_to_generate, initiating_rn_node_idx_0,target_hn_node_idx_0));
      wait(received_responses == num_outstanding_xacts_to_generate);
      outstanding_xact_count_reached = 1;
      `svt_xvm_debug("body",$sformatf("Received responses from interconnect to Write type transactions for %0d addresses from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d with suspend_wr_data set to 1.",
                                num_outstanding_xacts_to_generate, initiating_rn_node_idx_0,target_hn_node_idx_0));
     
      /** Self Check1: To check suspend_wr_data should not be modified to zero by the VIP
       * before reseting from test bench
       */
      foreach (write_seq[self_check_idx1]) begin
        if (!write_seq[self_check_idx1].write_tran.is_terminated()) begin
          if (write_seq[self_check_idx1].write_tran.suspend_wr_data == 0) begin
            `svt_xvm_error("body", $sformatf("%0s suspend_wr_data should be 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(write_seq[self_check_idx1].write_tran)));
          end
          else begin
            `svt_xvm_debug("body", $sformatf("%0s suspend_wr_data is 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(write_seq[self_check_idx1].write_tran)));
          end
        end
      end

      /** Self Check2: To check transaction is not ended by the VIP before resuming the 
       *  suspend_wr_data to zero from the test bench
       */
      foreach(write_seq[self_check_idx2]) begin
        if (!write_seq[self_check_idx2].write_tran.is_terminated()) begin
          if (write_seq[self_check_idx2].write_tran.end_event.is_on() == 1) begin
            `svt_xvm_error("body", $sformatf("Unexpected: %0s Transaction's end_event triggered when suspend_wr_data is still 1.", `SVT_CHI_PRINT_PREFIX(write_seq[self_check_idx2].write_tran)));
          end
          else begin
            `svt_xvm_debug("body", $sformatf("Expected: %0s Transaction's end_event is not triggered when suspend_wr_data is still 1.", `SVT_CHI_PRINT_PREFIX(write_seq[self_check_idx2].write_tran)));
          end
        end
      end
 
      /** Self Check 3: To check that the current_outstanding_*_xact_count in the RNs
       * are as per the transactions inititated by the sequence
       */
      /** Check if the total outstanding xact counter is set correctly in the shared status of the RN agent */
      if(write_seq[0].shared_status.prot_status.current_outstanding_xact_count != num_outstanding_xacts_to_generate)
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding transactions from the sequence but the outstanding transaction count in the shared status of RN%0d is %0d", num_outstanding_xacts_to_generate, initiating_rn_node_idx_0, write_seq[0].shared_status.prot_status.current_outstanding_xact_count));
      /** Check if the outstanding Write xact counter is set correctly in the shared status of the RN agent */
      if(write_seq[0].shared_status.prot_status.current_outstanding_write_xact_count != num_outstanding_xacts_to_generate) begin
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding Write transactions from the sequence but the outstanding Write transaction count in the shared status of RN%0d is %0d", num_outstanding_xacts_to_generate, initiating_rn_node_idx_0, write_seq[0].shared_status.prot_status.current_outstanding_write_xact_count));
      end

      `svt_xvm_debug("body", $sformatf("RN%0d: Number of outstanding transactions : %0d, Number of outstanding write xacts : %0d", initiating_rn_node_idx_0, write_seq[0].shared_status.prot_status.current_outstanding_xact_count, write_seq[0].shared_status.prot_status.current_outstanding_write_xact_count));

      if(use_seq_flag_to_resume_response_for_outstanding_xact) begin
        `svt_xvm_debug("body",$sformatf("Waiting for resume_response_for_outstanding_xact to be set to 1"));
        wait(resume_response_for_outstanding_xact == 1);
        `svt_xvm_debug("body",$sformatf("resume_response_for_outstanding_xact is set to 1"));
      end

      /** Resuming all NonCopyBackWrData for above write transactions */
      `svt_xvm_debug("body",$sformatf("Resuming the write transactions by setting svt_chi_rn_transaction::suspend_wr_data set to 0"))
      foreach(write_seq[index4]) begin
        write_seq[index4].write_tran.suspend_wr_data = 0;
        `svt_xvm_debug("body", $sformatf("After Resume received_responses is %0d for iteration %0d and suspend_wr_data is %0b",received_responses, index4, write_seq[index4].write_tran.suspend_wr_data));
      end
     
      /** Waiting for Write transactions to complete*/
      `svt_xvm_debug("body",$sformatf("Waiting for completion of all the outstanding write type transactions"));
      foreach(write_seq[self_check_idx3]) begin
        `svt_xvm_debug("body", $sformatf("Waiting for above write_seq[%0d] transaction %0s to end", self_check_idx3, `SVT_CHI_PRINT_PREFIX(write_seq[self_check_idx3].write_tran)));
        write_seq[self_check_idx3].write_tran.wait_end();

        /** Self Check4: To check suspend_wr_data should not be asserted after the transaction
         *  completes as it is reseted from test bench
         */
        if (!write_seq[self_check_idx3].write_tran.is_terminated()) begin
          if (write_seq[self_check_idx3].write_tran.suspend_wr_data == 1) begin
            `svt_xvm_error("body", $sformatf("%0s suspend_wr_data should be 0 as it has been reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(write_seq[self_check_idx3].write_tran)));
          end
          else begin
            `svt_xvm_debug("body", $sformatf("%0s suspend_wr_data is 0 as it is reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(write_seq[self_check_idx3].write_tran)));
          end
        end
      end
      `svt_xvm_debug("body",$sformatf("Received completions for all write type outstanding transactions"));

      /** Targetted HN ID from the RN should be same throughout*/
      foreach(write_seq[wr]) begin
        int hn_idx_0;
        hn_idx_0 = sys_cfg.get_hn_idx(write_seq[wr].output_xacts[0].addr);
        if (hn_idx_0 == target_hn_node_idx_0) begin
          `svt_xvm_debug("body", $sformatf("Targeted HN Index from the RN is same as expected.  rn[%0d] to hn_idx[%0d] and it matches target_hn_node_idx_0 %0d", initiating_rn_node_idx_0, hn_idx_0,target_hn_node_idx_0));
        end
        else begin
          `svt_xvm_error("body", $sformatf("Targeted HN Index from the RN is different, which is unexpected.  rn[%0d] %0s transaction to hn_idx[%0d] and it doesn't match target_hn_node_idx_0 %0d", 
                                           initiating_rn_node_idx_0, `SVT_CHI_PRINT_PREFIX( write_seq[wr].output_xacts[0]), hn_idx_0,target_hn_node_idx_0));
        end
      end
            
      /** Reset received_responses to Zero */
      received_responses = 0;

      /** Delete the contents of address collection queue */
      addr_q.delete();

    end//sequence_length
    
  `svt_xvm_debug("body", "Exiting...")
  endtask: body

  virtual task post_body();
    drop_phase_objection();
  endtask

endclass: svt_chi_system_protocol_flow_ctrl_write_outstanding_same_rn_same_hn_virtual_sequence

function svt_chi_system_protocol_flow_ctrl_write_outstanding_same_rn_same_hn_virtual_sequence::new(string name="svt_chi_system_protocol_flow_ctrl_write_outstanding_same_rn_same_hn_virtual_sequence");
  super.new(name);
endfunction


/** 
 * @groupname CHI_OUTSTANDING_WR_TYPE  
 * #- This sequence requires at least one HN node to be present in the Interconnect.
 * #- This sequence requires two initiating active and participating RN.
 * #- If another active and participating RN-F exists, perform cache
 *    initialization to a randomly selected HN.
 * #- Initiate 128 Write type transactions with 
 *    svt_chi_rn_transaction::suspend_wr_data set to 1 from each of the two initiating RNs to the randomly 
 *    selected HN in non blocking mode. <br>
 *    - Maximum number of outstanding transactions at the HN is as per either #max_num_outstanding_write_xacts_at_hn or
 *      #max_num_outstanding_xacts_at_hn, which can be controlled through config DB.   
 *    - This ensures that the maximum outstanding transaction limit is reached at the HN.
 *    - Also, both the RNs will not transmit NonCopyBackWrData corresponding to these transactions
 *      until svt_chi_rn_transaction::suspend_wr_data is set to 0 from the seqeunce.
 *    .
 * #- The addresses of these write transactions are such that:
 *    - Same as initialized cache line addresses if cache initialization is performed
 *    - Otherwise, random addresses targeting the same HN
 *    .
 * #- Once the RNs receive the responses for all the outstanding transactions from
 *    HN, svt_chi_rn_transaction::suspend_wr_data is set to 0 for all the outstanding
 *    transactions. <br>
 *    This ensures that the NonCopyBackWrData for these transactions can be resumed 
 *    from both the RNs.
 * #- Check that the HN responds properly for all outstanding write type transactions
 *    and these are completed successfully.
 * .
 */

class svt_chi_system_protocol_flow_ctrl_write_outstanding_diff_rn_same_hn_virtual_sequence extends svt_chi_system_base_virtual_sequence;
  
  //-----------------------------------------------------------------------------  
  // Member attributes
  //-----------------------------------------------------------------------------  

  /** To display contents of Active Participating RN's node info. */
  string str_rn_node;

  /** To display contents of Active Participating RN-F's node info. */
  string str_rn_f_node;

  /** UVM/OVM Object Utility macro */
  `svt_xvm_object_utils(svt_chi_system_protocol_flow_ctrl_write_outstanding_diff_rn_same_hn_virtual_sequence)
  
  //-----------------------------------------------------------------------------  
  // Methods
  //-----------------------------------------------------------------------------
  /** Constructor */
  extern function new(string name="svt_chi_system_protocol_flow_ctrl_write_outstanding_diff_rn_same_hn_virtual_sequence");
  
  //-----------------------------------------------------------------------------
  /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting any type of Request Nodes = 2
   *  #- Minimum required number of HN Nodes = 1   
   *  .
   */
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    
    /** local variables */
    int num_supporting_request_nodes;
    int num_hn_f_nodes;   
    int array_idx;
    bit is_rn_idx_0_participating, is_rn_idx_1_participating;
    string str_is_supported_info_prefix = "";
    string str_is_supported_info = "";
    string str_idx0_info = "";
    string str_idx1_info = "";    
    /** Supporting any type of Request Nodes required */
    int required_num_supporting_request_nodes = 2;
    int required_num_hn_nodes = 1;
    
    `svt_xvm_debug("is_supported",$sformatf("Entering ..."));

    /** By default is_supported is 0 */
    is_supported = 0;

    /** Check for minimum required HN nodes */
    num_hn_f_nodes = hn_f_nodes.size();
    
    /** Check requirment of number of HN nodes needed */
    if (num_hn_f_nodes < required_num_hn_nodes) begin
      issue_is_supported_failure($sformatf("This sequence requires minimum %0d HN-F nodes to be present in the system. Number of HN-F nodes are %0d. Program number of HN nodes using svt_chi_system_configuration::num_hn. Program the HN interface type using svt_chi_system_configuration::chi_addr_cfg.hn_interface_type[].", required_num_hn_nodes, num_hn_f_nodes));
      return 0;      
    end
    
    /** Check for minimum required RN nodes.
     *  Also check whether the selected RN nodes are part of participating arrays or not.
     */    
    num_supporting_request_nodes = active_participating_rn_nodes.size();

    /** Check the requirements of RN nodes */
    if (num_supporting_request_nodes) begin
      /** Display the contents of Active Participating RN Nodes */
      foreach (active_participating_rn_nodes[j]) begin
        str_rn_node = {str_rn_node, $sformatf(" %0d", active_participating_rn_nodes[j])};
      end 
      `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_nodes are %0s", str_rn_node));
    end

    str_is_supported_info_prefix = $sformatf("Number of Supporting RN Node(s)  - Minimum Required : %0d Current : %0d", required_num_supporting_request_nodes, num_supporting_request_nodes);
    
    if ((initiating_rn_node_index_0_status==0)&&(valid_initiating_rn_node_index_0==0)) begin
        str_idx0_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN's that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F or RN_I)";
    end
    else begin
      is_rn_idx_0_participating = is_value_found_in_int_assoc_array(active_participating_rn_nodes, initiating_rn_node_idx_0, array_idx);
      if (!is_rn_idx_0_participating) begin
        str_idx0_info = $sformatf("initiating_rn_node_idx_0 %0d is not valid for this sequence. The RN corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuration::participating_rn_nodes[])", initiating_rn_node_idx_0, initiating_rn_node_idx_0);
      end
    end
    if ((initiating_rn_node_index_1_status==0)&&(valid_initiating_rn_node_index_1==0)) begin
        str_idx1_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN's that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F or RN_I)";
    end
    else begin
      is_rn_idx_1_participating = is_value_found_in_int_assoc_array(active_participating_rn_nodes, initiating_rn_node_idx_1, array_idx);
      if (!is_rn_idx_1_participating) begin
        str_idx1_info = $sformatf("initiating_rn_node_idx_1 %0d is not valid for this sequence. The RN corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuration::participating_rn_nodes[])", initiating_rn_node_idx_1, initiating_rn_node_idx_1);
      end
    end

    if (is_rn_idx_0_participating && is_rn_idx_1_participating) begin
      is_supported = 1;
      if(max_num_outstanding_write_xacts_at_hn > 0) begin
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].num_outstanding_write_xact < (max_num_outstanding_write_xacts_at_hn/2)) begin
          str_idx0_info = $sformatf("Programmed value of max_num_outstanding_write_xacts_at_hn_status is %0d. But num_outstanding_write_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_write_xact of the initiating RN node must be equal to or greater than half of max_num_outstanding_write_xacts_at_hn_status of the target HN", max_num_outstanding_write_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_0_participating].num_outstanding_write_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].num_outstanding_write_xact < (max_num_outstanding_write_xacts_at_hn/2)) begin
          str_idx1_info = $sformatf("Programmed value of max_num_outstanding_write_xacts_at_hn_status is %0d. But num_outstanding_write_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_write_xact of the initiating RN node must be equal to or greater than half of max_num_outstanding_write_xacts_at_hn_status of the target HN", max_num_outstanding_write_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_1_participating].num_outstanding_write_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
      end else begin
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].num_outstanding_xact < (max_num_outstanding_xacts_at_hn/2)) begin
          str_idx0_info = $sformatf("Programmed value of max_num_outstanding_xacts_at_hn_status is %0d. But num_outstanding_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_xact of the initiating RN node must be equal to or greater than half of max_num_outstanding_xacts_at_hn of the target HN", max_num_outstanding_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_0_participating].num_outstanding_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].num_outstanding_xact < (max_num_outstanding_xacts_at_hn/2)) begin
          str_idx1_info = $sformatf("Programmed value of max_num_outstanding_xacts_at_hn_status is %0d. But num_outstanding_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_xact of the initiating RN node must be equal to or greater than half of max_num_outstanding_xacts_at_hn of the target HN", max_num_outstanding_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_1_participating].num_outstanding_xact, initiating_rn_node_idx_1);
          is_supported = 0;
        end
      end
    end
    
    if (!is_supported) begin
      str_is_supported_info = $sformatf("%0s%0s",str_idx0_info, str_idx1_info);
      if (is_rn_idx_0_participating && is_rn_idx_1_participating) begin
        issue_is_supported_failure($sformatf("This sequence cannot be run based on the current system configuration.\n\
                                              %0s\n\
                                              %0s \n\
                                              Modify configurations through \n\
                                              svt_chi_system_configuration::num_rn,\n\
                                              svt_chi_node_configuration::is_active,\n\
                                              svt_chi_system_configuration::participating_rn_nodes[]\n\
                                              ", str_is_supported_info_prefix, str_is_supported_info));
      end
      else begin
        issue_is_supported_failure($sformatf("This sequence cannot be run based on the current node configurations of RN%0d and/or RN%0d.\n\
                                              %0s \n\
                                              Modify configuration through \n\
                                              svt_chi_node_configuration::num_outstanding_xact,\n\
                                              svt_chi_node_configuration::num_outstanding_write_xact,\n\
                                              ",str_is_supported_info, initiating_rn_node_idx_0, initiating_rn_node_idx_1));
      end
    end      
    `svt_xvm_debug("is_supported",$sformatf("Exiting ..."));
    if (!is_target_hn_idx_valid_for_curr_cfg()) begin
      is_supported = 0;
      `svt_xvm_note("is_supported", "not a valid hn_idx based on random_tgt_id_enable for current cfg");
    end
  endfunction : is_supported

  virtual task pre_start();
    `svt_xvm_debug("pre_start",$sformatf("Entering ..."));
    super.pre_start();
    raise_phase_objection();
  endtask // pre_start

  virtual task body();
    /** Queue of addresses, used by the transactions generated */
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0] addr_q[$];
    bit seq_is_non_secure_access_q[$];
    /** Flag to track whether cache initialization needs to be performed or not*/
    bit                                perform_cache_initialization;
    int                                array_idx;
    /** Metric variables */
    int received_responses = 0;

    int num_outstanding_xacts_to_generate;

    /** Sub Write type transaction directed sequences initiated from this sequence */
    svt_chi_rn_write_type_transaction_directed_sequence write_seq[int];
    
    /** Sub Read type transaction cache initialization directed sequences initiated from this sequence */
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq[int];

    `svt_xvm_debug("body", "Entering ...")
    super.body();

    max_num_outstanding_xacts_at_hn_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(), "max_num_outstanding_xacts_at_hn", max_num_outstanding_xacts_at_hn);
    max_num_outstanding_write_xacts_at_hn_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(), "max_num_outstanding_write_xacts_at_hn", max_num_outstanding_write_xacts_at_hn);
    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :initiating_rn_node_index_0;
    initiating_rn_node_idx_1 = initiating_rn_node_index_1_status ? initiating_rn_node_index_1_from_config_db :initiating_rn_node_index_1;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_node_index_0;

    `svt_xvm_debug("body", $sformatf("max_num_outstanding_xacts_at_hn is %0d as a result of %0s.", max_num_outstanding_xacts_at_hn, max_num_outstanding_xacts_at_hn_status ? "config DB" : "default"));
    `svt_xvm_debug("body", $sformatf("max_num_outstanding_write_xacts_at_hn is %0d as a result of %0s.", max_num_outstanding_write_xacts_at_hn, max_num_outstanding_write_xacts_at_hn_status ? "config DB" : "default"));
    `svt_xvm_debug("body", $sformatf("initiating_rn_node_idx_0 is %0d as a result of %0s.", initiating_rn_node_idx_0, initiating_rn_node_index_0_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("initiating_rn_node_idx_1 is %0d as a result of %0s.", initiating_rn_node_idx_1, initiating_rn_node_index_1_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("target_hn_node_idx_0 is %0d as a result of %0s.", target_hn_node_idx_0, target_hn_node_index_0_status ? "config DB" : "Randomization")); 

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    //If there are participating RN-F nodes in the system, set the cache_line_init_rn_f_node_index to any one of them
    if(active_participating_rn_f_nodes.size()) begin
      cache_line_init_rn_f_node_index = active_participating_rn_f_nodes[0];
      perform_cache_initialization=1;
    end
    /**
     * If the cache_line_init_rn_f_node_index is same as any of the initiating RN node indices 
     * initiating_rn_node_idx_0,initiating_rn_node_idx_1,
     * then re-assign the cache_line_init_rn_f_node_index with RN node index ,which is active,
     * participating and not equal to initiating_rn_node_idx_0, initiating_rn_node_idx_1.
     */
      if((cache_line_init_rn_f_node_index == initiating_rn_node_idx_0)||(cache_line_init_rn_f_node_index == initiating_rn_node_idx_1))begin  
        int active_participating_q [$];
        `svt_chi_xxm_debug("body",$sformatf("cache_line_init_rn_f_node_index= %0d is same as initiating_rn_node_idx_0=%0d or initiating_rn_node_idx_1=%0d and active_participating_rn_f_nodes.size()= %0d",cache_line_init_rn_f_node_index,initiating_rn_node_idx_0,initiating_rn_node_idx_1,active_participating_rn_f_nodes.size()));
        active_participating_q = active_participating_rn_f_nodes.find with ((item != initiating_rn_node_idx_0) && (item != initiating_rn_node_idx_1));
        //If there are RN-Fs that do not coincide with initiating_rn_node_idx_0 and initiating_rn_node_idx_1, set one of them as cache_line_init_rn_f_node_index
        if(active_participating_q.size()>0)begin
          cache_line_init_rn_f_node_index = active_participating_q.pop_back();
          perform_cache_initialization=1;
          `svt_chi_xxm_debug("body", $sformatf("active_participating_q.size() is %0d and Selected different cache_line_init_rn_f_node_index=%0d", active_participating_q.size(),cache_line_init_rn_f_node_index));
          active_participating_q.delete();
        //If there are no other RN-Fs in the system, check if both initiating RN node index 0 and 1 are RN-Fs. If yes, then set cache_line_init_rn_f_node_index to one of the initiating RN nodes (we will initiate cache init transactions fromm both RN-Fs, so it does not matter which index we set cache_line_init_rn_f_node_index to). If no, then cache initialization cannot be performed.
        end else begin
          if((is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_node_idx_0, array_idx)) && (is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_node_idx_1, array_idx))) begin
            perform_cache_initialization=1;
            `svt_chi_xxm_debug("body",$sformatf("Selected cache_line_init_rn_f_node_index= %0d is same as initiating_rn_node_index_0=%0d or initiating_rn_node_index_1=%0d and active_participating_rn_f_nodes.size()= %0d. Cache initialization will be performed from initiating_rn_node_index_0 and initiating_rn_node_index_1",cache_line_init_rn_f_node_index,initiating_rn_node_index_0_from_config_db,initiating_rn_node_index_1_from_config_db,active_participating_rn_f_nodes.size()));
          end else begin
            perform_cache_initialization=0;
          end
        end
      end

    /**
     * If the cache_line_init_rn_f_node_index is not part of active_participating_rn_f_nodes array, then we cannot
     * perform cache initialization.
     */
    if (!(is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, cache_line_init_rn_f_node_index, array_idx))) begin
      perform_cache_initialization = 0;
    end

    `svt_xvm_debug("body", $sformatf("perform_cache_initialization is %0b, cache_line_init_rn_f_node_index is %0d, initiating_rn_node_idx_0 is %0d, initiating_rn_node_idx_1 is %0d", perform_cache_initialization, cache_line_init_rn_f_node_index, initiating_rn_node_idx_0, initiating_rn_node_idx_1));    

    //If max outstanding count for Write transactions has been programmed, use that to generate the outstanding Writes
    if(max_num_outstanding_write_xacts_at_hn > 0) begin
      num_outstanding_xacts_to_generate = max_num_outstanding_write_xacts_at_hn;
      `svt_xvm_debug("body",$sformatf("max_num_outstanding_write_xacts_at_hn is set to a non-zero value (%0d). Hence, the value programmed in max_num_outstanding_xacts_at_hn will be ignored. The number of outstanding transactions issued by the sequence will be equal to max_num_outstanding_write_xacts_at_hn", max_num_outstanding_write_xacts_at_hn));
    end
    //If not, use the max outstanding transaction count
    else
      num_outstanding_xacts_to_generate = max_num_outstanding_xacts_at_hn;

    for(int k = 0; k < sequence_length; k++) begin
      
      if(perform_cache_initialization) begin  
        
        `svt_xvm_debug("body",$sformatf("Starting cache initialization for %0d addresses from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d",
                                        num_outstanding_xacts_to_generate, cache_line_init_rn_f_node_index, target_hn_node_idx_0));
        
        for(int i = 0; i < num_outstanding_xacts_to_generate; i++) begin
          //cache_line_init_rn_f_node_index will be set to initiating_rn_node_idx_1 or initiating_rn_node_idx_0 only when there are only 2 RN-Fs in the system. In such a case,
          //the cache init transactions must be issued alternately from initiating_rn_node_idx_1 and
          //initiating_rn_node_idx_0 respectively
          if(cache_line_init_rn_f_node_index == initiating_rn_node_idx_1 || cache_line_init_rn_f_node_index == initiating_rn_node_idx_0) begin
            if(i % 2 == 0) 
              cache_line_init_rn_f_node_index = initiating_rn_node_idx_1;
            else
              cache_line_init_rn_f_node_index = initiating_rn_node_idx_0; 
          end
        
          /** Write data into Cache of Randomly selected first RN-F with address of randomly selected HN Node */
          `svt_xvm_do_on_with(makeunique_seq[i],p_sequencer.rn_virt_seqr[cache_line_init_rn_f_node_index].rn_xact_seqr,
          {
           sequence_length   == 1;
           hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
           seq_hn_node_idx   == target_hn_node_idx_0;
           use_seq_is_non_secure_access == 0;
          })
          
          `svt_xvm_debug("body", $sformatf("%0s Waiting for MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) to end",`SVT_CHI_PRINT_PREFIX(makeunique_seq[i].write_tran),i, makeunique_seq[i].write_tran.hn_node_idx, makeunique_seq[i].write_tran.tgt_id));
          makeunique_seq[i].write_tran.wait_end();
          `svt_xvm_debug("body", $sformatf("%0s MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) ended",`SVT_CHI_PRINT_PREFIX(makeunique_seq[i].write_tran),i, makeunique_seq[i].write_tran.hn_node_idx, makeunique_seq[i].write_tran.tgt_id));
          /** Queue for collecting the address of makeunique transactions */
          addr_q.push_back(makeunique_seq[i].output_xacts[0].addr);
          seq_is_non_secure_access_q.push_back(makeunique_seq[i].output_xacts[0].is_non_secure_access);
          `svt_xvm_verbose("body", $sformatf("MakeUnique transaction [%0d] is %0s", i,makeunique_seq[i].write_tran.sprint()));
        end
        
        `svt_xvm_debug("body",$sformatf("Ended cache initialization for %0d addresses from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d",
                                        num_outstanding_xacts_to_generate, cache_line_init_rn_f_node_index, target_hn_node_idx_0));
      end // if (perform_cache_initialization)
      
      `svt_xvm_debug("body",$sformatf("Starting transmission of Write type transactions for %0d addresses with suspend_wr_data set to 1",num_outstanding_xacts_to_generate));
      //for(int i = 0; i < num_outstanding_xacts_to_generate/2; i++) begin
      fork
        /** 
           * Do 128 transactions from each of the two different RNs each to all MAKEUNIQUE 
           * transaction address of same HN node with suspend response*/ 
        begin
          for(int i = 0; i < (num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2); i++) begin
            `svt_xvm_debug("body",$sformatf("Sending Write type transactions from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d with suspend_wr_data set to 1",initiating_rn_node_idx_0, target_hn_node_idx_0));
            `svt_xvm_do_on_with(write_seq[2*i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
            {
            `ifdef SVT_CHI_ISSUE_B_ENABLE
             if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A || sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0) {
               seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL};
             }
             else{
               seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL, svt_chi_transaction::WRITEUNIQUEFULLSTASH, svt_chi_transaction::WRITEUNIQUEPTLSTASH};
             }
            `else
               seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL};
            `endif
             sequence_length               == 1;
             `ifdef SVT_CHI_ISSUE_E_ENABLE
              if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision >= svt_chi_node_configuration::ISSUE_E) {
               seq_txn_id         == (i*3);
              }
              else{
               seq_txn_id         == (i % num_outstanding_xacts_to_generate);
              }
             `else
               seq_txn_id         == (i % num_outstanding_xacts_to_generate);
             `endif
             /** Transactions are set to ordered at requestor for stream WriteUniques transactions. */
             seq_order_type   == svt_chi_transaction::NO_ORDERING_REQUIRED;
             if (perform_cache_initialization) { 
               hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
               min_addr          == addr_q[2*i];
               max_addr          == addr_q[2*i];
               seq_is_non_secure_access == seq_is_non_secure_access_q[2*i]; 
               use_seq_is_non_secure_access == 1;
             }
             else {
               hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
               seq_hn_node_idx == target_hn_node_idx_0;
               use_seq_is_non_secure_access == 0;
             }
            })
           
            `svt_xvm_debug("body", $sformatf("%0s Transmitting Write Transaction [%0d] targeted to HN (idx %0d, id %0d) ",`SVT_CHI_PRINT_PREFIX(write_seq[2*i].write_tran),2*i, write_seq[2*i].write_tran.hn_node_idx, write_seq[2*i].write_tran.tgt_id));
            `svt_xvm_verbose("body", $sformatf("Write Transaction [%0d] is %0s", 2*i,write_seq[2*i].write_tran.sprint()));

          end
        end
        begin
          for(int i = 0; i < num_outstanding_xacts_to_generate/2; i++) begin
            `svt_xvm_debug("body",$sformatf("Sending Write type transactions from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d with suspend_wr_data set to 1",initiating_rn_node_idx_0, target_hn_node_idx_0));
            `svt_xvm_do_on_with(write_seq[2*i + 1], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,
            {
            `ifdef SVT_CHI_ISSUE_B_ENABLE
             if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision == svt_chi_node_configuration::ISSUE_A || sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 0) {
               seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL};
             }
             else{
               seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL, svt_chi_transaction::WRITEUNIQUEFULLSTASH, svt_chi_transaction::WRITEUNIQUEPTLSTASH};
             }
            `else
               seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL};
            `endif
             sequence_length               == 1;
             `ifdef SVT_CHI_ISSUE_E_ENABLE
              if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision >= svt_chi_node_configuration::ISSUE_E) {
               seq_txn_id         == (i*3);
              }
              else{
               seq_txn_id         == (i % num_outstanding_xacts_to_generate);
              }
             `else
               seq_txn_id         == (i % num_outstanding_xacts_to_generate);
             `endif
             /** Transactions are set to ordered at requestor for stream WriteUniques transactions. */
             seq_order_type   == svt_chi_transaction::NO_ORDERING_REQUIRED;
             if (perform_cache_initialization) {
               hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
               min_addr           == addr_q[2*i + 1];
               max_addr           == addr_q[2*i + 1];
               seq_is_non_secure_access == seq_is_non_secure_access_q[2*i +1]; 
               use_seq_is_non_secure_access == 1;
             }
             else {
               hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
               seq_hn_node_idx == target_hn_node_idx_0;
               use_seq_is_non_secure_access == 0;
             }
            })
          
            `svt_xvm_debug("body", $sformatf("%0s Transmitting Write Transaction [%0d] targeted to HN (idx %0d, id %0d) ",`SVT_CHI_PRINT_PREFIX(write_seq[2*i + 1].write_tran),2*i + 1, write_seq[2*i + 1].write_tran.hn_node_idx, write_seq[2*i + 1].write_tran.tgt_id));
            `svt_xvm_verbose("body", $sformatf("Write Transaction [%0d] is %0s", 2*i + 1,write_seq[2*i + 1].write_tran.sprint()));
          end
        end
      join
     // end //for(int i = 0; i < num_outstanding_xacts_to_generate/2; i++)  
      
      /** Waiting for the DBIDResp/CompDBDIResp responses from HN for write trasactions */
      foreach(write_seq[wr]) begin
        fork
          automatic int _wr = wr;
          begin
            `svt_xvm_debug("body", $sformatf("%0s Write transaction [%0d] targeted to HN (idx %0d, id %0d), suspend_wr_data %0b: waiting for response from interconnect",`SVT_CHI_PRINT_PREFIX(write_seq[_wr].write_tran),_wr, write_seq[_wr].write_tran.hn_node_idx, write_seq[_wr].write_tran.tgt_id,write_seq[_wr].write_tran.suspend_wr_data));
            fork
            begin
              fork
                begin
                  write_seq[_wr].write_tran.wait_for_tx_data_prereqs();
                end
                begin
                  wait(write_seq[_wr].write_tran.req_status == svt_chi_transaction::RETRY);// begin
                end
              join_any
              disable fork;
            end
            join
            received_responses++;
            `svt_xvm_debug("body", $sformatf("%0s Write transaction [%0d] targeted to HN (idx %0d, id %0d), suspend_wr_data %0b: received response from interconnect. Total responses received %0d",`SVT_CHI_PRINT_PREFIX(write_seq[_wr].write_tran),_wr, write_seq[_wr].write_tran.hn_node_idx, write_seq[_wr].write_tran.tgt_id,write_seq[_wr].write_tran.suspend_wr_data,received_responses));
          end
        join_none
      end

      /** Wait until All DBIDResp/CompDBDIResp responses are received for write transaction */ 
      `svt_xvm_debug("body",$sformatf("Completed initiation of Write type transactions for %0d addresses from p_sequencer.rn_virt_seqr[%0d] and p_sequencer.rn_virt_seqr[%0d] to HN idx %0d with suspend_wr_data set to 1, and waiting to receive responses from interconnect.",
                                num_outstanding_xacts_to_generate, initiating_rn_node_idx_0,initiating_rn_node_idx_1,target_hn_node_idx_0));
      wait(received_responses == num_outstanding_xacts_to_generate);
      `svt_xvm_debug("body",$sformatf("Received responses from interconnect to Write type transactions for %0d addresses from p_sequencer.rn_virt_seqr[%0d] and p_sequencer.rn_virt_seqr[%0d] to HN idx %0d with suspend_wr_data set to 1.",
                                num_outstanding_xacts_to_generate, initiating_rn_node_idx_0,initiating_rn_node_idx_1,target_hn_node_idx_0));
     
      /** Self Check1: To check suspend_wr_data should not be modified to zero by the VIP
       *  before reseting from test bench.
       */
      foreach (write_seq[self_check_idx1]) begin
        if (!write_seq[self_check_idx1].write_tran.is_terminated()) begin
          if (write_seq[self_check_idx1].write_tran.suspend_wr_data == 0) begin
            `svt_xvm_error("body", $sformatf("%0s suspend_wr_data should be 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(write_seq[self_check_idx1].write_tran)));
          end
          else begin
            `svt_xvm_debug("body", $sformatf("%0s suspend_wr_data is 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(write_seq[self_check_idx1].write_tran)));
          end
        end
      end

      /** Self Check2: To check transaction is not ended by the VIP before resuming the 
       *  suspend_wr_data to zero from the test bench
       */
      foreach(write_seq[self_check_idx2]) begin
        if (!write_seq[self_check_idx2].write_tran.is_terminated()) begin
          if (write_seq[self_check_idx2].write_tran.end_event.is_on() == 1) begin
            `svt_xvm_error("body", $sformatf("Unexpected: %0s Transaction's end_event triggered when suspend_wr_data is still 1.", `SVT_CHI_PRINT_PREFIX(write_seq[self_check_idx2].write_tran)));
          end
          else begin
            `svt_xvm_debug("body", $sformatf("Expected: %0s Transaction's end_event is not triggered when suspend_wr_data is still 1.", `SVT_CHI_PRINT_PREFIX(write_seq[self_check_idx2].write_tran)));
          end
        end
      end
 
      /** Self Check 3: To check that the current_outstanding_*_xact_count in the RNs
       * are as per the transactions inititated by the sequence
       */
      /** Check if the total outstanding xact counter is set correctly in the shared status of the RN agent */
      if(write_seq[0].shared_status.prot_status.current_outstanding_xact_count != (num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2))
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding transactions from the sequence but the outstanding transaction count in the shared status of RN%0d is %0d", (num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2), initiating_rn_node_idx_0, write_seq[0].shared_status.prot_status.current_outstanding_xact_count));
      /** Check if the outstanding Write xact counter is set correctly in the shared status of the RN agent */
      if(write_seq[0].shared_status.prot_status.current_outstanding_write_xact_count != (num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2)) begin
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding Write transactions from the sequence but the outstanding Write transaction count in the shared status of RN%0d is %0d", (num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2), initiating_rn_node_idx_0, write_seq[0].shared_status.prot_status.current_outstanding_write_xact_count));
      end
      /** Check if the total outstanding xact counter is set correctly in the shared status of the second RN agent */
      if(write_seq[1].shared_status.prot_status.current_outstanding_xact_count != num_outstanding_xacts_to_generate/2)
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding transactions from the sequence but the oustanding transaction count in the shared status of RN%0d is %0d", num_outstanding_xacts_to_generate/2, initiating_rn_node_idx_1, write_seq[1].shared_status.prot_status.current_outstanding_xact_count));
      /** Check if the outstanding Write xact counter is set correctly in the shared status of the RN agent */
      if(write_seq[1].shared_status.prot_status.current_outstanding_write_xact_count !=  num_outstanding_xacts_to_generate/2) begin
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding Write transactions from the sequence but the outstanding Write transaction count in the shared status of RN%0d is %0d", num_outstanding_xacts_to_generate/2, initiating_rn_node_idx_1, write_seq[1].shared_status.prot_status.current_outstanding_write_xact_count));
      end

      `svt_xvm_debug("body", $sformatf("RN%0d: Number of outstanding transactions : %0d, Number of outstanding write xacts : %0d", initiating_rn_node_idx_0, write_seq[0].shared_status.prot_status.current_outstanding_xact_count, write_seq[0].shared_status.prot_status.current_outstanding_write_xact_count));
      `svt_xvm_debug("body", $sformatf("RN%0d: Number of outstanding transactions : %0d, Number of outstanding write xacts : %0d", initiating_rn_node_idx_1, write_seq[0].shared_status.prot_status.current_outstanding_xact_count, write_seq[1].shared_status.prot_status.current_outstanding_write_xact_count));

      /** Resuming all NonCopyBackWrData for above write transactions */
      `svt_xvm_debug("body",$sformatf("Resuming the write transactions by setting svt_chi_rn_transaction::suspsend_wr_data set to 0"))
      foreach(write_seq[index4]) begin
        write_seq[index4].write_tran.suspend_wr_data = 0;
        `svt_xvm_debug("body", $sformatf("After Resume received_responses is %0d for iteration %0d and suspend_wr_data is %0b",received_responses, index4, write_seq[index4].write_tran.suspend_wr_data));
      end

      /** Waiting for Write transactions to complete*/
      `svt_xvm_debug("body",$sformatf("Waiting for completion of all the outstanding write type transactions"));
      foreach(write_seq[self_check_idx3]) begin
        `svt_xvm_debug("body", $sformatf("Waiting for above write_seq[%0d] transaction %0s to end", self_check_idx3, `SVT_CHI_PRINT_PREFIX(write_seq[self_check_idx3].write_tran)));
        write_seq[self_check_idx3].write_tran.wait_end();

        /** Self Check4: To check suspend_wr_data should not be asserted after the transaction
         *  completes as it is reseted from test bench
         */
        if (!write_seq[self_check_idx3].write_tran.is_terminated()) begin
          if (write_seq[self_check_idx3].write_tran.suspend_wr_data == 1) begin
            `svt_xvm_error("body", $sformatf("%0s suspend_wr_data should be 0 as it has been reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(write_seq[self_check_idx3].write_tran)));
          end
          else begin
            `svt_xvm_debug("body", $sformatf("%0s suspend_wr_data is 0 as it is reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(write_seq[self_check_idx3].write_tran)));
          end
        end
      end
      `svt_xvm_debug("body",$sformatf("Received completions for all write type outstanding transactions"));
      
      /** Targeted HN IDs from both RNs should be same */
      for(int index_5 = 0; index_5 < num_outstanding_xacts_to_generate/2; index_5++) begin
        int hn_idx_0, hn_idx_1;
        hn_idx_0 = sys_cfg.get_hn_idx(write_seq[2*index_5].output_xacts[0].addr);
        hn_idx_1 = sys_cfg.get_hn_idx(write_seq[2*index_5 + 1].output_xacts[0].addr);
        if ((hn_idx_0 == target_hn_node_idx_0) && (hn_idx_0 == hn_idx_1)) begin
          /** pass */
          `svt_xvm_debug("body", $sformatf("Targeted HN Index from both RNs are same as expected.  rn[%0d] to hn_idx[%0d], rn[%0d] to hn_idx[%0d] and they match with the target_hn_node_idx_0 %0d", initiating_rn_node_idx_0, hn_idx_0, initiating_rn_node_idx_1, hn_idx_1,target_hn_node_idx_0));
        end
        else begin
          /** fail */
          `svt_xvm_error("body", $sformatf("Targeted HN Index from both RNs are different, which is unexpected.  rn[%0d] %0s transaction to hn_idx[%0d], rn[%0d] %0s transaction to hn_idx[%0d] and one or both of hn_idx don't match with the target_hn_node_idx_0 %0d ",initiating_rn_node_idx_0, `SVT_CHI_PRINT_PREFIX( write_seq[2*index_5].output_xacts[0]), hn_idx_0, initiating_rn_node_idx_1, `SVT_CHI_PRINT_PREFIX( write_seq[2*index_5 + 1].output_xacts[0]), hn_idx_1,target_hn_node_idx_0));
        end
      end
     
      /** Reset received_responses to zero */
      received_responses = 0;
      
      /** Delete the contents of address collection queue */
      addr_q.delete();

    end //for(int k = 0; k < sequence_length; k++)
    
    `svt_xvm_debug("body", "Exiting...")
  endtask: body

  virtual task post_body();
    drop_phase_objection();
  endtask

endclass: svt_chi_system_protocol_flow_ctrl_write_outstanding_diff_rn_same_hn_virtual_sequence

function svt_chi_system_protocol_flow_ctrl_write_outstanding_diff_rn_same_hn_virtual_sequence::new(string name="svt_chi_system_protocol_flow_ctrl_write_outstanding_diff_rn_same_hn_virtual_sequence");
  super.new(name);
endfunction


/**
 * @groupname CHI_OUTSTANDING_WR_TYPE  
 * #- This sequence requires at least two HN nodes to be present in the Interconnect.
 * #- This sequence requires two initiating active and participating RNs.
 * #- If another active and participating RN-F exists, perform cache
 *    initialization to two randomly selected HNs.
 * #- Initiate Write type transactions with 
 *    svt_chi_rn_transaction::suspend_wr_data set  to 1 each from both the initiating RNs, 128 each to randomly 
 *    selected two HNs from each of the RN in non blocking mode. <br>
 *    - Maximum number of outstanding transactions at the HN is as per either #max_num_outstanding_write_xacts_at_hn or
 *      #max_num_outstanding_xacts_at_hn, which can be controlled through config DB.   
 *    - This ensures that the maximum outstanding transaction limit is reached at both the HNs.
 *    - Also, the RNs will not transmit NonCopyBackWrData corresponding to these transactions
 *      until svt_chi_rn_transaction::suspend_wr_data is set to 0 from the sequence.
 *    .
 * #- The addresses of these write transactions are such that:
 *    - Same as initialized cache line addresses if cache initialization is performed
 *    - Otherwise, random addresses targeting both the HNs
 *    .
 * #- Once the RNs receive the responses for all the outstanding transactions from
 *    both of the HNs, svt_chi_rn_transaction::suspend_wr_data is set to 0 for all the outstanding
 *    transactions. <br>
 *    This ensures that the NonCopyBackWrData for these transactions can be resumed 
 *    from the RNs.
 * #- Check that both of the HNs respond properly for all outstanding write type transactions
 *    and these are completed successfully.
 * .
 */

class svt_chi_system_protocol_flow_ctrl_write_outstanding_diff_rn_diff_hn_virtual_sequence extends svt_chi_system_base_virtual_sequence;
  
  //-----------------------------------------------------------------------------  
  // Member attributes
  //-----------------------------------------------------------------------------  

  /** To display contents of Active Participating RN's node info. */
  string str_rn_node;

  /** To display contents of Active Participating RN-F's node info. */
  string str_rn_f_node;

  rand  bit  txn_is_non_secure_access;
  /** UVM/OVM Object Utility macro */
  `svt_xvm_object_utils(svt_chi_system_protocol_flow_ctrl_write_outstanding_diff_rn_diff_hn_virtual_sequence)
  
  //-----------------------------------------------------------------------------  
  // Methods
  //-----------------------------------------------------------------------------
  /** Constructor */
  extern function new(string name="svt_chi_system_protocol_flow_ctrl_write_outstanding_diff_rn_diff_hn_virtual_sequence");

  //-----------------------------------------------------------------------------
  /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting any type of Request Nodes = 2
   *  #- Minimum required number of HN Nodes = 2   
   *  .
   */
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    
    /** local variables */
    int num_supporting_request_nodes;
    int num_hn_f_nodes;   
    int array_idx;
    bit is_rn_idx_0_participating, is_rn_idx_1_participating;
    string str_is_supported_info_prefix = "";
    string str_is_supported_info = "";
    string str_idx0_info = "";
    string str_idx1_info = "";    
    /** Supporting any type of Request Nodes required */
    int required_num_supporting_request_nodes = 2;
    int required_num_hn_nodes = 2;
    
    `svt_xvm_debug("is_supported",$sformatf("Entering ..."));

    /** By default is_supported is 0 */
    is_supported = 0;
    
    /** Check for minimum required HN nodes */
    num_hn_f_nodes = hn_f_nodes.size();
    
    /** Check requirment of number of HN nodes needed */
    if (num_hn_f_nodes < required_num_hn_nodes) begin
      issue_is_supported_failure($sformatf("This sequence requires minimum %0d HN-F nodes to be present in the system. Number of HN-F nodes are %0d. Program number of HN nodes using svt_chi_system_configuration::num_hn. Program the HN interface type using svt_chi_system_configuration::chi_addr_cfg.hn_interface_type[].", required_num_hn_nodes, num_hn_f_nodes));
      return 0;      
    end
    
    /** Check for minimum required RN nodes.
     *  Also check whether the selected RN nodes are part of participating arrays or not.
     */    
    num_supporting_request_nodes = active_participating_rn_nodes.size();

    /** Check the requirements of RN nodes */
    if (num_supporting_request_nodes) begin
      /** Display the contents of Active Participating RN Nodes */
      foreach (active_participating_rn_nodes[j]) begin
        str_rn_node = {str_rn_node, $sformatf(" %0d", active_participating_rn_nodes[j])};
      end 
      `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_nodes are %0s", str_rn_node));
    end

    str_is_supported_info_prefix = $sformatf("Number of Supporting RN Node(s)  - Minimum Required : %0d Current : %0d", required_num_supporting_request_nodes, num_supporting_request_nodes);
    
    if ((initiating_rn_node_index_0_status==0)&&(valid_initiating_rn_node_index_0==0)) begin
        str_idx0_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN's that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F or RN_I)";
    end
    else begin
      is_rn_idx_0_participating = is_value_found_in_int_assoc_array(active_participating_rn_nodes, initiating_rn_node_idx_0, array_idx);
      if (!is_rn_idx_0_participating) begin
        str_idx0_info = $sformatf("initiating_rn_node_idx_0 %0d is not valid for this sequence. The RN corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuration::participating_rn_nodes[])", initiating_rn_node_idx_0, initiating_rn_node_idx_0);
      end
    end
    if ((initiating_rn_node_index_1_status==0)&&(valid_initiating_rn_node_index_1==0)) begin
        str_idx1_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN's that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F or RN_I)";
    end
    else begin
      is_rn_idx_1_participating = is_value_found_in_int_assoc_array(active_participating_rn_nodes, initiating_rn_node_idx_1, array_idx);
      if (!is_rn_idx_1_participating) begin
        str_idx1_info = $sformatf("initiating_rn_node_idx_1 %0d is not valid for this sequence. The RN corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuration::participating_rn_nodes[])", initiating_rn_node_idx_1, initiating_rn_node_idx_1);
      end
    end

    if (is_rn_idx_0_participating && is_rn_idx_1_participating) begin
      is_supported = 1;
      if(max_num_outstanding_write_xacts_at_hn > 0) begin
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].num_outstanding_write_xact < max_num_outstanding_write_xacts_at_hn) begin
          str_idx0_info = $sformatf("Programmed value of max_num_outstanding_write_xacts_at_hn_status is %0d. But num_outstanding_write_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_write_xact of the initiating RN node must be equal to or greater than max_num_outstanding_write_xacts_at_hn_status of the target HN", max_num_outstanding_write_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_0_participating].num_outstanding_write_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].num_outstanding_write_xact < max_num_outstanding_write_xacts_at_hn) begin
          str_idx1_info = $sformatf("Programmed value of max_num_outstanding_write_xacts_at_hn_status is %0d. But num_outstanding_write_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_write_xact of the initiating RN node must be equal to or greater than max_num_outstanding_write_xacts_at_hn_status of the target HN", max_num_outstanding_write_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_1_participating].num_outstanding_write_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
      end else begin
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].num_outstanding_xact < max_num_outstanding_xacts_at_hn) begin
          str_idx0_info = $sformatf("Programmed value of max_num_outstanding_xacts_at_hn_status is %0d. But num_outstanding_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_xact of the initiating RN node must be equal to or greater than max_num_outstanding_xacts_at_hn of the target HN", max_num_outstanding_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_0_participating].num_outstanding_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].num_outstanding_xact < max_num_outstanding_xacts_at_hn) begin
          str_idx1_info = $sformatf("Programmed value of max_num_outstanding_xacts_at_hn_status is %0d. But num_outstanding_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_xact of the initiating RN node must be equal to or greater than max_num_outstanding_xacts_at_hn of the target HN", max_num_outstanding_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_1_participating].num_outstanding_xact, initiating_rn_node_idx_1);
          is_supported = 0;
        end
      end
    end
    
    if (!is_supported) begin
      str_is_supported_info = $sformatf("%0s%0s",str_idx0_info, str_idx1_info);
      if (is_rn_idx_0_participating && is_rn_idx_1_participating) begin
        issue_is_supported_failure($sformatf("This sequence cannot be run based on the current system configuration.\n\
                                              %0s\n\
                                              %0s \n\
                                              Modify configurations through \n\
                                              svt_chi_system_configuration::num_rn,\n\
                                              svt_chi_node_configuration::is_active,\n\
                                              svt_chi_system_configuration::participating_rn_nodes[]\n\
                                              ", str_is_supported_info_prefix, str_is_supported_info));
      end
      else begin
        issue_is_supported_failure($sformatf("This sequence cannot be run based on the current node configurations of RN%0d and/or RN%0d.\n\
                                              %0s \n\
                                              Modify configuration through \n\
                                              svt_chi_node_configuration::num_outstanding_xact,\n\
                                              svt_chi_node_configuration::num_outstanding_write_xact,\n\
                                              ",str_is_supported_info, initiating_rn_node_idx_0, initiating_rn_node_idx_1));
      end
    end      
    `svt_xvm_debug("is_supported",$sformatf("Exiting ..."));
    if (!is_target_hn_idx_valid_for_curr_cfg()) begin
      is_supported = 0;
      `svt_xvm_note("is_supported", "not a valid hn_idx based on random_tgt_id_enable for current cfg");
    end
  endfunction : is_supported

  virtual task pre_start();
    `svt_xvm_debug("pre_start",$sformatf("Entering ..."));
    super.pre_start();
    raise_phase_objection();
  endtask // pre_start

  virtual task body();
    /** Queue of addresses, used by the transactions generated */
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0] addr_q[$];
    bit secure_q[$];
    /** Flag to track whether cache initialization needs to be performed or not*/
    bit                                perform_cache_initialization;
    int                                array_idx;

    /** Metric variables */
    int received_responses = 0;
    int total_num_tran = 0;

    /** Sub Write type transaction directed sequences initiated from this sequence */
    svt_chi_rn_write_type_transaction_directed_sequence write_seq[int];
    
    /** Sub Read type transaction cache initialization directed sequences initiated from this sequence */
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq[int];
    super.body();

    `svt_xvm_debug("body", "Entering ...")

    max_num_outstanding_xacts_at_hn_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(), "max_num_outstanding_xacts_at_hn", max_num_outstanding_xacts_at_hn);
    max_num_outstanding_write_xacts_at_hn_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(), "max_num_outstanding_write_xacts_at_hn", max_num_outstanding_write_xacts_at_hn);
    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :initiating_rn_node_index_0;
    initiating_rn_node_idx_1 = initiating_rn_node_index_1_status ? initiating_rn_node_index_1_from_config_db :initiating_rn_node_index_1;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_node_index_0;
    target_hn_node_idx_1 = target_hn_node_index_1_status ? target_hn_node_index_1_from_config_db :target_hn_node_index_1;

    `svt_xvm_debug("body", $sformatf("max_num_outstanding_xacts_at_hn is %0d as a result of %0s.", max_num_outstanding_xacts_at_hn, max_num_outstanding_xacts_at_hn_status ? "config DB" : "default"));
    `svt_xvm_debug("body", $sformatf("max_num_outstanding_write_xacts_at_hn is %0d as a result of %0s.", max_num_outstanding_write_xacts_at_hn, max_num_outstanding_write_xacts_at_hn_status ? "config DB" : "default"));
    `svt_xvm_debug("body", $sformatf("initiating_rn_node_idx_0 is %0d as a result of %0s.", initiating_rn_node_idx_0, initiating_rn_node_index_0_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("initiating_rn_node_idx_1 is %0d as a result of %0s.", initiating_rn_node_idx_1, initiating_rn_node_index_1_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("target_hn_node_idx_0 is %0d as a result of %0s.", target_hn_node_idx_0, target_hn_node_index_0_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("target_hn_node_idx_1 is %0d as a result of %0s.", target_hn_node_idx_1, target_hn_node_index_1_status ? "config DB" : "Randomization")); 

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    //If there are participating RN-F nodes in the system, set the cache_line_init_rn_f_node_index to any one of them
    if(active_participating_rn_f_nodes.size()) begin
      cache_line_init_rn_f_node_index = active_participating_rn_f_nodes[0];
      perform_cache_initialization=1;
    end
    /**
     * If the cache_line_init_rn_f_node_index is same as any of the initiating RN node indices 
     * initiating_rn_node_idx_0,initiating_rn_node_idx_1,
     * then re-assign the cache_line_init_rn_f_node_index with RN node index ,which is active,
     * participating and not equal to initiating_rn_node_idx_0, initiating_rn_node_idx_1.
     */
      if((cache_line_init_rn_f_node_index == initiating_rn_node_idx_0)||(cache_line_init_rn_f_node_index == initiating_rn_node_idx_1))begin  
        int active_participating_q [$];
        `svt_chi_xxm_debug("body",$sformatf("cache_line_init_rn_f_node_index= %0d is same as initiating_rn_node_idx_0=%0d or initiating_rn_node_idx_1=%0d and active_participating_rn_f_nodes.size()= %0d",cache_line_init_rn_f_node_index,initiating_rn_node_idx_0,initiating_rn_node_idx_1,active_participating_rn_f_nodes.size()));
        active_participating_q = active_participating_rn_f_nodes.find with ((item != initiating_rn_node_idx_0) && (item != initiating_rn_node_idx_1));
        //If there are RN-Fs that do not coincide with initiating_rn_node_idx_0 and initiating_rn_node_idx_1, set one of them as cache_line_init_rn_f_node_index
        if(active_participating_q.size()>0)begin
          cache_line_init_rn_f_node_index = active_participating_q.pop_back();
          perform_cache_initialization=1;
          `svt_chi_xxm_debug("body", $sformatf("active_participating_q.size() is %0d and Selected different cache_line_init_rn_f_node_index=%0d", active_participating_q.size(),cache_line_init_rn_f_node_index));
          active_participating_q.delete();
        //If there are no other RN-Fs in the system, check if both initiating RN node index 0 and 1 are RN-Fs. If yes, then set cache_line_init_rn_f_node_index to one of the initiating RN nodes (we will initiate cache init transactions fromm both RN-Fs, so it does not matter which index we set cache_line_init_rn_f_node_index to). If no, then cache initialization cannot be performed.
        end else begin
          if((is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_node_idx_0, array_idx)) && (is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_node_idx_1, array_idx))) begin
            perform_cache_initialization=1;
            `svt_chi_xxm_debug("body",$sformatf("Selected cache_line_init_rn_f_node_index= %0d is same as initiating_rn_node_index_0=%0d or initiating_rn_node_index_1=%0d and active_participating_rn_f_nodes.size()= %0d. Cache initialization will be performed from initiating_rn_node_index_0 and initiating_rn_node_index_1",cache_line_init_rn_f_node_index,initiating_rn_node_index_0_from_config_db,initiating_rn_node_index_1_from_config_db,active_participating_rn_f_nodes.size()));
          end else begin
            perform_cache_initialization=0;
          end
        end
      end

    /**
     * If the cache_line_init_rn_f_node_index is not part of active_participating_rn_f_nodes array, then we cannot
     * perform cache initialization.
     */
    if (!(is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, cache_line_init_rn_f_node_index, array_idx))) begin
      perform_cache_initialization = 0;
    end
    
    `svt_xvm_debug("body", $sformatf("perform_cache_initialization is %0b, cache_line_init_rn_f_node_index is %0d, initiating_rn_node_idx_0 is %0d, initiating_rn_node_idx_1 is %0d", perform_cache_initialization, cache_line_init_rn_f_node_index, initiating_rn_node_idx_0, initiating_rn_node_idx_1));    

    for(int k = 0; k < sequence_length; k++) begin
      //If max outstanding count for Write transactions has been programmed, use that to generate the outstanding Writes
      if(max_num_outstanding_write_xacts_at_hn > 0) begin
        total_num_tran = (max_num_outstanding_write_xacts_at_hn * 2);
        `svt_xvm_debug("body",$sformatf("max_num_outstanding_write_xacts_at_hn is set to a non-zero value (%0d). Hence, the value programmed in max_num_outstanding_xacts_at_hn will be ignored. The number of outstanding transactions issued by the sequence will be equal to max_num_outstanding_write_xacts_at_hn", max_num_outstanding_write_xacts_at_hn));
      end
      else
        total_num_tran = (max_num_outstanding_xacts_at_hn * 2);
      `svt_xvm_debug("body", $sformatf("total_num_tran is %0d",total_num_tran));
      
      if(perform_cache_initialization) begin  
        
        `svt_xvm_debug("body",$sformatf("Starting cache initialization for %0d addresses from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d and HN idx %0d",
                                        total_num_tran, cache_line_init_rn_f_node_index, target_hn_node_idx_0,target_hn_node_idx_1));
      
        for(int i = 0; i < total_num_tran; i++) begin
          //cache_line_init_rn_f_node_index will be set to initiating_rn_node_idx_1 or initiating_rn_node_idx_0 only when there are only 2 RN-Fs in the system. In such a case,
          //the cache init transactions must be issued alternately from initiating_rn_node_idx_1 and
          //initiating_rn_node_idx_0 respectively
          if(cache_line_init_rn_f_node_index == initiating_rn_node_idx_1 || cache_line_init_rn_f_node_index == initiating_rn_node_idx_0) begin
            if(i % 2 == 0) 
              cache_line_init_rn_f_node_index = initiating_rn_node_idx_1;
            else
              cache_line_init_rn_f_node_index = initiating_rn_node_idx_0; 
          end
        
          /** Write data into Cache of Randomly selected first RN-F with address of randomly selected HN Node */
          `svt_xvm_do_on_with(makeunique_seq[i],p_sequencer.rn_virt_seqr[cache_line_init_rn_f_node_index].rn_xact_seqr,
          {
           sequence_length   == 1;
           hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
           seq_txn_id        == (i % (total_num_tran/2));
           if (i < total_num_tran/2) {
             seq_hn_node_idx == target_hn_node_idx_0;
           }
           else if(i < total_num_tran) {
              seq_hn_node_idx == target_hn_node_idx_1;
           }
           use_seq_is_non_secure_access == 0;
          })

          `svt_xvm_debug("body", $sformatf("%0s Waiting for MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) to end",`SVT_CHI_PRINT_PREFIX(makeunique_seq[i].write_tran),i, makeunique_seq[i].write_tran.hn_node_idx, makeunique_seq[i].write_tran.tgt_id));
          makeunique_seq[i].write_tran.wait_end();
          `svt_xvm_debug("body", $sformatf("%0s MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) ended",`SVT_CHI_PRINT_PREFIX(makeunique_seq[i].write_tran),i, makeunique_seq[i].write_tran.hn_node_idx, makeunique_seq[i].write_tran.tgt_id));
          
          /** Collecting address into address queue*/
          addr_q.push_back(makeunique_seq[i].output_xacts[0].addr);
          secure_q.push_back(makeunique_seq[i].output_xacts[0].is_non_secure_access);
          
          `svt_xvm_verbose("body", $sformatf("MakeUnique transaction [%0d] is %0s", i,makeunique_seq[i].write_tran.sprint()));
        end
        
        `svt_xvm_debug("body",$sformatf("Ended cache initialization for %0d addresses from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d and HN idx %0d",
                                        total_num_tran, cache_line_init_rn_f_node_index, target_hn_node_idx_0,target_hn_node_idx_1));
      end // if (perform_cache_initialization)

      `svt_xvm_debug("body",$sformatf("Starting transmission of Write type transactions for %0d addresses with suspend_wr_data set to 1",total_num_tran));
      for(int i = 0; i < total_num_tran/2; i++) begin
        fork
          /** 
           * Do transactions from each of the two different RNs each to all MAKEUNIQUE 
           * transaction address of the two different HN nodes, 128 each from one RN to one HN. 
           */ 
          begin
            if (i < total_num_tran/4) begin
              `svt_xvm_debug("body",$sformatf("Sending Write type transactions from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d ", initiating_rn_node_idx_0, target_hn_node_idx_0));
            end
            else begin
              `svt_xvm_debug("body",$sformatf("Sending Write type transactions from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d ", initiating_rn_node_idx_0, target_hn_node_idx_1));
            end
            
            `svt_xvm_do_on_with(write_seq[2*i],p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
            {
            `ifdef SVT_CHI_ISSUE_B_ENABLE
             if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A || sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0) {
               seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL};
             }
             else{
               seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL, svt_chi_transaction::WRITEUNIQUEFULLSTASH, svt_chi_transaction::WRITEUNIQUEPTLSTASH};
             }
            `else
               seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL};
            `endif
             sequence_length               == 1;
             seq_txn_id                    == (i % (total_num_tran/2));
             /** Transactions are set to ordered at requestor for stream WriteUniques transactions. */
             seq_order_type   == svt_chi_transaction::NO_ORDERING_REQUIRED;
             if (perform_cache_initialization) {  
               hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
               min_addr          == addr_q[2*i];
               max_addr          == addr_q[2*i];
               seq_is_non_secure_access == secure_q[2*i];
               use_seq_is_non_secure_access == 1;
             }
             else {
               hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
               if (i < total_num_tran/4) {
                 seq_hn_node_idx == target_hn_node_idx_0;
               }
               else if(i < total_num_tran/2) {
                 seq_hn_node_idx == target_hn_node_idx_1;
               }
               use_seq_is_non_secure_access == 0;
             }

            })
           
            `svt_xvm_debug("body", $sformatf("%0s Transmitting Write Transaction [%0d] targeted to HN (idx %0d, id %0d) ",`SVT_CHI_PRINT_PREFIX(write_seq[2*i].write_tran),2*i, write_seq[2*i].write_tran.hn_node_idx, write_seq[2*i].write_tran.tgt_id));
            `svt_xvm_verbose("body", $sformatf("Write Transaction [%0d] is %0s", 2*i,write_seq[2*i].write_tran.sprint()));

          end
          begin
            if (i < total_num_tran/4) begin
              `svt_xvm_debug("body",$sformatf("Sending Write type transactions from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d ", initiating_rn_node_idx_1, target_hn_node_idx_0));
            end
            else begin
              `svt_xvm_debug("body",$sformatf("Sending Write type transactions from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d ", initiating_rn_node_idx_1, target_hn_node_idx_1));
            end
            
            `svt_xvm_do_on_with(write_seq[2*i + 1],p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,
            {
            `ifdef SVT_CHI_ISSUE_B_ENABLE
             if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision == svt_chi_node_configuration::ISSUE_A || sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 0) {
               seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL};
             }
             else{
               seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL, svt_chi_transaction::WRITEUNIQUEFULLSTASH, svt_chi_transaction::WRITEUNIQUEPTLSTASH};
             }
            `else
               seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL};
            `endif
             sequence_length               == 1;
             seq_txn_id                    == (i % (total_num_tran/2));
             /** Transactions are set to ordered at requestor for stream WriteUniques transactions. */
             seq_order_type   == svt_chi_transaction::NO_ORDERING_REQUIRED;
             if (perform_cache_initialization) {  
               hn_addr_rand_type             == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
               min_addr         == addr_q[2*i + 1];
               max_addr         == addr_q[2*i + 1];
               seq_is_non_secure_access == secure_q[2*i+1];
               use_seq_is_non_secure_access == 1;
             }
             else {
               hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
               if (i < total_num_tran/4) {
                 seq_hn_node_idx == target_hn_node_idx_0;
               }
               else if(i < total_num_tran/2) {
                 seq_hn_node_idx == target_hn_node_idx_1;
               }
               use_seq_is_non_secure_access == 0;
             } 

            })
           
           `svt_xvm_debug("body", $sformatf("%0s Transmitting Write Transaction [%0d] targeted to HN (idx %0d, id %0d) ",`SVT_CHI_PRINT_PREFIX(write_seq[2*i + 1].write_tran),2*i + 1, write_seq[2*i + 1].write_tran.hn_node_idx, write_seq[2*i + 1].write_tran.tgt_id));
           `svt_xvm_verbose("body", $sformatf("Write Transaction [%0d] is %0s", 2*i + 1,write_seq[2*i + 1].write_tran.sprint()));
          end
        join
      end // for (int i = 0; i < total_num_tran/2; i++)

      /** Waiting for the DBIDResp/CompDBDIResp responses from HN for write trasactions */
      foreach(write_seq[wr]) begin
        fork
          automatic int _wr = wr;
          begin
            `svt_xvm_debug("body", $sformatf("%0s Write transaction [%0d] targeted to HN (idx %0d, id %0d), suspend_wr_data %0b: waiting for response from interconnect",`SVT_CHI_PRINT_PREFIX(write_seq[_wr].write_tran),_wr, write_seq[_wr].write_tran.hn_node_idx, write_seq[_wr].write_tran.tgt_id,write_seq[_wr].write_tran.suspend_wr_data));
            fork
            begin
              fork
                begin
                  write_seq[_wr].write_tran.wait_for_tx_data_prereqs();
                end
                begin
                  wait(write_seq[_wr].write_tran.req_status == svt_chi_transaction::RETRY);// begin
                end
              join_any
              disable fork;
            end
            join
            received_responses++;
            `svt_xvm_debug("body", $sformatf("%0s Write transaction [%0d] targeted to HN (idx %0d, id %0d), suspend_wr_data %0b: received response from interconnect. Total responses received %0d",`SVT_CHI_PRINT_PREFIX(write_seq[_wr].write_tran),_wr, write_seq[_wr].write_tran.hn_node_idx, write_seq[_wr].write_tran.tgt_id,write_seq[_wr].write_tran.suspend_wr_data,received_responses));
          end
        join_none
      end

      /** Wait until All 512 DBIDResp/CompDBDIResp responses are received for write transaction */ 
      `svt_xvm_debug("body",$sformatf("Completed initiation of Write type transactions for %0d addresses from p_sequencer.rn_virt_seqr[%0d] and p_sequencer.rn_virt_seqr[%0d] to HN idx %0d and HN idx %0d with suspend_wr_data set to 1, and waiting to receive responses from interconnect.",
                                total_num_tran, initiating_rn_node_idx_0,initiating_rn_node_idx_1,target_hn_node_idx_0,target_hn_node_idx_1));
      wait(received_responses == total_num_tran);
      `svt_xvm_debug("body",$sformatf("Received responses from interconnect to Write type transactions for %0d addresses from p_sequencer.rn_virt_seqr[%0d] and p_sequencer.rn_virt_seqr[%0d] to HN idx %0d and HN idx %0d with suspend_wr_data set to 1.",
                                total_num_tran, initiating_rn_node_idx_0,initiating_rn_node_idx_1,target_hn_node_idx_0,target_hn_node_idx_1));
     
      /** Self Check1: To check suspend_wr_data should not be modified to zero by the VIP
       *  before reseting from test bench.
       */
      foreach (write_seq[self_check_idx1]) begin
        if (!write_seq[self_check_idx1].write_tran.is_terminated()) begin
          if (write_seq[self_check_idx1].write_tran.suspend_wr_data == 0) begin
            `svt_xvm_error("body", $sformatf("%0s suspend_wr_data should be 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(write_seq[self_check_idx1].write_tran)));
          end
          else begin
            `svt_xvm_debug("body", $sformatf("%0s suspend_wr_data is 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(write_seq[self_check_idx1].write_tran)));
          end
        end
      end
     
      /** Self Check2: To check transaction is not ended by the VIP before resuming the 
       *  suspend_wr_data to zero from the test bench
       */
      foreach(write_seq[self_check_idx2]) begin
        if (!write_seq[self_check_idx2].write_tran.is_terminated()) begin
          if (write_seq[self_check_idx2].write_tran.end_event.is_on() == 1) begin
            `svt_xvm_error("body", $sformatf("Unexpected: %0s Transaction's end_event triggered when suspend_wr_data is still 1.", `SVT_CHI_PRINT_PREFIX(write_seq[self_check_idx2].write_tran)));
          end
          else begin
            `svt_xvm_debug("body", $sformatf("Expected: %0s Transaction's end_event is not triggered when suspend_wr_data is still 1.", `SVT_CHI_PRINT_PREFIX(write_seq[self_check_idx2].write_tran)));
          end
        end
      end
 
      /** Self Check 3: To check that the current_outstanding_*_xact_count in the RNs
       * are as per the transactions inititated by the sequence
       */
      /** Check if the total outstanding xact counter is set correctly in the shared status of the RN agent */
      if(write_seq[0].shared_status.prot_status.current_outstanding_xact_count != total_num_tran/2)
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding transactions from the sequence but the outstanding transaction count in the shared status of RN%0d is %0d", total_num_tran/2, initiating_rn_node_idx_0, write_seq[0].shared_status.prot_status.current_outstanding_xact_count));
      /** Check if the outstanding Write xact counter is set correctly in the shared status of the RN agent */
      if(write_seq[0].shared_status.prot_status.current_outstanding_write_xact_count != total_num_tran/2) begin
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding Write transactions from the sequence but the outstanding Write transaction count in the shared status of RN%0d is %0d", total_num_tran/2, initiating_rn_node_idx_0, write_seq[0].shared_status.prot_status.current_outstanding_write_xact_count));
      end
      /** Check if the total outstanding xact counter is set correctly in the shared status of the second RN agent */
      if(write_seq[1].shared_status.prot_status.current_outstanding_xact_count != total_num_tran/2)
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding transactions from the sequence but the oustanding transaction count in the shared status of RN%0d is %0d", total_num_tran/2, initiating_rn_node_idx_1, write_seq[1].shared_status.prot_status.current_outstanding_xact_count));
      /** Check if the outstanding Write xact counter is set correctly in the shared status of the RN agent */
      if(write_seq[1].shared_status.prot_status.current_outstanding_write_xact_count != total_num_tran/2) begin
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding Write transactions from the sequence but the outstanding Write transaction count in the shared status of RN%0d is %0d", total_num_tran/2, initiating_rn_node_idx_1, write_seq[1].shared_status.prot_status.current_outstanding_write_xact_count));
      end

      `svt_xvm_debug("body", $sformatf("RN%0d: Number of outstanding transactions : %0d, Number of outstanding write xacts : %0d", initiating_rn_node_idx_0, write_seq[0].shared_status.prot_status.current_outstanding_xact_count, write_seq[0].shared_status.prot_status.current_outstanding_write_xact_count));
      `svt_xvm_debug("body", $sformatf("RN%0d: Number of outstanding transactions : %0d, Number of outstanding write xacts : %0d", initiating_rn_node_idx_1, write_seq[0].shared_status.prot_status.current_outstanding_xact_count, write_seq[1].shared_status.prot_status.current_outstanding_write_xact_count));

      /** Resuming all NonCopyBackWrData for above write transactions */
      `svt_xvm_debug("body",$sformatf("Resuming the write transactions by setting svt_chi_rn_transaction::suspsend_wr_data set to 0"))
      foreach(write_seq[index4]) begin
        write_seq[index4].write_tran.suspend_wr_data = 0;
          `svt_xvm_debug("body", $sformatf("After Resume received_responses is %0d for iteration %0d and suspend_wr_data is %0b",received_responses, index4, write_seq[index4].write_tran.suspend_wr_data));
      end
      
      /** Waiting for Write transactions to complete */
      `svt_xvm_debug("body",$sformatf("Waiting for completion of all the outstanding write type transactions"));
      foreach(write_seq[self_check_idx3]) begin
        `svt_xvm_debug("body", $sformatf("Waiting for above write_seq[%0d] transaction %0s to end", self_check_idx3, `SVT_CHI_PRINT_PREFIX(write_seq[self_check_idx3].write_tran)));
        write_seq[self_check_idx3].write_tran.wait_end();
      
        /** Self Check4: To check suspend_wr_data should not be asserted after the transaction 
         *  completes as it is reseted from test bench
         */
        if (!write_seq[self_check_idx3].write_tran.is_terminated()) begin
          if (write_seq[self_check_idx3].write_tran.suspend_wr_data == 1) begin
            `svt_xvm_error("body", $sformatf("%0s suspend_wr_data should be 0 as it has been reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(write_seq[self_check_idx3].write_tran)));
          end
          else begin
            `svt_xvm_debug("body", $sformatf("%0s suspend_wr_data is 0 as it is reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(write_seq[self_check_idx3].write_tran)));
          end
        end
      end
      `svt_xvm_debug("body",$sformatf("Received completions for all write type outstanding transactions"));
     
      // Targetted HN IDs from both RNs should be different. Currently, this self-check is only performed
      // the number of outstanding transactions to be issued to an HN is a multiple of 2,ie, total_num_tran is a multiple of 4
      if((total_num_tran % 4) == 0) begin
        for(int i = 0; i<total_num_tran/2; i++)begin
          int hn_idx_0, hn_idx_1;
          hn_idx_0 = sys_cfg.get_hn_idx(write_seq[2*i].output_xacts[0].addr);
          hn_idx_1 = sys_cfg.get_hn_idx(write_seq[2*i + 1].output_xacts[0].addr);
          if(i < total_num_tran/4) begin
            if ((hn_idx_0 == hn_idx_1) && (hn_idx_0 == target_hn_node_idx_0)) begin
            // pass
              `svt_xvm_debug("body", $sformatf("Targeted HN Index from both RNs are same as expected.  rn[%0d] to hn_idx[%0d], rn[%0d] to hn_idx[%0d] and they match with the target_hn_node_idx_0 %0d", initiating_rn_node_idx_0, hn_idx_0, initiating_rn_node_idx_1, hn_idx_1,target_hn_node_idx_0));
            end
            else begin
            // fail
              `svt_xvm_error("body", $sformatf("Targeted HN Index from one or both of the RNs are different from first target node index, which is unexpected.  rn[%0d] %0s transaction to hn_idx[%0d], rn[%0d] %0s transaction to hn_idx[%0d] and the target_hn_node_idx_0 is %0d", initiating_rn_node_idx_0, `SVT_CHI_PRINT_PREFIX( write_seq[2*i].output_xacts[0]), hn_idx_0, initiating_rn_node_idx_1, `SVT_CHI_PRINT_PREFIX( write_seq[2*i + 1].output_xacts[0]), hn_idx_1,target_hn_node_idx_0));
            end
          end
          else if(i < total_num_tran/2) begin
            if ((hn_idx_0 == hn_idx_1) && (hn_idx_0 == target_hn_node_idx_1)) begin
            // pass
              `svt_xvm_debug("body", $sformatf("Targeted HN Index from both RNs are same as expected.  rn[%0d] to hn_idx[%0d], rn[%0d] to hn_idx[%0d] and they match with the target_hn_node_idx_1 %0d", initiating_rn_node_idx_0, hn_idx_0, initiating_rn_node_idx_1, hn_idx_1,target_hn_node_idx_1));
            end
            else begin
              // fail
              `svt_xvm_error("body", $sformatf("Targeted HN Index from one or both of the RNs is different from second target node index, which is unexpected.  rn[%0d] %0s transaction to hn_idx[%0d], rn[%0d] %0s transaction to hn_idx[%0d] and the target_hn_node_idx_1 is %0d", initiating_rn_node_idx_0, `SVT_CHI_PRINT_PREFIX( write_seq[2*i].output_xacts[0]), hn_idx_0, initiating_rn_node_idx_1, `SVT_CHI_PRINT_PREFIX( write_seq[2*i + 1].output_xacts[0]), hn_idx_1,target_hn_node_idx_1));
            end
          end
        end
      end
      
      /** Reset received_responses to zero */
      received_responses = 0;
      
      /** Delete the contents of address collection queue */
      addr_q.delete();
    
    end //for(int k = 0; k < sequence_length; k++)
    
    `svt_xvm_debug("body", "Exiting...")
  endtask: body

  virtual task post_body();
    drop_phase_objection();
  endtask

endclass: svt_chi_system_protocol_flow_ctrl_write_outstanding_diff_rn_diff_hn_virtual_sequence

function svt_chi_system_protocol_flow_ctrl_write_outstanding_diff_rn_diff_hn_virtual_sequence::new(string name="svt_chi_system_protocol_flow_ctrl_write_outstanding_diff_rn_diff_hn_virtual_sequence");
  super.new(name);
endfunction
//------------------------------------------------------------------------------------------------------

`ifdef SVT_CHI_ISSUE_E_ENABLE
/** 
 * @groupname CHI_OUTSTANDING_WR_TYPE 
 * #- This sequence requires at least one HN node to be present in the Interconnect.
 * #- This sequence requires one initiating active and participating RN.
 * #- If another active and participating RN-F exists, perform cache
 *    initialization to a randomly selected HN.
 * #- Initiate maximum number of Write type transactions with 
 *    svt_chi_rn_transaction::suspend_wr_data set  to 1 from initiating RN to randomly 
 *    selected HN in non blocking mode. <br>
 *    - Maximum number of outstanding transactions at the HN is as per either #max_num_outstanding_write_xacts_at_hn or
 *      #max_num_outstanding_xacts_at_hn, which can be controlled through config DB.   
 *    - This ensures that the maximum outstanding transaction limit is reached at the HN. 
 *    - Also, the RN will not transmit NonCopyBackWrData corresponding to these transactions
 *      until svt_chi_rn_transaction::suspend_wr_data is set to 0 from the seqeunce.
 *    .
 * #- The addresses of these write transactions are such that:
 *    - Same as initialized cache line addresses if cache initialization is performed
 *    - Otherwise, random addresses targeting the same HN
 *    .
 * #- Once the RN receives the responses for all the outstanding transactions from
 *    HN, svt_chi_rn_transaction::suspend_wr_data is set to 0 for all the outstanding
 *    transactions. <br>
 *    This ensures that the NonCopyBackWrData for these transactions can be resumed 
 *    from RN.
 * #- Check that the HN responds properly for all outstanding write type transactions
 *    and these are completed successfully.
 * .
 */ 

class svt_chi_system_chi_e_protocol_flow_ctrl_combined_noncopyback_write_cmo_outstanding_same_rn_same_hn_virtual_sequence extends svt_chi_system_base_virtual_sequence;
  
  //-----------------------------------------------------------------------------  
  // Member attributes
  //-----------------------------------------------------------------------------  

  /** To display contents of Active Participating RN's node info. */
  string str_rn_node;

  /** To display contents of Active Participating RN-F's node info. */
  string str_rn_f_node;

  /** UVM/OVM Object Utility macro */
  `svt_xvm_object_utils(svt_chi_system_chi_e_protocol_flow_ctrl_combined_noncopyback_write_cmo_outstanding_same_rn_same_hn_virtual_sequence)
  
  //-----------------------------------------------------------------------------  
  // Methods
  //-----------------------------------------------------------------------------
  /** Constructor */
  extern function new(string name="svt_chi_system_chi_e_protocol_flow_ctrl_combined_noncopyback_write_cmo_outstanding_same_rn_same_hn_virtual_sequence");

  //-----------------------------------------------------------------------------
  /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting any type of Request Nodes = 1
   *  #- Minimum required number of HN Nodes = 1   
   *  .
   */
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    
    /** local variables */
    int num_supporting_request_nodes;
    int num_hn_f_nodes;   
    int array_idx;
    bit is_rn_idx_0_participating;
    string str_is_supported_info_prefix = "";
    string str_is_supported_info = "";
    string str_idx0_info = "";
    /** Supporting any type of Request Nodes required */
    int required_num_supporting_request_nodes = 1;
    int required_num_hn_nodes = 1;
    
    `svt_xvm_debug("is_supported",$sformatf("Entering ..."));

    /** By default is_supported is 0 */
    is_supported = 0;

    /** Check for minimum required HN nodes */
    num_hn_f_nodes = hn_f_nodes.size();
    
    /** Check requirment of number of HN nodes needed */
    if (num_hn_f_nodes < required_num_hn_nodes) begin
      issue_is_supported_failure($sformatf("This sequence requires minimum %0d HN-F nodes to be present in the system. Number of HN-F nodes are %0d. Program number of HN nodes using svt_chi_system_configuration::num_hn. Program the HN interface type using svt_chi_system_configuration::chi_addr_cfg.hn_interface_type[].", required_num_hn_nodes, num_hn_f_nodes));
      return 0;      
    end
    
    /** Check for minimum required RN nodes.
     *  Also check whether the selected RN nodes are part of participating arrays or not.
     */    
    num_supporting_request_nodes = active_participating_rn_nodes.size();

    /** Check the requirements of RN nodes */
    if (num_supporting_request_nodes) begin
      /** Display the contents of Active Participating RN Nodes */
      foreach (active_participating_rn_nodes[j]) begin
        str_rn_node = {str_rn_node, $sformatf(" %0d", active_participating_rn_nodes[j])};
      end 
      `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_nodes are %0s", str_rn_node));
    end

    str_is_supported_info_prefix = $sformatf("Number of Supporting RN Node(s)  - Minimum Required : %0d Current : %0d", required_num_supporting_request_nodes, num_supporting_request_nodes);
    
    if ((initiating_rn_node_index_0_status==0)&&(valid_initiating_rn_node_index_0==0)) begin
        str_idx0_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN's that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F or RN_I)";
    end
    else begin
      is_rn_idx_0_participating = is_value_found_in_int_assoc_array(active_participating_rn_nodes, initiating_rn_node_idx_0, array_idx);
      if (!is_rn_idx_0_participating) begin
        str_idx0_info = $sformatf("initiating_rn_node_idx_0 %0d is not valid for this sequence. The RN corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuration::participating_rn_nodes[])", initiating_rn_node_idx_0, initiating_rn_node_idx_0);
      end
    end

    if (is_rn_idx_0_participating) begin
      is_supported = 1;
      if(max_num_outstanding_write_xacts_at_hn > 0) begin
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].num_outstanding_write_xact < max_num_outstanding_write_xacts_at_hn) begin
          str_idx0_info = $sformatf("Programmed value of max_num_outstanding_write_xacts_at_hn_status is %0d. But num_outstanding_write_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_write_xact of the initiating RN node must be equal to or greater than max_num_outstanding_write_xacts_at_hn_status of the target HN", max_num_outstanding_write_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_0_participating].num_outstanding_write_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
      end else begin
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].num_outstanding_xact < max_num_outstanding_xacts_at_hn) begin
          str_idx0_info = $sformatf("Programmed value of max_num_outstanding_xacts_at_hn_status is %0d. But num_outstanding_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_xact of the initiating RN node must be equal to or greater than max_num_outstanding_xacts_at_hn of the target HN", max_num_outstanding_xacts_at_hn, sys_cfg.rn_cfg[initiating_rn_node_idx_0].num_outstanding_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
      end
    end

    //check for spec version
    if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision < svt_chi_node_configuration::ISSUE_E) begin
      is_supported = 0;
      str_idx0_info = {str_idx0_info, "\n", $sformatf("svt_chi_node_configuration::chi_spec_revision is not set to svt_chi_node_configuration::ISSUE_E or later for initiating requester node %0d. This sequence is only applicable when svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_E or later ", initiating_rn_node_idx_0)};
    end 
    //check if cache stashing is disabled for this sequence
    if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable ==1) begin
      is_supported =0;
      str_idx0_info = {str_idx0_info, "\n", $sformatf("This sequence doesn't support cache stashing. Set cache_stashing_enable to 0 for RN %0d. This sequence is only applicable when svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_E or later ", initiating_rn_node_idx_0)};
    end
    
    if (!is_supported) begin
      str_is_supported_info = $sformatf("%0s",str_idx0_info);
      if (is_rn_idx_0_participating) begin
        issue_is_supported_failure($sformatf("This sequence cannot be run based on the current system configuration.\n\
                                              %0s\n\
                                              %0s \n\
                                              Modify configurations through \n\
                                              svt_chi_system_configuration::num_rn,\n\
                                              svt_chi_node_configuration::is_active,\n\
                                              svt_chi_system_configuration::participating_rn_nodes[]\n\
                                              ", str_is_supported_info_prefix, str_is_supported_info));
      end
      else begin
        issue_is_supported_failure($sformatf("This sequence cannot be run based on the current node configurations of RN%0d\n\
                                              %0s \n\
                                              Modify configuration through \n\
                                              svt_chi_node_configuration::num_outstanding_xact,\n\
                                              svt_chi_node_configuration::num_outstanding_write_xact,\n\
                                              ",str_is_supported_info, initiating_rn_node_idx_0));
      end
    end
  
    `svt_xvm_debug("is_supported",$sformatf("Exiting ..."));
    if (!is_target_hn_idx_valid_for_curr_cfg()) begin
      is_supported = 0;
      `svt_xvm_note("is_supported", "not a valid hn_idx based on random_tgt_id_enable for current cfg");
    end
  endfunction : is_supported

  virtual task pre_start();
    `svt_xvm_debug("pre_start",$sformatf("Entering ..."));
    super.pre_start();
    raise_phase_objection();
  endtask // pre_start

  virtual task body();
    /** Queue of addresses, used by the transactions generated */
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0] addr_q[$];
    bit seq_is_non_secure_access_q[$];
    /** Flag to track whether cache initialization needs to be performed or not*/
    bit                                perform_cache_initialization;
    int                                array_idx;
    int                                num_outstanding_xacts_to_generate;
    /** Metric variables */
    int received_responses = 0;

    int pgroup_id_arr[$];
    int pgroup_id_width=`SVT_CHI_PGROUPID_WIDTH;
    
    /** Sub Write type transaction directed sequences initiated from this sequence */
    svt_chi_rn_write_type_transaction_directed_sequence write_seq[int];
    /** Sub Read type transaction cache initialization directed sequences initiated from this sequence */
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq[int];

    `svt_xvm_debug("body", "Entering ...")
    super.body();

    max_num_outstanding_xacts_at_hn_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(), "max_num_outstanding_xacts_at_hn", max_num_outstanding_xacts_at_hn);
    max_num_outstanding_write_xacts_at_hn_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(), "max_num_outstanding_write_xacts_at_hn", max_num_outstanding_write_xacts_at_hn);

    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :initiating_rn_node_idx_0;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_node_index_0;

    `svt_xvm_debug("body", $sformatf("max_num_outstanding_xacts_at_hn is %0d as a result of %0s.", max_num_outstanding_xacts_at_hn, max_num_outstanding_xacts_at_hn_status ? "config DB" : "default"));
    `svt_xvm_debug("body", $sformatf("max_num_outstanding_write_xacts_at_hn is %0d as a result of %0s.", max_num_outstanding_write_xacts_at_hn, max_num_outstanding_write_xacts_at_hn_status ? "config DB" : "default"));
    `svt_xvm_debug("body", $sformatf("initiating_rn_node_idx_0 is %0d as a result of %0s.", initiating_rn_node_idx_0, initiating_rn_node_index_0_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("target_hn_node_idx_0 is %0d as a result of %0s.", target_hn_node_idx_0, target_hn_node_index_0_status ? "config DB" : "Randomization"));

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /**
     * If the cache_line_init_rn_f_node_index is same as the RN node index 
     * which are passed through config i.e initiating_rn_node_idx_0,
     * then re-assign the cache_line_init_rn_f_node_index with RN node index ,which is active,
     * participating and not equal to initiating_rn_node_idx_0.
     */
    if(initiating_rn_node_index_0_status)begin  
      if((cache_line_init_rn_f_node_index == initiating_rn_node_idx_0))begin  
        int active_participating_q [$];
        `svt_chi_xxm_debug("body",$sformatf("cache_line_init_rn_f_node_index= %0d is same as initiating_rn_node_idx_0=%0d and active_participating_rn_f_nodes.size()= %0d",cache_line_init_rn_f_node_index,initiating_rn_node_idx_0,active_participating_rn_f_nodes.size()));
        if(active_participating_rn_f_nodes.size()>1)begin
          active_participating_q = active_participating_rn_f_nodes.find with (item != initiating_rn_node_idx_0);
          cache_line_init_rn_f_node_index = active_participating_q.pop_back();
          `svt_chi_xxm_debug("body", $sformatf("active_participating_q.size() is %0d and Selected different cache_line_init_rn_f_node_index=%0d", active_participating_q.size(),cache_line_init_rn_f_node_index));
          active_participating_q.delete();
        end else begin
          perform_cache_initialization=0;
          `svt_chi_xxm_debug("body",$sformatf("BYPASSING Cache Initialization as selected cache_line_init_rn_f_node_index= %0d is same as initiating_rn_node_index_0_from_config_db=%0d and active_participating_rn_f_nodes.size()= %0d",cache_line_init_rn_f_node_index,initiating_rn_node_index_0_from_config_db,active_participating_rn_f_nodes.size()));
        end
      end  
    end 

    // If the cache_line_init_rn_f_node_index is part of active_participating_rn_f_nodes array, and
    // it is not equal to initiating_rn_node_idx_0; then we can
    // perform cache initialization from the RN[cache_line_init_rn_f_node_index].
    if ((is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, cache_line_init_rn_f_node_index, array_idx)) &&
        (cache_line_init_rn_f_node_index != initiating_rn_node_idx_0)) begin
      perform_cache_initialization = 1;
    end
    
    `svt_xvm_debug("body", $sformatf("perform_cache_initialization is %0b, cache_line_init_rn_f_node_index is %0d, initiating_rn_node_idx_0 is %0d", perform_cache_initialization, cache_line_init_rn_f_node_index, initiating_rn_node_idx_0));    

    //If max outstanding count for Write transactions has been programmed, use that to generate the outstanding Writes
    if(max_num_outstanding_write_xacts_at_hn > 0) begin
      num_outstanding_xacts_to_generate = max_num_outstanding_write_xacts_at_hn;
      `svt_xvm_debug("body",$sformatf("max_num_outstanding_write_xacts_at_hn is set to a non-zero value (%0d). Hence, the value programmed in max_num_outstanding_xacts_at_hn will be ignored. The number of outstanding transactions issued by the sequence will be equal to max_num_outstanding_write_xacts_at_hn", max_num_outstanding_write_xacts_at_hn));
    end
    //If not, use the max outstanding transaction count
    else
      num_outstanding_xacts_to_generate = max_num_outstanding_xacts_at_hn;

    for(int k = 0; k < sequence_length; k++) begin
      
      for(int id=0; id < (2**`SVT_CHI_PGROUPID_WIDTH); id++) begin
        pgroup_id_arr.push_back(id);
      end
      pgroup_id_arr.shuffle;

      `svt_xvm_debug("body", $sformatf("cache_line_init_rn_f_node_index is %0d,initiating_rn_node_idx_0 is %0d" ,cache_line_init_rn_f_node_index, initiating_rn_node_idx_0));

      if(perform_cache_initialization) begin
        
        `svt_xvm_debug("body",$sformatf("Starting cache initialization for %0d addresses from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d",num_outstanding_xacts_to_generate, cache_line_init_rn_f_node_index, target_hn_node_idx_0));
      
        for(int i = 0; i < num_outstanding_xacts_to_generate; i++) begin     
          /** Write data into Cache of Randomly selected first RN-F with address of randomly selected HN Node */
          `svt_xvm_do_on_with(makeunique_seq[i],p_sequencer.rn_virt_seqr[cache_line_init_rn_f_node_index].rn_xact_seqr,
          {
            sequence_length   == 1;
            set_unique_addr_value    == 1;
            hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
            seq_hn_node_idx   == target_hn_node_idx_0;
            use_seq_is_non_secure_access == 0;
          })
          
          `svt_xvm_debug("body", $sformatf("%0s Waiting for MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) to end",`SVT_CHI_PRINT_PREFIX(makeunique_seq[i].write_tran),i, makeunique_seq[i].write_tran.hn_node_idx, makeunique_seq[i].write_tran.tgt_id));
          makeunique_seq[i].write_tran.wait_end();
          `svt_xvm_debug("body", $sformatf("%0s MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) ended",`SVT_CHI_PRINT_PREFIX(makeunique_seq[i].write_tran),i, makeunique_seq[i].write_tran.hn_node_idx, makeunique_seq[i].write_tran.tgt_id));
          /** Queue for collecting the address of makeunique transactions */
          addr_q.push_back(makeunique_seq[i].output_xacts[0].addr);
          seq_is_non_secure_access_q.push_back(makeunique_seq[i].output_xacts[0].is_non_secure_access);
          `svt_xvm_verbose("body", $sformatf("MakeUnique transaction [%0d] is %0s", i,makeunique_seq[i].write_tran.sprint()));
        end
        
      end// if (perform_cache_initialization)

      `svt_xvm_debug("body",$sformatf("Starting transmission of Write type transactions for %0d addresses from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d with suspend_wr_data set to 1",
                                      num_outstanding_xacts_to_generate, initiating_rn_node_idx_0, target_hn_node_idx_0));
      
      for(int i = 0; i < num_outstanding_xacts_to_generate; i++) begin 
        automatic int pgroup_id   = pgroup_id_arr.pop_front();
        `svt_xvm_debug("body", $sformatf("initiating_rn_node_idx_0 is %0d",initiating_rn_node_idx_0));
        /** 
          * Do WRITE transactions from same RN to the MAKEUNIQUE 
          * transaction addresses of same HN-F node in case of 
          * initialization or select the randomly selected HN-F 
          * if initialization is not necessary.  
          */ 
        `svt_xvm_do_on_with(write_seq[i],p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
          {
           if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].cleansharedpersistsep_xact_enable == 1) {
             seq_xact_type inside {svt_chi_transaction::WRITENOSNPFULL_CLEANSHARED, svt_chi_transaction::WRITENOSNPFULL_CLEANINVALID, svt_chi_transaction::WRITENOSNPPTL_CLEANSHARED, svt_chi_transaction::WRITENOSNPFULL_CLEANSHAREDPERSISTSEP, svt_chi_transaction::WRITENOSNPPTL_CLEANSHAREDPERSISTSEP, svt_chi_transaction::WRITENOSNPPTL_CLEANINVALID,svt_chi_transaction::WRITEUNIQUEFULL_CLEANSHARED, svt_chi_transaction::WRITEUNIQUEFULL_CLEANSHAREDPERSISTSEP,svt_chi_transaction::WRITEUNIQUEPTL_CLEANSHARED,svt_chi_transaction::WRITEUNIQUEPTL_CLEANSHAREDPERSISTSEP};
             seq_pgroup_id == pgroup_id;
           }
           else {
             seq_xact_type inside {svt_chi_transaction::WRITENOSNPFULL_CLEANSHARED, svt_chi_transaction::WRITENOSNPFULL_CLEANINVALID, svt_chi_transaction::WRITENOSNPPTL_CLEANSHARED, svt_chi_transaction::WRITENOSNPPTL_CLEANINVALID,svt_chi_transaction::WRITEUNIQUEFULL_CLEANSHARED, svt_chi_transaction::WRITEUNIQUEPTL_CLEANSHARED};
           }
           sequence_length    == 1;
           seq_txn_id         == (i*3);
           seq_order_type     == svt_chi_transaction::NO_ORDERING_REQUIRED;
           if(perform_cache_initialization) {
             hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
             min_addr         == addr_q[i];
             max_addr         == addr_q[i];
             seq_is_non_secure_access == seq_is_non_secure_access_q[i]; 
             use_seq_is_non_secure_access == 1;
           }
           else {
             hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
             seq_hn_node_idx    == target_hn_node_idx_0;
             use_seq_is_non_secure_access == 0;
           }
          })
           
          `svt_xvm_debug("body", $sformatf("%0s Transmitting Write Transaction [%0d] targeted to HN (idx %0d, id %0d) ",`SVT_CHI_PRINT_PREFIX(write_seq[i].write_tran),i, write_seq[i].write_tran.hn_node_idx, write_seq[i].write_tran.tgt_id));
          `svt_xvm_verbose("body", $sformatf("Write Transaction [%0d] is %0s", i,write_seq[i].write_tran.sprint()));
          
      end

      /** Waiting for the DBIDResp/CompDBDIResp responses from HN for write trasactions */
      foreach(write_seq[wr]) begin
        fork
          automatic int _wr = wr;
          begin
            `svt_xvm_debug("body", $sformatf("%0s Write transaction [%0d] targeted to HN (idx %0d, id %0d), suspend_wr_data %0b: waiting for response from interconnect",`SVT_CHI_PRINT_PREFIX(write_seq[_wr].write_tran),_wr, write_seq[_wr].write_tran.hn_node_idx, write_seq[_wr].write_tran.tgt_id,write_seq[_wr].write_tran.suspend_wr_data));
            fork
            begin
              fork
                begin
                  write_seq[_wr].write_tran.wait_for_tx_data_prereqs();
                end
                begin
                  wait(write_seq[_wr].write_tran.req_status == svt_chi_transaction::RETRY);// begin
                end
              join_any
              disable fork;
            end
            join
            received_responses++;
            `svt_xvm_debug("body", $sformatf("%0s Write transaction [%0d] targeted to HN (idx %0d, id %0d), suspend_wr_data %0b: received response from interconnect. Total responses received %0d",`SVT_CHI_PRINT_PREFIX(write_seq[_wr].write_tran),_wr, write_seq[_wr].write_tran.hn_node_idx, write_seq[_wr].write_tran.tgt_id,write_seq[_wr].write_tran.suspend_wr_data,received_responses));
          end
        join_none
      end

      /** Wait until All DBIDResp/CompDBDIResp responses are received for write transaction */ 
      `svt_xvm_debug("body",$sformatf("Completed initiation of Write type transactions for %0d addresses from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d with suspend_wr_data set to 1, and waiting to receive responses from interconnect.",
                                num_outstanding_xacts_to_generate, initiating_rn_node_idx_0,target_hn_node_idx_0));
      wait(received_responses == num_outstanding_xacts_to_generate);
      outstanding_xact_count_reached = 1;
      `svt_xvm_debug("body",$sformatf("Received responses from interconnect to Write type transactions for %0d addresses from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d with suspend_wr_data set to 1.",
                                num_outstanding_xacts_to_generate, initiating_rn_node_idx_0,target_hn_node_idx_0));
     
      /** Self Check1: To check suspend_wr_data should not be modified to zero by the VIP
       * before reseting from test bench
       */
      foreach (write_seq[self_check_idx1]) begin
        if (!write_seq[self_check_idx1].write_tran.is_terminated()) begin
          if (write_seq[self_check_idx1].write_tran.suspend_wr_data == 0) begin
            `svt_xvm_error("body", $sformatf("%0s suspend_wr_data should be 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(write_seq[self_check_idx1].write_tran)));
          end
          else begin
            `svt_xvm_debug("body", $sformatf("%0s suspend_wr_data is 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(write_seq[self_check_idx1].write_tran)));
          end
        end
      end

      /** Self Check2: To check transaction is not ended by the VIP before resuming the 
       *  suspend_wr_data to zero from the test bench
       */
      foreach(write_seq[self_check_idx2]) begin
        if (!write_seq[self_check_idx2].write_tran.is_terminated()) begin
          if (write_seq[self_check_idx2].write_tran.end_event.is_on() == 1) begin
            `svt_xvm_error("body", $sformatf("Unexpected: %0s Transaction's end_event triggered when suspend_wr_data is still 1.", `SVT_CHI_PRINT_PREFIX(write_seq[self_check_idx2].write_tran)));
          end
          else begin
            `svt_xvm_debug("body", $sformatf("Expected: %0s Transaction's end_event is not triggered when suspend_wr_data is still 1.", `SVT_CHI_PRINT_PREFIX(write_seq[self_check_idx2].write_tran)));
          end
        end
      end
 
      /** Self Check 3: To check that the current_outstanding_*_xact_count in the RNs
       * are as per the transactions inititated by the sequence
       */
      /** Check if the total outstanding xact counter is set correctly in the shared status of the RN agent */
      if(write_seq[0].shared_status.prot_status.current_outstanding_xact_count != num_outstanding_xacts_to_generate)
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding transactions from the sequence but the outstanding transaction count in the shared status of RN%0d is %0d", num_outstanding_xacts_to_generate, initiating_rn_node_idx_0, write_seq[0].shared_status.prot_status.current_outstanding_xact_count));
      /** Check if the outstanding Write xact counter is set correctly in the shared status of the RN agent */
      if(write_seq[0].shared_status.prot_status.current_outstanding_write_xact_count != num_outstanding_xacts_to_generate) begin
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding Write transactions from the sequence but the outstanding Write transaction count in the shared status of RN%0d is %0d", num_outstanding_xacts_to_generate, initiating_rn_node_idx_0, write_seq[0].shared_status.prot_status.current_outstanding_write_xact_count));
      end

      `svt_xvm_debug("body", $sformatf("RN%0d: Number of outstanding transactions : %0d, Number of outstanding write xacts : %0d", initiating_rn_node_idx_0, write_seq[0].shared_status.prot_status.current_outstanding_xact_count, write_seq[0].shared_status.prot_status.current_outstanding_write_xact_count));

      if(use_seq_flag_to_resume_response_for_outstanding_xact) begin
        `svt_xvm_debug("body",$sformatf("Waiting for resume_response_for_outstanding_xact to be set to 1"));
        wait(resume_response_for_outstanding_xact == 1);
        `svt_xvm_debug("body",$sformatf("resume_response_for_outstanding_xact is set to 1"));
      end

      /** Resuming all NonCopyBackWrData for above write transactions */
      `svt_xvm_debug("body",$sformatf("Resuming the write transactions by setting svt_chi_rn_transaction::suspend_wr_data set to 0"))
      foreach(write_seq[index4]) begin
        write_seq[index4].write_tran.suspend_wr_data = 0;
        `svt_xvm_debug("body", $sformatf("After Resume received_responses is %0d for iteration %0d and suspend_wr_data is %0b",received_responses, index4, write_seq[index4].write_tran.suspend_wr_data));
      end
     
      /** Waiting for Write transactions to complete*/
      `svt_xvm_debug("body",$sformatf("Waiting for completion of all the outstanding write type transactions"));
      foreach(write_seq[self_check_idx3]) begin
        `svt_xvm_debug("body", $sformatf("Waiting for above write_seq[%0d] transaction %0s to end", self_check_idx3, `SVT_CHI_PRINT_PREFIX(write_seq[self_check_idx3].write_tran)));
        write_seq[self_check_idx3].write_tran.wait_end();

        /** Self Check4: To check suspend_wr_data should not be asserted after the transaction
         *  completes as it is reseted from test bench
         */
        if (!write_seq[self_check_idx3].write_tran.is_terminated()) begin
          if (write_seq[self_check_idx3].write_tran.suspend_wr_data == 1) begin
            `svt_xvm_error("body", $sformatf("%0s suspend_wr_data should be 0 as it has been reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(write_seq[self_check_idx3].write_tran)));
          end
          else begin
            `svt_xvm_debug("body", $sformatf("%0s suspend_wr_data is 0 as it is reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(write_seq[self_check_idx3].write_tran)));
          end
        end
      end
      `svt_xvm_debug("body",$sformatf("Received completions for all write type outstanding transactions"));

      /** Targetted HN ID from the RN should be same throughout*/
      foreach(write_seq[wr]) begin
        int hn_idx_0;
        hn_idx_0 = sys_cfg.get_hn_idx(write_seq[wr].output_xacts[0].addr);
        if (hn_idx_0 == target_hn_node_idx_0) begin
          `svt_xvm_debug("body", $sformatf("Targeted HN Index from the RN is same as expected.  rn[%0d] to hn_idx[%0d] and it matches target_hn_node_idx_0 %0d", initiating_rn_node_idx_0, hn_idx_0,target_hn_node_idx_0));
        end
        else begin
          `svt_xvm_error("body", $sformatf("Targeted HN Index from the RN is different, which is unexpected.  rn[%0d] %0s transaction to hn_idx[%0d] and it doesn't match target_hn_node_idx_0 %0d", 
                                           initiating_rn_node_idx_0, `SVT_CHI_PRINT_PREFIX( write_seq[wr].output_xacts[0]), hn_idx_0,target_hn_node_idx_0));
        end
      end
            
      /** Reset received_responses to Zero */
      received_responses = 0;

      /** Delete the contents of address collection queue */
      addr_q.delete();

    end//sequence_length
    
  `svt_xvm_debug("body", "Exiting...")
  endtask: body

  virtual task post_body();
    drop_phase_objection();
  endtask

endclass: svt_chi_system_chi_e_protocol_flow_ctrl_combined_noncopyback_write_cmo_outstanding_same_rn_same_hn_virtual_sequence

function svt_chi_system_chi_e_protocol_flow_ctrl_combined_noncopyback_write_cmo_outstanding_same_rn_same_hn_virtual_sequence::new(string name="svt_chi_system_chi_e_protocol_flow_ctrl_combined_noncopyback_write_cmo_outstanding_same_rn_same_hn_virtual_sequence");
  super.new(name);
endfunction
//-------------------------------------------------------------------------------------------------------------------

/** 
 * @groupname CHI_OUTSTANDING_WR_TYPE  
 * #- This sequence requires at least one HN node to be present in the Interconnect.
 * #- This sequence requires two initiating active and participating RN.
 * #- If another active and participating RN-F exists, perform cache
 *    initialization to a randomly selected HN.
 * #- Initiate 128 Write type transactions with 
 *    svt_chi_rn_transaction::suspend_wr_data set to 1 from each of the two initiating RNs to the randomly 
 *    selected HN in non blocking mode. <br>
 *    - Maximum number of outstanding transactions at the HN is as per either #max_num_outstanding_write_xacts_at_hn or
 *      #max_num_outstanding_xacts_at_hn, which can be controlled through config DB.   
 *    - This ensures that the maximum outstanding transaction limit is reached at the HN.
 *    - Also, both the RNs will not transmit NonCopyBackWrData corresponding to these transactions
 *      until svt_chi_rn_transaction::suspend_wr_data is set to 0 from the seqeunce.
 *    .
 * #- The addresses of these write transactions are such that:
 *    - Same as initialized cache line addresses if cache initialization is performed
 *    - Otherwise, random addresses targeting the same HN
 *    .
 * #- Once the RNs receive the responses for all the outstanding transactions from
 *    HN, svt_chi_rn_transaction::suspend_wr_data is set to 0 for all the outstanding
 *    transactions. <br>
 *    This ensures that the NonCopyBackWrData for these transactions can be resumed 
 *    from both the RNs.
 * #- Check that the HN responds properly for all outstanding write type transactions
 *    and these are completed successfully.
 * .
 */

class svt_chi_system_chi_e_protocol_flow_ctrl_combined_noncopyback_write_cmo_outstanding_diff_rn_same_hn_virtual_sequence extends svt_chi_system_base_virtual_sequence;
  
  //-----------------------------------------------------------------------------  
  // Member attributes
  //-----------------------------------------------------------------------------  

  /** To display contents of Active Participating RN's node info. */
  string str_rn_node;

  /** To display contents of Active Participating RN-F's node info. */
  string str_rn_f_node;

  /** UVM/OVM Object Utility macro */
  `svt_xvm_object_utils(svt_chi_system_chi_e_protocol_flow_ctrl_combined_noncopyback_write_cmo_outstanding_diff_rn_same_hn_virtual_sequence)
  
  //-----------------------------------------------------------------------------  
  // Methods
  //-----------------------------------------------------------------------------
  /** Constructor */
  extern function new(string name="svt_chi_system_chi_e_protocol_flow_ctrl_combined_noncopyback_write_cmo_outstanding_diff_rn_same_hn_virtual_sequence");
  
  //-----------------------------------------------------------------------------
  /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting any type of Request Nodes = 2
   *  #- Minimum required number of HN Nodes = 1   
   *  .
   */
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    
    /** local variables */
    int num_supporting_request_nodes;
    int num_hn_f_nodes;   
    int array_idx;
    bit is_rn_idx_0_participating, is_rn_idx_1_participating;
    string str_is_supported_info_prefix = "";
    string str_is_supported_info = "";
    string str_idx0_info = "";
    string str_idx1_info = "";    
    /** Supporting any type of Request Nodes required */
    int required_num_supporting_request_nodes = 2;
    int required_num_hn_nodes = 1;
    
    `svt_xvm_debug("is_supported",$sformatf("Entering ..."));

    /** By default is_supported is 0 */
    is_supported = 0;

    /** Check for minimum required HN nodes */
    num_hn_f_nodes = hn_f_nodes.size();
    
    /** Check requirment of number of HN nodes needed */
    if (num_hn_f_nodes < required_num_hn_nodes) begin
      issue_is_supported_failure($sformatf("This sequence requires minimum %0d HN-F nodes to be present in the system. Number of HN-F nodes are %0d. Program number of HN nodes using svt_chi_system_configuration::num_hn. Program the HN interface type using svt_chi_system_configuration::chi_addr_cfg.hn_interface_type[].", required_num_hn_nodes, num_hn_f_nodes));
      return 0;      
    end
    
    /** Check for minimum required RN nodes.
     *  Also check whether the selected RN nodes are part of participating arrays or not.
     */    
    num_supporting_request_nodes = active_participating_rn_nodes.size();

    /** Check the requirements of RN nodes */
    if (num_supporting_request_nodes) begin
      /** Display the contents of Active Participating RN Nodes */
      foreach (active_participating_rn_nodes[j]) begin
        str_rn_node = {str_rn_node, $sformatf(" %0d", active_participating_rn_nodes[j])};
      end 
      `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_nodes are %0s", str_rn_node));
    end

    str_is_supported_info_prefix = $sformatf("Number of Supporting RN Node(s)  - Minimum Required : %0d Current : %0d", required_num_supporting_request_nodes, num_supporting_request_nodes);
    
    if ((initiating_rn_node_index_0_status==0)&&(valid_initiating_rn_node_index_0==0)) begin
        str_idx0_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN's that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F or RN_I)";
    end
    else begin
      is_rn_idx_0_participating = is_value_found_in_int_assoc_array(active_participating_rn_nodes, initiating_rn_node_idx_0, array_idx);
      if (!is_rn_idx_0_participating) begin
        str_idx0_info = $sformatf("initiating_rn_node_idx_0 %0d is not valid for this sequence. The RN corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuration::participating_rn_nodes[])", initiating_rn_node_idx_0, initiating_rn_node_idx_0);
      end
    end
    if ((initiating_rn_node_index_1_status==0)&&(valid_initiating_rn_node_index_1==0)) begin
        str_idx1_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN's that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F or RN_I)";
    end
    else begin
      is_rn_idx_1_participating = is_value_found_in_int_assoc_array(active_participating_rn_nodes, initiating_rn_node_idx_1, array_idx);
      if (!is_rn_idx_1_participating) begin
        str_idx1_info = $sformatf("initiating_rn_node_idx_1 %0d is not valid for this sequence. The RN corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuration::participating_rn_nodes[])", initiating_rn_node_idx_1, initiating_rn_node_idx_1);
      end
    end

    if (is_rn_idx_0_participating && is_rn_idx_1_participating) begin
      is_supported = 1;
      if(max_num_outstanding_write_xacts_at_hn > 0) begin
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].num_outstanding_write_xact < (max_num_outstanding_write_xacts_at_hn/2)) begin
          str_idx0_info = $sformatf("Programmed value of max_num_outstanding_write_xacts_at_hn_status is %0d. But num_outstanding_write_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_write_xact of the initiating RN node must be equal to or greater than half of max_num_outstanding_write_xacts_at_hn_status of the target HN", max_num_outstanding_write_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_0_participating].num_outstanding_write_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].num_outstanding_write_xact < (max_num_outstanding_write_xacts_at_hn/2)) begin
          str_idx1_info = $sformatf("Programmed value of max_num_outstanding_write_xacts_at_hn_status is %0d. But num_outstanding_write_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_write_xact of the initiating RN node must be equal to or greater than half of max_num_outstanding_write_xacts_at_hn_status of the target HN", max_num_outstanding_write_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_1_participating].num_outstanding_write_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
      end else begin
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].num_outstanding_xact < (max_num_outstanding_xacts_at_hn/2)) begin
          str_idx0_info = $sformatf("Programmed value of max_num_outstanding_xacts_at_hn_status is %0d. But num_outstanding_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_xact of the initiating RN node must be equal to or greater than half of max_num_outstanding_xacts_at_hn of the target HN", max_num_outstanding_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_0_participating].num_outstanding_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].num_outstanding_xact < (max_num_outstanding_xacts_at_hn/2)) begin
          str_idx1_info = $sformatf("Programmed value of max_num_outstanding_xacts_at_hn_status is %0d. But num_outstanding_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_xact of the initiating RN node must be equal to or greater than half of max_num_outstanding_xacts_at_hn of the target HN", max_num_outstanding_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_1_participating].num_outstanding_xact, initiating_rn_node_idx_1);
          is_supported = 0;
        end
      end

      //Check if cache stashing is disabled for this sequence
      if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable ==1) begin
        is_supported =0;
        str_idx0_info = { str_idx0_info, "\n", $sformatf("This sequence is not applicable for RN with svt__chi_node_configuration::cache_stashing_enable set to 1. Set the cache_stashing_enable to 0. RN node: 'd%0d",initiating_rn_node_idx_0)};
      end
      if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable ==1) begin
        is_supported =0;
        str_idx1_info = { str_idx1_info, "\n", $sformatf("This sequence is not applicable for RN with svt__chi_node_configuration::cache_stashing_enable set to 1. Set the cache_stashing_enable to 0. RN node: 'd%0d",initiating_rn_node_idx_1)};
      end
      //check for spec revision
      if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision < svt_chi_node_configuration::ISSUE_E) begin
        is_supported =0;
        str_idx0_info = { str_idx0_info, "\n", $sformatf("This sequence is not applicable for RN with svt_chi_node_configuration::chi_spec_revision < ISSUE_E. Set the chi_spec_revision to ISSUE_E or further. RN node: 'd%0d",initiating_rn_node_idx_0)};
      end
      if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision < svt_chi_node_configuration::ISSUE_E) begin
        is_supported =0;
        str_idx1_info = { str_idx1_info, "\n", $sformatf("This sequence is not applicable for RN with svt_chi_node_configuration::chi_spec_revision < ISSUE_E. Set the chi_spec_revision to ISSUE_E or further. RN node: 'd%0d",initiating_rn_node_idx_1)};
      end

    end
    
    if (!is_supported) begin
      str_is_supported_info = $sformatf("%0s%0s",str_idx0_info, str_idx1_info);
      if (is_rn_idx_0_participating && is_rn_idx_1_participating) begin
        issue_is_supported_failure($sformatf("This sequence cannot be run based on the current system configuration.\n\
                                              %0s\n\
                                              %0s \n\
                                              Modify configurations through \n\
                                              svt_chi_system_configuration::num_rn,\n\
                                              svt_chi_node_configuration::is_active,\n\
                                              svt_chi_system_configuration::participating_rn_nodes[]\n\
                                              ", str_is_supported_info_prefix, str_is_supported_info));
      end
      else begin
        issue_is_supported_failure($sformatf("This sequence cannot be run based on the current node configurations of RN%0d and/or RN%0d.\n\
                                              %0s \n\
                                              Modify configuration through \n\
                                              svt_chi_node_configuration::num_outstanding_xact,\n\
                                              svt_chi_node_configuration::num_outstanding_write_xact,\n\
                                              ",str_is_supported_info, initiating_rn_node_idx_0, initiating_rn_node_idx_1));
      end
    end      
    `svt_xvm_debug("is_supported",$sformatf("Exiting ..."));
    if (!is_target_hn_idx_valid_for_curr_cfg()) begin
      is_supported = 0;
      `svt_xvm_note("is_supported", "not a valid hn_idx based on random_tgt_id_enable for current cfg");
    end
  endfunction : is_supported

  virtual task pre_start();
    `svt_xvm_debug("pre_start",$sformatf("Entering ..."));
    super.pre_start();
    raise_phase_objection();
  endtask // pre_start

  virtual task body();
    /** Queue of addresses, used by the transactions generated */
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0] addr_q[$];
    bit seq_is_non_secure_access_q[$];
    /** Flag to track whether cache initialization needs to be performed or not*/
    bit                                perform_cache_initialization;
    int                                array_idx;
    /** Metric variables */
    int received_responses = 0;

    int num_outstanding_xacts_to_generate;

    int pgroup_id_arr_0[$];
    int pgroup_id_arr_1[$];
    int pgroup_id_width=`SVT_CHI_PGROUPID_WIDTH;

    /** Sub Write type transaction directed sequences initiated from this sequence */
    svt_chi_rn_write_type_transaction_directed_sequence write_seq[int];
    
    /** Sub Read type transaction cache initialization directed sequences initiated from this sequence */
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq[int];

    `svt_xvm_debug("body", "Entering ...")
    super.body();

    max_num_outstanding_xacts_at_hn_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(), "max_num_outstanding_xacts_at_hn", max_num_outstanding_xacts_at_hn);
    max_num_outstanding_write_xacts_at_hn_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(), "max_num_outstanding_write_xacts_at_hn", max_num_outstanding_write_xacts_at_hn);
    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :initiating_rn_node_index_0;
    initiating_rn_node_idx_1 = initiating_rn_node_index_1_status ? initiating_rn_node_index_1_from_config_db :initiating_rn_node_index_1;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_node_index_0;

    `svt_xvm_debug("body", $sformatf("max_num_outstanding_xacts_at_hn is %0d as a result of %0s.", max_num_outstanding_xacts_at_hn, max_num_outstanding_xacts_at_hn_status ? "config DB" : "default"));
    `svt_xvm_debug("body", $sformatf("max_num_outstanding_write_xacts_at_hn is %0d as a result of %0s.", max_num_outstanding_write_xacts_at_hn, max_num_outstanding_write_xacts_at_hn_status ? "config DB" : "default"));
    `svt_xvm_debug("body", $sformatf("initiating_rn_node_idx_0 is %0d as a result of %0s.", initiating_rn_node_idx_0, initiating_rn_node_index_0_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("initiating_rn_node_idx_1 is %0d as a result of %0s.", initiating_rn_node_idx_1, initiating_rn_node_index_1_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("target_hn_node_idx_0 is %0d as a result of %0s.", target_hn_node_idx_0, target_hn_node_index_0_status ? "config DB" : "Randomization")); 

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    //If there are participating RN-F nodes in the system, set the cache_line_init_rn_f_node_index to any one of them
    if(active_participating_rn_f_nodes.size()) begin
      cache_line_init_rn_f_node_index = active_participating_rn_f_nodes[0];
      perform_cache_initialization=1;
    end
    /**
     * If the cache_line_init_rn_f_node_index is same as any of the initiating RN node indices 
     * initiating_rn_node_idx_0,initiating_rn_node_idx_1,
     * then re-assign the cache_line_init_rn_f_node_index with RN node index ,which is active,
     * participating and not equal to initiating_rn_node_idx_0, initiating_rn_node_idx_1.
     */
      if((cache_line_init_rn_f_node_index == initiating_rn_node_idx_0)||(cache_line_init_rn_f_node_index == initiating_rn_node_idx_1))begin  
        int active_participating_q [$];
        `svt_chi_xxm_debug("body",$sformatf("cache_line_init_rn_f_node_index= %0d is same as initiating_rn_node_idx_0=%0d or initiating_rn_node_idx_1=%0d and active_participating_rn_f_nodes.size()= %0d",cache_line_init_rn_f_node_index,initiating_rn_node_idx_0,initiating_rn_node_idx_1,active_participating_rn_f_nodes.size()));
        active_participating_q = active_participating_rn_f_nodes.find with ((item != initiating_rn_node_idx_0) && (item != initiating_rn_node_idx_1));
        //If there are RN-Fs that do not coincide with initiating_rn_node_idx_0 and initiating_rn_node_idx_1, set one of them as cache_line_init_rn_f_node_index
        if(active_participating_q.size()>0)begin
          cache_line_init_rn_f_node_index = active_participating_q.pop_back();
          perform_cache_initialization=1;
          `svt_chi_xxm_debug("body", $sformatf("active_participating_q.size() is %0d and Selected different cache_line_init_rn_f_node_index=%0d", active_participating_q.size(),cache_line_init_rn_f_node_index));
          active_participating_q.delete();
        //If there are no other RN-Fs in the system, check if both initiating RN node index 0 and 1 are RN-Fs. If yes, then set cache_line_init_rn_f_node_index to one of the initiating RN nodes (we will initiate cache init transactions fromm both RN-Fs, so it does not matter which index we set cache_line_init_rn_f_node_index to). If no, then cache initialization cannot be performed.
        end else begin
          if((is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_node_idx_0, array_idx)) && (is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_node_idx_1, array_idx))) begin
            perform_cache_initialization=1;
            `svt_chi_xxm_debug("body",$sformatf("Selected cache_line_init_rn_f_node_index= %0d is same as initiating_rn_node_index_0=%0d or initiating_rn_node_index_1=%0d and active_participating_rn_f_nodes.size()= %0d. Cache initialization will be performed from initiating_rn_node_index_0 and initiating_rn_node_index_1",cache_line_init_rn_f_node_index,initiating_rn_node_index_0_from_config_db,initiating_rn_node_index_1_from_config_db,active_participating_rn_f_nodes.size()));
          end else begin
            perform_cache_initialization=0;
          end
        end
      end

    /**
     * If the cache_line_init_rn_f_node_index is not part of active_participating_rn_f_nodes array, then we cannot
     * perform cache initialization.
     */
    if (!(is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, cache_line_init_rn_f_node_index, array_idx))) begin
      perform_cache_initialization = 0;
    end

    `svt_xvm_debug("body", $sformatf("perform_cache_initialization is %0b, cache_line_init_rn_f_node_index is %0d, initiating_rn_node_idx_0 is %0d, initiating_rn_node_idx_1 is %0d", perform_cache_initialization, cache_line_init_rn_f_node_index, initiating_rn_node_idx_0, initiating_rn_node_idx_1));    

    //If max outstanding count for Write transactions has been programmed, use that to generate the outstanding Writes
    if(max_num_outstanding_write_xacts_at_hn > 0) begin
      num_outstanding_xacts_to_generate = max_num_outstanding_write_xacts_at_hn;
      `svt_xvm_debug("body",$sformatf("max_num_outstanding_write_xacts_at_hn is set to a non-zero value (%0d). Hence, the value programmed in max_num_outstanding_xacts_at_hn will be ignored. The number of outstanding transactions issued by the sequence will be equal to max_num_outstanding_write_xacts_at_hn", max_num_outstanding_write_xacts_at_hn));
    end
    //If not, use the max outstanding transaction count
    else
      num_outstanding_xacts_to_generate = max_num_outstanding_xacts_at_hn;

    for(int k = 0; k < sequence_length; k++) begin

      for(int id=0; id < (2**`SVT_CHI_PGROUPID_WIDTH); id++) begin
        pgroup_id_arr_0.push_back(id);
        pgroup_id_arr_1.push_back(id);
      end
      pgroup_id_arr_0.shuffle;
      pgroup_id_arr_1.shuffle;
      
      if(perform_cache_initialization) begin  
        
        `svt_xvm_debug("body",$sformatf("Starting cache initialization for %0d addresses from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d",
                                        num_outstanding_xacts_to_generate, cache_line_init_rn_f_node_index, target_hn_node_idx_0));
        
        for(int i = 0; i < num_outstanding_xacts_to_generate; i++) begin
          //cache_line_init_rn_f_node_index will be set to initiating_rn_node_idx_1 or initiating_rn_node_idx_0 only when there are only 2 RN-Fs in the system. In such a case,
          //the cache init transactions must be issued alternately from initiating_rn_node_idx_1 and
          //initiating_rn_node_idx_0 respectively
          if(cache_line_init_rn_f_node_index == initiating_rn_node_idx_1 || cache_line_init_rn_f_node_index == initiating_rn_node_idx_0) begin
            if(i % 2 == 0) 
              cache_line_init_rn_f_node_index = initiating_rn_node_idx_1;
            else
              cache_line_init_rn_f_node_index = initiating_rn_node_idx_0; 
          end
        
          /** Write data into Cache of Randomly selected first RN-F with address of randomly selected HN Node */
          `svt_xvm_do_on_with(makeunique_seq[i],p_sequencer.rn_virt_seqr[cache_line_init_rn_f_node_index].rn_xact_seqr,
          {
           sequence_length   == 1;
           hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
           seq_hn_node_idx   == target_hn_node_idx_0;
           use_seq_is_non_secure_access == 0;
          })
          
          `svt_xvm_debug("body", $sformatf("%0s Waiting for MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) to end",`SVT_CHI_PRINT_PREFIX(makeunique_seq[i].write_tran),i, makeunique_seq[i].write_tran.hn_node_idx, makeunique_seq[i].write_tran.tgt_id));
          makeunique_seq[i].write_tran.wait_end();
          `svt_xvm_debug("body", $sformatf("%0s MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) ended",`SVT_CHI_PRINT_PREFIX(makeunique_seq[i].write_tran),i, makeunique_seq[i].write_tran.hn_node_idx, makeunique_seq[i].write_tran.tgt_id));
          /** Queue for collecting the address of makeunique transactions */
          addr_q.push_back(makeunique_seq[i].output_xacts[0].addr);
          seq_is_non_secure_access_q.push_back(makeunique_seq[i].output_xacts[0].is_non_secure_access);
          `svt_xvm_verbose("body", $sformatf("MakeUnique transaction [%0d] is %0s", i,makeunique_seq[i].write_tran.sprint()));
        end
        
        `svt_xvm_debug("body",$sformatf("Ended cache initialization for %0d addresses from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d",
                                        num_outstanding_xacts_to_generate, cache_line_init_rn_f_node_index, target_hn_node_idx_0));
      end // if (perform_cache_initialization)
      
      `svt_xvm_debug("body",$sformatf("Starting transmission of Write type transactions for %0d addresses with suspend_wr_data set to 1",num_outstanding_xacts_to_generate));
      //for(int i = 0; i < num_outstanding_xacts_to_generate/2; i++) begin
      fork
        /** 
           * Do 128 transactions from each of the two different RNs each to all MAKEUNIQUE 
           * transaction address of same HN node with suspend response*/ 
        begin
          for(int i = 0; i < (num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2); i++) begin
            automatic int pgroup_id_0   = pgroup_id_arr_0.pop_front();
            `svt_xvm_debug("body",$sformatf("Sending Write type transactions from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d with suspend_wr_data set to 1",initiating_rn_node_idx_0, target_hn_node_idx_0));
            `svt_xvm_do_on_with(write_seq[2*i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
            {
             if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].cleansharedpersistsep_xact_enable == 1) {
               seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL_CLEANSHARED, svt_chi_transaction::WRITEUNIQUEFULL_CLEANSHAREDPERSISTSEP, svt_chi_transaction::WRITEUNIQUEPTL_CLEANSHARED, svt_chi_transaction::WRITEUNIQUEPTL_CLEANSHAREDPERSISTSEP};             
               seq_pgroup_id == pgroup_id_0;
             }
             else {
               seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL_CLEANSHARED, svt_chi_transaction::WRITEUNIQUEPTL_CLEANSHARED};             
             }
             sequence_length               == 1;
             seq_txn_id         == (i*3);
             /** Transactions are set to ordered at requestor for stream WriteUniques transactions. */
             seq_order_type   == svt_chi_transaction::NO_ORDERING_REQUIRED;
             if (perform_cache_initialization) { 
               hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
               min_addr          == addr_q[2*i];
               max_addr          == addr_q[2*i];
               seq_is_non_secure_access == seq_is_non_secure_access_q[2*i]; 
               use_seq_is_non_secure_access == 1;
             }
             else {
               hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
               seq_hn_node_idx == target_hn_node_idx_0;
               use_seq_is_non_secure_access == 0;
             }
            })
           
            `svt_xvm_debug("body", $sformatf("%0s Transmitting Write Transaction [%0d] targeted to HN (idx %0d, id %0d) ",`SVT_CHI_PRINT_PREFIX(write_seq[2*i].write_tran),2*i, write_seq[2*i].write_tran.hn_node_idx, write_seq[2*i].write_tran.tgt_id));
            `svt_xvm_verbose("body", $sformatf("Write Transaction [%0d] is %0s", 2*i,write_seq[2*i].write_tran.sprint()));

          end
        end
        begin
          for(int i = 0; i < num_outstanding_xacts_to_generate/2; i++) begin
            automatic int pgroup_id_1   = pgroup_id_arr_1.pop_front();
            `svt_xvm_debug("body",$sformatf("Sending Write type transactions from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d with suspend_wr_data set to 1",initiating_rn_node_idx_1, target_hn_node_idx_0));
            `svt_xvm_do_on_with(write_seq[2*i + 1], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,
            {
             if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].cleansharedpersistsep_xact_enable == 1) {
               seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL_CLEANSHARED, svt_chi_transaction::WRITEUNIQUEFULL_CLEANSHAREDPERSISTSEP, svt_chi_transaction::WRITEUNIQUEPTL_CLEANSHARED, svt_chi_transaction::WRITEUNIQUEPTL_CLEANSHAREDPERSISTSEP};             
               seq_pgroup_id == pgroup_id_1;
             }
             else {
               seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL_CLEANSHARED, svt_chi_transaction::WRITEUNIQUEPTL_CLEANSHARED};             
             }
             sequence_length               == 1;
             seq_txn_id         == (i*3);
             /** Transactions are set to ordered at requestor for stream WriteUniques transactions. */
             seq_order_type   == svt_chi_transaction::NO_ORDERING_REQUIRED;
             if (perform_cache_initialization) {
               hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
               min_addr           == addr_q[2*i + 1];
               max_addr           == addr_q[2*i + 1];
               seq_is_non_secure_access == seq_is_non_secure_access_q[2*i +1]; 
               use_seq_is_non_secure_access == 1;
             }
             else {
               hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
               seq_hn_node_idx == target_hn_node_idx_0;
               use_seq_is_non_secure_access == 0;
             }
            })
          
            `svt_xvm_debug("body", $sformatf("%0s Transmitting Write Transaction [%0d] targeted to HN (idx %0d, id %0d) ",`SVT_CHI_PRINT_PREFIX(write_seq[2*i + 1].write_tran),2*i + 1, write_seq[2*i + 1].write_tran.hn_node_idx, write_seq[2*i + 1].write_tran.tgt_id));
            `svt_xvm_verbose("body", $sformatf("Write Transaction [%0d] is %0s", 2*i + 1,write_seq[2*i + 1].write_tran.sprint()));
          end
        end
      join
     // end //for(int i = 0; i < num_outstanding_xacts_to_generate/2; i++)  
      
      /** Waiting for the DBIDResp/CompDBDIResp responses from HN for write trasactions */
      foreach(write_seq[wr]) begin
        fork
          automatic int _wr = wr;
          begin
            `svt_xvm_debug("body", $sformatf("%0s Write transaction [%0d] targeted to HN (idx %0d, id %0d), suspend_wr_data %0b: waiting for response from interconnect",`SVT_CHI_PRINT_PREFIX(write_seq[_wr].write_tran),_wr, write_seq[_wr].write_tran.hn_node_idx, write_seq[_wr].write_tran.tgt_id,write_seq[_wr].write_tran.suspend_wr_data));
            fork
            begin
              fork
                begin
                  write_seq[_wr].write_tran.wait_for_tx_data_prereqs();
                end
                begin
                  wait(write_seq[_wr].write_tran.req_status == svt_chi_transaction::RETRY);// begin
                end
              join_any
              disable fork;
            end
            join
            received_responses++;
            `svt_xvm_debug("body", $sformatf("%0s Write transaction [%0d] targeted to HN (idx %0d, id %0d), suspend_wr_data %0b: received response from interconnect. Total responses received %0d",`SVT_CHI_PRINT_PREFIX(write_seq[_wr].write_tran),_wr, write_seq[_wr].write_tran.hn_node_idx, write_seq[_wr].write_tran.tgt_id,write_seq[_wr].write_tran.suspend_wr_data,received_responses));
          end
        join_none
      end

      /** Wait until All DBIDResp/CompDBDIResp responses are received for write transaction */ 
      `svt_xvm_debug("body",$sformatf("Completed initiation of Write type transactions for %0d addresses from p_sequencer.rn_virt_seqr[%0d] and p_sequencer.rn_virt_seqr[%0d] to HN idx %0d with suspend_wr_data set to 1, and waiting to receive responses from interconnect.",
                                num_outstanding_xacts_to_generate, initiating_rn_node_idx_0,initiating_rn_node_idx_1,target_hn_node_idx_0));
      wait(received_responses == num_outstanding_xacts_to_generate);
      `svt_xvm_debug("body",$sformatf("Received responses from interconnect to Write type transactions for %0d addresses from p_sequencer.rn_virt_seqr[%0d] and p_sequencer.rn_virt_seqr[%0d] to HN idx %0d with suspend_wr_data set to 1.",
                                num_outstanding_xacts_to_generate, initiating_rn_node_idx_0,initiating_rn_node_idx_1,target_hn_node_idx_0));
     
      /** Self Check1: To check suspend_wr_data should not be modified to zero by the VIP
       *  before reseting from test bench.
       */
      foreach (write_seq[self_check_idx1]) begin
        if (!write_seq[self_check_idx1].write_tran.is_terminated()) begin
          if (write_seq[self_check_idx1].write_tran.suspend_wr_data == 0) begin
            `svt_xvm_error("body", $sformatf("%0s suspend_wr_data should be 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(write_seq[self_check_idx1].write_tran)));
          end
          else begin
            `svt_xvm_debug("body", $sformatf("%0s suspend_wr_data is 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(write_seq[self_check_idx1].write_tran)));
          end
        end
      end

      /** Self Check2: To check transaction is not ended by the VIP before resuming the 
       *  suspend_wr_data to zero from the test bench
       */
      foreach(write_seq[self_check_idx2]) begin
        if (!write_seq[self_check_idx2].write_tran.is_terminated()) begin
          if (write_seq[self_check_idx2].write_tran.end_event.is_on() == 1) begin
            `svt_xvm_error("body", $sformatf("Unexpected: %0s Transaction's end_event triggered when suspend_wr_data is still 1.", `SVT_CHI_PRINT_PREFIX(write_seq[self_check_idx2].write_tran)));
          end
          else begin
            `svt_xvm_debug("body", $sformatf("Expected: %0s Transaction's end_event is not triggered when suspend_wr_data is still 1.", `SVT_CHI_PRINT_PREFIX(write_seq[self_check_idx2].write_tran)));
          end
        end
      end
 
      /** Self Check 3: To check that the current_outstanding_*_xact_count in the RNs
       * are as per the transactions inititated by the sequence
       */
      /** Check if the total outstanding xact counter is set correctly in the shared status of the RN agent */
      if(write_seq[0].shared_status.prot_status.current_outstanding_xact_count != (num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2))
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding transactions from the sequence but the outstanding transaction count in the shared status of RN%0d is %0d", (num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2), initiating_rn_node_idx_0, write_seq[0].shared_status.prot_status.current_outstanding_xact_count));
      /** Check if the outstanding Write xact counter is set correctly in the shared status of the RN agent */
      if(write_seq[0].shared_status.prot_status.current_outstanding_write_xact_count != (num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2)) begin
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding Write transactions from the sequence but the outstanding Write transaction count in the shared status of RN%0d is %0d", (num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2), initiating_rn_node_idx_0, write_seq[0].shared_status.prot_status.current_outstanding_write_xact_count));
      end
      /** Check if the total outstanding xact counter is set correctly in the shared status of the second RN agent */
      if(write_seq[1].shared_status.prot_status.current_outstanding_xact_count != num_outstanding_xacts_to_generate/2)
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding transactions from the sequence but the oustanding transaction count in the shared status of RN%0d is %0d", num_outstanding_xacts_to_generate/2, initiating_rn_node_idx_1, write_seq[1].shared_status.prot_status.current_outstanding_xact_count));
      /** Check if the outstanding Write xact counter is set correctly in the shared status of the RN agent */
      if(write_seq[1].shared_status.prot_status.current_outstanding_write_xact_count !=  num_outstanding_xacts_to_generate/2) begin
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding Write transactions from the sequence but the outstanding Write transaction count in the shared status of RN%0d is %0d", num_outstanding_xacts_to_generate/2, initiating_rn_node_idx_1, write_seq[1].shared_status.prot_status.current_outstanding_write_xact_count));
      end

      `svt_xvm_debug("body", $sformatf("RN%0d: Number of outstanding transactions : %0d, Number of outstanding write xacts : %0d", initiating_rn_node_idx_0, write_seq[0].shared_status.prot_status.current_outstanding_xact_count, write_seq[0].shared_status.prot_status.current_outstanding_write_xact_count));
      `svt_xvm_debug("body", $sformatf("RN%0d: Number of outstanding transactions : %0d, Number of outstanding write xacts : %0d", initiating_rn_node_idx_1, write_seq[0].shared_status.prot_status.current_outstanding_xact_count, write_seq[1].shared_status.prot_status.current_outstanding_write_xact_count));

      /** Resuming all NonCopyBackWrData for above write transactions */
      `svt_xvm_debug("body",$sformatf("Resuming the write transactions by setting svt_chi_rn_transaction::suspsend_wr_data set to 0"))
      foreach(write_seq[index4]) begin
        write_seq[index4].write_tran.suspend_wr_data = 0;
        `svt_xvm_debug("body", $sformatf("After Resume received_responses is %0d for iteration %0d and suspend_wr_data is %0b",received_responses, index4, write_seq[index4].write_tran.suspend_wr_data));
      end

      /** Waiting for Write transactions to complete*/
      `svt_xvm_debug("body",$sformatf("Waiting for completion of all the outstanding write type transactions"));
      foreach(write_seq[self_check_idx3]) begin
        `svt_xvm_debug("body", $sformatf("Waiting for above write_seq[%0d] transaction %0s to end", self_check_idx3, `SVT_CHI_PRINT_PREFIX(write_seq[self_check_idx3].write_tran)));
        write_seq[self_check_idx3].write_tran.wait_end();

        /** Self Check4: To check suspend_wr_data should not be asserted after the transaction
         *  completes as it is reseted from test bench
         */
        if (!write_seq[self_check_idx3].write_tran.is_terminated()) begin
          if (write_seq[self_check_idx3].write_tran.suspend_wr_data == 1) begin
            `svt_xvm_error("body", $sformatf("%0s suspend_wr_data should be 0 as it has been reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(write_seq[self_check_idx3].write_tran)));
          end
          else begin
            `svt_xvm_debug("body", $sformatf("%0s suspend_wr_data is 0 as it is reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(write_seq[self_check_idx3].write_tran)));
          end
        end
      end
      `svt_xvm_debug("body",$sformatf("Received completions for all write type outstanding transactions"));
      
      /** Targeted HN IDs from both RNs should be same */
      for(int index_5 = 0; index_5 < num_outstanding_xacts_to_generate/2; index_5++) begin
        int hn_idx_0, hn_idx_1;
        hn_idx_0 = sys_cfg.get_hn_idx(write_seq[2*index_5].output_xacts[0].addr);
        hn_idx_1 = sys_cfg.get_hn_idx(write_seq[2*index_5 + 1].output_xacts[0].addr);
        if ((hn_idx_0 == target_hn_node_idx_0) && (hn_idx_0 == hn_idx_1)) begin
          /** pass */
          `svt_xvm_debug("body", $sformatf("Targeted HN Index from both RNs are same as expected.  rn[%0d] to hn_idx[%0d], rn[%0d] to hn_idx[%0d] and they match with the target_hn_node_idx_0 %0d", initiating_rn_node_idx_0, hn_idx_0, initiating_rn_node_idx_1, hn_idx_1,target_hn_node_idx_0));
        end
        else begin
          /** fail */
          `svt_xvm_error("body", $sformatf("Targeted HN Index from both RNs are different, which is unexpected.  rn[%0d] %0s transaction to hn_idx[%0d], rn[%0d] %0s transaction to hn_idx[%0d] and one or both of hn_idx don't match with the target_hn_node_idx_0 %0d ",initiating_rn_node_idx_0, `SVT_CHI_PRINT_PREFIX( write_seq[2*index_5].output_xacts[0]), hn_idx_0, initiating_rn_node_idx_1, `SVT_CHI_PRINT_PREFIX( write_seq[2*index_5 + 1].output_xacts[0]), hn_idx_1,target_hn_node_idx_0));
        end
      end
     
      /** Reset received_responses to zero */
      received_responses = 0;
      
      /** Delete the contents of address collection queue */
      addr_q.delete();

    end //for(int k = 0; k < sequence_length; k++)
    
    `svt_xvm_debug("body", "Exiting...")
  endtask: body

  virtual task post_body();
    drop_phase_objection();
  endtask

endclass: svt_chi_system_chi_e_protocol_flow_ctrl_combined_noncopyback_write_cmo_outstanding_diff_rn_same_hn_virtual_sequence

function svt_chi_system_chi_e_protocol_flow_ctrl_combined_noncopyback_write_cmo_outstanding_diff_rn_same_hn_virtual_sequence::new(string name="svt_chi_system_chi_e_protocol_flow_ctrl_combined_noncopyback_write_cmo_outstanding_diff_rn_same_hn_virtual_sequence");
  super.new(name);
endfunction
//--------------------------------------------------------------------------------------

class svt_chi_e_system_protocol_flow_ctrl_combined_noncopyback_write_cmo_outstanding_diff_rn_diff_hn_virtual_sequence extends svt_chi_system_base_virtual_sequence;
  
  //-----------------------------------------------------------------------------  
  // Member attributes
  //-----------------------------------------------------------------------------  

  /** To display contents of Active Participating RN's node info. */
  string str_rn_node;

  /** To display contents of Active Participating RN-F's node info. */
  string str_rn_f_node;

  rand  bit  txn_is_non_secure_access;
  /** UVM/OVM Object Utility macro */
  `svt_xvm_object_utils(svt_chi_e_system_protocol_flow_ctrl_combined_noncopyback_write_cmo_outstanding_diff_rn_diff_hn_virtual_sequence)
  
  //-----------------------------------------------------------------------------  
  // Methods
  //-----------------------------------------------------------------------------
  /** Constructor */
  extern function new(string name="svt_chi_e_system_protocol_flow_ctrl_combined_noncopyback_write_cmo_outstanding_diff_rn_diff_hn_virtual_sequence");

  //-----------------------------------------------------------------------------
  /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting any type of Request Nodes = 2
   *  #- Minimum required number of HN Nodes = 2   
   *  .
   */
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    
    /** local variables */
    int num_supporting_request_nodes;
    int num_hn_f_nodes;   
    int array_idx;
    bit is_rn_idx_0_participating, is_rn_idx_1_participating;
    string str_is_supported_info_prefix = "";
    string str_is_supported_info = "";
    string str_idx0_info = "";
    string str_idx1_info = "";    
    /** Supporting any type of Request Nodes required */
    int required_num_supporting_request_nodes = 2;
    int required_num_hn_nodes = 2;
    
    `svt_xvm_debug("is_supported",$sformatf("Entering ..."));

    /** By default is_supported is 0 */
    is_supported = 0;
    
    /** Check for minimum required HN nodes */
    num_hn_f_nodes = hn_f_nodes.size();
    
    /** Check requirment of number of HN nodes needed */
    if (num_hn_f_nodes < required_num_hn_nodes) begin
      issue_is_supported_failure($sformatf("This sequence requires minimum %0d HN-F nodes to be present in the system. Number of HN-F nodes are %0d. Program number of HN nodes using svt_chi_system_configuration::num_hn. Program the HN interface type using svt_chi_system_configuration::chi_addr_cfg.hn_interface_type[].", required_num_hn_nodes, num_hn_f_nodes));
      return 0;      
    end
    
    /** Check for minimum required RN nodes.
     *  Also check whether the selected RN nodes are part of participating arrays or not.
     */    
    num_supporting_request_nodes = active_participating_rn_nodes.size();

    /** Check the requirements of RN nodes */
    if (num_supporting_request_nodes) begin
      /** Display the contents of Active Participating RN Nodes */
      foreach (active_participating_rn_nodes[j]) begin
        str_rn_node = {str_rn_node, $sformatf(" %0d", active_participating_rn_nodes[j])};
      end 
      `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_nodes are %0s", str_rn_node));
    end

    str_is_supported_info_prefix = $sformatf("Number of Supporting RN Node(s)  - Minimum Required : %0d Current : %0d", required_num_supporting_request_nodes, num_supporting_request_nodes);
    
    if ((initiating_rn_node_index_0_status==0)&&(valid_initiating_rn_node_index_0==0)) begin
        str_idx0_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN's that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F or RN_I)";
    end
    else begin
      is_rn_idx_0_participating = is_value_found_in_int_assoc_array(active_participating_rn_nodes, initiating_rn_node_idx_0, array_idx);
      if (!is_rn_idx_0_participating) begin
        str_idx0_info = $sformatf("initiating_rn_node_idx_0 %0d is not valid for this sequence. The RN corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuration::participating_rn_nodes[])", initiating_rn_node_idx_0, initiating_rn_node_idx_0);
      end
    end
    if ((initiating_rn_node_index_1_status==0)&&(valid_initiating_rn_node_index_1==0)) begin
        str_idx1_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN's that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F or RN_I)";
    end
    else begin
      is_rn_idx_1_participating = is_value_found_in_int_assoc_array(active_participating_rn_nodes, initiating_rn_node_idx_1, array_idx);
      if (!is_rn_idx_1_participating) begin
        str_idx1_info = $sformatf("initiating_rn_node_idx_1 %0d is not valid for this sequence. The RN corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuration::participating_rn_nodes[])", initiating_rn_node_idx_1, initiating_rn_node_idx_1);
      end
    end

    if (is_rn_idx_0_participating && is_rn_idx_1_participating) begin
      is_supported = 1;
      if(max_num_outstanding_write_xacts_at_hn > 0) begin
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].num_outstanding_write_xact < max_num_outstanding_write_xacts_at_hn) begin
          str_idx0_info = $sformatf("Programmed value of max_num_outstanding_write_xacts_at_hn_status is %0d. But num_outstanding_write_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_write_xact of the initiating RN node must be equal to or greater than max_num_outstanding_write_xacts_at_hn_status of the target HN", max_num_outstanding_write_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_0_participating].num_outstanding_write_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].num_outstanding_write_xact < max_num_outstanding_write_xacts_at_hn) begin
          str_idx1_info = $sformatf("Programmed value of max_num_outstanding_write_xacts_at_hn_status is %0d. But num_outstanding_write_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_write_xact of the initiating RN node must be equal to or greater than max_num_outstanding_write_xacts_at_hn_status of the target HN", max_num_outstanding_write_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_1_participating].num_outstanding_write_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
      end else begin
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].num_outstanding_xact < max_num_outstanding_xacts_at_hn) begin
          str_idx0_info = $sformatf("Programmed value of max_num_outstanding_xacts_at_hn_status is %0d. But num_outstanding_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_xact of the initiating RN node must be equal to or greater than max_num_outstanding_xacts_at_hn of the target HN", max_num_outstanding_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_0_participating].num_outstanding_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].num_outstanding_xact < max_num_outstanding_xacts_at_hn) begin
          str_idx1_info = $sformatf("Programmed value of max_num_outstanding_xacts_at_hn_status is %0d. But num_outstanding_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_xact of the initiating RN node must be equal to or greater than max_num_outstanding_xacts_at_hn of the target HN", max_num_outstanding_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_1_participating].num_outstanding_xact, initiating_rn_node_idx_1);
          is_supported = 0;
        end
      end
      
        //Check if cache stashing is disabled for this sequence
      if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable ==1) begin
        is_supported =0;
        str_idx0_info = { str_idx0_info, "\n", $sformatf("This sequence is not applicable for RN with svt_chi_node_configuration::cache_stashing_enable set to 1. Set the cache_stashing_enable to 0. RN node: 'd%0d",initiating_rn_node_idx_0)};
      end
      if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable ==1) begin
        is_supported =0;
        str_idx1_info = { str_idx1_info, "\n", $sformatf("This sequence is not applicable for RN with svt_chi_node_configuration::cache_stashing_enable set to 1. Set the cache_stashing_enable to 0. RN node: 'd%0d",initiating_rn_node_idx_1)};
      end
      //check for spec revision
      if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision < svt_chi_node_configuration::ISSUE_E) begin
        is_supported =0;
        str_idx0_info = { str_idx0_info, "\n", $sformatf("This sequence is not applicable for RN with svt_chi_node_configuration::chi_spec_revision < ISSUE_E. Set the chi_spec_revision to ISSUE_E or further. RN node: 'd%0d",initiating_rn_node_idx_0)};
      end
      if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision < svt_chi_node_configuration::ISSUE_E) begin
        is_supported =0;
        str_idx1_info = { str_idx1_info, "\n", $sformatf("This sequence is not applicable for RN with svt_chi_node_configuration::chi_spec_revision < ISSUE_E. Set the chi_spec_revision to ISSUE_E or further. RN node: 'd%0d",initiating_rn_node_idx_1)};
      end

    end
    
    if (!is_supported) begin
      str_is_supported_info = $sformatf("%0s%0s",str_idx0_info, str_idx1_info);
      if (is_rn_idx_0_participating && is_rn_idx_1_participating) begin
        issue_is_supported_failure($sformatf("This sequence cannot be run based on the current system configuration.\n\
                                              %0s\n\
                                              %0s \n\
                                              Modify configurations through \n\
                                              svt_chi_system_configuration::num_rn,\n\
                                              svt_chi_node_configuration::is_active,\n\
                                              svt_chi_system_configuration::participating_rn_nodes[]\n\
                                              ", str_is_supported_info_prefix, str_is_supported_info));
      end
      else begin
        issue_is_supported_failure($sformatf("This sequence cannot be run based on the current node configurations of RN%0d and/or RN%0d.\n\
                                              %0s \n\
                                              Modify configuration through \n\
                                              svt_chi_node_configuration::num_outstanding_xact,\n\
                                              svt_chi_node_configuration::num_outstanding_write_xact,\n\
                                              ",str_is_supported_info, initiating_rn_node_idx_0, initiating_rn_node_idx_1));
      end
    end      
    `svt_xvm_debug("is_supported",$sformatf("Exiting ..."));
    if (!is_target_hn_idx_valid_for_curr_cfg()) begin
      is_supported = 0;
      `svt_xvm_note("is_supported", "not a valid hn_idx based on random_tgt_id_enable for current cfg");
    end
  endfunction : is_supported

  virtual task pre_start();
    `svt_xvm_debug("pre_start",$sformatf("Entering ..."));
    super.pre_start();
    raise_phase_objection();
  endtask // pre_start

  virtual task body();
    /** Queue of addresses, used by the transactions generated */
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0] addr_q[$];
    bit secure_q[$];
    /** Flag to track whether cache initialization needs to be performed or not*/
    bit                                perform_cache_initialization;
    int                                array_idx;

    /** Metric variables */
    int received_responses = 0;
    int total_num_tran = 0;

    int pgroup_id_arr_0[$];
    int pgroup_id_arr_1[$];
    int pgroup_id_width=`SVT_CHI_PGROUPID_WIDTH;

    /** Sub Write type transaction directed sequences initiated from this sequence */
    svt_chi_rn_write_type_transaction_directed_sequence write_seq[int];
    
    /** Sub Read type transaction cache initialization directed sequences initiated from this sequence */
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq[int];
    super.body();

    `svt_xvm_debug("body", "Entering ...")

    max_num_outstanding_xacts_at_hn_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(), "max_num_outstanding_xacts_at_hn", max_num_outstanding_xacts_at_hn);
    max_num_outstanding_write_xacts_at_hn_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(), "max_num_outstanding_write_xacts_at_hn", max_num_outstanding_write_xacts_at_hn);
    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :initiating_rn_node_index_0;
    initiating_rn_node_idx_1 = initiating_rn_node_index_1_status ? initiating_rn_node_index_1_from_config_db :initiating_rn_node_index_1;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_node_index_0;
    target_hn_node_idx_1 = target_hn_node_index_1_status ? target_hn_node_index_1_from_config_db :target_hn_node_index_1;

    `svt_xvm_debug("body", $sformatf("max_num_outstanding_xacts_at_hn is %0d as a result of %0s.", max_num_outstanding_xacts_at_hn, max_num_outstanding_xacts_at_hn_status ? "config DB" : "default"));
    `svt_xvm_debug("body", $sformatf("max_num_outstanding_write_xacts_at_hn is %0d as a result of %0s.", max_num_outstanding_write_xacts_at_hn, max_num_outstanding_write_xacts_at_hn_status ? "config DB" : "default"));
    `svt_xvm_debug("body", $sformatf("initiating_rn_node_idx_0 is %0d as a result of %0s.", initiating_rn_node_idx_0, initiating_rn_node_index_0_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("initiating_rn_node_idx_1 is %0d as a result of %0s.", initiating_rn_node_idx_1, initiating_rn_node_index_1_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("target_hn_node_idx_0 is %0d as a result of %0s.", target_hn_node_idx_0, target_hn_node_index_0_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("target_hn_node_idx_1 is %0d as a result of %0s.", target_hn_node_idx_1, target_hn_node_index_1_status ? "config DB" : "Randomization")); 

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    //If there are participating RN-F nodes in the system, set the cache_line_init_rn_f_node_index to any one of them
    if(active_participating_rn_f_nodes.size()) begin
      cache_line_init_rn_f_node_index = active_participating_rn_f_nodes[0];
      perform_cache_initialization=1;
    end
    /**
     * If the cache_line_init_rn_f_node_index is same as any of the initiating RN node indices 
     * initiating_rn_node_idx_0,initiating_rn_node_idx_1,
     * then re-assign the cache_line_init_rn_f_node_index with RN node index ,which is active,
     * participating and not equal to initiating_rn_node_idx_0, initiating_rn_node_idx_1.
     */
      if((cache_line_init_rn_f_node_index == initiating_rn_node_idx_0)||(cache_line_init_rn_f_node_index == initiating_rn_node_idx_1))begin  
        int active_participating_q [$];
        `svt_chi_xxm_debug("body",$sformatf("cache_line_init_rn_f_node_index= %0d is same as initiating_rn_node_idx_0=%0d or initiating_rn_node_idx_1=%0d and active_participating_rn_f_nodes.size()= %0d",cache_line_init_rn_f_node_index,initiating_rn_node_idx_0,initiating_rn_node_idx_1,active_participating_rn_f_nodes.size()));
        active_participating_q = active_participating_rn_f_nodes.find with ((item != initiating_rn_node_idx_0) && (item != initiating_rn_node_idx_1));
        //If there are RN-Fs that do not coincide with initiating_rn_node_idx_0 and initiating_rn_node_idx_1, set one of them as cache_line_init_rn_f_node_index
        if(active_participating_q.size()>0)begin
          cache_line_init_rn_f_node_index = active_participating_q.pop_back();
          perform_cache_initialization=1;
          `svt_chi_xxm_debug("body", $sformatf("active_participating_q.size() is %0d and Selected different cache_line_init_rn_f_node_index=%0d", active_participating_q.size(),cache_line_init_rn_f_node_index));
          active_participating_q.delete();
        //If there are no other RN-Fs in the system, check if both initiating RN node index 0 and 1 are RN-Fs. If yes, then set cache_line_init_rn_f_node_index to one of the initiating RN nodes (we will initiate cache init transactions fromm both RN-Fs, so it does not matter which index we set cache_line_init_rn_f_node_index to). If no, then cache initialization cannot be performed.
        end else begin
          if((is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_node_idx_0, array_idx)) && (is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_node_idx_1, array_idx))) begin
            perform_cache_initialization=1;
            `svt_chi_xxm_debug("body",$sformatf("Selected cache_line_init_rn_f_node_index= %0d is same as initiating_rn_node_index_0=%0d or initiating_rn_node_index_1=%0d and active_participating_rn_f_nodes.size()= %0d. Cache initialization will be performed from initiating_rn_node_index_0 and initiating_rn_node_index_1",cache_line_init_rn_f_node_index,initiating_rn_node_index_0_from_config_db,initiating_rn_node_index_1_from_config_db,active_participating_rn_f_nodes.size()));
          end else begin
            perform_cache_initialization=0;
          end
        end
      end

    /**
     * If the cache_line_init_rn_f_node_index is not part of active_participating_rn_f_nodes array, then we cannot
     * perform cache initialization.
     */
    if (!(is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, cache_line_init_rn_f_node_index, array_idx))) begin
      perform_cache_initialization = 0;
    end
    
    `svt_xvm_debug("body", $sformatf("perform_cache_initialization is %0b, cache_line_init_rn_f_node_index is %0d, initiating_rn_node_idx_0 is %0d, initiating_rn_node_idx_1 is %0d", perform_cache_initialization, cache_line_init_rn_f_node_index, initiating_rn_node_idx_0, initiating_rn_node_idx_1));    

    for(int k = 0; k < sequence_length; k++) begin

      for(int id=0; id < (2**`SVT_CHI_PGROUPID_WIDTH); id++) begin
        pgroup_id_arr_0.push_back(id);
        pgroup_id_arr_1.push_back(id);
      end
      pgroup_id_arr_0.shuffle;
      pgroup_id_arr_1.shuffle;

      //If max outstanding count for Write transactions has been programmed, use that to generate the outstanding Writes
      if(max_num_outstanding_write_xacts_at_hn > 0) begin
        total_num_tran = (max_num_outstanding_write_xacts_at_hn * 2);
        `svt_xvm_debug("body",$sformatf("max_num_outstanding_write_xacts_at_hn is set to a non-zero value (%0d). Hence, the value programmed in max_num_outstanding_xacts_at_hn will be ignored. The number of outstanding transactions issued by the sequence will be equal to max_num_outstanding_write_xacts_at_hn", max_num_outstanding_write_xacts_at_hn));
      end
      else
        total_num_tran = (max_num_outstanding_xacts_at_hn * 2);
      `svt_xvm_debug("body", $sformatf("total_num_tran is %0d",total_num_tran));
      
      if(perform_cache_initialization) begin  
        
        `svt_xvm_debug("body",$sformatf("Starting cache initialization for %0d addresses from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d and HN idx %0d",
                                        total_num_tran, cache_line_init_rn_f_node_index, target_hn_node_idx_0,target_hn_node_idx_1));
      
        for(int i = 0; i < total_num_tran; i++) begin
          //cache_line_init_rn_f_node_index will be set to initiating_rn_node_idx_1 or initiating_rn_node_idx_0 only when there are only 2 RN-Fs in the system. In such a case,
          //the cache init transactions must be issued alternately from initiating_rn_node_idx_1 and
          //initiating_rn_node_idx_0 respectively
          if(cache_line_init_rn_f_node_index == initiating_rn_node_idx_1 || cache_line_init_rn_f_node_index == initiating_rn_node_idx_0) begin
            if(i % 2 == 0) 
              cache_line_init_rn_f_node_index = initiating_rn_node_idx_1;
            else
              cache_line_init_rn_f_node_index = initiating_rn_node_idx_0; 
          end
        
          /** Write data into Cache of Randomly selected first RN-F with address of randomly selected HN Node */
          `svt_xvm_do_on_with(makeunique_seq[i],p_sequencer.rn_virt_seqr[cache_line_init_rn_f_node_index].rn_xact_seqr,
          {
           sequence_length   == 1;
           hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
           seq_txn_id        == (i % (total_num_tran/2));
           if (i < total_num_tran/2) {
             seq_hn_node_idx == target_hn_node_idx_0;
           }
           else if(i < total_num_tran) {
              seq_hn_node_idx == target_hn_node_idx_1;
           }
           use_seq_is_non_secure_access == 0;
          })

          `svt_xvm_debug("body", $sformatf("%0s Waiting for MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) to end",`SVT_CHI_PRINT_PREFIX(makeunique_seq[i].write_tran),i, makeunique_seq[i].write_tran.hn_node_idx, makeunique_seq[i].write_tran.tgt_id));
          makeunique_seq[i].write_tran.wait_end();
          `svt_xvm_debug("body", $sformatf("%0s MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) ended",`SVT_CHI_PRINT_PREFIX(makeunique_seq[i].write_tran),i, makeunique_seq[i].write_tran.hn_node_idx, makeunique_seq[i].write_tran.tgt_id));
          
          /** Collecting address into address queue*/
          addr_q.push_back(makeunique_seq[i].output_xacts[0].addr);
          secure_q.push_back(makeunique_seq[i].output_xacts[0].is_non_secure_access);
          
          `svt_xvm_verbose("body", $sformatf("MakeUnique transaction [%0d] is %0s", i,makeunique_seq[i].write_tran.sprint()));
        end
        
        `svt_xvm_debug("body",$sformatf("Ended cache initialization for %0d addresses from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d and HN idx %0d",
                                        total_num_tran, cache_line_init_rn_f_node_index, target_hn_node_idx_0,target_hn_node_idx_1));
      end // if (perform_cache_initialization)

      `svt_xvm_debug("body",$sformatf("Starting transmission of Write type transactions for %0d addresses with suspend_wr_data set to 1",total_num_tran));
      for(int i = 0; i < total_num_tran/2; i++) begin
        automatic int pgroup_id_0   = pgroup_id_arr_0.pop_front();
        automatic int pgroup_id_1   = pgroup_id_arr_1.pop_front();
        fork
          /** 
           * Do transactions from each of the two different RNs each to all MAKEUNIQUE 
           * transaction address of the two different HN nodes, 128 each from one RN to one HN. 
           */ 
          begin
            if (i < total_num_tran/4) begin
              `svt_xvm_debug("body",$sformatf("Sending Write type transactions from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d ", initiating_rn_node_idx_0, target_hn_node_idx_0));
            end
            else begin
              `svt_xvm_debug("body",$sformatf("Sending Write type transactions from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d ", initiating_rn_node_idx_0, target_hn_node_idx_1));
            end
            
            `svt_xvm_do_on_with(write_seq[2*i],p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
            {
             if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].cleansharedpersistsep_xact_enable == 1) {
               seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL_CLEANSHARED, svt_chi_transaction::WRITEUNIQUEFULL_CLEANSHAREDPERSISTSEP, svt_chi_transaction::WRITEUNIQUEPTL_CLEANSHARED, svt_chi_transaction::WRITEUNIQUEPTL_CLEANSHAREDPERSISTSEP};             
               seq_pgroup_id == pgroup_id_0;
             }
             else {
               seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL_CLEANSHARED, svt_chi_transaction::WRITEUNIQUEPTL_CLEANSHARED};             
             }
           
             sequence_length               == 1;
             seq_txn_id                    == (i % (total_num_tran/2));
             /** Transactions are set to ordered at requestor for stream WriteUniques transactions. */
             seq_order_type   == svt_chi_transaction::NO_ORDERING_REQUIRED;
             if (perform_cache_initialization) {  
               hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
               min_addr          == addr_q[2*i];
               max_addr          == addr_q[2*i];
               seq_is_non_secure_access == secure_q[2*i];
               use_seq_is_non_secure_access == 1;
             }
             else {
               hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
               if (i < total_num_tran/4) {
                 seq_hn_node_idx == target_hn_node_idx_0;
               }
               else if(i < total_num_tran/2) {
                 seq_hn_node_idx == target_hn_node_idx_1;
               }
               use_seq_is_non_secure_access == 0;
             }

            })
           
            `svt_xvm_debug("body", $sformatf("%0s Transmitting Write Transaction [%0d] targeted to HN (idx %0d, id %0d) ",`SVT_CHI_PRINT_PREFIX(write_seq[2*i].write_tran),2*i, write_seq[2*i].write_tran.hn_node_idx, write_seq[2*i].write_tran.tgt_id));
            `svt_xvm_verbose("body", $sformatf("Write Transaction [%0d] is %0s", 2*i,write_seq[2*i].write_tran.sprint()));

          end
          begin
            if (i < total_num_tran/4) begin
              `svt_xvm_debug("body",$sformatf("Sending Write type transactions from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d ", initiating_rn_node_idx_1, target_hn_node_idx_0));
            end
            else begin
              `svt_xvm_debug("body",$sformatf("Sending Write type transactions from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d ", initiating_rn_node_idx_1, target_hn_node_idx_1));
            end
            
            `svt_xvm_do_on_with(write_seq[2*i + 1],p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,
            {
             if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].cleansharedpersistsep_xact_enable == 1) {
               seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL_CLEANSHARED, svt_chi_transaction::WRITEUNIQUEFULL_CLEANSHAREDPERSISTSEP, svt_chi_transaction::WRITEUNIQUEPTL_CLEANSHARED, svt_chi_transaction::WRITEUNIQUEPTL_CLEANSHAREDPERSISTSEP};             
               seq_pgroup_id == pgroup_id_1;
             }
             else {
               seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL_CLEANSHARED, svt_chi_transaction::WRITEUNIQUEPTL_CLEANSHARED};             
             }
             sequence_length               == 1;
             seq_txn_id                    == (i % (total_num_tran/2));
             /** Transactions are set to ordered at requestor for stream WriteUniques transactions. */
             seq_order_type   == svt_chi_transaction::NO_ORDERING_REQUIRED;
             if (perform_cache_initialization) {  
               hn_addr_rand_type             == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
               min_addr         == addr_q[2*i + 1];
               max_addr         == addr_q[2*i + 1];
               seq_is_non_secure_access == secure_q[2*i+1];
               use_seq_is_non_secure_access == 1;
             }
             else {
               hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
               if (i < total_num_tran/4) {
                 seq_hn_node_idx == target_hn_node_idx_0;
               }
               else if(i < total_num_tran/2) {
                 seq_hn_node_idx == target_hn_node_idx_1;
               }
               use_seq_is_non_secure_access == 0;
             } 

            })
           
           `svt_xvm_debug("body", $sformatf("%0s Transmitting Write Transaction [%0d] targeted to HN (idx %0d, id %0d) ",`SVT_CHI_PRINT_PREFIX(write_seq[2*i + 1].write_tran),2*i + 1, write_seq[2*i + 1].write_tran.hn_node_idx, write_seq[2*i + 1].write_tran.tgt_id));
           `svt_xvm_verbose("body", $sformatf("Write Transaction [%0d] is %0s", 2*i + 1,write_seq[2*i + 1].write_tran.sprint()));
          end
        join
      end // for (int i = 0; i < total_num_tran/2; i++)

      /** Waiting for the DBIDResp/CompDBDIResp responses from HN for write trasactions */
      foreach(write_seq[wr]) begin
        fork
          automatic int _wr = wr;
          begin
            `svt_xvm_debug("body", $sformatf("%0s Write transaction [%0d] targeted to HN (idx %0d, id %0d), suspend_wr_data %0b: waiting for response from interconnect",`SVT_CHI_PRINT_PREFIX(write_seq[_wr].write_tran),_wr, write_seq[_wr].write_tran.hn_node_idx, write_seq[_wr].write_tran.tgt_id,write_seq[_wr].write_tran.suspend_wr_data));
            fork
            begin
              fork
                begin
                  write_seq[_wr].write_tran.wait_for_tx_data_prereqs();
                end
                begin
                  wait(write_seq[_wr].write_tran.req_status == svt_chi_transaction::RETRY);// begin
                end
              join_any
              disable fork;
            end
            join
            received_responses++;
            `svt_xvm_debug("body", $sformatf("%0s Write transaction [%0d] targeted to HN (idx %0d, id %0d), suspend_wr_data %0b: received response from interconnect. Total responses received %0d",`SVT_CHI_PRINT_PREFIX(write_seq[_wr].write_tran),_wr, write_seq[_wr].write_tran.hn_node_idx, write_seq[_wr].write_tran.tgt_id,write_seq[_wr].write_tran.suspend_wr_data,received_responses));
          end
        join_none
      end

      /** Wait until All 512 DBIDResp/CompDBDIResp responses are received for write transaction */ 
      `svt_xvm_debug("body",$sformatf("Completed initiation of Write type transactions for %0d addresses from p_sequencer.rn_virt_seqr[%0d] and p_sequencer.rn_virt_seqr[%0d] to HN idx %0d and HN idx %0d with suspend_wr_data set to 1, and waiting to receive responses from interconnect.",
                                total_num_tran, initiating_rn_node_idx_0,initiating_rn_node_idx_1,target_hn_node_idx_0,target_hn_node_idx_1));
      wait(received_responses == total_num_tran);
      `svt_xvm_debug("body",$sformatf("Received responses from interconnect to Write type transactions for %0d addresses from p_sequencer.rn_virt_seqr[%0d] and p_sequencer.rn_virt_seqr[%0d] to HN idx %0d and HN idx %0d with suspend_wr_data set to 1.",
                                total_num_tran, initiating_rn_node_idx_0,initiating_rn_node_idx_1,target_hn_node_idx_0,target_hn_node_idx_1));
     
      /** Self Check1: To check suspend_wr_data should not be modified to zero by the VIP
       *  before reseting from test bench.
       */
      foreach (write_seq[self_check_idx1]) begin
        if (!write_seq[self_check_idx1].write_tran.is_terminated()) begin
          if (write_seq[self_check_idx1].write_tran.suspend_wr_data == 0) begin
            `svt_xvm_error("body", $sformatf("%0s suspend_wr_data should be 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(write_seq[self_check_idx1].write_tran)));
          end
          else begin
            `svt_xvm_debug("body", $sformatf("%0s suspend_wr_data is 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(write_seq[self_check_idx1].write_tran)));
          end
        end
      end
     
      /** Self Check2: To check transaction is not ended by the VIP before resuming the 
       *  suspend_wr_data to zero from the test bench
       */
      foreach(write_seq[self_check_idx2]) begin
        if (!write_seq[self_check_idx2].write_tran.is_terminated()) begin
          if (write_seq[self_check_idx2].write_tran.end_event.is_on() == 1) begin
            `svt_xvm_error("body", $sformatf("Unexpected: %0s Transaction's end_event triggered when suspend_wr_data is still 1.", `SVT_CHI_PRINT_PREFIX(write_seq[self_check_idx2].write_tran)));
          end
          else begin
            `svt_xvm_debug("body", $sformatf("Expected: %0s Transaction's end_event is not triggered when suspend_wr_data is still 1.", `SVT_CHI_PRINT_PREFIX(write_seq[self_check_idx2].write_tran)));
          end
        end
      end
 
      /** Self Check 3: To check that the current_outstanding_*_xact_count in the RNs
       * are as per the transactions inititated by the sequence
       */
      /** Check if the total outstanding xact counter is set correctly in the shared status of the RN agent */
      if(write_seq[0].shared_status.prot_status.current_outstanding_xact_count != total_num_tran/2)
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding transactions from the sequence but the outstanding transaction count in the shared status of RN%0d is %0d", total_num_tran/2, initiating_rn_node_idx_0, write_seq[0].shared_status.prot_status.current_outstanding_xact_count));
      /** Check if the outstanding Write xact counter is set correctly in the shared status of the RN agent */
      if(write_seq[0].shared_status.prot_status.current_outstanding_write_xact_count != total_num_tran/2) begin
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding Write transactions from the sequence but the outstanding Write transaction count in the shared status of RN%0d is %0d", total_num_tran/2, initiating_rn_node_idx_0, write_seq[0].shared_status.prot_status.current_outstanding_write_xact_count));
      end
      /** Check if the total outstanding xact counter is set correctly in the shared status of the second RN agent */
      if(write_seq[1].shared_status.prot_status.current_outstanding_xact_count != total_num_tran/2)
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding transactions from the sequence but the oustanding transaction count in the shared status of RN%0d is %0d", total_num_tran/2, initiating_rn_node_idx_1, write_seq[1].shared_status.prot_status.current_outstanding_xact_count));
      /** Check if the outstanding Write xact counter is set correctly in the shared status of the RN agent */
      if(write_seq[1].shared_status.prot_status.current_outstanding_write_xact_count != total_num_tran/2) begin
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding Write transactions from the sequence but the outstanding Write transaction count in the shared status of RN%0d is %0d", total_num_tran/2, initiating_rn_node_idx_1, write_seq[1].shared_status.prot_status.current_outstanding_write_xact_count));
      end

      `svt_xvm_debug("body", $sformatf("RN%0d: Number of outstanding transactions : %0d, Number of outstanding write xacts : %0d", initiating_rn_node_idx_0, write_seq[0].shared_status.prot_status.current_outstanding_xact_count, write_seq[0].shared_status.prot_status.current_outstanding_write_xact_count));
      `svt_xvm_debug("body", $sformatf("RN%0d: Number of outstanding transactions : %0d, Number of outstanding write xacts : %0d", initiating_rn_node_idx_1, write_seq[0].shared_status.prot_status.current_outstanding_xact_count, write_seq[1].shared_status.prot_status.current_outstanding_write_xact_count));

      /** Resuming all NonCopyBackWrData for above write transactions */
      `svt_xvm_debug("body",$sformatf("Resuming the write transactions by setting svt_chi_rn_transaction::suspsend_wr_data set to 0"))
      foreach(write_seq[index4]) begin
        write_seq[index4].write_tran.suspend_wr_data = 0;
          `svt_xvm_debug("body", $sformatf("After Resume received_responses is %0d for iteration %0d and suspend_wr_data is %0b",received_responses, index4, write_seq[index4].write_tran.suspend_wr_data));
      end
      
      /** Waiting for Write transactions to complete */
      `svt_xvm_debug("body",$sformatf("Waiting for completion of all the outstanding write type transactions"));
      foreach(write_seq[self_check_idx3]) begin
        `svt_xvm_debug("body", $sformatf("Waiting for above write_seq[%0d] transaction %0s to end", self_check_idx3, `SVT_CHI_PRINT_PREFIX(write_seq[self_check_idx3].write_tran)));
        write_seq[self_check_idx3].write_tran.wait_end();
      
        /** Self Check4: To check suspend_wr_data should not be asserted after the transaction 
         *  completes as it is reseted from test bench
         */
        if (!write_seq[self_check_idx3].write_tran.is_terminated()) begin
          if (write_seq[self_check_idx3].write_tran.suspend_wr_data == 1) begin
            `svt_xvm_error("body", $sformatf("%0s suspend_wr_data should be 0 as it has been reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(write_seq[self_check_idx3].write_tran)));
          end
          else begin
            `svt_xvm_debug("body", $sformatf("%0s suspend_wr_data is 0 as it is reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(write_seq[self_check_idx3].write_tran)));
          end
        end
      end
      `svt_xvm_debug("body",$sformatf("Received completions for all write type outstanding transactions"));
     
      // Targetted HN IDs from both RNs should be different. Currently, this self-check is only performed
      // the number of outstanding transactions to be issued to an HN is a multiple of 2,ie, total_num_tran is a multiple of 4
      if((total_num_tran % 4) == 0) begin
        for(int i = 0; i<total_num_tran/2; i++)begin
          int hn_idx_0, hn_idx_1;
          hn_idx_0 = sys_cfg.get_hn_idx(write_seq[2*i].output_xacts[0].addr);
          hn_idx_1 = sys_cfg.get_hn_idx(write_seq[2*i + 1].output_xacts[0].addr);
          if(i < total_num_tran/4) begin
            if ((hn_idx_0 == hn_idx_1) && (hn_idx_0 == target_hn_node_idx_0)) begin
            // pass
              `svt_xvm_debug("body", $sformatf("Targeted HN Index from both RNs are same as expected.  rn[%0d] to hn_idx[%0d], rn[%0d] to hn_idx[%0d] and they match with the target_hn_node_idx_0 %0d", initiating_rn_node_idx_0, hn_idx_0, initiating_rn_node_idx_1, hn_idx_1,target_hn_node_idx_0));
            end
            else begin
            // fail
              `svt_xvm_error("body", $sformatf("Targeted HN Index from one or both of the RNs are different from first target node index, which is unexpected.  rn[%0d] %0s transaction to hn_idx[%0d], rn[%0d] %0s transaction to hn_idx[%0d] and the target_hn_node_idx_0 is %0d", initiating_rn_node_idx_0, `SVT_CHI_PRINT_PREFIX( write_seq[2*i].output_xacts[0]), hn_idx_0, initiating_rn_node_idx_1, `SVT_CHI_PRINT_PREFIX( write_seq[2*i + 1].output_xacts[0]), hn_idx_1,target_hn_node_idx_0));
            end
          end
          else if(i < total_num_tran/2) begin
            if ((hn_idx_0 == hn_idx_1) && (hn_idx_0 == target_hn_node_idx_1)) begin
            // pass
              `svt_xvm_debug("body", $sformatf("Targeted HN Index from both RNs are same as expected.  rn[%0d] to hn_idx[%0d], rn[%0d] to hn_idx[%0d] and they match with the target_hn_node_idx_1 %0d", initiating_rn_node_idx_0, hn_idx_0, initiating_rn_node_idx_1, hn_idx_1,target_hn_node_idx_1));
            end
            else begin
              // fail
              `svt_xvm_error("body", $sformatf("Targeted HN Index from one or both of the RNs is different from second target node index, which is unexpected.  rn[%0d] %0s transaction to hn_idx[%0d], rn[%0d] %0s transaction to hn_idx[%0d] and the target_hn_node_idx_1 is %0d", initiating_rn_node_idx_0, `SVT_CHI_PRINT_PREFIX( write_seq[2*i].output_xacts[0]), hn_idx_0, initiating_rn_node_idx_1, `SVT_CHI_PRINT_PREFIX( write_seq[2*i + 1].output_xacts[0]), hn_idx_1,target_hn_node_idx_1));
            end
          end
        end
      end
      
      /** Reset received_responses to zero */
      received_responses = 0;
      
      /** Delete the contents of address collection queue */
      addr_q.delete();
    
    end //for(int k = 0; k < sequence_length; k++)
    
    `svt_xvm_debug("body", "Exiting...")
  endtask: body

  virtual task post_body();
    drop_phase_objection();
  endtask

endclass: svt_chi_e_system_protocol_flow_ctrl_combined_noncopyback_write_cmo_outstanding_diff_rn_diff_hn_virtual_sequence

function svt_chi_e_system_protocol_flow_ctrl_combined_noncopyback_write_cmo_outstanding_diff_rn_diff_hn_virtual_sequence::new(string name="svt_chi_e_system_protocol_flow_ctrl_combined_noncopyback_write_cmo_outstanding_diff_rn_diff_hn_virtual_sequence");
  super.new(name);
endfunction

/** 
 * @groupname CHI_OUTSTANDING_CPBK_TYPE 
 * #- This sequence requires atleast two HN nodes to be present in the Interconnect.
 * #- This sequence requires atleast two initiating active and participating RN-Fs.
 * #- Inititate maximum number of MAKEUNIQUE transactions from existing active and 
 *    participating different RN-Fs, to perform cache initialization to a
 *    randomly selected different HNs.
 * #- Initiate maximum number of combined write copyback cmo type transactions with 
 *    svt_chi_rn_transaction::suspend_wr_data set to 1 from initiating RN-Fs to randomly 
 *    selected HNs in non blocking mode. <br>
 *    - Maximum number of outstanding transactions at the HN is as per either #max_num_outstanding_write_xacts_at_hn or
 *      #max_num_outstanding_xacts_at_hn, which can be controlled through config DB.   
 *    - This ensures that the maximum outstanding transaction limit is reached at
 *      two different HNs. 
 *    - Also, the RN-Fs will not transmit CopyBackWrData corresponding to these
 *      transactions until svt_chi_rn_transaction::suspend_wr_data is set to 0 from the 
 *      sequence.
 *    .
 * #- The addresses of these combined write copyback cmo transactions are such that:
 *    - Same as initialized cache line addresses if cache initialization is performed
 *    .
 * #- The RN-Fs of these combined write copyback cmo transactions are such that:
 *    - Same as RN-Fs from which cache initialization is performed
 *    .
 * #- Once the RN-Fs receives the responses for all the outstanding transactions from
 *    HNs, svt_chi_rn_transaction::suspend_wr_data is set to 0 for all the outstanding
 *    transactions. <br>
 *    This ensures that the CopyBackWrData for these transactions can be resumed 
 *    from RN-Fs.
 * #- Check that the HNs responds properly for all outstanding combined write copyback cmo type
 *    transactions and these are completed successfully.
 * .
 */ 

class svt_chi_e_system_protocol_flow_ctrl_combined_copyback_write_cmo_outstanding_diff_rn_diff_hn_virtual_sequence extends svt_chi_system_base_virtual_sequence;

  //-----------------------------------------------------------------------------  
  // Member attributes
  //-----------------------------------------------------------------------------  
  /** Parameter that controls the enabling of transactions in non-blocking mode from the sequence */
  bit enable_outstanding = 0;

  /** To display contents of Active Participating RN-F's node */
  string str_rn_f_node;

  /** UVM/OVM Object Utility macro */
  `svt_xvm_object_utils(svt_chi_e_system_protocol_flow_ctrl_combined_copyback_write_cmo_outstanding_diff_rn_diff_hn_virtual_sequence)

  //-----------------------------------------------------------------------------  
  // Methods
  //-----------------------------------------------------------------------------
  /** Constructor */
  extern function new(string name="svt_chi_e_system_protocol_flow_ctrl_combined_copyback_write_cmo_outstanding_diff_rn_diff_hn_virtual_sequence"); 

  /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting RN-F Nodes = 2 
   *  #- minimum supporting HN-F Nodes = 2 
   */
  //-----------------------------------------------------------------------------
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    
    /** local variables */
    int num_supporting_rn_f_nodes;
    string str_is_supported_info_prefix = "";
    string str_is_supported_info = "";
    int num_hn_f_nodes;
    int array_idx;
    string str_idx0_info = "";
    string str_idx1_info = "";
    bit    is_rn_idx_0_participating, is_rn_idx_1_participating;

    /** Supporting any type of Request Nodes required */
    int required_num_supporting_rn_f_nodes = 2;
    int required_num_hn_nodes = 2;
         
    `svt_xvm_debug("is_supported",$sformatf("Entering ..."));

    /** By default is_supported is 0 */
    is_supported = 0;

    /** Check for minimum required HN nodes */
    num_hn_f_nodes = hn_f_nodes.size();

    /** Check requirment of number of HN nodes needed */ 
    if (num_hn_f_nodes < required_num_hn_nodes) begin
      issue_is_supported_failure($sformatf("This sequence requires minimum %0d HN_F nodes to be present in the system. Number of HN_F nodes are %0d. Program number of HN nodes using svt_chi_system_configuration::num_hn. Program the HN interface type using svt_chi_system_configuration::chi_addr_cfg.hn_interface_type[].", required_num_hn_nodes, num_hn_f_nodes));
      return 0;      
    end

    /** Check for minimum required RN-F nodes.
     *  Also check whether the selected RN-F nodes are part of participating arrays or not.
     */
    num_supporting_rn_f_nodes = active_participating_rn_f_nodes.size();

    /** Check the requirements of RN-F nodes */  
    if (num_supporting_rn_f_nodes) begin
      /** Display the contents of Active Participating RN-F Nodes */
      foreach (active_participating_rn_f_nodes[j]) begin
        str_rn_f_node = {str_rn_f_node, $sformatf(" %0d", active_participating_rn_f_nodes[j])};
      end      
      `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_f_nodes are %0s", str_rn_f_node));
    end
    
    str_is_supported_info_prefix = $sformatf("Number of Supporting RN_F Node(s)  - Minimum Required : %0d Current : %0d", required_num_supporting_rn_f_nodes,num_supporting_rn_f_nodes);
    
    if ((initiating_rn_node_index_0_status==0)&&(valid_initiating_rn_f_node_index_0==0)) begin
        str_idx0_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN-Fs that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)";
    end
    else begin
      is_rn_idx_0_participating = is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_node_idx_0, array_idx);
      if (!is_rn_idx_0_participating) begin
        str_idx0_info = $sformatf("initiating_rn_node_idx_0 %0d is not valid for this sequence. The RN-F corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)", initiating_rn_node_idx_0, initiating_rn_node_idx_0);
      end
    end

    if ((initiating_rn_node_index_1_status==0)&&(valid_initiating_rn_f_node_index_1==0)) begin
    str_idx1_info = "Valid initiating_rn_node_idx_1 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN-Fs that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)";  
    end 
    else begin
      is_rn_idx_1_participating = is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_node_idx_1, array_idx);
      if (!is_rn_idx_1_participating) begin
        str_idx1_info = $sformatf("initiating_rn_node_idx_1 %0d is not valid for this sequence. The RN-F corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)", initiating_rn_node_idx_1, initiating_rn_node_idx_1);
      end
    end  
    
    if (is_rn_idx_0_participating && is_rn_idx_1_participating) begin
      is_supported = 1;
      if(max_num_outstanding_write_xacts_at_hn > 0) begin
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].num_outstanding_write_xact < max_num_outstanding_write_xacts_at_hn) begin
          str_idx0_info = $sformatf("Programmed value of max_num_outstanding_write_xacts_at_hn_status is %0d. But num_outstanding_write_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_write_xact of the initiating RN node must be equal to or greater than max_num_outstanding_write_xacts_at_hn_status of the target HN", max_num_outstanding_write_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_0_participating].num_outstanding_write_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].num_outstanding_write_xact < max_num_outstanding_write_xacts_at_hn) begin
          str_idx1_info = $sformatf("Programmed value of max_num_outstanding_write_xacts_at_hn_status is %0d. But num_outstanding_write_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_write_xact of the initiating RN node must be equal to or greater than max_num_outstanding_write_xacts_at_hn_status of the target HN", max_num_outstanding_write_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_1_participating].num_outstanding_write_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
      end else begin
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].num_outstanding_xact < max_num_outstanding_xacts_at_hn) begin
          str_idx0_info = $sformatf("Programmed value of max_num_outstanding_xacts_at_hn_status is %0d. But num_outstanding_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_xact of the initiating RN node must be equal to or greater than max_num_outstanding_xacts_at_hn of the target HN", max_num_outstanding_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_0_participating].num_outstanding_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].num_outstanding_xact < max_num_outstanding_xacts_at_hn) begin
          str_idx1_info = $sformatf("Programmed value of max_num_outstanding_xacts_at_hn_status is %0d. But num_outstanding_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_xact of the initiating RN node must be equal to or greater than max_num_outstanding_xacts_at_hn of the target HN", max_num_outstanding_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_1_participating].num_outstanding_xact, initiating_rn_node_idx_1);
          is_supported = 0;
        end
      end

      //check for spec revision
      if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision < svt_chi_node_configuration::ISSUE_E) begin
        is_supported =0;
        str_idx0_info = { str_idx0_info, "\n", $sformatf("This sequence is not applicable for RN with svt_chi_node_configuration::chi_spec_revision < ISSUE_E. Set the chi_spec_revision to ISSUE_E or further. RN node: 'd%0d",initiating_rn_node_idx_0)};
      end
      if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision < svt_chi_node_configuration::ISSUE_E) begin
        is_supported =0;
        str_idx1_info = { str_idx1_info, "\n", $sformatf("This sequence is not applicable for RN with svt_chi_node_configuration::chi_spec_revision < ISSUE_E. Set the chi_spec_revision to ISSUE_E or further. RN node: 'd%0d",initiating_rn_node_idx_1)};
      end

    end
    
    if (!is_supported) begin
      str_is_supported_info = $sformatf("%0s%0s",str_idx0_info, str_idx1_info);
      if (is_rn_idx_0_participating && is_rn_idx_1_participating) begin
        issue_is_supported_failure($sformatf("This sequence cannot be run based on the current system configuration.\n\
                                              %0s\n\
                                              %0s \n\
                                              Modify configurations through \n\
                                              svt_chi_system_configuration::num_rn,\n\
                                              svt_chi_node_configuration::is_active,\n\
                                              svt_chi_system_configuration::participating_rn_nodes[]\n\
                                              ", str_is_supported_info_prefix, str_is_supported_info));
      end
      else begin
        issue_is_supported_failure($sformatf("This sequence cannot be run based on the current node configurations of RN%0d and/or RN%0d.\n\
                                              %0s \n\
                                              Modify configuration through \n\
                                              svt_chi_node_configuration::num_outstanding_xact,\n\
                                              svt_chi_node_configuration::num_outstanding_write_xact,\n\
                                              ",str_is_supported_info, initiating_rn_node_idx_0, initiating_rn_node_idx_1));
      end
    end
    `svt_xvm_debug("is_supported",$sformatf("Exiting ..."));
    if (!is_target_hn_idx_valid_for_curr_cfg()) begin
      is_supported = 0;
      `svt_xvm_note("is_supported", "not a valid hn_idx based on random_tgt_id_enable for current cfg");
    end
  endfunction : is_supported

  //-----------------------------------------------------------------------------
  virtual task pre_start();
    bit enable_outstanding_status;
    `svt_xvm_debug("pre_start",$sformatf("Entering ..."));
    super.pre_start();
    raise_phase_objection();
    enable_outstanding_status = uvm_config_db#(bit)::get(m_sequencer, get_type_name(), "enable_outstanding", enable_outstanding);
    `svt_xvm_debug("body", $sformatf("enable_outstanding is %0b as a result of %0s", enable_outstanding, (enable_outstanding_status?"config DB":"default setting")));
    `svt_xvm_debug("pre_start",$sformatf("Exiting ..."));
  endtask // pre_start

  //-----------------------------------------------------------------------------
  virtual task body();

    int received_copyback_responses=0;
    int NUM_OUTSTANDING_XACT;

    /** Setting transaction id width */
    int txn_id_width=`SVT_CHI_TXN_ID_WIDTH;

    /** Queue of RN-F's, intitiating combined write copyback cmo transactions */
    int initiating_rn_f_node_idx_1_queue[$];
    int initiating_rn_f_node_idx_0_queue[$];

    /** Queue of addresses, used by the transactions generated */
    bit[`SVT_CHI_MAX_ADDR_WIDTH -1:0] rn_f_node_idx_0_copyback_addr_queue[$];                      
    bit[`SVT_CHI_MAX_ADDR_WIDTH -1:0] rn_f_node_idx_1_copyback_addr_queue[$];                      
    bit rn_f_node_idx_0_copyback_non_secure_queue[$];                      
    bit rn_f_node_idx_1_copyback_non_secure_queue[$];                      


    /** Queue of Unique transaction id's, used by the transactions generated */
    int rn_f_node_idx_0_txn_id_queue[$];
    int rn_f_node_idx_1_txn_id_queue[$];

    int pgroup_id_arr_0[$];
    int pgroup_id_arr_1[$];
    int pgroup_id_width=`SVT_CHI_PGROUPID_WIDTH;

    /** Sub Read type transaction cache initialization directed sequences initiated from this sequence */
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq_0[int];
    /** Sub combined write copyback cmo type transaction directed sequences initiated from this sequence */
    svt_chi_rn_copyback_type_transaction_directed_sequence copyback_seq[int];
     
    `svt_xvm_debug("body", "Entering ...")
    super.body();
    
    max_num_outstanding_xacts_at_hn_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(), "max_num_outstanding_xacts_at_hn", max_num_outstanding_xacts_at_hn);
    max_num_outstanding_write_xacts_at_hn_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(), "max_num_outstanding_write_xacts_at_hn", max_num_outstanding_write_xacts_at_hn);
    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :initiating_rn_f_node_index_0;
    initiating_rn_node_idx_1 = initiating_rn_node_index_1_status ? initiating_rn_node_index_1_from_config_db :initiating_rn_f_node_index_1;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_f_node_index_0;
    target_hn_node_idx_1 = target_hn_node_index_1_status ? target_hn_node_index_1_from_config_db :target_hn_f_node_index_1;

    `svt_xvm_debug("body", $sformatf("max_num_outstanding_xacts_at_hn is %0d as a result of %0s.", max_num_outstanding_xacts_at_hn, max_num_outstanding_xacts_at_hn_status ? "config DB" : "default"));
    `svt_xvm_debug("body", $sformatf("max_num_outstanding_write_xacts_at_hn is %0d as a result of %0s.", max_num_outstanding_write_xacts_at_hn, max_num_outstanding_write_xacts_at_hn_status ? "config DB" : "default"));
    `svt_xvm_debug("body", $sformatf("initiating_rn_node_idx_0 is %0d as a result of %0s.", initiating_rn_node_idx_0, initiating_rn_node_index_0_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("initiating_rn_node_idx_1 is %0d as a result of %0s.", initiating_rn_node_idx_1, initiating_rn_node_index_1_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("target_hn_node_idx_0 is %0d as a result of %0s.", target_hn_node_idx_0, target_hn_node_index_0_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("target_hn_node_idx_1 is %0d as a result of %0s.", target_hn_node_idx_1, target_hn_node_index_1_status ? "config DB" : "Randomization"));  
   
    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    //If max outstanding count for Write transactions has been programmed, use that to generate the outstanding combined write copyback cmo
    if(max_num_outstanding_write_xacts_at_hn > 0) begin
      NUM_OUTSTANDING_XACT = (max_num_outstanding_write_xacts_at_hn * 2);
      `svt_xvm_debug("body",$sformatf("max_num_outstanding_write_xacts_at_hn is set to a non-zero value (%0d). Hence, the value programmed in max_num_outstanding_xacts_at_hn will be ignored. The number of outstanding transactions issued by the sequence will be equal to max_num_outstanding_write_xacts_at_hn", max_num_outstanding_write_xacts_at_hn));
    end
    else
      NUM_OUTSTANDING_XACT = (max_num_outstanding_xacts_at_hn * 2);
    `svt_xvm_debug("body", $sformatf("Number of NUM_OUTSTANDING_XACT is %0d",NUM_OUTSTANDING_XACT));

    //start the transactions
    for(int i = 0; i < sequence_length; i++) begin

      /** Collecting txn_id */
       for(int id=0; id <= `SVT_CHI_SPEC_PERMITTED_MAX_TXNID_VALUE_FOR_ISSUE_E; id++) begin
         rn_f_node_idx_0_txn_id_queue.push_back(id);
         rn_f_node_idx_1_txn_id_queue.push_back(id);
       end    
    
      /** Shuffling all collected txn_id */
      rn_f_node_idx_0_txn_id_queue.shuffle;
      rn_f_node_idx_1_txn_id_queue.shuffle;

      for(int id=0; id < (2**`SVT_CHI_PGROUPID_WIDTH); id++) begin
        pgroup_id_arr_0.push_back(id);
        pgroup_id_arr_1.push_back(id);
      end
      pgroup_id_arr_0.shuffle;
      pgroup_id_arr_1.shuffle;

      /** Initiating outstanding MakeUnique transactions from different RN-Fs
       *  to initialize the cache line state 
       */
      for(int l=0; l<NUM_OUTSTANDING_XACT ; l++) begin
        automatic int initiating_rn_index;
        
        if (l%2)begin
          initiating_rn_index = initiating_rn_node_idx_1;
          initiating_rn_f_node_idx_1_queue.push_back(initiating_rn_index);
        end 
        else begin
          initiating_rn_index = initiating_rn_node_idx_0;
          initiating_rn_f_node_idx_0_queue.push_back(initiating_rn_index);
        end 

        `svt_xvm_do_on_with(makeunique_seq_0[l], p_sequencer.rn_virt_seqr[initiating_rn_index].rn_xact_seqr,{
          sequence_length    == 1;
          hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
          use_seq_is_non_secure_access == 0;
          if(l == 0)
          {
            seq_hn_node_idx    == target_hn_node_idx_0;                                        
          }
          else if (l < NUM_OUTSTANDING_XACT/4)
          {
            seq_hn_node_idx == makeunique_seq_0[0].seq_hn_node_idx;                                   
          }
          else if (l == NUM_OUTSTANDING_XACT/4)
          {
            seq_hn_node_idx    == target_hn_node_idx_1;                                        
          }
          else if (l < NUM_OUTSTANDING_XACT/2)
          {
            seq_hn_node_idx == makeunique_seq_0[NUM_OUTSTANDING_XACT/4].seq_hn_node_idx;                                   
          }
          else if ((l >= NUM_OUTSTANDING_XACT/2) && (l < NUM_OUTSTANDING_XACT*3/4))
          {
            seq_hn_node_idx == makeunique_seq_0[0].seq_hn_node_idx;                                   
          }
          else
          {
            seq_hn_node_idx == makeunique_seq_0[NUM_OUTSTANDING_XACT/4].seq_hn_node_idx;                                   
          }
        })
        
        /** Retrieving the addresses from output transactions generated by the sequence  */
        if (l%2)begin
          rn_f_node_idx_1_copyback_addr_queue.push_back(makeunique_seq_0[l].write_tran.addr);
          rn_f_node_idx_1_copyback_non_secure_queue.push_back(makeunique_seq_0[l].write_tran.is_non_secure_access);
        end 
        else begin
          rn_f_node_idx_0_copyback_addr_queue.push_back(makeunique_seq_0[l].write_tran.addr);
          rn_f_node_idx_0_copyback_non_secure_queue.push_back(makeunique_seq_0[l].write_tran.is_non_secure_access);
        end 
      end 

      /** Waiting for above MakeUnique transactions to complete */ 
      foreach(makeunique_seq_0[mu]) begin
         `svt_xvm_debug("body", $sformatf("%0s Waiting for MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) to end",`SVT_CHI_PRINT_PREFIX(makeunique_seq_0[mu].write_tran),mu, makeunique_seq_0[mu].write_tran.hn_node_idx, makeunique_seq_0[mu].write_tran.tgt_id));
         makeunique_seq_0[mu].write_tran.wait_end(); 
         `svt_xvm_debug("body", $sformatf("%0s MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) ended",`SVT_CHI_PRINT_PREFIX(makeunique_seq_0[mu].write_tran),mu, makeunique_seq_0[mu].write_tran.hn_node_idx, makeunique_seq_0[mu].write_tran.tgt_id));

         `svt_xvm_verbose("body", $sformatf("MakeUnique transaction [%0d]  is %0s", mu,makeunique_seq_0[mu].write_tran.sprint()));
      end 

      /** Initiating combined write copyback cmo write */
      for(int j = 0; j < NUM_OUTSTANDING_XACT/2; j++) begin
        automatic int initiating_rn_index;

        fork
          begin
            automatic bit[`SVT_CHI_MAX_ADDR_WIDTH -1:0] txn_addr;                                      
            automatic bit txn_is_non_secure_access;
            automatic bit[(`SVT_CHI_TXN_ID_WIDTH-1):0]txn_id;
            automatic int pgroup_id_1   = pgroup_id_arr_1.pop_front();
            txn_addr = rn_f_node_idx_1_copyback_addr_queue.pop_front();
            txn_is_non_secure_access = rn_f_node_idx_1_copyback_non_secure_queue.pop_front();
            txn_id = rn_f_node_idx_1_txn_id_queue.pop_front();
            
            `svt_xvm_do_on_with(copyback_seq[j], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,{
              sequence_length == 1;
              seq_txn_id == txn_id;
              if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].cleansharedpersistsep_xact_enable == 1) {
                seq_xact_type inside {svt_chi_transaction::WRITEBACKFULL_CLEANSHARED,svt_chi_transaction::WRITEBACKFULL_CLEANSHAREDPERSISTSEP,svt_chi_transaction::WRITEBACKFULL_CLEANINVALID,svt_chi_transaction::WRITECLEANFULL_CLEANSHARED,svt_chi_transaction::WRITECLEANFULL_CLEANSHAREDPERSISTSEP};
                seq_pgroup_id == pgroup_id_1;
              }
              else {
                seq_xact_type inside {svt_chi_transaction::WRITEBACKFULL_CLEANSHARED,svt_chi_transaction::WRITEBACKFULL_CLEANINVALID,svt_chi_transaction::WRITECLEANFULL_CLEANSHARED};
              }
              seq_order_type  == svt_chi_transaction::NO_ORDERING_REQUIRED;
              seq_copyback_req_order_enable == 0;                                          
              hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
              min_addr           == txn_addr;
              max_addr           == txn_addr;     
              seq_is_non_secure_access == txn_is_non_secure_access;
              use_seq_is_non_secure_access == 1;       
              })
            `svt_xvm_debug("body", $sformatf("%0s Transmitting transaction [%0d] targeted to HN (idx %0d, id %0d)",`SVT_CHI_PRINT_PREFIX(copyback_seq[j].copyback_tran),j, copyback_seq[j].copyback_tran.hn_node_idx, copyback_seq[j].copyback_tran.tgt_id));
            `svt_xvm_verbose("body", $sformatf("Combined write copyback cmo Transaction [%0d] is %0s", j,copyback_seq[j].copyback_tran.sprint()));
        end//begin
          begin
            automatic bit[`SVT_CHI_MAX_ADDR_WIDTH -1:0] txn_addr;                                      
            automatic bit txn_is_non_secure_access;
            automatic bit[(`SVT_CHI_TXN_ID_WIDTH-1):0]txn_id;
            automatic int pgroup_id_0   = pgroup_id_arr_0.pop_front();
            txn_addr = rn_f_node_idx_0_copyback_addr_queue.pop_front();
            txn_is_non_secure_access = rn_f_node_idx_0_copyback_non_secure_queue.pop_front();
            txn_id = rn_f_node_idx_0_txn_id_queue.pop_front();
            `svt_xvm_do_on_with(copyback_seq[((NUM_OUTSTANDING_XACT/2) + j)], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,{
              sequence_length == 1;
              seq_txn_id == txn_id;
              if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].cleansharedpersistsep_xact_enable == 1) {
                seq_xact_type inside {svt_chi_transaction::WRITEBACKFULL_CLEANSHARED,svt_chi_transaction::WRITEBACKFULL_CLEANSHAREDPERSISTSEP,svt_chi_transaction::WRITEBACKFULL_CLEANINVALID,svt_chi_transaction::WRITECLEANFULL_CLEANSHARED,svt_chi_transaction::WRITECLEANFULL_CLEANSHAREDPERSISTSEP};
                seq_pgroup_id == pgroup_id_0;
              }
              else {
                seq_xact_type inside {svt_chi_transaction::WRITEBACKFULL_CLEANSHARED,svt_chi_transaction::WRITEBACKFULL_CLEANINVALID,svt_chi_transaction::WRITECLEANFULL_CLEANSHARED};
              }
              seq_order_type  == svt_chi_transaction::NO_ORDERING_REQUIRED;
              seq_copyback_req_order_enable == 0;                                          
              hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
              min_addr           == txn_addr;
              max_addr           == txn_addr;     
              seq_is_non_secure_access == txn_is_non_secure_access;
              use_seq_is_non_secure_access == 1;       
              })
            `svt_xvm_debug("body", $sformatf("%0s Transmitting  transaction [%0d] targeted to HN (idx %0d, id %0d)",`SVT_CHI_PRINT_PREFIX(copyback_seq[((NUM_OUTSTANDING_XACT/2) + j)].copyback_tran),((NUM_OUTSTANDING_XACT/2) + j), copyback_seq[((NUM_OUTSTANDING_XACT/2) + j)].copyback_tran.hn_node_idx, copyback_seq[((NUM_OUTSTANDING_XACT/2) + j)].copyback_tran.tgt_id));
            `svt_xvm_verbose("body", $sformatf("Combined write copyback cmo Transaction [%0d] is %0s", ((NUM_OUTSTANDING_XACT/2) + j),copyback_seq[((NUM_OUTSTANDING_XACT/2) + j)].copyback_tran.sprint()));
          end//begin
        join       
      end//forloop of CopyBack

      /** Checking for the reception of all the CompDBIDResp from the Interconnect */
      foreach(copyback_seq[index_1]) begin
        fork
            automatic int _index_1 = index_1;
          begin
          `svt_xvm_debug("body", $sformatf("%0s combined write copyback cmo transaction [%0d] targeted to HN (idx %0d, id %0d), suspend_wr_data %0b: waiting for response from interconnect",`SVT_CHI_PRINT_PREFIX(copyback_seq[_index_1].copyback_tran),_index_1, copyback_seq[_index_1].copyback_tran.hn_node_idx, copyback_seq[_index_1].copyback_tran.tgt_id,copyback_seq[_index_1].copyback_tran.suspend_wr_data));
            
            //Wait until a CompDBIDResp/RetryAck is received for the generated combined write copyback cmo
            fork
            begin
              fork
                begin
                  copyback_seq[_index_1].copyback_tran.wait_for_tx_data_prereqs();
                end
                begin
                  wait(copyback_seq[_index_1].copyback_tran.req_status == svt_chi_transaction::RETRY);// begin
                end
              join_any
              disable fork;
            end
            join
            received_copyback_responses++;
            
            `svt_xvm_debug("body", $sformatf("%0s Combined write copyback cmo transaction [%0d] targeted to HN (idx %0d, id %0d), suspend_wr_data %0b: waiting for response from interconnect. Total responses received %0d",`SVT_CHI_PRINT_PREFIX(copyback_seq[_index_1].copyback_tran),_index_1, copyback_seq[_index_1].copyback_tran.hn_node_idx, copyback_seq[_index_1].copyback_tran.tgt_id,copyback_seq[_index_1].copyback_tran.suspend_wr_data, received_copyback_responses));
          end
        join_none  
      end
     
      `svt_xvm_debug("body", $sformatf(" Waiting for the CompDBIDResp from HN to Resume the Suspended Response of Copyback transactions "));
      /** Waiting for the CompDBIDResp from HN to Resume the Suspended Response of all above Copyback transactions */ 
      wait(received_copyback_responses == NUM_OUTSTANDING_XACT); 
      
      /** Self Check1: To check suspend_wr_data should not be modified to zero by the VIP
       *  before reseting from test bench.
       */
      foreach (copyback_seq[self_check_idx1]) begin
        if(!copyback_seq[self_check_idx1].copyback_tran.is_terminated()) begin 
          if (copyback_seq[self_check_idx1].copyback_tran.suspend_wr_data == 0) begin
            `svt_xvm_error("body", $sformatf("%0s suspend_wr_data should be 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(copyback_seq[self_check_idx1].copyback_tran)));
          end
          else begin
            `svt_xvm_debug("body", $sformatf("%0s suspend_wr_data is 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(copyback_seq[self_check_idx1].copyback_tran)));
          end
        end  
      end

      /** Self Check2: To check transaction is not ended by the VIP before resuming the 
       *  suspend_wr_data to zero from the test bench<br>
       */
      foreach (copyback_seq[self_check_idx2]) begin
        if(!copyback_seq[self_check_idx2].copyback_tran.is_terminated()) begin 
          /** Fail  event has triggered */
          if (copyback_seq[self_check_idx2].copyback_tran.end_event.is_on() == 1) begin
            `svt_xvm_error("body", $sformatf("Unexpected: %0s Transaction's end_event triggered when suspend_wr_data is still 1.", `SVT_CHI_PRINT_PREFIX(copyback_seq[self_check_idx2].copyback_tran)));
          end
          /** Pass  event is not triggered */
          else begin
            `svt_xvm_debug("body", $sformatf("Expected: %0s Transaction's end_event is not triggered when suspend_wr_data is still 1.", `SVT_CHI_PRINT_PREFIX(copyback_seq[self_check_idx2].copyback_tran)));
          end
        end
      end
 
      /** Self Check 3: To check that the current_outstanding_*_xact_count in the RNs
       * are as per the transactions inititated by the sequence
       */
      /** Check if the total outstanding xact counter is set correctly in the shared status of the RN agent */
      if(copyback_seq[0].shared_status.prot_status.current_outstanding_xact_count != NUM_OUTSTANDING_XACT/2)
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding transactions from the sequence but the outstanding transaction count in the shared status of RN%0d is %0d", NUM_OUTSTANDING_XACT/2, initiating_rn_node_idx_0, copyback_seq[0].shared_status.prot_status.current_outstanding_xact_count));
      /** Check if the outstanding Write xact counter is set correctly in the shared status of the RN agent */
      if(copyback_seq[0].shared_status.prot_status.current_outstanding_write_xact_count != NUM_OUTSTANDING_XACT/2) begin
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding combined write copyback cmo transactions from the sequence but the outstanding Write transaction count in the shared status of RN%0d is %0d", NUM_OUTSTANDING_XACT/2, initiating_rn_node_idx_0, copyback_seq[0].shared_status.prot_status.current_outstanding_write_xact_count));
      end
      /** Check if the total outstanding xact counter is set correctly in the shared status of the RN agent */
      if(copyback_seq[1].shared_status.prot_status.current_outstanding_xact_count != NUM_OUTSTANDING_XACT/2)
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding transactions from the sequence but the outstanding transaction count in the shared status of RN%0d is %0d", NUM_OUTSTANDING_XACT/2, initiating_rn_node_idx_1, copyback_seq[1].shared_status.prot_status.current_outstanding_xact_count));
      /** Check if the outstanding Write xact counter is set correctly in the shared status of the RN agent */
      if(copyback_seq[1].shared_status.prot_status.current_outstanding_write_xact_count != NUM_OUTSTANDING_XACT/2) begin
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding combined write copyback cmo transactions from the sequence but the outstanding Write transaction count in the shared status of RN%0d is %0d", NUM_OUTSTANDING_XACT/2, initiating_rn_node_idx_1, copyback_seq[1].shared_status.prot_status.current_outstanding_write_xact_count));
      end

      `svt_xvm_debug("body", $sformatf("RN%0d: Number of outstanding transactions : %0d, Number of outstanding write xacts : %0d", initiating_rn_node_idx_0, copyback_seq[0].shared_status.prot_status.current_outstanding_xact_count, copyback_seq[0].shared_status.prot_status.current_outstanding_write_xact_count));
      `svt_xvm_debug("body", $sformatf("RN%0d: Number of outstanding transactions : %0d, Number of outstanding write xacts : %0d", initiating_rn_node_idx_1, copyback_seq[1].shared_status.prot_status.current_outstanding_xact_count, copyback_seq[1].shared_status.prot_status.current_outstanding_write_xact_count));

      /** Resuming the Suspended Response of all above combined write copyback cmo transactions  */
      foreach(copyback_seq[wr]) begin
        `svt_xvm_debug("body",$sformatf("Received responses for all combined write copyback cmo type transactions from interconnect, resuming the transactions by setting svt_chi_rn_transaction::suspend_wr_data set to 0 %0s",`SVT_CHI_PRINT_PREFIX(copyback_seq[wr].copyback_tran)));
        copyback_seq[wr].copyback_tran.suspend_wr_data=0; 
        `svt_xvm_debug("body", $sformatf("For iteration %0d : After Resume, received_cmo_responses is %0d,suspend_wr_data is %0b", wr,received_copyback_responses,copyback_seq[wr].copyback_tran.suspend_wr_data));
      end

      `svt_xvm_debug("body",$sformatf("Waiting for completion of all the outstanding copyback type transactions"));
      /** Waiting for above combined write copyback cmo outstanding transactions to complete */ 
      foreach(copyback_seq[index_5]) begin
        `svt_xvm_debug("body", $sformatf("Waiting for above copyback[%0d] transaction %0s to end", index_5, `SVT_CHI_PRINT_PREFIX(copyback_seq[index_5].copyback_tran)));
        copyback_seq[index_5].copyback_tran.wait_end(); 
        /** Self Check4: To check suspend_wr_data should not be asserted after
         * the transaction completes as it is reseted from test bench
         */
        if(!copyback_seq[index_5].copyback_tran.is_terminated()) begin 
          if (copyback_seq[index_5].copyback_tran.suspend_wr_data == 1) begin
            `svt_xvm_error("body", $sformatf("%0s suspend_wr_data  should be 0 as it should be reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(copyback_seq[index_5].copyback_tran)));
          end
          else begin
            `svt_xvm_debug("body", $sformatf("%0s suspend_wr_data is 0 as it is reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(copyback_seq[index_5].copyback_tran)));
          end
        end
      end

      // Targetted HN IDs from both RNs should be different. This check is currently enabled only when
      // the number of outstanding transactions to be issued to an HN is a multiple of 4,ie, NUM_OUTSTANDING_XACT is a multiple of 8
      if((NUM_OUTSTANDING_XACT % 8) == 0) begin
        for(int i = 0; i<NUM_OUTSTANDING_XACT/2; i++)begin
          int hn_idx_0, hn_idx_1;
          hn_idx_0 = sys_cfg.get_hn_idx(copyback_seq[i].output_xacts[0].addr);
          hn_idx_1 = sys_cfg.get_hn_idx(copyback_seq[(NUM_OUTSTANDING_XACT/2) + i].output_xacts[0].addr);
          if((i < NUM_OUTSTANDING_XACT/8) || ((i >= NUM_OUTSTANDING_XACT/4) && (i < 3*NUM_OUTSTANDING_XACT/8))) begin
            if ((hn_idx_0 == hn_idx_1) && (hn_idx_0 == target_hn_node_idx_0)) begin
              `svt_xvm_debug("body", $sformatf("Targeted HN Index from both RNs are same as expected.  rn[%0d] to hn_idx[%0d], rn[%0d] to hn_idx[%0d] and they match with the target_hn_node_idx_0 %0d", initiating_rn_node_idx_0, hn_idx_0, initiating_rn_node_idx_1, hn_idx_1,target_hn_node_idx_0));
            end
            else begin
              `svt_xvm_error("body", $sformatf("Targeted HN Index from one or both of the RNs are different from first target node index, which is unexpected.  rn[%0d] %0s transaction to hn_idx[%0d], rn[%0d] %0s transaction to hn_idx[%0d] and the target_hn_node_idx_0 is %0d", initiating_rn_node_idx_0, `SVT_CHI_PRINT_PREFIX(copyback_seq[2*i].output_xacts[0]), hn_idx_0, initiating_rn_node_idx_1, `SVT_CHI_PRINT_PREFIX( copyback_seq[2*i + 1].output_xacts[0]), hn_idx_1,target_hn_node_idx_0));
            end
          end
          else if((i < NUM_OUTSTANDING_XACT/4) || ((i >= 3*NUM_OUTSTANDING_XACT/8) && (i < NUM_OUTSTANDING_XACT/2))) begin
            if ((hn_idx_0 == hn_idx_1) && (hn_idx_0 == target_hn_node_idx_1)) begin
              `svt_xvm_debug("body", $sformatf("Targeted HN Index from both RNs are same as expected.  rn[%0d] to hn_idx[%0d], rn[%0d] to hn_idx[%0d] and they match with the target_hn_node_idx_1 %0d", initiating_rn_node_idx_0, hn_idx_0, initiating_rn_node_idx_1, hn_idx_1,target_hn_node_idx_1));
            end
            else begin
              `svt_xvm_error("body", $sformatf("Targeted HN Index from one or both of the RNs are different from first target node index, which is unexpected.  rn[%0d] %0s transaction to hn_idx[%0d], rn[%0d] %0s transaction to hn_idx[%0d] and the target_hn_node_idx_1 is %0d", initiating_rn_node_idx_0,`SVT_CHI_PRINT_PREFIX(copyback_seq[2*i].output_xacts[0]),hn_idx_0, initiating_rn_node_idx_1, `SVT_CHI_PRINT_PREFIX(copyback_seq[2*i + 1].output_xacts[0]),hn_idx_1,target_hn_node_idx_1));
            end
          end
        end
      end

      /** Empty the address ,RN-F's and txn_id queues */
      rn_f_node_idx_0_copyback_addr_queue.delete();
      rn_f_node_idx_1_copyback_addr_queue.delete();
      rn_f_node_idx_0_copyback_non_secure_queue.delete();
      rn_f_node_idx_1_copyback_non_secure_queue.delete();
      rn_f_node_idx_0_txn_id_queue.delete();
      rn_f_node_idx_1_txn_id_queue.delete();    
      initiating_rn_f_node_idx_1_queue.delete();  
      initiating_rn_f_node_idx_0_queue.delete();

      /** Reset received_copyback_responses to Zero */
      received_copyback_responses = 0;

    end//forloop of sequence_length

    `svt_xvm_debug("body", "Exiting...")
  endtask: body

  //-----------------------------------------------------------------------------
  virtual task post_start();
    super.post_start();
    drop_phase_objection();
  endtask

endclass:svt_chi_e_system_protocol_flow_ctrl_combined_copyback_write_cmo_outstanding_diff_rn_diff_hn_virtual_sequence

//===============================================================================
function svt_chi_e_system_protocol_flow_ctrl_combined_copyback_write_cmo_outstanding_diff_rn_diff_hn_virtual_sequence::new(string name="svt_chi_e_system_protocol_flow_ctrl_combined_copyback_write_cmo_outstanding_diff_rn_diff_hn_virtual_sequence");
  super.new(name);
endfunction

//====================================================================================
/** 
 * @groupname CHI_OUTSTANDING_CPBK_TYPE 
 * #- This sequence requires atleast one HN node to be present in the Interconnect.
 * #- This sequence requires atleast two initiating active and participating RN-Fs.
 * #- Inititate maximum number of MAKEUNIQUE transactions from existing active and 
 *    participating different RN-Fs, to perform cache initialization to a
 *    randomly selected HN.
 * #- Initiate maximum number of combined write copyback cmo type transactions with 
 *    svt_chi_rn_transaction::suspend_wr_data set to 1 from initiating RN-Fs to randomly 
 *    selected HN in non blocking mode. <br>
 *    - Maximum number of outstanding transactions at the HN is as per either #max_num_outstanding_write_xacts_at_hn or
 *      #max_num_outstanding_xacts_at_hn, which can be controlled through config DB.  
 *    - This ensures that the maximum outstanding transaction limit is reached at
 *      the HN. 
 *    - Also,the RN-Fs will not transmit CopyBackWrData corresponding to these
 *      transactions until svt_chi_rn_transaction::suspend_wr_data is set to 0 from the 
 *      sequence.
 *    .
 * #- The addresses of these combined write copyback cmo transactions are such that:
 *    - Same as initialized cache line addresses if cache initialization is performed
 *    .
 * #- The RN-Fs of these combined write copyback cmo transactions are such that:
 *    - Same as RN-Fs from which cache initialization is performed
 *    .
 * #- Once the RN-Fs receives the responses for all the outstanding transactions from
 *    the HN, svt_chi_rn_transaction::suspend_wr_data is set to 0 for all the outstanding
 *    transactions. <br>
 *    This ensures that the CopyBackWrData for these transactions can be resumed 
 *    from RN-Fs.
 * #- Check that the HN responds properly for all outstanding combined write copyback cmo type
 *    transactions and these are completed successfully.
 * .
 */ 

class svt_chi_e_system_protocol_flow_ctrl_combined_write_copyback_cmo_outstanding_diff_rn_same_hn_virtual_sequence extends svt_chi_system_base_virtual_sequence;

  //-----------------------------------------------------------------------------  
  // Member attributes
  //----------------------------------------------------------------------------- 

  /** To display contents of Active Participating RN-F's node */
  string str_rn_f_node;

  /** Represents the received read responses */
  int received_copyback_responses = 0;

  /** UVM Object Utility macro */
  `svt_xvm_object_utils(svt_chi_e_system_protocol_flow_ctrl_combined_write_copyback_cmo_outstanding_diff_rn_same_hn_virtual_sequence)

  //-----------------------------------------------------------------------------  
  // Methods
  //-----------------------------------------------------------------------------
  /** Constructor */
  extern function new(string name="svt_chi_e_system_protocol_flow_ctrl_combined_write_copyback_cmo_outstanding_diff_rn_same_hn_virtual_sequence"); 
 
  //-----------------------------------------------------------------------------  
  virtual task pre_start();
    `svt_xvm_debug("pre_start",$sformatf("Entering ..."));
    super.pre_start();
    raise_phase_objection();
    `svt_xvm_debug("pre_start",$sformatf("Exiting ..."));
  endtask // pre_start

  /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting Request Nodes = 2
   *  #- minimum supporting Home Nodes = 1
   */
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    
    /** local variables */
    int num_supporting_rn_f_nodes;
    int num_hn_f_nodes;   
    int array_idx;
    bit is_rn_idx_0_participating, is_rn_idx_1_participating;
    string str_is_supported_info_prefix = "";
    string str_is_supported_info = "";
    string str_idx0_info = "";
    string str_idx1_info = "";    

    /** Supporting RN-F Nodes required */
    int required_num_supporting_rn_f_nodes = 2;
    int required_num_hn_nodes = 1;
    
    `svt_xvm_debug("is_supported",$sformatf("Entering ..."));

    /** By default is_supported is 0 */
    is_supported = 0;

    /** Check for minimum required HN nodes */
    num_hn_f_nodes = hn_f_nodes.size();

    /** Check requirment of number of HN nodes needed */  
    if (num_hn_f_nodes < required_num_hn_nodes) begin
      issue_is_supported_failure($sformatf("This sequence requires minimum %0d HN-F nodes to be present in the system. Number of HN-F nodes are %0d. Program number of HN nodes using svt_chi_system_configuration::num_hn. Program the HN interface type using svt_chi_system_configuration::chi_addr_cfg.hn_interface_type[].", required_num_hn_nodes, num_hn_f_nodes));             
      return 0;      
    end
    /** Check for minimum required RN-F nodes.
     *  Also check whether the selected RN-F nodes are part of participating arrays or not.
     */ 
    num_supporting_rn_f_nodes = active_participating_rn_f_nodes.size();

    /** Check the requirements of RN-F nodes */  
    if (num_supporting_rn_f_nodes) begin
      /** Display the contents of Active Participating RN-F Nodes */
      foreach (active_participating_rn_f_nodes[j]) begin
        str_rn_f_node = {str_rn_f_node, $sformatf(" %0d", active_participating_rn_f_nodes[j])};
      end 
      `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_f_nodes are %0s", str_rn_f_node));
    end

    str_is_supported_info_prefix = $sformatf("Number of Supporting RN-F Node(s)  - Minimum Required : %0d Current : %0d", required_num_supporting_rn_f_nodes, num_supporting_rn_f_nodes);
    
    if ((initiating_rn_node_index_0_status==0)&&(valid_initiating_rn_f_node_index_0==0)) begin
        str_idx0_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN-Fs that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)";
    end
    else begin
      is_rn_idx_0_participating = is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_node_idx_0, array_idx);
      if (!is_rn_idx_0_participating) begin
        str_idx0_info = $sformatf("initiating_rn_node_idx_0 %0d is not valid for this sequence. The RN-F corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)", initiating_rn_node_idx_0, initiating_rn_node_idx_0);
      end
    end

    if ((initiating_rn_node_index_1_status==0)&&(valid_initiating_rn_f_node_index_1==0)) begin
      str_idx1_info = "Valid initiating_rn_node_idx_1 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN-Fs that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)";
    end 
    else begin
      is_rn_idx_1_participating = is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_node_idx_1, array_idx);
      if (!is_rn_idx_1_participating) begin
        str_idx1_info = $sformatf("initiating_rn_node_idx_1 %0d is not valid for this sequence. The RN-F corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)", initiating_rn_node_idx_1, initiating_rn_node_idx_1);
      end
    end  

    if (is_rn_idx_0_participating && is_rn_idx_1_participating) begin
      is_supported = 1;
      if(max_num_outstanding_write_xacts_at_hn > 0) begin
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].num_outstanding_write_xact < (max_num_outstanding_write_xacts_at_hn/2)) begin
          str_idx0_info = $sformatf("Programmed value of max_num_outstanding_write_xacts_at_hn_status is %0d. But num_outstanding_write_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_write_xact of the initiating RN node must be equal to or greater than half of max_num_outstanding_write_xacts_at_hn_status of the target HN", max_num_outstanding_write_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_0_participating].num_outstanding_write_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].num_outstanding_write_xact < (max_num_outstanding_write_xacts_at_hn/2)) begin
          str_idx1_info = $sformatf("Programmed value of max_num_outstanding_write_xacts_at_hn_status is %0d. But num_outstanding_write_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_write_xact of the initiating RN node must be equal to or greater than half of max_num_outstanding_write_xacts_at_hn_status of the target HN", max_num_outstanding_write_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_1_participating].num_outstanding_write_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
      end else begin
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].num_outstanding_xact < (max_num_outstanding_xacts_at_hn/2)) begin
          str_idx0_info = $sformatf("Programmed value of max_num_outstanding_xacts_at_hn_status is %0d. But num_outstanding_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_xact of the initiating RN node must be equal to or greater than half of max_num_outstanding_xacts_at_hn of the target HN", max_num_outstanding_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_0_participating].num_outstanding_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].num_outstanding_xact < (max_num_outstanding_xacts_at_hn/2)) begin
          str_idx1_info = $sformatf("Programmed value of max_num_outstanding_xacts_at_hn_status is %0d. But num_outstanding_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_xact of the initiating RN node must be equal to or greater than half of max_num_outstanding_xacts_at_hn of the target HN", max_num_outstanding_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_1_participating].num_outstanding_xact, initiating_rn_node_idx_1);
          is_supported = 0;
        end
      end

      //check for chi_spec_revision
       if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision < svt_chi_node_configuration::ISSUE_E) begin
        is_supported =0;
        str_idx0_info = { str_idx0_info, "\n", $sformatf("This sequence is not applicable for RN with svt_chi_node_configuration::chi_spec_revision < ISSUE_E. Set the chi_spec_revision to ISSUE_E or further. RN node: 'd%0d",initiating_rn_node_idx_0)};
      end
      if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision < svt_chi_node_configuration::ISSUE_E) begin
        is_supported =0;
        str_idx1_info = { str_idx1_info, "\n", $sformatf("This sequence is not applicable for RN with svt_chi_node_configuration::chi_spec_revision < ISSUE_E. Set the chi_spec_revision to ISSUE_E or further. RN node: 'd%0d",initiating_rn_node_idx_1)};
      end

    end
    
    if (!is_supported) begin
      str_is_supported_info = $sformatf("%0s%0s",str_idx0_info, str_idx1_info);
      if (is_rn_idx_0_participating && is_rn_idx_1_participating) begin
        issue_is_supported_failure($sformatf("This sequence cannot be run based on the current system configuration.\n\
                                              %0s\n\
                                              %0s \n\
                                              Modify configurations through \n\
                                              svt_chi_system_configuration::num_rn,\n\
                                              svt_chi_node_configuration::is_active,\n\
                                              svt_chi_system_configuration::participating_rn_nodes[]\n\
                                              ", str_is_supported_info_prefix, str_is_supported_info));
      end
      else begin
        issue_is_supported_failure($sformatf("This sequence cannot be run based on the current node configurations of RN%0d and/or RN%0d.\n\
                                              %0s \n\
                                              Modify configuration through \n\
                                              svt_chi_node_configuration::num_outstanding_xact,\n\
                                              svt_chi_node_configuration::num_outstanding_write_xact,\n\
                                              ",str_is_supported_info, initiating_rn_node_idx_0, initiating_rn_node_idx_1));
      end
    end      
    if (!is_target_hn_idx_valid_for_curr_cfg()) begin
      is_supported = 0;
      `svt_xvm_note("is_supported", "not a valid hn_idx based on random_tgt_id_enable for current cfg");
    end
  endfunction : is_supported

  //----------------------------------------------------------------------------- 
  virtual task body();
    /** Queue for collecting the Address to send combined write copyback cmo transactions */
    bit[`SVT_CHI_MAX_ADDR_WIDTH -1:0] rn_f_node_idx_0_copyback_addr_queue[$];                      
    bit[`SVT_CHI_MAX_ADDR_WIDTH -1:0] rn_f_node_idx_1_copyback_addr_queue[$];     
    bit rn_f_node_idx_0_copyback_non_secure_queue[$];                      
    bit rn_f_node_idx_1_copyback_non_secure_queue[$];                      
    /** Queue to collect Unique transaction id's */    
    int txn_id_arr[$];
    /** Setting transaction id width */
    int txn_id_width=`SVT_CHI_TXN_ID_WIDTH;
    int num_outstanding_xacts_to_generate;

    int pgroup_id_arr_0[$];
    int pgroup_id_arr_1[$];
    int pgroup_id_width=`SVT_CHI_PGROUPID_WIDTH;

    /** Sub sequences initiated from this sequence */
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq[int];
    svt_chi_rn_copyback_type_transaction_directed_sequence copyback_seq[int];

    `svt_xvm_debug("body", "Entering ...")
    super.body();

    max_num_outstanding_xacts_at_hn_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(), "max_num_outstanding_xacts_at_hn", max_num_outstanding_xacts_at_hn);
    max_num_outstanding_write_xacts_at_hn_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(), "max_num_outstanding_write_xacts_at_hn", max_num_outstanding_write_xacts_at_hn);
    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :initiating_rn_f_node_index_0;
    initiating_rn_node_idx_1 = initiating_rn_node_index_1_status ? initiating_rn_node_index_1_from_config_db :initiating_rn_f_node_index_1;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_f_node_index_0;

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    //If max outstanding count for Write transactions has been programmed, use that to generate the outstanding combined write copyback cmo
    if(max_num_outstanding_write_xacts_at_hn > 0) begin
      num_outstanding_xacts_to_generate = max_num_outstanding_write_xacts_at_hn;
      `svt_xvm_debug("body",$sformatf("max_num_outstanding_write_xacts_at_hn is set to a non-zero value (%0d). Hence, the value programmed in max_num_outstanding_xacts_at_hn will be ignored. The number of outstanding transactions issued by the sequence will be equal to max_num_outstanding_write_xacts_at_hn", max_num_outstanding_write_xacts_at_hn));
    end
    //If not, use the max outstanding transaction count
    else
      num_outstanding_xacts_to_generate = max_num_outstanding_xacts_at_hn;

    for(int i = 0; i < sequence_length; i++) begin
      `svt_xvm_debug("body",$sformatf("Starting cache initialization for %0d addresses from p_sequencer.rn_virt_seqr[%0d] and p_sequencer.rn_virt_seqr[%0d] to HN idx %0d",
                                        num_outstanding_xacts_to_generate, initiating_rn_node_idx_0, initiating_rn_node_idx_1, target_hn_node_idx_0));

      /** Collecting txn_id */
      for(int id=0; id <= `SVT_CHI_SPEC_PERMITTED_MAX_TXNID_VALUE_FOR_ISSUE_E; id++) begin
        txn_id_arr.push_back(id);
      end

      /** Shuffling all collected txn_id */
      txn_id_arr.shuffle;

      for(int id=0; id < (2**`SVT_CHI_PGROUPID_WIDTH); id++) begin
        pgroup_id_arr_0.push_back(id);
        pgroup_id_arr_1.push_back(id);
      end
      pgroup_id_arr_0.shuffle;
      pgroup_id_arr_1.shuffle;

      /** Initiating outstanding MakeUnique transactions from different RN-Fs
       *  to initialize the cache line state  
       */
      for(int l=0; l< num_outstanding_xacts_to_generate; l++) begin
        automatic int initiating_rn_index;
        if (l%2)begin
          initiating_rn_index = initiating_rn_node_idx_1;
        end 
        else begin
          initiating_rn_index = initiating_rn_node_idx_0;
        end 
        `svt_xvm_do_on_with(makeunique_seq[l], p_sequencer.rn_virt_seqr[initiating_rn_index].rn_xact_seqr,{
          sequence_length    == 1;
          hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
          seq_hn_node_idx  == target_hn_node_idx_0;
          use_seq_is_non_secure_access == 0;        
        })
        
        `svt_xvm_debug("body", $sformatf("%0s Waiting for MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) to end",`SVT_CHI_PRINT_PREFIX(makeunique_seq[l].write_tran),l, makeunique_seq[l].write_tran.hn_node_idx, makeunique_seq[l].write_tran.tgt_id));
        // Waiting for current MakeUnique transaction to complete 
        makeunique_seq[l].write_tran.wait_end();
        
          //Checking if transaction is dropped
         if (makeunique_seq[l].output_xacts[0].is_xact_dropped) begin
           `svt_xvm_debug("body", $sformatf("%0s First set of MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) is Droppped. Re-randomizing the transaction.",`SVT_CHI_PRINT_PREFIX(makeunique_seq[l].write_tran),l, makeunique_seq[l].write_tran.hn_node_idx, makeunique_seq[l].write_tran.tgt_id));
           l--;
         end
         
         else begin
           
           if (l%2)begin
             rn_f_node_idx_1_copyback_addr_queue.push_back(makeunique_seq[l].write_tran.addr);
             rn_f_node_idx_1_copyback_non_secure_queue.push_back(makeunique_seq[l].write_tran.is_non_secure_access);
           end 
           else begin
             rn_f_node_idx_0_copyback_addr_queue.push_back(makeunique_seq[l].write_tran.addr);
             rn_f_node_idx_0_copyback_non_secure_queue.push_back(makeunique_seq[l].write_tran.is_non_secure_access);
           end 

           `svt_xvm_debug("body", $sformatf("%0s MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) ended",`SVT_CHI_PRINT_PREFIX(makeunique_seq[l].write_tran),l, makeunique_seq[l].write_tran.hn_node_idx, makeunique_seq[l].write_tran.tgt_id));
           
           `svt_xvm_verbose("body", $sformatf("MakeUnique transaction [%0d]  is %0s", l,makeunique_seq[l].write_tran.sprint()));
           
         end //end of else condition of cache state check
      end //forloop of MakeUnique 

      /** Initiating outstanding combined write copyBack cmo transactions from two Random RN-Fs.  
       */
        fork
          begin
            for(int j = 0; j < (num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2); j++) begin
              automatic bit[`SVT_CHI_MAX_ADDR_WIDTH -1:0] txn_addr;                                      
              automatic bit txn_is_non_secure_access;                                      
              automatic bit[(`SVT_CHI_TXN_ID_WIDTH-1):0]txn_id   = txn_id_arr.pop_front();
              automatic int pgroup_id_0   = pgroup_id_arr_0.pop_front();
              txn_addr = rn_f_node_idx_0_copyback_addr_queue.pop_front();
              txn_is_non_secure_access = rn_f_node_idx_0_copyback_non_secure_queue.pop_front();
              `svt_xvm_do_on_with(copyback_seq[j], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,{
                sequence_length == 1;
                seq_txn_id == txn_id;
                if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].cleansharedpersistsep_xact_enable == 1) {
                  seq_xact_type inside {svt_chi_transaction::WRITEBACKFULL_CLEANSHARED,svt_chi_transaction::WRITEBACKFULL_CLEANSHAREDPERSISTSEP,svt_chi_transaction::WRITEBACKFULL_CLEANINVALID,svt_chi_transaction::WRITECLEANFULL_CLEANSHARED,svt_chi_transaction::WRITECLEANFULL_CLEANSHAREDPERSISTSEP};
                  seq_pgroup_id == pgroup_id_0;
                }
                else {
                  seq_xact_type inside {svt_chi_transaction::WRITEBACKFULL_CLEANSHARED,svt_chi_transaction::WRITEBACKFULL_CLEANINVALID,svt_chi_transaction::WRITECLEANFULL_CLEANSHARED};
                }
                seq_order_type  == svt_chi_transaction::NO_ORDERING_REQUIRED;
                seq_copyback_req_order_enable == 0;                        
                hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                min_addr           == txn_addr;
                max_addr           == txn_addr;     
                seq_is_non_secure_access == txn_is_non_secure_access;
                use_seq_is_non_secure_access == 1;
                })

              `svt_xvm_debug("body", $sformatf("%0s Transmitting combined write copyback cmo transaction [%0d] targeted to HN (idx %0d, id %0d) ",`SVT_CHI_PRINT_PREFIX(copyback_seq[j].copyback_tran),j, copyback_seq[j].copyback_tran.hn_node_idx, copyback_seq[j].copyback_tran.tgt_id));
              `svt_xvm_verbose("body", $sformatf("Combined write copyback cmo Transaction [%0d] is %0s", j,copyback_seq[j].copyback_tran.sprint()));
            end  
          end  
          begin
            for(int j = 0; j < num_outstanding_xacts_to_generate/2; j++) begin
              automatic bit[`SVT_CHI_MAX_ADDR_WIDTH -1:0] txn_addr;                                      
              automatic bit txn_is_non_secure_access;                                      
              automatic bit[(`SVT_CHI_TXN_ID_WIDTH-1):0]txn_id   = txn_id_arr.pop_front();
              automatic int pgroup_id_1   = pgroup_id_arr_1.pop_front();
              txn_addr = rn_f_node_idx_1_copyback_addr_queue.pop_front();
              txn_is_non_secure_access = rn_f_node_idx_1_copyback_non_secure_queue.pop_front();
              `svt_xvm_do_on_with(copyback_seq[((num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2)+j)], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,{
                sequence_length == 1;
                seq_txn_id == txn_id;
                if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].cleansharedpersistsep_xact_enable == 1) {
                  seq_xact_type inside {svt_chi_transaction::WRITEBACKFULL_CLEANSHARED,svt_chi_transaction::WRITEBACKFULL_CLEANSHAREDPERSISTSEP,svt_chi_transaction::WRITEBACKFULL_CLEANINVALID,svt_chi_transaction::WRITECLEANFULL_CLEANSHARED,svt_chi_transaction::WRITECLEANFULL_CLEANSHAREDPERSISTSEP};
                  seq_pgroup_id == pgroup_id_1;
                }
                else {
                  seq_xact_type inside {svt_chi_transaction::WRITEBACKFULL_CLEANSHARED,svt_chi_transaction::WRITEBACKFULL_CLEANINVALID,svt_chi_transaction::WRITECLEANFULL_CLEANSHARED};
                }
                seq_order_type  == svt_chi_transaction::NO_ORDERING_REQUIRED;
                seq_copyback_req_order_enable == 0;     
                hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                min_addr           == txn_addr;
                max_addr           == txn_addr;     
                seq_is_non_secure_access == txn_is_non_secure_access;
                use_seq_is_non_secure_access == 1;       
                })
              `svt_xvm_debug("body", $sformatf("%0s Transmitting  combined write copyback cmo transaction [%0d] targeted to HN (idx %0d, id %0d) ",`SVT_CHI_PRINT_PREFIX(copyback_seq[((num_outstanding_xacts_to_generate/2)+j)].copyback_tran),((num_outstanding_xacts_to_generate/2)+j), copyback_seq[((num_outstanding_xacts_to_generate/2)+j)].copyback_tran.hn_node_idx, copyback_seq[((num_outstanding_xacts_to_generate/2)+j)].copyback_tran.tgt_id));
              `svt_xvm_verbose("body", $sformatf("Combined write copyback cmo Transaction [%0d] is %0s", ((num_outstanding_xacts_to_generate/2)+j),copyback_seq[((num_outstanding_xacts_to_generate/2)+j)].copyback_tran.sprint()));
            end  
          end  
        join  

      /** Checking for the reception of all the CompDBIDResp from the Interconnect */
      foreach(copyback_seq[index_1]) begin
        fork
          automatic int _index_1 = index_1;
          begin
            `svt_xvm_debug("body", $sformatf("%0s Combined write copyback cmo transaction [%0d] targeted to HN (idx %0d, id %0d), suspend_wr_data %0b: waiting for response from interconnect",`SVT_CHI_PRINT_PREFIX(copyback_seq[_index_1].copyback_tran),_index_1, copyback_seq[_index_1].copyback_tran.hn_node_idx, copyback_seq[_index_1].copyback_tran.tgt_id,copyback_seq[_index_1].copyback_tran.suspend_wr_data));
            fork
            begin
              fork
                begin
                  copyback_seq[_index_1].copyback_tran.wait_for_tx_data_prereqs();
                end
                begin
                  wait(copyback_seq[_index_1].copyback_tran.req_status == svt_chi_transaction::RETRY);
                end
              join_any
              disable fork;
            end
            join
            received_copyback_responses++;
            `svt_xvm_debug("body", $sformatf("%0s Combined write copyback cmo transaction [%0d] targeted to HN (idx %0d, id %0d), suspend_comp_ack %0b: received response from interconnect. Total responses received %0d",`SVT_CHI_PRINT_PREFIX(copyback_seq[_index_1].copyback_tran),_index_1, copyback_seq[_index_1].copyback_tran.hn_node_idx, copyback_seq[_index_1].copyback_tran.tgt_id,copyback_seq[_index_1].copyback_tran.suspend_wr_data, received_copyback_responses));
          end
        join_none  
      end

      /** Wait until All write_data responses are received at RN-Fs */
      `svt_xvm_debug("body",$sformatf("Completed initiation of combined write copyback cmo type transactions for %0d addresses from p_sequencer.rn_virt_seqr[%0d] and p_sequencer.rn_virt_seqr[%0d] to HN idx %0d with suspend_wr_data set to 1, and waiting to receive responses from interconnect.",
                                num_outstanding_xacts_to_generate, initiating_rn_node_idx_0, initiating_rn_node_idx_1, target_hn_node_idx_0)); 
      wait(received_copyback_responses == num_outstanding_xacts_to_generate);
      `svt_xvm_debug("body",$sformatf("Received responses from interconnect to combined write copyback cmo type transactions for %0d addresses from p_sequencer.rn_virt_seqr[%0d] and p_sequencer.rn_virt_seqr[%0d] to HN idx %0d with suspend_wr_data set to 1",
                                      num_outstanding_xacts_to_generate, initiating_rn_node_idx_0, initiating_rn_node_idx_1, target_hn_node_idx_0)); 

      /** Self Check1: To check suspend_wr_data should not be modified to zero by the VIP
       *  before reseting from test bench.
       */
      foreach (copyback_seq[self_check_idx1]) begin
        if(!copyback_seq[self_check_idx1].copyback_tran.is_terminated()) begin 

          if (copyback_seq[self_check_idx1].copyback_tran.suspend_wr_data == 0) begin
            `svt_xvm_error("body", $sformatf("%0s suspend_wr_data should be 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(copyback_seq[self_check_idx1].copyback_tran)));
          end
          else begin
            `svt_xvm_debug("body", $sformatf("%0s suspend_wr_data is 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(copyback_seq[self_check_idx1].copyback_tran)));
          end
        end
      end

      /** Self Check2: To check suspend_wr_data should not be modified to zero by the VIP 
       *  before reseting from test bench.
       */ 
      foreach (copyback_seq[self_check_idx2]) begin
        if(!copyback_seq[self_check_idx2].copyback_tran.is_terminated()) begin 
          /** Pass event is not triggered */
          if (copyback_seq[self_check_idx2].copyback_tran.end_event.is_on() == 1) begin
            `svt_xvm_error("body", $sformatf("Unexpected: %0s Transaction's end_event triggered when suspend_wr_data is still 1.", `SVT_CHI_PRINT_PREFIX(copyback_seq[self_check_idx2].copyback_tran)));
          end
          /** Fail event has triggered */
          else begin
            `svt_xvm_debug("body", $sformatf("Expected: %0s Transaction's end_event is not triggered when suspend_wr_data is still 1.", `SVT_CHI_PRINT_PREFIX(copyback_seq[self_check_idx2].copyback_tran)));
          end
        end
      end
 
      /** Self Check 3: To check that the current_outstanding_*_xact_count in the RNs
       * are as per the transactions initiated by the sequence
       */
      /** Check if the total outstanding xact counter is set correctly in the shared status of the RN agent */
      if(copyback_seq[0].shared_status.prot_status.current_outstanding_xact_count != (num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2))
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding transactions from the sequence but the outstanding transaction count in the shared status of RN%0d is %0d", (num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2), initiating_rn_node_idx_0, copyback_seq[0].shared_status.prot_status.current_outstanding_xact_count));
      /** Check if the outstanding Write xact counter is set correctly in the shared status of the RN agent */
      if(copyback_seq[0].shared_status.prot_status.current_outstanding_write_xact_count != (num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2)) begin
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding combined write copyback cmo transactions from the sequence but the outstanding Write transaction count in the shared status of RN%0d is %0d", (num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2), initiating_rn_node_idx_0, copyback_seq[0].shared_status.prot_status.current_outstanding_write_xact_count));
      end
      /** Check if the total outstanding xact counter is set correctly in the shared status of the RN agent */
      if(copyback_seq[(num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2)].shared_status.prot_status.current_outstanding_xact_count != num_outstanding_xacts_to_generate/2)
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding transactions from the sequence but the outstanding transaction count in the shared status of RN%0d is %0d", num_outstanding_xacts_to_generate/2, initiating_rn_node_idx_1, copyback_seq[(num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2)].shared_status.prot_status.current_outstanding_xact_count));
      /** Check if the outstanding Write xact counter is set correctly in the shared status of the RN agent */
      if(copyback_seq[(num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2)].shared_status.prot_status.current_outstanding_write_xact_count != num_outstanding_xacts_to_generate/2) begin
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding combined write copyback cmo transactions from the sequence but the outstanding Write transaction count in the shared status of RN%0d is %0d", num_outstanding_xacts_to_generate/2, initiating_rn_node_idx_1, copyback_seq[(num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2)].shared_status.prot_status.current_outstanding_write_xact_count));
      end

      `svt_xvm_debug("body", $sformatf("RN%0d: Number of outstanding transactions : %0d, Number of outstanding write xacts : %0d", initiating_rn_node_idx_0, copyback_seq[0].shared_status.prot_status.current_outstanding_xact_count, copyback_seq[0].shared_status.prot_status.current_outstanding_write_xact_count));
      `svt_xvm_debug("body", $sformatf("RN%0d: Number of outstanding transactions : %0d, Number of outstanding write xacts : %0d", initiating_rn_node_idx_1, copyback_seq[1].shared_status.prot_status.current_outstanding_xact_count, copyback_seq[1].shared_status.prot_status.current_outstanding_write_xact_count));

      /** Targeted HN IDs from both RN-Fs should be same */
      for(int index_3 = 0; index_3 < num_outstanding_xacts_to_generate/2; index_3++) begin
        int hn_idx_0, hn_idx_1;
        hn_idx_0 = sys_cfg.get_hn_idx(copyback_seq[index_3].output_xacts[0].addr);
        hn_idx_1 = sys_cfg.get_hn_idx(copyback_seq[((num_outstanding_xacts_to_generate/2) + index_3)].output_xacts[0].addr);
        if ((hn_idx_0 == target_hn_node_idx_0) && (hn_idx_0 == hn_idx_1)) begin
          /** pass */
          `svt_xvm_debug("body", $sformatf("Targeted HN Index from both RNs is same as expected.  rn[%0d] to hn_idx[%0d], rn[%0d] to hn_idx[%0d]", initiating_rn_node_idx_0, hn_idx_0, initiating_rn_node_idx_1, hn_idx_1));
        end
        else begin
          /** fail */
          `svt_xvm_error("body", $sformatf("Targeted HN Index from both RNs is different, which is unexpected.  rn[%0d] %0s transaction to hn_idx[%0d], rn[%0d] %0s transaction to hn_idx[%0d]",initiating_rn_node_idx_0, `SVT_CHI_PRINT_PREFIX( copyback_seq[index_3].output_xacts[0]), hn_idx_0, initiating_rn_node_idx_1, `SVT_CHI_PRINT_PREFIX( copyback_seq[((num_outstanding_xacts_to_generate/2)+index_3)].output_xacts[0]), hn_idx_1));
        end
      end  

      /** Resuming all Suspended Response of all above combined write copyback cmo transactions  */
      foreach(copyback_seq[wr]) begin
        `svt_xvm_debug("body",$sformatf("Received responses for all combined write copyback cmo type transactions from interconnect, resuming the transactions by setting svt_chi_rn_transaction::suspend_wr_data set to 0 %0s",`SVT_CHI_PRINT_PREFIX(copyback_seq[wr].copyback_tran)));
        copyback_seq[wr].copyback_tran.suspend_wr_data=0;
        `svt_xvm_debug("body", $sformatf("For iteration %0d : After Resume, received_copyback_responses is %0d,suspend_wr_data is %0b ", wr,received_copyback_responses,copyback_seq[wr].copyback_tran.suspend_wr_data));
      end

      /** Waiting for above combined write copyback cmok outstanding transactions to complete */
      foreach(copyback_seq[index_2]) begin
        `svt_xvm_debug("body", $sformatf("Waiting for above copyback_seq[%0d] transaction %0s to end", index_2, `SVT_CHI_PRINT_PREFIX(copyback_seq[index_2].copyback_tran)));
        copyback_seq[index_2].copyback_tran.wait_end(); 
        
        /** Self Check4: To check suspend_wr_data should not be asserted after the transaction 
         *  completes as it is reseted from test bench
         */
        if(!copyback_seq[index_2].copyback_tran.is_terminated()) begin 
            if (copyback_seq[index_2].copyback_tran.suspend_wr_data == 1) begin
              `svt_xvm_error("body", $sformatf("%0s suspend_wr_data should be 0 as it has been reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(copyback_seq[index_2].copyback_tran)));
            end
            else begin
              `svt_xvm_debug("body", $sformatf("%0s suspend_wr_data is 0 as it is reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(copyback_seq[index_2].copyback_tran)));
            end
        end
      end
     
      /** Empty the address and txn_id queues */
      rn_f_node_idx_0_copyback_addr_queue.delete();                      
      rn_f_node_idx_1_copyback_addr_queue.delete();                      
      rn_f_node_idx_0_copyback_non_secure_queue.delete();                      
      rn_f_node_idx_1_copyback_non_secure_queue.delete();                      
      txn_id_arr.delete();
      
      /** Reset received_read_responses to Zero */
      received_copyback_responses = 0;
      `svt_xvm_debug("body", "Exiting...")
    end//sequence_length

  endtask: body

  virtual task post_body();
    drop_phase_objection();
  endtask

endclass: svt_chi_e_system_protocol_flow_ctrl_combined_write_copyback_cmo_outstanding_diff_rn_same_hn_virtual_sequence

function svt_chi_e_system_protocol_flow_ctrl_combined_write_copyback_cmo_outstanding_diff_rn_same_hn_virtual_sequence::new(string name="svt_chi_e_system_protocol_flow_ctrl_combined_write_copyback_cmo_outstanding_diff_rn_same_hn_virtual_sequence");
  super.new(name);
endfunction

//====================================================================================
/** 
 * @groupname CHI_OUTSTANDING_CPBK_TYPE  
 * #- This sequence requires atleast one HN node to be present in the Interconnect.
 * #- This sequence requires atleast one initiating active and participating RN-F.
 * #- Initiate maximum number of MAKEUNIQUE transactions from existing active and 
 *    participating RN-F, to perform cache initialization to a
 *    randomly selected HN.
 * #- Initiate maximum number of combined copyback write cmo type transactions with 
 *    svt_chi_rn_transaction::suspend_wr_data set to 1 from the initiating
 *    RN-F to the randomly selected HN in non blocking mode. <br>
 *    - Maximum number of outstanding transactions at the HN is as per either #max_num_outstanding_write_xacts_at_hn or
 *      #max_num_outstanding_xacts_at_hn, which can be controlled through config DB.   
 *    - This ensures that the maximum outstanding transaction limit is reached at HN.
 *    - Also, the RN-F will not transmit CopyBackWrData corresponding to these
 *      transactions until svt_chi_rn_transaction::suspend_wr_data is set to 0 from the 
 *      sequence.
 *    .
 * #- The addresses of these combined copyback write cmo transactions are such that:
 *    - Same as initialized cache line addresses if cache initialization is performed
 *    .
 * #- The RN-F of these combined copyback write cmo transactions are such that:
 *    - Same as RN-F from which cache initialization is performed
 *    .
 * #- Once the RN-F receives the responses for all the outstanding transactions from
 *    HN, svt_chi_rn_transaction::suspend_wr_data is set to 0 for all the outstanding
 *    transactions. <br>
 *    This ensures that the CopyBackWrData for these transactions can be resumed 
 *    from RN-F.
 * #- Check that the HN responds properly for all outstanding combined copyback write cmo type
 *    transactions and these are completed successfully.
 * .
 */ 

class svt_chi_e_system_protocol_flow_ctrl_combined_copyback_write_cmo_outstanding_same_rn_same_hn_virtual_sequence extends svt_chi_system_base_virtual_sequence;
  
  //-----------------------------------------------------------------------------  
  // Member attributes
  //-----------------------------------------------------------------------------
  /** Parameter that controls the enabling of transactions in non-blocking mode from the sequence */
  bit enable_outstanding = 0;

  /** To display contents of Active Participating RN-F's node */
  string str_rn_f_node;

  /** Represents the received read responses */
  int received_copyback_responses = 0;

  /** UVM/OVM Object Utility macro */
  `svt_xvm_object_utils(svt_chi_e_system_protocol_flow_ctrl_combined_copyback_write_cmo_outstanding_same_rn_same_hn_virtual_sequence)

  //-----------------------------------------------------------------------------  
  // Methods
  //-----------------------------------------------------------------------------
  /** Constructor */
  extern function new(string name="svt_chi_e_system_protocol_flow_ctrl_combined_copyback_write_cmo_outstanding_same_rn_same_hn_virtual_sequence"); 

  /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting RN-F Nodes = 1
   *  #- minimum supporting Home Nodes = 1
   */
   //-----------------------------------------------------------------------------
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    
    /** local variables */
    int num_supporting_rn_f_nodes;
    int num_hn_f_nodes;   
    int array_idx;
    bit is_rn_idx_0_participating; 
    string str_is_supported_info_prefix = "";
    string str_is_supported_info = "";
    string str_idx0_info = "";

    /** Supporting RN-F Nodes required */
    int required_num_supporting_rn_f_nodes = 1;
    int required_num_hn_nodes = 1;
    
    `svt_xvm_debug("is_supported",$sformatf("Entering ..."));

    /** By default is_supported is 0 */
    is_supported = 0;

    /** Check for minimum required HN nodes */
    num_hn_f_nodes = hn_f_nodes.size();

    /** Check requirment of number of HN nodes needed */  
    if (num_hn_f_nodes < required_num_hn_nodes) begin
      issue_is_supported_failure($sformatf("This sequence requires minimum %0d HN_F nodes to be present in the system. Number of HN_F nodes are %0d. Program number of HN nodes using svt_chi_system_configuration::num_hn. Program the HN interface type using svt_chi_system_configuration::chi_addr_cfg.hn_interface_type[].", required_num_hn_nodes, num_hn_f_nodes));
      return 0;      
    end
    
    /** Check for minimum required RN-F nodes.
     *  Also check whether the selected RN-F nodes are part of participating arrays or not.
     */
    num_supporting_rn_f_nodes = active_participating_rn_f_nodes.size();

    /** Check the requirements of RN-F nodes */ 
    if (num_supporting_rn_f_nodes) begin
      /** Display the contents of Active Participating RN-F Nodes */
      foreach (active_participating_rn_f_nodes[j]) begin
        str_rn_f_node = {str_rn_f_node, $sformatf(" %0d", active_participating_rn_f_nodes[j])};
      end 
      `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_f_nodes are %0s", str_rn_f_node));
    end

    str_is_supported_info_prefix = $sformatf("Number of Supporting RN-F Node(s)  - Minimum Required : %0d Current : %0d", required_num_supporting_rn_f_nodes, num_supporting_rn_f_nodes);
    
    if ((initiating_rn_node_index_0_status==0)&&(valid_initiating_rn_f_node_index_0==0)) begin
        str_idx0_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN-Fs that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)";
    end
    else begin
      is_rn_idx_0_participating = is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_node_idx_0, array_idx);
      if (!is_rn_idx_0_participating) begin
        str_idx0_info = $sformatf("initiating_rn_node_idx_0 %0d is not valid for this sequence. The RN-F corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)", initiating_rn_node_idx_0, initiating_rn_node_idx_0);
      end
    end
    
    if (is_rn_idx_0_participating) begin
      is_supported = 1;
      if(max_num_outstanding_write_xacts_at_hn > 0) begin
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].num_outstanding_write_xact < max_num_outstanding_write_xacts_at_hn) begin
          str_idx0_info = $sformatf("Programmed value of max_num_outstanding_write_xacts_at_hn_status is %0d. But num_outstanding_write_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_write_xact of the initiating RN node must be equal to or greater than max_num_outstanding_write_xacts_at_hn_status of the target HN", max_num_outstanding_write_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_0_participating].num_outstanding_write_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
      end else begin
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].num_outstanding_xact < max_num_outstanding_xacts_at_hn) begin
          str_idx0_info = $sformatf("Programmed value of max_num_outstanding_xacts_at_hn_status is %0d. But num_outstanding_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_xact of the initiating RN node must be equal to or greater than max_num_outstanding_xacts_at_hn of the target HN", max_num_outstanding_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_0_participating].num_outstanding_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
      end

      //check for chi_spec_revision
      if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision < svt_chi_node_configuration::ISSUE_E) begin
        is_supported =0;
        str_idx0_info = { str_idx0_info, "\n", $sformatf("This sequence is not applicable for RN with svt_chi_node_configuration::chi_spec_revision < ISSUE_E. Set the chi_spec_revision to ISSUE_E or further. RN node: 'd%0d",initiating_rn_node_idx_0)};
      end

    end
    
    if (!is_supported) begin
      str_is_supported_info = $sformatf("%0s",str_idx0_info);
      if (is_rn_idx_0_participating) begin
        issue_is_supported_failure($sformatf("This sequence cannot be run based on the current system configuration.\n\
                                              %0s\n\
                                              %0s \n\
                                              Modify configurations through \n\
                                              svt_chi_system_configuration::num_rn,\n\
                                              svt_chi_node_configuration::is_active,\n\
                                              svt_chi_system_configuration::participating_rn_nodes[]\n\
                                              ", str_is_supported_info_prefix, str_is_supported_info));
      end
      else begin
        issue_is_supported_failure($sformatf("This sequence cannot be run based on the current node configurations of RN%0d\n\
                                              %0s \n\
                                              Modify configuration through \n\
                                              svt_chi_node_configuration::num_outstanding_xact,\n\
                                              svt_chi_node_configuration::num_outstanding_write_xact,\n\
                                              ",str_is_supported_info, initiating_rn_node_idx_0));
      end
    end      
    if (!is_target_hn_idx_valid_for_curr_cfg()) begin
      is_supported = 0;
      `svt_xvm_note("is_supported", "not a valid hn_idx based on random_tgt_id_enable for current cfg");
    end
  endfunction : is_supported
  
   //-----------------------------------------------------------------------------
  virtual task pre_start();
   bit enable_outstanding_status;
   `svt_xvm_debug("pre_start",$sformatf("Entering ..."));
    super.pre_start();
    raise_phase_objection();
    enable_outstanding_status = uvm_config_db#(bit)::get(m_sequencer, get_type_name(), "enable_outstanding", enable_outstanding);
    `svt_xvm_debug("body", $sformatf("enable_outstanding is %0b as a result of %0s", enable_outstanding, (enable_outstanding_status?"config DB":"default setting")));
    `svt_xvm_debug("pre_start",$sformatf("Exiting ..."));
  endtask // pre_start

//-----------------------------------------------------------------------------
  virtual task body();

    /** Setting transaction id width */
    int txn_id_width=`SVT_CHI_TXN_ID_WIDTH;

    /** Queue of addresses, used by the transactions generated */
    bit[`SVT_CHI_MAX_ADDR_WIDTH -1:0] copyback_addr_queue[$];                      
    bit copyback_is_non_secure_access_queue[$];                      
    /** Queue of Unique transaction id's, used by the transactions generated */
    int txn_id_arr[$];

    int pgroup_id_arr[$];
    int pgroup_id_width=`SVT_CHI_PGROUPID_WIDTH;

    int num_outstanding_xacts_to_generate;

    /** Sub Read type transaction cache initialization directed sequences initiated from this sequence */
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq[int];
    /** Sub combined copyback write cmo type transaction directed sequences initiated from this sequence */
    svt_chi_rn_copyback_type_transaction_directed_sequence copyback_seq[int];

    `svt_xvm_debug("body", "Entering ...")
    super.body();

    max_num_outstanding_xacts_at_hn_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(), "max_num_outstanding_xacts_at_hn", max_num_outstanding_xacts_at_hn);
    max_num_outstanding_write_xacts_at_hn_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(), "max_num_outstanding_write_xacts_at_hn", max_num_outstanding_write_xacts_at_hn);
    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :initiating_rn_f_node_index_0;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_f_node_index_0;

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    //If max outstanding count for Write transactions has been programmed, use that to generate the outstanding Copyback
    if(max_num_outstanding_write_xacts_at_hn > 0) begin
      num_outstanding_xacts_to_generate = max_num_outstanding_write_xacts_at_hn;
      `svt_xvm_debug("body",$sformatf("max_num_outstanding_write_xacts_at_hn is set to a non-zero value (%0d). Hence, the value programmed in max_num_outstanding_xacts_at_hn will be ignored. The number of outstanding transactions issued by the sequence will be equal to max_num_outstanding_write_xacts_at_hn", max_num_outstanding_write_xacts_at_hn));
    end
    //If not, use the max outstanding transaction count
    else
      num_outstanding_xacts_to_generate = max_num_outstanding_xacts_at_hn;

    for(int i = 0; i < sequence_length; i++) begin

      /** Collecting txn_id */
      for(int id=0; id <= `SVT_CHI_SPEC_PERMITTED_MAX_TXNID_VALUE_FOR_ISSUE_E; id++) begin
        txn_id_arr.push_back(id);
      end


      /** Shuffling all collected txn_id */
      txn_id_arr.shuffle;

      for(int id=0; id < (2**`SVT_CHI_PGROUPID_WIDTH); id++) begin
        pgroup_id_arr.push_back(id);
      end
      pgroup_id_arr.shuffle;

      /** Initiating outstanding MakeUnique transactions from random RN-F
       *  to initialize the cache line.
       */
      for(int l=0; l< num_outstanding_xacts_to_generate; l++) begin
        `svt_xvm_do_on_with(makeunique_seq[l], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,{
          sequence_length    == 1;
          set_unique_addr_value    == 1;
          hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
          seq_hn_node_idx  == target_hn_node_idx_0;        
          use_seq_is_non_secure_access == 0;                    
        })  
        `svt_xvm_verbose("body", $sformatf(" MakeUnique Transaction %0s",makeunique_seq[l].write_tran.sprint()));
        /** Retrieving address from output transactions generated by the sequence  */
        copyback_addr_queue.push_back(makeunique_seq[l].write_tran.addr);
        copyback_is_non_secure_access_queue.push_back(makeunique_seq[l].write_tran.is_non_secure_access);
      end //forloop of MakeUnique 

      /** Waiting for above MakeUnique transactions to complete */ 
      foreach(makeunique_seq[mu]) begin
        `svt_xvm_debug("body", $sformatf("%0s Waiting for MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) to end",`SVT_CHI_PRINT_PREFIX(makeunique_seq[mu].write_tran),mu, makeunique_seq[mu].write_tran.hn_node_idx, makeunique_seq[mu].write_tran.tgt_id));
      
        makeunique_seq[mu].write_tran.wait_end(); 

        `svt_xvm_debug("body", $sformatf("%0s MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) ended",`SVT_CHI_PRINT_PREFIX(makeunique_seq[mu].write_tran),mu, makeunique_seq[mu].write_tran.hn_node_idx, makeunique_seq[mu].write_tran.tgt_id));
      end 

      /** Initiating outstanding combined copyback write cmo transactions from a Random RN-F.  
       */
      for(int j = 0; j < num_outstanding_xacts_to_generate; j++) begin
        bit[`SVT_CHI_MAX_ADDR_WIDTH -1:0]txn_addr = copyback_addr_queue.pop_front();
        bit txn_is_non_secure = copyback_is_non_secure_access_queue.pop_front();
        automatic int txn_id   = txn_id_arr.pop_front();
        automatic int pgroup_id   = pgroup_id_arr.pop_front();
        `svt_xvm_do_on_with(copyback_seq[j], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,{
          sequence_length == 1;
          seq_txn_id == txn_id;
          if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].cleansharedpersistsep_xact_enable == 1) {
            seq_xact_type inside {svt_chi_transaction::WRITEBACKFULL_CLEANSHARED,svt_chi_transaction::WRITEBACKFULL_CLEANSHAREDPERSISTSEP,svt_chi_transaction::WRITEBACKFULL_CLEANINVALID,svt_chi_transaction::WRITECLEANFULL_CLEANSHARED,svt_chi_transaction::WRITECLEANFULL_CLEANSHAREDPERSISTSEP};
            seq_pgroup_id == pgroup_id;
          }
          else {
            seq_xact_type inside {svt_chi_transaction::WRITEBACKFULL_CLEANSHARED,svt_chi_transaction::WRITEBACKFULL_CLEANINVALID,svt_chi_transaction::WRITECLEANFULL_CLEANSHARED};
          }
          seq_order_type  == svt_chi_transaction::NO_ORDERING_REQUIRED;
          seq_copyback_req_order_enable == 0;  
          hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
          min_addr           == txn_addr;
          max_addr           == txn_addr;     
          seq_is_non_secure_access == txn_is_non_secure;
          use_seq_is_non_secure_access == 1;              
          })
        
        `svt_xvm_debug("body", $sformatf("%0s Transmitting combined copyback write cmo Transaction [%0d] targeted to HN (idx %0d, id %0d) ",`SVT_CHI_PRINT_PREFIX(copyback_seq[j].copyback_tran),j, copyback_seq[j].copyback_tran.hn_node_idx, copyback_seq[j].copyback_tran.tgt_id));
        `svt_xvm_verbose("body", $sformatf("CopyBack Transaction [%0d] is %0s", j,copyback_seq[j].copyback_tran.sprint()));
      end //forloop

      /** Checking for the reception of all the CompDBIDResp from the Interconnect */
      foreach(copyback_seq[index_1]) begin
        fork
          automatic int _index_1 = index_1;
          begin
            `svt_xvm_debug("body", $sformatf("%0s Combined copyback write cmo transaction [%0d] targeted to HN (idx %0d, id %0d), suspend_wr_data %0b: waiting for response from interconnect",`SVT_CHI_PRINT_PREFIX(copyback_seq[_index_1].copyback_tran),_index_1, copyback_seq[_index_1].copyback_tran.hn_node_idx, copyback_seq[_index_1].copyback_tran.tgt_id,copyback_seq[_index_1].copyback_tran.suspend_wr_data));
            
            fork
            begin
              fork
                begin
                  copyback_seq[_index_1].copyback_tran.wait_for_tx_data_prereqs();
                end
                begin
                  wait(copyback_seq[_index_1].copyback_tran.req_status == svt_chi_transaction::RETRY);// begin
                end
              join_any
              disable fork;
            end
            join
            received_copyback_responses++;
            
            `svt_xvm_debug("body", $sformatf("%0s Combined copyback write cmo transaction [%0d] targeted to HN (idx %0d, id %0d), suspend_wr_data %0b: waiting for response from interconnect. Total responses received %0d",`SVT_CHI_PRINT_PREFIX(copyback_seq[_index_1].copyback_tran),_index_1, copyback_seq[_index_1].copyback_tran.hn_node_idx, copyback_seq[_index_1].copyback_tran.tgt_id,copyback_seq[_index_1].copyback_tran.suspend_wr_data, received_copyback_responses));
          end
        join_none  
      end
     
      /** Waiting for the CompDBIDResp from HN to Resume the Suspended Response of all above combined copyback write cmo transactions */ 
      `svt_xvm_debug("body",$sformatf("Completed initiation of combined copyback write cmo type transactions for %0d addresses from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d with suspend_wr_data set to 1, and waiting to receive responses from interconnect.",num_outstanding_xacts_to_generate, initiating_rn_node_idx_0, target_hn_node_idx_0));
      
      wait(received_copyback_responses == num_outstanding_xacts_to_generate);
      outstanding_xact_count_reached = 1;
      `svt_xvm_debug("body",$sformatf("Received responses from interconnect to combined copyback write cmo type transactions for %0d addresses from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d with suspend_wr_data set to 1",num_outstanding_xacts_to_generate, initiating_rn_node_idx_0, target_hn_node_idx_0));

      /** Self Check1: To check suspend_wr_data should not be modified to zero by the VIP
       *  before reseting from test bench.
       */
      foreach (copyback_seq[self_check_idx1]) begin
        if(!copyback_seq[self_check_idx1].copyback_tran.is_terminated()) begin 
          if (copyback_seq[self_check_idx1].copyback_tran.suspend_wr_data == 0) begin
            `svt_xvm_error("body", $sformatf("%0s suspend_wr_data should be 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(copyback_seq[self_check_idx1].copyback_tran)));
          end
          else begin
            `svt_xvm_debug("body", $sformatf("%0s suspend_wr_data is 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(copyback_seq[self_check_idx1].copyback_tran)));
          end
        end
      end

      /** Self Check2: To check transaction is not ended by the VIP before resuming the 
       *  suspend_wr_data to zero from the test bench<br>
       */
      foreach (copyback_seq[self_check_idx2]) begin
        if(!copyback_seq[self_check_idx2].copyback_tran.is_terminated()) begin 
          if (copyback_seq[self_check_idx2].copyback_tran.end_event.is_on() == 1) begin
            // Fail  event has triggered
            `svt_xvm_error("body", $sformatf("Unexpected: %0s Transaction's end_event triggered when suspend_wr_data is still 1.", `SVT_CHI_PRINT_PREFIX(copyback_seq[self_check_idx2].copyback_tran)));
          end
          else begin
            // Pass  event is not triggered
            `svt_xvm_debug("body", $sformatf("Expected: %0s Transaction's end_event is not triggered when suspend_wr_data is still 1.", `SVT_CHI_PRINT_PREFIX(copyback_seq[self_check_idx2].copyback_tran)));
          end
        end
      end
 
      /** Self Check 3: To check that the current_outstanding_*_xact_count in the RN
       * is as per the transactions inititated by the sequence
       */
      /** Check if the total outstanding xact counter is set correctly in the shared status of the RN agent */
      if(copyback_seq[0].shared_status.prot_status.current_outstanding_xact_count != num_outstanding_xacts_to_generate)
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding transactions from the sequence but the outstanding transaction count in the shared status of RN%0d is %0d", num_outstanding_xacts_to_generate, initiating_rn_node_idx_0, copyback_seq[0].shared_status.prot_status.current_outstanding_xact_count));
      /** Check if the outstanding Write xact counter is set correctly in the shared status of the RN agent */
      if(copyback_seq[0].shared_status.prot_status.current_outstanding_write_xact_count != num_outstanding_xacts_to_generate) begin
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding combined copyback write cmo transactions from the sequence but the outstanding Write transaction count in the shared status of RN%0d is %0d", num_outstanding_xacts_to_generate, initiating_rn_node_idx_0, copyback_seq[0].shared_status.prot_status.current_outstanding_write_xact_count));
      end

      `svt_xvm_debug("body", $sformatf("RN%0d: Number of outstanding transactions : %0d, Number of outstanding write xacts : %0d", initiating_rn_node_idx_0, copyback_seq[0].shared_status.prot_status.current_outstanding_xact_count, copyback_seq[0].shared_status.prot_status.current_outstanding_write_xact_count));

      /** Targeted HN ID from the RN should be same throughout */
      foreach(copyback_seq[wr]) begin
        int hn_idx_0;
        hn_idx_0 = sys_cfg.get_hn_idx(copyback_seq[wr].output_xacts[0].addr);
        if (hn_idx_0 == target_hn_node_idx_0) begin
          `svt_xvm_debug("body", $sformatf("Targeted HN Index from the RN is same as expected.  rn[%0d] to hn_idx[%0d]", initiating_rn_node_idx_0, hn_idx_0));
        end
        else begin
          `svt_xvm_error("body", $sformatf("Targeted HN Index from the RN is different, which is unexpected.  rn[%0d] %0s transaction to hn_idx[%0d]",initiating_rn_node_idx_0, `SVT_CHI_PRINT_PREFIX( copyback_seq[wr].output_xacts[0]), hn_idx_0));
        end
      end
      
      if(use_seq_flag_to_resume_response_for_outstanding_xact) begin
        `svt_xvm_debug("body",$sformatf("Waiting for resume_response_for_outstanding_xact to be set to 1"));
        wait(resume_response_for_outstanding_xact == 1);
        `svt_xvm_debug("body",$sformatf("resume_response_for_outstanding_xact is set to 1"));
      end
      
      /** Resuming all Suspended Response of all above Copyback transactions  */
      foreach(copyback_seq[wr]) begin
        `svt_xvm_debug("body",$sformatf("Received responses for all combined copyback write cmo type transactions from interconnect, resuming the transactions by setting svt_chi_rn_transaction::suspend_wr_data set to 0 %0s",`SVT_CHI_PRINT_PREFIX(copyback_seq[wr].copyback_tran)));
        copyback_seq[wr].copyback_tran.suspend_wr_data=0; 
        `svt_xvm_debug("body", $sformatf("For iteration %0d : After Resume, received_copyback_responses is %0d,suspend_wr_data is %0b",wr,received_copyback_responses,copyback_seq[wr].copyback_tran.suspend_wr_data));
      end

      `svt_xvm_debug("body",$sformatf("Waiting for completion of all the outstanding combined copyback write cmo type transactions"));
      /** Waiting for above Copyback outstanding transactions to complete */
      foreach(copyback_seq[index_2]) begin
        `svt_xvm_debug("body", $sformatf("Waiting for above copyback_seq[%0d] transaction %0s to end", index_2,`SVT_CHI_PRINT_PREFIX(copyback_seq[index_2].copyback_tran)));
        copyback_seq[index_2].copyback_tran.wait_end(); 
        /** Self Check4: To check suspend_wr_data should not be asserted after the transaction 
         *  completes as it is reseted from test bench
         */
        if(!copyback_seq[index_2].copyback_tran.is_terminated()) begin 
          if (copyback_seq[index_2].copyback_tran.suspend_wr_data == 1) begin
            `svt_xvm_error("body", $sformatf("%0s suspend_wr_data should be 0 as it has been reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(copyback_seq[index_2].copyback_tran)));
          end
          else begin
            `svt_xvm_debug("body", $sformatf("%0s suspend_wr_data is 0 as it is reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(copyback_seq[index_2].copyback_tran)));
          end
        end
      end
      `svt_xvm_debug("body",$sformatf("Received completions for all combined copyback write cmo type outstanding transactions"));
      
  
      /** Reset received_copyback_responses to Zero */
      received_copyback_responses = 0;

      /** Empty the address and txn_id queues */
      copyback_addr_queue.delete();
      copyback_is_non_secure_access_queue.delete();
      txn_id_arr.delete();
       
    end//for loop of sequence_length
    
    `svt_xvm_debug("body", "Exiting...")
  endtask: body

   //-----------------------------------------------------------------------------  
  virtual task post_start();
    super.post_start();
    drop_phase_objection();
  endtask

endclass: svt_chi_e_system_protocol_flow_ctrl_combined_copyback_write_cmo_outstanding_same_rn_same_hn_virtual_sequence

//===============================================================================
function svt_chi_e_system_protocol_flow_ctrl_combined_copyback_write_cmo_outstanding_same_rn_same_hn_virtual_sequence::new(string name="svt_chi_e_system_protocol_flow_ctrl_combined_copyback_write_cmo_outstanding_same_rn_same_hn_virtual_sequence");
  super.new(name);
endfunction

`endif //CHI_ISSUE_E macro

/////////////////////////////
//CopyBack type
/////////////////////////////

//====================================================================================
/** 
 * @groupname CHI_OUTSTANDING_CPBK_TYPE  
 * #- This sequence requires atleast one HN node to be present in the Interconnect.
 * #- This sequence requires atleast one initiating active and participating RN-F.
 * #- Inititate maximum number of MAKEUNIQUE transactions from existing active and 
 *    participating RN-F, to perform cache initialization to a
 *    randomly selected HN.
 * #- Initiate maximum number of COPYBACK type transactions with 
 *    svt_chi_rn_transaction::suspend_wr_data set to 1 from the initiating
 *    RN-F to the randomly selected HN in non blocking mode. <br>
 *    - Maximum number of outstanding transactions at the HN is as per either #max_num_outstanding_write_xacts_at_hn or
 *      #max_num_outstanding_xacts_at_hn, which can be controlled through config DB.   
 *    - This ensures that the maximum outstanding transaction limit is reached at HN.
 *    - Also, the RN-F will not transmit CopyBackWrData corresponding to these
 *      transactions until svt_chi_rn_transaction::suspend_wr_data is set to 0 from the 
 *      sequence.
 *    .
 * #- The addresses of these COPYBACK transactions are such that:
 *    - Same as initialized cache line addresses if cache initialization is performed
 *    .
 * #- The RN-F of these COPYBACK transactions are such that:
 *    - Same as RN-F from which cache initialization is performed
 *    .
 * #- Once the RN-F receives the responses for all the outstanding transactions from
 *    HN, svt_chi_rn_transaction::suspend_wr_data is set to 0 for all the outstanding
 *    transactions. <br>
 *    This ensures that the CopyBackWrData for these transactions can be resumed 
 *    from RN-F.
 * #- Check that the HN responds properly for all outstanding COPYBACK type
 *    transactions and these are completed successfully.
 * .
 * #- This sequence does not support EVICT and WRITEEVICTFULL transactions.<br>
 */ 

class svt_chi_system_protocol_flow_ctrl_copyback_outstanding_same_rn_same_hn_virtual_sequence extends svt_chi_system_base_virtual_sequence;
  
  //-----------------------------------------------------------------------------  
  // Member attributes
  //-----------------------------------------------------------------------------
  /** Parameter that controls the enabling of transactions in non-blocking mode from the sequence */
  bit enable_outstanding = 0;

  /** To display contents of Active Participating RN-F's node */
  string str_rn_f_node;

  /** Represents the received read responses */
  int received_copyback_responses = 0;

  /** UVM/OVM Object Utility macro */
  `svt_xvm_object_utils(svt_chi_system_protocol_flow_ctrl_copyback_outstanding_same_rn_same_hn_virtual_sequence)

  //-----------------------------------------------------------------------------  
  // Methods
  //-----------------------------------------------------------------------------
  /** Constructor */
  extern function new(string name="svt_chi_system_protocol_flow_ctrl_copyback_outstanding_same_rn_same_hn_virtual_sequence"); 

  /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting RN-F Nodes = 1
   *  #- minimum supporting Home Nodes = 1
   */
   //-----------------------------------------------------------------------------
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    
    /** local variables */
    int num_supporting_rn_f_nodes;
    int num_hn_f_nodes;   
    int array_idx;
    bit is_rn_idx_0_participating; 
    string str_is_supported_info_prefix = "";
    string str_is_supported_info = "";
    string str_idx0_info = "";

    /** Supporting RN-F Nodes required */
    int required_num_supporting_rn_f_nodes = 1;
    int required_num_hn_nodes = 1;
    
    `svt_xvm_debug("is_supported",$sformatf("Entering ..."));

    /** By default is_supported is 0 */
    is_supported = 0;

    /** Check for minimum required HN nodes */
    num_hn_f_nodes = hn_f_nodes.size();

    /** Check requirment of number of HN nodes needed */  
    if (num_hn_f_nodes < required_num_hn_nodes) begin
      issue_is_supported_failure($sformatf("This sequence requires minimum %0d HN_F nodes to be present in the system. Number of HN_F nodes are %0d. Program number of HN nodes using svt_chi_system_configuration::num_hn. Program the HN interface type using svt_chi_system_configuration::chi_addr_cfg.hn_interface_type[].", required_num_hn_nodes, num_hn_f_nodes));
      return 0;      
    end
    
    /** Check for minimum required RN-F nodes.
     *  Also check whether the selected RN-F nodes are part of participating arrays or not.
     */
    num_supporting_rn_f_nodes = active_participating_rn_f_nodes.size();

    /** Check the requirements of RN-F nodes */ 
    if (num_supporting_rn_f_nodes) begin
      /** Display the contents of Active Participating RN-F Nodes */
      foreach (active_participating_rn_f_nodes[j]) begin
        str_rn_f_node = {str_rn_f_node, $sformatf(" %0d", active_participating_rn_f_nodes[j])};
      end 
      `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_f_nodes are %0s", str_rn_f_node));
    end

    str_is_supported_info_prefix = $sformatf("Number of Supporting RN-F Node(s)  - Minimum Required : %0d Current : %0d", required_num_supporting_rn_f_nodes, num_supporting_rn_f_nodes);
    
    if ((initiating_rn_node_index_0_status==0)&&(valid_initiating_rn_f_node_index_0==0)) begin
        str_idx0_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN-Fs that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)";
    end
    else begin
      is_rn_idx_0_participating = is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_node_idx_0, array_idx);
      if (!is_rn_idx_0_participating) begin
        str_idx0_info = $sformatf("initiating_rn_node_idx_0 %0d is not valid for this sequence. The RN-F corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)", initiating_rn_node_idx_0, initiating_rn_node_idx_0);
      end
    end
    
    if (is_rn_idx_0_participating) begin
      is_supported = 1;
      if(max_num_outstanding_write_xacts_at_hn > 0) begin
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].num_outstanding_write_xact < max_num_outstanding_write_xacts_at_hn) begin
          str_idx0_info = $sformatf("Programmed value of max_num_outstanding_write_xacts_at_hn_status is %0d. But num_outstanding_write_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_write_xact of the initiating RN node must be equal to or greater than max_num_outstanding_write_xacts_at_hn_status of the target HN", max_num_outstanding_write_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_0_participating].num_outstanding_write_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
      end else begin
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].num_outstanding_xact < max_num_outstanding_xacts_at_hn) begin
          str_idx0_info = $sformatf("Programmed value of max_num_outstanding_xacts_at_hn_status is %0d. But num_outstanding_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_xact of the initiating RN node must be equal to or greater than max_num_outstanding_xacts_at_hn of the target HN", max_num_outstanding_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_0_participating].num_outstanding_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
      end
    end
    
    if (!is_supported) begin
      str_is_supported_info = $sformatf("%0s",str_idx0_info);
      if (is_rn_idx_0_participating) begin
        issue_is_supported_failure($sformatf("This sequence cannot be run based on the current system configuration.\n\
                                              %0s\n\
                                              %0s \n\
                                              Modify configurations through \n\
                                              svt_chi_system_configuration::num_rn,\n\
                                              svt_chi_node_configuration::is_active,\n\
                                              svt_chi_system_configuration::participating_rn_nodes[]\n\
                                              ", str_is_supported_info_prefix, str_is_supported_info));
      end
      else begin
        issue_is_supported_failure($sformatf("This sequence cannot be run based on the current node configurations of RN%0d\n\
                                              %0s \n\
                                              Modify configuration through \n\
                                              svt_chi_node_configuration::num_outstanding_xact,\n\
                                              svt_chi_node_configuration::num_outstanding_write_xact,\n\
                                              ",str_is_supported_info, initiating_rn_node_idx_0));
      end
    end      
    if (!is_target_hn_idx_valid_for_curr_cfg()) begin
      is_supported = 0;
      `svt_xvm_note("is_supported", "not a valid hn_idx based on random_tgt_id_enable for current cfg");
    end
  endfunction : is_supported
  
   //-----------------------------------------------------------------------------
  virtual task pre_start();
   bit enable_outstanding_status;
   `svt_xvm_debug("pre_start",$sformatf("Entering ..."));
    super.pre_start();
    raise_phase_objection();
    enable_outstanding_status = uvm_config_db#(bit)::get(m_sequencer, get_type_name(), "enable_outstanding", enable_outstanding);
    `svt_xvm_debug("body", $sformatf("enable_outstanding is %0b as a result of %0s", enable_outstanding, (enable_outstanding_status?"config DB":"default setting")));
    `svt_xvm_debug("pre_start",$sformatf("Exiting ..."));
  endtask // pre_start

//-----------------------------------------------------------------------------
  virtual task body();

    /** Setting transaction id width */
    int txn_id_width=`SVT_CHI_TXN_ID_WIDTH;

    /** Queue of addresses, used by the transactions generated */
    bit[`SVT_CHI_MAX_ADDR_WIDTH -1:0] copyback_addr_queue[$];                      
    bit copyback_is_non_secure_access_queue[$];                      
    /** Queue of Unique transaction id's, used by the transactions generated */
    int txn_id_arr[$];

    int num_outstanding_xacts_to_generate;

    /** Sub Read type transaction cache initialization directed sequences initiated from this sequence */
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq[int];
    /** Sub CopyBack type transaction directed sequences initiated from this sequence */
    svt_chi_rn_copyback_type_transaction_directed_sequence copyback_seq[int];

    `svt_xvm_debug("body", "Entering ...")
    super.body();

    max_num_outstanding_xacts_at_hn_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(), "max_num_outstanding_xacts_at_hn", max_num_outstanding_xacts_at_hn);
    max_num_outstanding_write_xacts_at_hn_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(), "max_num_outstanding_write_xacts_at_hn", max_num_outstanding_write_xacts_at_hn);
    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :initiating_rn_f_node_index_0;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_f_node_index_0;

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    //If max outstanding count for Write transactions has been programmed, use that to generate the outstanding Copyback
    if(max_num_outstanding_write_xacts_at_hn > 0) begin
      num_outstanding_xacts_to_generate = max_num_outstanding_write_xacts_at_hn;
      `svt_xvm_debug("body",$sformatf("max_num_outstanding_write_xacts_at_hn is set to a non-zero value (%0d).  Hence, the value programmed in max_num_outstanding_xacts_at_hn will be ignored. The number of outstanding transactions issued by the sequence will be equal to max_num_outstanding_write_xacts_at_hn", max_num_outstanding_write_xacts_at_hn));
    end
    //If not, use the max outstanding transaction count
    else
      num_outstanding_xacts_to_generate = max_num_outstanding_xacts_at_hn;

    for(int i = 0; i < sequence_length; i++) begin

      /** Collecting txn_id */
      `ifdef SVT_CHI_ISSUE_E_ENABLE
        if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision >= svt_chi_node_configuration::ISSUE_E) begin
          for(int id=0; id <= `SVT_CHI_SPEC_PERMITTED_MAX_TXNID_VALUE_FOR_ISSUE_E; id++) begin
            txn_id_arr.push_back(id);
          end
        end
        else if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision >= svt_chi_node_configuration::ISSUE_D) begin
          for(int id=0; id <= `SVT_CHI_SPEC_PERMITTED_MAX_TXNID_VALUE_FOR_ISSUE_D; id++) begin
            txn_id_arr.push_back(id);
          end
        end else begin
          for(int id=0; id <= `SVT_CHI_SPEC_PERMITTED_MAX_TXNID_VALUE_UPTO_ISSUE_C; id++) begin
            txn_id_arr.push_back(id);
          end
        end
      `elsif SVT_CHI_ISSUE_D_ENABLE
        if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision >= svt_chi_node_configuration::ISSUE_D) begin
          for(int id=0; id <= `SVT_CHI_SPEC_PERMITTED_MAX_TXNID_VALUE_FOR_ISSUE_D; id++) begin
            txn_id_arr.push_back(id);
          end
        end else begin
          for(int id=0; id <= `SVT_CHI_SPEC_PERMITTED_MAX_TXNID_VALUE_UPTO_ISSUE_C; id++) begin
            txn_id_arr.push_back(id);
          end
        end
      `else
        for(int id=0; id <= `SVT_CHI_SPEC_PERMITTED_MAX_TXNID_VALUE_UPTO_ISSUE_C; id++) begin
          txn_id_arr.push_back(id);
        end
      `endif

      /** Shuffling all collected txn_id */
      txn_id_arr.shuffle;

      /** Initiating outstanding MakeUnique transactions from random RN-F
       *  to initialise the cache line state to UD state for below transactions.  
       *   svt_chi_transaction::WRITEBACKFULL  
       *   svt_chi_transaction::WRITEBACKPTL  
       *   svt_chi_transaction::WRITECLEANFULL  
       *   svt_chi_transaction::WRITECLEANPTL 
       */
      for(int l=0; l< num_outstanding_xacts_to_generate; l++) begin
        `svt_xvm_do_on_with(makeunique_seq[l], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,{
          sequence_length    == 1;
          set_unique_addr_value    == 1;
          hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
          seq_hn_node_idx  == target_hn_node_idx_0;        
          use_seq_is_non_secure_access == 0;                    
        })  
        `svt_xvm_verbose("body", $sformatf(" MakeUnique Transaction %0s",makeunique_seq[l].write_tran.sprint()));
        /** Retrieving address from output transactions generated by the sequence  */
        copyback_addr_queue.push_back(makeunique_seq[l].write_tran.addr);
        copyback_is_non_secure_access_queue.push_back(makeunique_seq[l].write_tran.is_non_secure_access);
      end //forloop of MakeUnique 

      /** Waiting for above MakeUnique transactions to complete */ 
      foreach(makeunique_seq[mu]) begin
        `svt_xvm_debug("body", $sformatf("%0s Waiting for MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) to end",`SVT_CHI_PRINT_PREFIX(makeunique_seq[mu].write_tran),mu, makeunique_seq[mu].write_tran.hn_node_idx, makeunique_seq[mu].write_tran.tgt_id));
      
        makeunique_seq[mu].write_tran.wait_end(); 

        `svt_xvm_debug("body", $sformatf("%0s MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) ended",`SVT_CHI_PRINT_PREFIX(makeunique_seq[mu].write_tran),mu, makeunique_seq[mu].write_tran.hn_node_idx, makeunique_seq[mu].write_tran.tgt_id));
      end 

      /** Initiating outstanding CopyBack transactions from a Random RN-F.  
       *  Initial cache line state is:
       *   UD :  svt_chi_transaction::WRITEBACKFULL  
       *         svt_chi_transaction::WRITEBACKPTL  
       *         svt_chi_transaction::WRITECLEANFULL  
       *         svt_chi_transaction::WRITECLEANPTL 
       */
      for(int j = 0; j < num_outstanding_xacts_to_generate; j++) begin
        bit[`SVT_CHI_MAX_ADDR_WIDTH -1:0]txn_addr = copyback_addr_queue.pop_front();
        bit txn_is_non_secure = copyback_is_non_secure_access_queue.pop_front();
        automatic int txn_id   = txn_id_arr.pop_front();
        `svt_xvm_do_on_with(copyback_seq[j], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,{
          sequence_length == 1;
          seq_txn_id == txn_id;
          seq_xact_type != svt_chi_transaction::EVICT;
          seq_xact_type != svt_chi_transaction::WRITEEVICTFULL;
          seq_order_type  == svt_chi_transaction::NO_ORDERING_REQUIRED;
          seq_copyback_req_order_enable == 0;  
          hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
          min_addr           == txn_addr;
          max_addr           == txn_addr;     
          seq_is_non_secure_access == txn_is_non_secure;
          use_seq_is_non_secure_access == 1;              
          })
        
        `svt_xvm_debug("body", $sformatf("%0s Transmitting CopyBack Transaction [%0d] targeted to HN (idx %0d, id %0d) ",`SVT_CHI_PRINT_PREFIX(copyback_seq[j].copyback_tran),j, copyback_seq[j].copyback_tran.hn_node_idx, copyback_seq[j].copyback_tran.tgt_id));
        `svt_xvm_verbose("body", $sformatf("CopyBack Transaction [%0d] is %0s", j,copyback_seq[j].copyback_tran.sprint()));
      end //forloop of CopyBack

      /** Checking for the reception of all the CompDBIDResp from the Interconnect */
      foreach(copyback_seq[index_1]) begin
        fork
          automatic int _index_1 = index_1;
          begin
            `svt_xvm_debug("body", $sformatf("%0s CopyBack transaction [%0d] targeted to HN (idx %0d, id %0d), suspend_wr_data %0b: waiting for response from interconnect",`SVT_CHI_PRINT_PREFIX(copyback_seq[_index_1].copyback_tran),_index_1, copyback_seq[_index_1].copyback_tran.hn_node_idx, copyback_seq[_index_1].copyback_tran.tgt_id,copyback_seq[_index_1].copyback_tran.suspend_wr_data));
            
            fork
            begin
              fork
                begin
                  copyback_seq[_index_1].copyback_tran.wait_for_tx_data_prereqs();
                end
                begin
                  wait(copyback_seq[_index_1].copyback_tran.req_status == svt_chi_transaction::RETRY);// begin
                end
              join_any
              disable fork;
            end
            join
            received_copyback_responses++;
            
            `svt_xvm_debug("body", $sformatf("%0s CopyBack transaction [%0d] targeted to HN (idx %0d, id %0d), suspend_wr_data %0b: waiting for response from interconnect. Total responses received %0d",`SVT_CHI_PRINT_PREFIX(copyback_seq[_index_1].copyback_tran),_index_1, copyback_seq[_index_1].copyback_tran.hn_node_idx, copyback_seq[_index_1].copyback_tran.tgt_id,copyback_seq[_index_1].copyback_tran.suspend_wr_data, received_copyback_responses));
          end
        join_none  
      end
     
      /** Waiting for the CompDBIDResp from HN to Resume the Suspended Response of all above Copyback transactions */ 
      `svt_xvm_debug("body",$sformatf("Completed initiation of CopyBack type transactions for %0d addresses from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d with suspend_wr_data set to 1, and waiting to receive responses from interconnect.",num_outstanding_xacts_to_generate, initiating_rn_node_idx_0, target_hn_node_idx_0));
      
      wait(received_copyback_responses == num_outstanding_xacts_to_generate);
      outstanding_xact_count_reached = 1;
      `svt_xvm_debug("body",$sformatf("Received responses from interconnect to CopyBack type transactions for %0d addresses from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d with suspend_wr_data set to 1",num_outstanding_xacts_to_generate, initiating_rn_node_idx_0, target_hn_node_idx_0));

      /** Self Check1: To check suspend_wr_data should not be modified to zero by the VIP
       *  before reseting from test bench.
       */
      foreach (copyback_seq[self_check_idx1]) begin
        if(!copyback_seq[self_check_idx1].copyback_tran.is_terminated()) begin 
          if (copyback_seq[self_check_idx1].copyback_tran.suspend_wr_data == 0) begin
            `svt_xvm_error("body", $sformatf("%0s suspend_wr_data should be 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(copyback_seq[self_check_idx1].copyback_tran)));
          end
          else begin
            `svt_xvm_debug("body", $sformatf("%0s suspend_wr_data is 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(copyback_seq[self_check_idx1].copyback_tran)));
          end
        end
      end

      /** Self Check2: To check transaction is not ended by the VIP before resuming the 
       *  suspend_wr_data to zero from the test bench<br>
       */
      foreach (copyback_seq[self_check_idx2]) begin
        if(!copyback_seq[self_check_idx2].copyback_tran.is_terminated()) begin 
          if (copyback_seq[self_check_idx2].copyback_tran.end_event.is_on() == 1) begin
            // Fail  event has triggered
            `svt_xvm_error("body", $sformatf("Unexpected: %0s Transaction's end_event triggered when suspend_wr_data is still 1.", `SVT_CHI_PRINT_PREFIX(copyback_seq[self_check_idx2].copyback_tran)));
          end
          else begin
            // Pass  event is not triggered
            `svt_xvm_debug("body", $sformatf("Expected: %0s Transaction's end_event is not triggered when suspend_wr_data is still 1.", `SVT_CHI_PRINT_PREFIX(copyback_seq[self_check_idx2].copyback_tran)));
          end
        end
      end
 
      /** Self Check 3: To check that the current_outstanding_*_xact_count in the RN
       * is as per the transactions inititated by the sequence
       */
      /** Check if the total outstanding xact counter is set correctly in the shared status of the RN agent */
      if(copyback_seq[0].shared_status.prot_status.current_outstanding_xact_count != num_outstanding_xacts_to_generate)
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding transactions from the sequence but the outstanding transaction count in the shared status of RN%0d is %0d", num_outstanding_xacts_to_generate, initiating_rn_node_idx_0, copyback_seq[0].shared_status.prot_status.current_outstanding_xact_count));
      /** Check if the outstanding Write xact counter is set correctly in the shared status of the RN agent */
      if(copyback_seq[0].shared_status.prot_status.current_outstanding_write_xact_count != num_outstanding_xacts_to_generate) begin
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding Copyback transactions from the sequence but the outstanding Write transaction count in the shared status of RN%0d is %0d", num_outstanding_xacts_to_generate, initiating_rn_node_idx_0, copyback_seq[0].shared_status.prot_status.current_outstanding_write_xact_count));
      end

      `svt_xvm_debug("body", $sformatf("RN%0d: Number of outstanding transactions : %0d, Number of outstanding write xacts : %0d", initiating_rn_node_idx_0, copyback_seq[0].shared_status.prot_status.current_outstanding_xact_count, copyback_seq[0].shared_status.prot_status.current_outstanding_write_xact_count));

      /** Targeted HN ID from the RN should be same throughout */
      foreach(copyback_seq[wr]) begin
        int hn_idx_0;
        hn_idx_0 = sys_cfg.get_hn_idx(copyback_seq[wr].output_xacts[0].addr);
        if (hn_idx_0 == target_hn_node_idx_0) begin
          `svt_xvm_debug("body", $sformatf("Targeted HN Index from the RN is same as expected.  rn[%0d] to hn_idx[%0d]", initiating_rn_node_idx_0, hn_idx_0));
        end
        else begin
          `svt_xvm_error("body", $sformatf("Targeted HN Index from the RN is different, which is unexpected.  rn[%0d] %0s transaction to hn_idx[%0d]",initiating_rn_node_idx_0, `SVT_CHI_PRINT_PREFIX( copyback_seq[wr].output_xacts[0]), hn_idx_0));
        end
      end
      
      if(use_seq_flag_to_resume_response_for_outstanding_xact) begin
        `svt_xvm_debug("body",$sformatf("Waiting for resume_response_for_outstanding_xact to be set to 1"));
        wait(resume_response_for_outstanding_xact == 1);
        `svt_xvm_debug("body",$sformatf("resume_response_for_outstanding_xact is set to 1"));
      end
      
      /** Resuming all Suspended Response of all above Copyback transactions  */
      foreach(copyback_seq[wr]) begin
        `svt_xvm_debug("body",$sformatf("Received responses for all CopyBack type transactions from interconnect, resuming the transactions by setting svt_chi_rn_transaction::suspend_wr_data set to 0 %0s",`SVT_CHI_PRINT_PREFIX(copyback_seq[wr].copyback_tran)));
        copyback_seq[wr].copyback_tran.suspend_wr_data=0; 
        `svt_xvm_debug("body", $sformatf("For iteration %0d : After Resume, received_copyback_responses is %0d,suspend_wr_data is %0b",wr,received_copyback_responses,copyback_seq[wr].copyback_tran.suspend_wr_data));
      end

      `svt_xvm_debug("body",$sformatf("Waiting for completion of all the outstanding CopyBack type transactions"));
      /** Waiting for above Copyback outstanding transactions to complete */
      foreach(copyback_seq[index_2]) begin
        `svt_xvm_debug("body", $sformatf("Waiting for above copyback_seq[%0d] transaction %0s to end", index_2,`SVT_CHI_PRINT_PREFIX(copyback_seq[index_2].copyback_tran)));
        copyback_seq[index_2].copyback_tran.wait_end(); 
        /** Self Check4: To check suspend_wr_data should not be asserted after the transaction 
         *  completes as it is reseted from test bench
         */
        if(!copyback_seq[index_2].copyback_tran.is_terminated()) begin 
          if (copyback_seq[index_2].copyback_tran.suspend_wr_data == 1) begin
            `svt_xvm_error("body", $sformatf("%0s suspend_wr_data should be 0 as it has been reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(copyback_seq[index_2].copyback_tran)));
          end
          else begin
            `svt_xvm_debug("body", $sformatf("%0s suspend_wr_data is 0 as it is reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(copyback_seq[index_2].copyback_tran)));
          end
        end
      end
      `svt_xvm_debug("body",$sformatf("Received completions for all CopyBack type outstanding transactions"));
      
  
      /** Reset received_copyback_responses to Zero */
      received_copyback_responses = 0;

      /** Empty the address and txn_id queues */
      copyback_addr_queue.delete();
      copyback_is_non_secure_access_queue.delete();
      txn_id_arr.delete();
       
    end//for loop of sequence_length
    /** 
    * To check the Interconnect HN Node shall responds to 
    * outstanding tranactions to RN.<br>
    * Check done by System monitor(List of checkers)<br>
    *  #- copyback_data_integrity_check
    *  .  
    */
    `svt_xvm_debug("body", "Exiting...")
  endtask: body

   //-----------------------------------------------------------------------------  
  virtual task post_start();
    super.post_start();
    drop_phase_objection();
  endtask

endclass: svt_chi_system_protocol_flow_ctrl_copyback_outstanding_same_rn_same_hn_virtual_sequence

//===============================================================================
function svt_chi_system_protocol_flow_ctrl_copyback_outstanding_same_rn_same_hn_virtual_sequence::new(string name="svt_chi_system_protocol_flow_ctrl_copyback_outstanding_same_rn_same_hn_virtual_sequence");
  super.new(name);
endfunction


//====================================================================================
/** 
 * @groupname CHI_OUTSTANDING_CPBK_TYPE 
 * #- This sequence requires atleast one HN node to be present in the Interconnect.
 * #- This sequence requires atleast two initiating active and participating RN-Fs.
 * #- Inititate maximum number of MAKEUNIQUE transactions from existing active and 
 *    participating different RN-Fs, to perform cache initialization to a
 *    randomly selected HN.
 * #- Initiate maximum number of COPYBACK type transactions with 
 *    svt_chi_rn_transaction::suspend_wr_data set to 1 from initiating RN-Fs to randomly 
 *    selected HN in non blocking mode. <br>
 *    - Maximum number of outstanding transactions at the HN is as per either #max_num_outstanding_write_xacts_at_hn or
 *      #max_num_outstanding_xacts_at_hn, which can be controlled through config DB.  
 *    - This ensures that the maximum outstanding transaction limit is reached at
 *      the HN. 
 *    - Also,the RN-Fs will not transmit CopyBackWrData corresponding to these
 *      transactions until svt_chi_rn_transaction::suspend_wr_data is set to 0 from the 
 *      sequence.
 *    .
 * #- The addresses of these COPYBACK transactions are such that:
 *    - Same as initialized cache line addresses if cache initialization is performed
 *    .
 * #- The RN-Fs of these COPYBACK transactions are such that:
 *    - Same as RN-Fs from which cache initialization is performed
 *    .
 * #- Once the RN-Fs receives the responses for all the outstanding transactions from
 *    the HN, svt_chi_rn_transaction::suspend_wr_data is set to 0 for all the outstanding
 *    transactions. <br>
 *    This ensures that the CopyBackWrData for these transactions can be resumed 
 *    from RN-Fs.
 * #- Check that the HN responds properly for all outstanding COPYBACK type
 *    transactions and these are completed successfully.
 * .
 * #- This sequence does not support EVICT and WRITEEVICTFULL transactions.<br>
 */ 

class svt_chi_system_protocol_flow_ctrl_copyback_outstanding_diff_rn_same_hn_virtual_sequence extends svt_chi_system_base_virtual_sequence;

  //-----------------------------------------------------------------------------  
  // Member attributes
  //----------------------------------------------------------------------------- 

  /** To display contents of Active Participating RN-F's node */
  string str_rn_f_node;

  /** Represents the received read responses */
  int received_copyback_responses = 0;

  /** UVM Object Utility macro */
  `svt_xvm_object_utils(svt_chi_system_protocol_flow_ctrl_copyback_outstanding_diff_rn_same_hn_virtual_sequence)

  //-----------------------------------------------------------------------------  
  // Methods
  //-----------------------------------------------------------------------------
  /** Constructor */
  extern function new(string name="svt_chi_system_protocol_flow_ctrl_copyback_outstanding_diff_rn_same_hn_virtual_sequence"); 
 
  //-----------------------------------------------------------------------------  
  virtual task pre_start();
    `svt_xvm_debug("pre_start",$sformatf("Entering ..."));
    super.pre_start();
    raise_phase_objection();
    `svt_xvm_debug("pre_start",$sformatf("Exiting ..."));
  endtask // pre_start

  /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting Request Nodes = 2
   *  #- minimum supporting Home Nodes = 1
   */
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    
    /** local variables */
    int num_supporting_rn_f_nodes;
    int num_hn_f_nodes;   
    int array_idx;
    bit is_rn_idx_0_participating, is_rn_idx_1_participating;
    string str_is_supported_info_prefix = "";
    string str_is_supported_info = "";
    string str_idx0_info = "";
    string str_idx1_info = "";    

    /** Supporting RN-F Nodes required */
    int required_num_supporting_rn_f_nodes = 2;
    int required_num_hn_nodes = 1;
    
    `svt_xvm_debug("is_supported",$sformatf("Entering ..."));

    /** By default is_supported is 0 */
    is_supported = 0;

    /** Check for minimum required HN nodes */
    num_hn_f_nodes = hn_f_nodes.size();

    /** Check requirment of number of HN nodes needed */  
    if (num_hn_f_nodes < required_num_hn_nodes) begin
      issue_is_supported_failure($sformatf("This sequence requires minimum %0d HN-F nodes to be present in the system. Number of HN-F nodes are %0d. Program number of HN nodes using svt_chi_system_configuration::num_hn. Program the HN interface type using svt_chi_system_configuration::chi_addr_cfg.hn_interface_type[].", required_num_hn_nodes, num_hn_f_nodes));             
      return 0;      
    end
    /** Check for minimum required RN-F nodes.
     *  Also check whether the selected RN-F nodes are part of participating arrays or not.
     */ 
    num_supporting_rn_f_nodes = active_participating_rn_f_nodes.size();

    /** Check the requirements of RN-F nodes */  
    if (num_supporting_rn_f_nodes) begin
      /** Display the contents of Active Participating RN-F Nodes */
      foreach (active_participating_rn_f_nodes[j]) begin
        str_rn_f_node = {str_rn_f_node, $sformatf(" %0d", active_participating_rn_f_nodes[j])};
      end 
      `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_f_nodes are %0s", str_rn_f_node));
    end

    str_is_supported_info_prefix = $sformatf("Number of Supporting RN-F Node(s)  - Minimum Required : %0d Current : %0d", required_num_supporting_rn_f_nodes, num_supporting_rn_f_nodes);
    
    if ((initiating_rn_node_index_0_status==0)&&(valid_initiating_rn_f_node_index_0==0)) begin
        str_idx0_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN-Fs that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)";
    end
    else begin
      is_rn_idx_0_participating = is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_node_idx_0, array_idx);
      if (!is_rn_idx_0_participating) begin
        str_idx0_info = $sformatf("initiating_rn_node_idx_0 %0d is not valid for this sequence. The RN-F corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)", initiating_rn_node_idx_0, initiating_rn_node_idx_0);
      end
    end

    if ((initiating_rn_node_index_1_status==0)&&(valid_initiating_rn_f_node_index_1==0)) begin
      str_idx1_info = "Valid initiating_rn_node_idx_1 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN-Fs that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)";
    end 
    else begin
      is_rn_idx_1_participating = is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_node_idx_1, array_idx);
      if (!is_rn_idx_1_participating) begin
        str_idx1_info = $sformatf("initiating_rn_node_idx_1 %0d is not valid for this sequence. The RN-F corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)", initiating_rn_node_idx_1, initiating_rn_node_idx_1);
      end
    end  

    if (is_rn_idx_0_participating && is_rn_idx_1_participating) begin
      is_supported = 1;
      if(max_num_outstanding_write_xacts_at_hn > 0) begin
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].num_outstanding_write_xact < (max_num_outstanding_write_xacts_at_hn/2)) begin
          str_idx0_info = $sformatf("Programmed value of max_num_outstanding_write_xacts_at_hn_status is %0d. But num_outstanding_write_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_write_xact of the initiating RN node must be equal to or greater than half of max_num_outstanding_write_xacts_at_hn_status of the target HN", max_num_outstanding_write_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_0_participating].num_outstanding_write_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].num_outstanding_write_xact < (max_num_outstanding_write_xacts_at_hn/2)) begin
          str_idx1_info = $sformatf("Programmed value of max_num_outstanding_write_xacts_at_hn_status is %0d. But num_outstanding_write_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_write_xact of the initiating RN node must be equal to or greater than half of max_num_outstanding_write_xacts_at_hn_status of the target HN", max_num_outstanding_write_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_1_participating].num_outstanding_write_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
      end else begin
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].num_outstanding_xact < (max_num_outstanding_xacts_at_hn/2)) begin
          str_idx0_info = $sformatf("Programmed value of max_num_outstanding_xacts_at_hn_status is %0d. But num_outstanding_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_xact of the initiating RN node must be equal to or greater than half of max_num_outstanding_xacts_at_hn of the target HN", max_num_outstanding_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_0_participating].num_outstanding_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].num_outstanding_xact < (max_num_outstanding_xacts_at_hn/2)) begin
          str_idx1_info = $sformatf("Programmed value of max_num_outstanding_xacts_at_hn_status is %0d. But num_outstanding_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_xact of the initiating RN node must be equal to or greater than half of max_num_outstanding_xacts_at_hn of the target HN", max_num_outstanding_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_1_participating].num_outstanding_xact, initiating_rn_node_idx_1);
          is_supported = 0;
        end
      end
    end
    
    if (!is_supported) begin
      str_is_supported_info = $sformatf("%0s%0s",str_idx0_info, str_idx1_info);
      if (is_rn_idx_0_participating && is_rn_idx_1_participating) begin
        issue_is_supported_failure($sformatf("This sequence cannot be run based on the current system configuration.\n\
                                              %0s\n\
                                              %0s \n\
                                              Modify configurations through \n\
                                              svt_chi_system_configuration::num_rn,\n\
                                              svt_chi_node_configuration::is_active,\n\
                                              svt_chi_system_configuration::participating_rn_nodes[]\n\
                                              ", str_is_supported_info_prefix, str_is_supported_info));
      end
      else begin
        issue_is_supported_failure($sformatf("This sequence cannot be run based on the current node configurations of RN%0d and/or RN%0d.\n\
                                              %0s \n\
                                              Modify configuration through \n\
                                              svt_chi_node_configuration::num_outstanding_xact,\n\
                                              svt_chi_node_configuration::num_outstanding_write_xact,\n\
                                              ",str_is_supported_info, initiating_rn_node_idx_0, initiating_rn_node_idx_1));
      end
    end      
    if (!is_target_hn_idx_valid_for_curr_cfg()) begin
      is_supported = 0;
      `svt_xvm_note("is_supported", "not a valid hn_idx based on random_tgt_id_enable for current cfg");
    end
  endfunction : is_supported

  //----------------------------------------------------------------------------- 
  virtual task body();
    /** Queue for collecting the Address to send Copyback transactions */
    bit[`SVT_CHI_MAX_ADDR_WIDTH -1:0] rn_f_node_idx_0_copyback_addr_queue[$];                      
    bit[`SVT_CHI_MAX_ADDR_WIDTH -1:0] rn_f_node_idx_1_copyback_addr_queue[$];     
    bit rn_f_node_idx_0_copyback_non_secure_queue[$];                      
    bit rn_f_node_idx_1_copyback_non_secure_queue[$];                      
    /** Queue to collect Unique transaction id's */    
    int txn_id_arr[$];
    /** Setting transaction id width */
    int txn_id_width=`SVT_CHI_TXN_ID_WIDTH;
    int num_outstanding_xacts_to_generate;

    /** Sub sequences initiated from this sequence */
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq[int];
    svt_chi_rn_copyback_type_transaction_directed_sequence copyback_seq[int];

    `svt_xvm_debug("body", "Entering ...")
    super.body();

    max_num_outstanding_xacts_at_hn_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(), "max_num_outstanding_xacts_at_hn", max_num_outstanding_xacts_at_hn);
    max_num_outstanding_write_xacts_at_hn_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(), "max_num_outstanding_write_xacts_at_hn", max_num_outstanding_write_xacts_at_hn);
    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :initiating_rn_f_node_index_0;
    initiating_rn_node_idx_1 = initiating_rn_node_index_1_status ? initiating_rn_node_index_1_from_config_db :initiating_rn_f_node_index_1;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_f_node_index_0;

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    //If max outstanding count for Write transactions has been programmed, use that to generate the outstanding Copyback
    if(max_num_outstanding_write_xacts_at_hn > 0) begin
      num_outstanding_xacts_to_generate = max_num_outstanding_write_xacts_at_hn;
      `svt_xvm_debug("body",$sformatf("max_num_outstanding_write_xacts_at_hn is set to a non-zero value (%0d). Hence, the value programmed in max_num_outstanding_xacts_at_hn will be ignored. The number of outstanding transactions issued by the sequence will be equal to max_num_outstanding_write_xacts_at_hn", max_num_outstanding_write_xacts_at_hn));
    end
    //If not, use the max outstanding transaction count
    else
      num_outstanding_xacts_to_generate = max_num_outstanding_xacts_at_hn;

    for(int i = 0; i < sequence_length; i++) begin
      `svt_xvm_debug("body",$sformatf("Starting cache initialization for %0d addresses from p_sequencer.rn_virt_seqr[%0d] and p_sequencer.rn_virt_seqr[%0d] to HN idx %0d",
                                        num_outstanding_xacts_to_generate, initiating_rn_node_idx_0, initiating_rn_node_idx_1, target_hn_node_idx_0));

      /** Collecting txn_id */
      `ifdef SVT_CHI_ISSUE_E_ENABLE
        if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision >= svt_chi_node_configuration::ISSUE_E) begin
          for(int id=0; id <= `SVT_CHI_SPEC_PERMITTED_MAX_TXNID_VALUE_FOR_ISSUE_E; id++) begin
            txn_id_arr.push_back(id);
          end
        end
        else if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision >= svt_chi_node_configuration::ISSUE_D) begin
          for(int id=0; id <= `SVT_CHI_SPEC_PERMITTED_MAX_TXNID_VALUE_FOR_ISSUE_D; id++) begin
            txn_id_arr.push_back(id);
          end
        end else begin
          for(int id=0; id <= `SVT_CHI_SPEC_PERMITTED_MAX_TXNID_VALUE_UPTO_ISSUE_C; id++) begin
            txn_id_arr.push_back(id);
          end
        end
      `elsif SVT_CHI_ISSUE_D_ENABLE
        if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision >= svt_chi_node_configuration::ISSUE_D) begin
          for(int id=0; id <= `SVT_CHI_SPEC_PERMITTED_MAX_TXNID_VALUE_FOR_ISSUE_D; id++) begin
            txn_id_arr.push_back(id);
          end
        end else begin
          for(int id=0; id <= `SVT_CHI_SPEC_PERMITTED_MAX_TXNID_VALUE_UPTO_ISSUE_C; id++) begin
            txn_id_arr.push_back(id);
          end
        end
      `else
        for(int id=0; id <= `SVT_CHI_SPEC_PERMITTED_MAX_TXNID_VALUE_UPTO_ISSUE_C; id++) begin
          txn_id_arr.push_back(id);
        end
      `endif

      /** Shuffling all collected txn_id */
      txn_id_arr.shuffle;

      /** Initiating outstanding MakeUnique transactions from different RN-Fs
       *  to initialise the cache line state to UD state for below transactions.  
       *   svt_chi_transaction::WRITEBACKFULL  
       *   svt_chi_transaction::WRITEBACKPTL  
       *   svt_chi_transaction::WRITECLEANFULL  
       *   svt_chi_transaction::WRITECLEANPTL 
       */
      for(int l=0; l< num_outstanding_xacts_to_generate; l++) begin
        automatic int initiating_rn_index;
        if (l%2)begin
          initiating_rn_index = initiating_rn_node_idx_1;
        end 
        else begin
          initiating_rn_index = initiating_rn_node_idx_0;
        end 
        `svt_xvm_do_on_with(makeunique_seq[l], p_sequencer.rn_virt_seqr[initiating_rn_index].rn_xact_seqr,{
          sequence_length    == 1;
          hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
          seq_hn_node_idx  == target_hn_node_idx_0;
          use_seq_is_non_secure_access == 0;        
        })
        
        `svt_xvm_debug("body", $sformatf("%0s Waiting for MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) to end",`SVT_CHI_PRINT_PREFIX(makeunique_seq[l].write_tran),l, makeunique_seq[l].write_tran.hn_node_idx, makeunique_seq[l].write_tran.tgt_id));
        // Waiting for current MakeUnique transaction to complete 
        makeunique_seq[l].write_tran.wait_end();
        
          //Checking if transaction is dropped
         if (makeunique_seq[l].output_xacts[0].is_xact_dropped) begin
           `svt_xvm_debug("body", $sformatf("%0s First set of MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) is Droppped. Re-randomizing the transaction.",`SVT_CHI_PRINT_PREFIX(makeunique_seq[l].write_tran),l, makeunique_seq[l].write_tran.hn_node_idx, makeunique_seq[l].write_tran.tgt_id));
           l--;
         end
         
         else begin
           
           if (l%2)begin
             rn_f_node_idx_1_copyback_addr_queue.push_back(makeunique_seq[l].write_tran.addr);
             rn_f_node_idx_1_copyback_non_secure_queue.push_back(makeunique_seq[l].write_tran.is_non_secure_access);
           end 
           else begin
             rn_f_node_idx_0_copyback_addr_queue.push_back(makeunique_seq[l].write_tran.addr);
             rn_f_node_idx_0_copyback_non_secure_queue.push_back(makeunique_seq[l].write_tran.is_non_secure_access);
           end 

           `svt_xvm_debug("body", $sformatf("%0s MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) ended",`SVT_CHI_PRINT_PREFIX(makeunique_seq[l].write_tran),l, makeunique_seq[l].write_tran.hn_node_idx, makeunique_seq[l].write_tran.tgt_id));
           
           `svt_xvm_verbose("body", $sformatf("MakeUnique transaction [%0d]  is %0s", l,makeunique_seq[l].write_tran.sprint()));
           
         end //end of else condition of cache state check
      end //forloop of MakeUnique 

      /** Initiating outstanding CopyBack transactions from two Random RN-Fs.  
       *  Initial cache line state is:
       *   UD :  svt_chi_transaction::WRITEBACKFULL  
       *         svt_chi_transaction::WRITEBACKPTL  
       *         svt_chi_transaction::WRITECLEANFULL  
       *         svt_chi_transaction::WRITECLEANPTL 
       */
        fork
          begin
            for(int j = 0; j < (num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2); j++) begin
              automatic bit[`SVT_CHI_MAX_ADDR_WIDTH -1:0] txn_addr;                                      
              automatic bit txn_is_non_secure_access;                                      
              automatic bit[(`SVT_CHI_TXN_ID_WIDTH-1):0]txn_id   = txn_id_arr.pop_front();
              txn_addr = rn_f_node_idx_0_copyback_addr_queue.pop_front();
              txn_is_non_secure_access = rn_f_node_idx_0_copyback_non_secure_queue.pop_front();
              `svt_xvm_do_on_with(copyback_seq[j], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,{
                sequence_length == 1;
                seq_txn_id == txn_id;
                seq_xact_type inside {svt_chi_transaction::WRITEBACKFULL,svt_chi_transaction::WRITEBACKPTL,svt_chi_transaction::WRITECLEANFULL,svt_chi_transaction::WRITECLEANPTL};
                seq_order_type  == svt_chi_transaction::NO_ORDERING_REQUIRED;
                seq_copyback_req_order_enable == 0;                        
                hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                min_addr           == txn_addr;
                max_addr           == txn_addr;     
                seq_is_non_secure_access == txn_is_non_secure_access;
                use_seq_is_non_secure_access == 1;
                })

              `svt_xvm_debug("body", $sformatf("%0s Transmitting Copyback Transaction [%0d] targeted to HN (idx %0d, id %0d) ",`SVT_CHI_PRINT_PREFIX(copyback_seq[j].copyback_tran),j, copyback_seq[j].copyback_tran.hn_node_idx, copyback_seq[j].copyback_tran.tgt_id));
              `svt_xvm_verbose("body", $sformatf("Copyback Transaction [%0d] is %0s", j,copyback_seq[j].copyback_tran.sprint()));
            end  
          end  
          begin
            for(int j = 0; j < num_outstanding_xacts_to_generate/2; j++) begin
              automatic bit[`SVT_CHI_MAX_ADDR_WIDTH -1:0] txn_addr;                                      
              automatic bit txn_is_non_secure_access;                                      
              automatic bit[(`SVT_CHI_TXN_ID_WIDTH-1):0]txn_id   = txn_id_arr.pop_front();
              txn_addr = rn_f_node_idx_1_copyback_addr_queue.pop_front();
              txn_is_non_secure_access = rn_f_node_idx_1_copyback_non_secure_queue.pop_front();
              `svt_xvm_do_on_with(copyback_seq[((num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2)+j)], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,{
                sequence_length == 1;
                seq_txn_id == txn_id;
                seq_xact_type inside {svt_chi_transaction::WRITEBACKFULL,svt_chi_transaction::WRITEBACKPTL,svt_chi_transaction::WRITECLEANFULL,svt_chi_transaction::WRITECLEANPTL};
                seq_order_type  == svt_chi_transaction::NO_ORDERING_REQUIRED;
                seq_copyback_req_order_enable == 0;     
                hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                min_addr           == txn_addr;
                max_addr           == txn_addr;     
                seq_is_non_secure_access == txn_is_non_secure_access;
                use_seq_is_non_secure_access == 1;       
                })
              `svt_xvm_debug("body", $sformatf("%0s Transmitting Copyback Transaction [%0d] targeted to HN (idx %0d, id %0d) ",`SVT_CHI_PRINT_PREFIX(copyback_seq[((num_outstanding_xacts_to_generate/2)+j)].copyback_tran),((num_outstanding_xacts_to_generate/2)+j), copyback_seq[((num_outstanding_xacts_to_generate/2)+j)].copyback_tran.hn_node_idx, copyback_seq[((num_outstanding_xacts_to_generate/2)+j)].copyback_tran.tgt_id));
              `svt_xvm_verbose("body", $sformatf("Copyback Transaction [%0d] is %0s", ((num_outstanding_xacts_to_generate/2)+j),copyback_seq[((num_outstanding_xacts_to_generate/2)+j)].copyback_tran.sprint()));
            end  
          end  
        join  

      /** Checking for the reception of all the CompDBIDResp from the Interconnect */
      foreach(copyback_seq[index_1]) begin
        fork
          automatic int _index_1 = index_1;
          begin
            `svt_xvm_debug("body", $sformatf("%0s Copyback transaction [%0d] targeted to HN (idx %0d, id %0d), suspend_wr_data %0b: waiting for response from interconnect",`SVT_CHI_PRINT_PREFIX(copyback_seq[_index_1].copyback_tran),_index_1, copyback_seq[_index_1].copyback_tran.hn_node_idx, copyback_seq[_index_1].copyback_tran.tgt_id,copyback_seq[_index_1].copyback_tran.suspend_wr_data));
            fork
            begin
              fork
                begin
                  copyback_seq[_index_1].copyback_tran.wait_for_tx_data_prereqs();
                end
                begin
                  wait(copyback_seq[_index_1].copyback_tran.req_status == svt_chi_transaction::RETRY);// begin
                end
              join_any
              disable fork;
            end
            join
            received_copyback_responses++;
            `svt_xvm_debug("body", $sformatf("%0s Copyback transaction [%0d] targeted to HN (idx %0d, id %0d), suspend_comp_ack %0b: received response from interconnect. Total responses received %0d",`SVT_CHI_PRINT_PREFIX(copyback_seq[_index_1].copyback_tran),_index_1, copyback_seq[_index_1].copyback_tran.hn_node_idx, copyback_seq[_index_1].copyback_tran.tgt_id,copyback_seq[_index_1].copyback_tran.suspend_wr_data, received_copyback_responses));
          end
        join_none  
      end

      /** Wait until All write_data responses are received at RN-Fs */
      `svt_xvm_debug("body",$sformatf("Completed initiation of Copyback type transactions for %0d addresses from p_sequencer.rn_virt_seqr[%0d] and p_sequencer.rn_virt_seqr[%0d] to HN idx %0d with suspend_wr_data set to 1, and waiting to receive responses from interconnect.",
                                num_outstanding_xacts_to_generate, initiating_rn_node_idx_0, initiating_rn_node_idx_1, target_hn_node_idx_0)); 
      wait(received_copyback_responses == num_outstanding_xacts_to_generate);
      `svt_xvm_debug("body",$sformatf("Received responses from interconnect to Copyback type transactions for %0d addresses from p_sequencer.rn_virt_seqr[%0d] and p_sequencer.rn_virt_seqr[%0d] to HN idx %0d with suspend_wr_data set to 1",
                                      num_outstanding_xacts_to_generate, initiating_rn_node_idx_0, initiating_rn_node_idx_1, target_hn_node_idx_0)); 

      /** Self Check1: To check suspend_wr_data should not be modified to zero by the VIP
       *  before reseting from test bench.
       */
      foreach (copyback_seq[self_check_idx1]) begin
        if(!copyback_seq[self_check_idx1].copyback_tran.is_terminated()) begin 

          if (copyback_seq[self_check_idx1].copyback_tran.suspend_wr_data == 0) begin
            `svt_xvm_error("body", $sformatf("%0s suspend_wr_data should be 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(copyback_seq[self_check_idx1].copyback_tran)));
          end
          else begin
            `svt_xvm_debug("body", $sformatf("%0s suspend_wr_data is 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(copyback_seq[self_check_idx1].copyback_tran)));
          end
        end
      end

      /** Self Check2: To check suspend_wr_data should not be modified to zero by the VIP 
       *  before reseting from test bench.
       */ 
      foreach (copyback_seq[self_check_idx2]) begin
        if(!copyback_seq[self_check_idx2].copyback_tran.is_terminated()) begin 
          /** Pass event is not triggered */
          if (copyback_seq[self_check_idx2].copyback_tran.end_event.is_on() == 1) begin
            `svt_xvm_error("body", $sformatf("Unexpected: %0s Transaction's end_event triggered when suspend_wr_data is still 1.", `SVT_CHI_PRINT_PREFIX(copyback_seq[self_check_idx2].copyback_tran)));
          end
          /** Fail event has triggered */
          else begin
            `svt_xvm_debug("body", $sformatf("Expected: %0s Transaction's end_event is not triggered when suspend_wr_data is still 1.", `SVT_CHI_PRINT_PREFIX(copyback_seq[self_check_idx2].copyback_tran)));
          end
        end
      end
 
      /** Self Check 3: To check that the current_outstanding_*_xact_count in the RNs
       * are as per the transactions inititated by the sequence
       */
      /** Check if the total outstanding xact counter is set correctly in the shared status of the RN agent */
      if(copyback_seq[0].shared_status.prot_status.current_outstanding_xact_count != (num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2))
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding transactions from the sequence but the outstanding transaction count in the shared status of RN%0d is %0d", (num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2), initiating_rn_node_idx_0, copyback_seq[0].shared_status.prot_status.current_outstanding_xact_count));
      /** Check if the outstanding Write xact counter is set correctly in the shared status of the RN agent */
      if(copyback_seq[0].shared_status.prot_status.current_outstanding_write_xact_count != (num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2)) begin
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding Copyback transactions from the sequence but the outstanding Write transaction count in the shared status of RN%0d is %0d", (num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2), initiating_rn_node_idx_0, copyback_seq[0].shared_status.prot_status.current_outstanding_write_xact_count));
      end
      /** Check if the total outstanding xact counter is set correctly in the shared status of the RN agent */
      if(copyback_seq[(num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2)].shared_status.prot_status.current_outstanding_xact_count != num_outstanding_xacts_to_generate/2)
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding transactions from the sequence but the outstanding transaction count in the shared status of RN%0d is %0d", num_outstanding_xacts_to_generate/2, initiating_rn_node_idx_1, copyback_seq[(num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2)].shared_status.prot_status.current_outstanding_xact_count));
      /** Check if the outstanding Write xact counter is set correctly in the shared status of the RN agent */
      if(copyback_seq[(num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2)].shared_status.prot_status.current_outstanding_write_xact_count != num_outstanding_xacts_to_generate/2) begin
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding Copyback transactions from the sequence but the outstanding Write transaction count in the shared status of RN%0d is %0d", num_outstanding_xacts_to_generate/2, initiating_rn_node_idx_1, copyback_seq[(num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2)].shared_status.prot_status.current_outstanding_write_xact_count));
      end

      `svt_xvm_debug("body", $sformatf("RN%0d: Number of outstanding transactions : %0d, Number of outstanding write xacts : %0d", initiating_rn_node_idx_0, copyback_seq[0].shared_status.prot_status.current_outstanding_xact_count, copyback_seq[0].shared_status.prot_status.current_outstanding_write_xact_count));
      `svt_xvm_debug("body", $sformatf("RN%0d: Number of outstanding transactions : %0d, Number of outstanding write xacts : %0d", initiating_rn_node_idx_1, copyback_seq[1].shared_status.prot_status.current_outstanding_xact_count, copyback_seq[1].shared_status.prot_status.current_outstanding_write_xact_count));

      /** Targeted HN IDs from both RN-Fs should be same */
      for(int index_3 = 0; index_3 < num_outstanding_xacts_to_generate/2; index_3++) begin
        int hn_idx_0, hn_idx_1;
        hn_idx_0 = sys_cfg.get_hn_idx(copyback_seq[index_3].output_xacts[0].addr);
        hn_idx_1 = sys_cfg.get_hn_idx(copyback_seq[((num_outstanding_xacts_to_generate/2) + index_3)].output_xacts[0].addr);
        if ((hn_idx_0 == target_hn_node_idx_0) && (hn_idx_0 == hn_idx_1)) begin
          /** pass */
          `svt_xvm_debug("body", $sformatf("Targeted HN Index from both RNs is same as expected.  rn[%0d] to hn_idx[%0d], rn[%0d] to hn_idx[%0d]", initiating_rn_node_idx_0, hn_idx_0, initiating_rn_node_idx_1, hn_idx_1));
        end
        else begin
          /** fail */
          `svt_xvm_error("body", $sformatf("Targeted HN Index from both RNs is different, which is unexpected.  rn[%0d] %0s transaction to hn_idx[%0d], rn[%0d] %0s transaction to hn_idx[%0d]",initiating_rn_node_idx_0, `SVT_CHI_PRINT_PREFIX( copyback_seq[index_3].output_xacts[0]), hn_idx_0, initiating_rn_node_idx_1, `SVT_CHI_PRINT_PREFIX( copyback_seq[((num_outstanding_xacts_to_generate/2)+index_3)].output_xacts[0]), hn_idx_1));
        end
      end  

      /** Resuming all Suspended Response of all above Copyback transactions  */
      foreach(copyback_seq[wr]) begin
        `svt_xvm_debug("body",$sformatf("Received responses for all Copyback type transactions from interconnect, resuming the transactions by setting svt_chi_rn_transaction::suspend_wr_data set to 0 %0s",`SVT_CHI_PRINT_PREFIX(copyback_seq[wr].copyback_tran)));
        copyback_seq[wr].copyback_tran.suspend_wr_data=0;
        `svt_xvm_debug("body", $sformatf("For iteration %0d : After Resume, received_copyback_responses is %0d,suspend_wr_data is %0b ", wr,received_copyback_responses,copyback_seq[wr].copyback_tran.suspend_wr_data));
      end

      /** Waiting for above copyback outstanding transactions to complete */
      foreach(copyback_seq[index_2]) begin
        `svt_xvm_debug("body", $sformatf("Waiting for above copyback_seq[%0d] transaction %0s to end", index_2, `SVT_CHI_PRINT_PREFIX(copyback_seq[index_2].copyback_tran)));
        copyback_seq[index_2].copyback_tran.wait_end(); 
        
        /** Self Check4: To check suspend_wr_data should not be asserted after the transaction 
         *  completes as it is reseted from test bench
         */
        if(!copyback_seq[index_2].copyback_tran.is_terminated()) begin 
            if (copyback_seq[index_2].copyback_tran.suspend_wr_data == 1) begin
              `svt_xvm_error("body", $sformatf("%0s suspend_wr_data should be 0 as it has been reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(copyback_seq[index_2].copyback_tran)));
            end
            else begin
              `svt_xvm_debug("body", $sformatf("%0s suspend_wr_data is 0 as it is reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(copyback_seq[index_2].copyback_tran)));
            end
        end
      end
     
      /** Empty the address and txn_id queues */
      rn_f_node_idx_0_copyback_addr_queue.delete();                      
      rn_f_node_idx_1_copyback_addr_queue.delete();                      
      rn_f_node_idx_0_copyback_non_secure_queue.delete();                      
      rn_f_node_idx_1_copyback_non_secure_queue.delete();                      
      txn_id_arr.delete();
      
      /** Reset received_read_responses to Zero */
      received_copyback_responses = 0;
      `svt_xvm_debug("body", "Exiting...")
    end//sequence_length
    /** 
     * To check the Interconnect HN Node shall responds to 
     * outstanding transactions from RN-Fs.<br>
     * Check done by System monitor(List of checkers)<br>
     *  #- copyback_data_integrity_check
     *  .  
     */
  endtask: body

  virtual task post_body();
    drop_phase_objection();
  endtask

endclass: svt_chi_system_protocol_flow_ctrl_copyback_outstanding_diff_rn_same_hn_virtual_sequence

function svt_chi_system_protocol_flow_ctrl_copyback_outstanding_diff_rn_same_hn_virtual_sequence::new(string name="svt_chi_system_protocol_flow_ctrl_copyback_outstanding_diff_rn_same_hn_virtual_sequence");
  super.new(name);
endfunction


//====================================================================================
/** 
 * @groupname CHI_OUTSTANDING_CPBK_TYPE 
 * #- This sequence requires atleast two HN nodes to be present in the Interconnect.
 * #- This sequence requires atleast two initiating active and participating RN-Fs.
 * #- Inititate maximum number of MAKEUNIQUE transactions from existing active and 
 *    participating different RN-Fs, to perform cache initialization to a
 *    randomly selected different HNs.
 * #- Initiate maximum number of COPYBACK type transactions with 
 *    svt_chi_rn_transaction::suspend_wr_data set to 1 from initiating RN-Fs to randomly 
 *    selected HNs in non blocking mode. <br>
 *    - Maximum number of outstanding transactions at the HN is as per either #max_num_outstanding_write_xacts_at_hn or
 *      #max_num_outstanding_xacts_at_hn, which can be controlled through config DB.   
 *    - This ensures that the maximum outstanding transaction limit is reached at
 *      two different HNs. 
 *    - Also, the RN-Fs will not transmit CopyBackWrData corresponding to these
 *      transactions until svt_chi_rn_transaction::suspend_wr_data is set to 0 from the 
 *      sequence.
 *    .
 * #- The addresses of these COPYBACK transactions are such that:
 *    - Same as initialized cache line addresses if cache initialization is performed
 *    .
 * #- The RN-Fs of these COPYBACK transactions are such that:
 *    - Same as RN-Fs from which cache initialization is performed
 *    .
 * #- Once the RN-Fs receives the responses for all the outstanding transactions from
 *    HNs, svt_chi_rn_transaction::suspend_wr_data is set to 0 for all the outstanding
 *    transactions. <br>
 *    This ensures that the CopyBackWrData for these transactions can be resumed 
 *    from RN-Fs.
 * #- Check that the HNs responds properly for all outstanding COPYBACK type
 *    transactions and these are completed successfully.
 * .
 * #- This sequence does not support EVICT and WRITEEVICTFULL transactions.<br>
 */ 

class svt_chi_system_protocol_flow_ctrl_copyback_outstanding_diff_rn_diff_hn_virtual_sequence extends svt_chi_system_base_virtual_sequence;

  //-----------------------------------------------------------------------------  
  // Member attributes
  //-----------------------------------------------------------------------------  
  /** Parameter that controls the enabling of transactions in non-blocking mode from the sequence */
  bit enable_outstanding = 0;

  /** To display contents of Active Participating RN-F's node */
  string str_rn_f_node;

  /** UVM/OVM Object Utility macro */
  `svt_xvm_object_utils(svt_chi_system_protocol_flow_ctrl_copyback_outstanding_diff_rn_diff_hn_virtual_sequence)

  //-----------------------------------------------------------------------------  
  // Methods
  //-----------------------------------------------------------------------------
  /** Constructor */
  extern function new(string name="svt_chi_system_protocol_flow_ctrl_copyback_outstanding_diff_rn_diff_hn_virtual_sequence"); 

  /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting RN-F Nodes = 2 
   *  #- minimum supporting HN-F Nodes = 2 
   */
  //-----------------------------------------------------------------------------
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    
    /** local variables */
    int num_supporting_rn_f_nodes;
    string str_is_supported_info_prefix = "";
    string str_is_supported_info = "";
    int num_hn_f_nodes;
    int array_idx;
    string str_idx0_info = "";
    string str_idx1_info = "";
    bit    is_rn_idx_0_participating, is_rn_idx_1_participating;

    /** Supporting any type of Request Nodes required */
    int required_num_supporting_rn_f_nodes = 2;
    int required_num_hn_nodes = 2;
         
    `svt_xvm_debug("is_supported",$sformatf("Entering ..."));

    /** By default is_supported is 0 */
    is_supported = 0;

    /** Check for minimum required HN nodes */
    num_hn_f_nodes = hn_f_nodes.size();

    /** Check requirment of number of HN nodes needed */ 
    if (num_hn_f_nodes < required_num_hn_nodes) begin
      issue_is_supported_failure($sformatf("This sequence requires minimum %0d HN_F nodes to be present in the system. Number of HN_F nodes are %0d. Program number of HN nodes using svt_chi_system_configuration::num_hn. Program the HN interface type using svt_chi_system_configuration::chi_addr_cfg.hn_interface_type[].", required_num_hn_nodes, num_hn_f_nodes));
      return 0;      
    end

    /** Check for minimum required RN-F nodes.
     *  Also check whether the selected RN-F nodes are part of participating arrays or not.
     */
    num_supporting_rn_f_nodes = active_participating_rn_f_nodes.size();

    /** Check the requirements of RN-F nodes */  
    if (num_supporting_rn_f_nodes) begin
      /** Display the contents of Active Participating RN-F Nodes */
      foreach (active_participating_rn_f_nodes[j]) begin
        str_rn_f_node = {str_rn_f_node, $sformatf(" %0d", active_participating_rn_f_nodes[j])};
      end      
      `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_f_nodes are %0s", str_rn_f_node));
    end
    
    str_is_supported_info_prefix = $sformatf("Number of Supporting RN_F Node(s)  - Minimum Required : %0d Current : %0d", required_num_supporting_rn_f_nodes,num_supporting_rn_f_nodes);
    
    if ((initiating_rn_node_index_0_status==0)&&(valid_initiating_rn_f_node_index_0==0)) begin
        str_idx0_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN-Fs that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)";
    end
    else begin
      is_rn_idx_0_participating = is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_node_idx_0, array_idx);
      if (!is_rn_idx_0_participating) begin
        str_idx0_info = $sformatf("initiating_rn_node_idx_0 %0d is not valid for this sequence. The RN-F corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)", initiating_rn_node_idx_0, initiating_rn_node_idx_0);
      end
    end

    if ((initiating_rn_node_index_1_status==0)&&(valid_initiating_rn_f_node_index_1==0)) begin
    str_idx1_info = "Valid initiating_rn_node_idx_1 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN-Fs that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)";  
    end 
    else begin
      is_rn_idx_1_participating = is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_node_idx_1, array_idx);
      if (!is_rn_idx_1_participating) begin
        str_idx1_info = $sformatf("initiating_rn_node_idx_1 %0d is not valid for this sequence. The RN-F corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)", initiating_rn_node_idx_1, initiating_rn_node_idx_1);
      end
    end  
    
    if (is_rn_idx_0_participating && is_rn_idx_1_participating) begin
      is_supported = 1;
      if(max_num_outstanding_write_xacts_at_hn > 0) begin
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].num_outstanding_write_xact < max_num_outstanding_write_xacts_at_hn) begin
          str_idx0_info = $sformatf("Programmed value of max_num_outstanding_write_xacts_at_hn_status is %0d. But num_outstanding_write_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_write_xact of the initiating RN node must be equal to or greater than max_num_outstanding_write_xacts_at_hn_status of the target HN", max_num_outstanding_write_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_0_participating].num_outstanding_write_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].num_outstanding_write_xact < max_num_outstanding_write_xacts_at_hn) begin
          str_idx1_info = $sformatf("Programmed value of max_num_outstanding_write_xacts_at_hn_status is %0d. But num_outstanding_write_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_write_xact of the initiating RN node must be equal to or greater than max_num_outstanding_write_xacts_at_hn_status of the target HN", max_num_outstanding_write_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_1_participating].num_outstanding_write_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
      end else begin
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].num_outstanding_xact < max_num_outstanding_xacts_at_hn) begin
          str_idx0_info = $sformatf("Programmed value of max_num_outstanding_xacts_at_hn_status is %0d. But num_outstanding_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_xact of the initiating RN node must be equal to or greater than max_num_outstanding_xacts_at_hn of the target HN", max_num_outstanding_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_0_participating].num_outstanding_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].num_outstanding_xact < max_num_outstanding_xacts_at_hn) begin
          str_idx1_info = $sformatf("Programmed value of max_num_outstanding_xacts_at_hn_status is %0d. But num_outstanding_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_xact of the initiating RN node must be equal to or greater than max_num_outstanding_xacts_at_hn of the target HN", max_num_outstanding_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_1_participating].num_outstanding_xact, initiating_rn_node_idx_1);
          is_supported = 0;
        end
      end
    end
    
    if (!is_supported) begin
      str_is_supported_info = $sformatf("%0s%0s",str_idx0_info, str_idx1_info);
      if (is_rn_idx_0_participating && is_rn_idx_1_participating) begin
        issue_is_supported_failure($sformatf("This sequence cannot be run based on the current system configuration.\n\
                                              %0s\n\
                                              %0s \n\
                                              Modify configurations through \n\
                                              svt_chi_system_configuration::num_rn,\n\
                                              svt_chi_node_configuration::is_active,\n\
                                              svt_chi_system_configuration::participating_rn_nodes[]\n\
                                              ", str_is_supported_info_prefix, str_is_supported_info));
      end
      else begin
        issue_is_supported_failure($sformatf("This sequence cannot be run based on the current node configurations of RN%0d and/or RN%0d.\n\
                                              %0s \n\
                                              Modify configuration through \n\
                                              svt_chi_node_configuration::num_outstanding_xact,\n\
                                              svt_chi_node_configuration::num_outstanding_write_xact,\n\
                                              ",str_is_supported_info, initiating_rn_node_idx_0, initiating_rn_node_idx_1));
      end
    end
    `svt_xvm_debug("is_supported",$sformatf("Exiting ..."));
    if (!is_target_hn_idx_valid_for_curr_cfg()) begin
      is_supported = 0;
      `svt_xvm_note("is_supported", "not a valid hn_idx based on random_tgt_id_enable for current cfg");
    end
  endfunction : is_supported

  //-----------------------------------------------------------------------------
  virtual task pre_start();
    bit enable_outstanding_status;
    `svt_xvm_debug("pre_start",$sformatf("Entering ..."));
    super.pre_start();
    raise_phase_objection();
    enable_outstanding_status = uvm_config_db#(bit)::get(m_sequencer, get_type_name(), "enable_outstanding", enable_outstanding);
    `svt_xvm_debug("body", $sformatf("enable_outstanding is %0b as a result of %0s", enable_outstanding, (enable_outstanding_status?"config DB":"default setting")));
    `svt_xvm_debug("pre_start",$sformatf("Exiting ..."));
  endtask // pre_start

  //-----------------------------------------------------------------------------
  virtual task body();

    int received_copyback_responses=0;
    int NUM_OUTSTANDING_XACT;

    /** Setting transaction id width */
    int txn_id_width=`SVT_CHI_TXN_ID_WIDTH;

    /** Queue of RN-F's, intitiating Copyback transactions */
    int initiating_rn_f_node_idx_1_queue[$];
    int initiating_rn_f_node_idx_0_queue[$];

    /** Queue of addresses, used by the transactions generated */
    bit[`SVT_CHI_MAX_ADDR_WIDTH -1:0] rn_f_node_idx_0_copyback_addr_queue[$];                      
    bit[`SVT_CHI_MAX_ADDR_WIDTH -1:0] rn_f_node_idx_1_copyback_addr_queue[$];                      
    bit rn_f_node_idx_0_copyback_non_secure_queue[$];                      
    bit rn_f_node_idx_1_copyback_non_secure_queue[$];                      


    /** Queue of Unique transaction id's, used by the transactions generated */
    int rn_f_node_idx_0_txn_id_queue[$];
    int rn_f_node_idx_1_txn_id_queue[$];

    /** Sub Read type transaction cache initialization directed sequences initiated from this sequence */
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq_0[int];
    /** Sub CopyBack type transaction directed sequences initiated from this sequence */
    svt_chi_rn_copyback_type_transaction_directed_sequence copyback_seq[int];
     
    `svt_xvm_debug("body", "Entering ...")
    super.body();
    
    max_num_outstanding_xacts_at_hn_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(), "max_num_outstanding_xacts_at_hn", max_num_outstanding_xacts_at_hn);
    max_num_outstanding_write_xacts_at_hn_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(), "max_num_outstanding_write_xacts_at_hn", max_num_outstanding_write_xacts_at_hn);
    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :initiating_rn_f_node_index_0;
    initiating_rn_node_idx_1 = initiating_rn_node_index_1_status ? initiating_rn_node_index_1_from_config_db :initiating_rn_f_node_index_1;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_f_node_index_0;
    target_hn_node_idx_1 = target_hn_node_index_1_status ? target_hn_node_index_1_from_config_db :target_hn_f_node_index_1;

    `svt_xvm_debug("body", $sformatf("max_num_outstanding_xacts_at_hn is %0d as a result of %0s.", max_num_outstanding_xacts_at_hn, max_num_outstanding_xacts_at_hn_status ? "config DB" : "default"));
    `svt_xvm_debug("body", $sformatf("max_num_outstanding_write_xacts_at_hn is %0d as a result of %0s.", max_num_outstanding_write_xacts_at_hn, max_num_outstanding_write_xacts_at_hn_status ? "config DB" : "default"));
    `svt_xvm_debug("body", $sformatf("initiating_rn_node_idx_0 is %0d as a result of %0s.", initiating_rn_node_idx_0, initiating_rn_node_index_0_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("initiating_rn_node_idx_1 is %0d as a result of %0s.", initiating_rn_node_idx_1, initiating_rn_node_index_1_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("target_hn_node_idx_0 is %0d as a result of %0s.", target_hn_node_idx_0, target_hn_node_index_0_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("target_hn_node_idx_1 is %0d as a result of %0s.", target_hn_node_idx_1, target_hn_node_index_1_status ? "config DB" : "Randomization"));  
   
    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    //If max outstanding count for Write transactions has been programmed, use that to generate the outstanding Copyback
    if(max_num_outstanding_write_xacts_at_hn > 0) begin
      NUM_OUTSTANDING_XACT = (max_num_outstanding_write_xacts_at_hn * 2);
      `svt_xvm_debug("body",$sformatf("max_num_outstanding_write_xacts_at_hn is set to a non-zero value (%0d). Hence, the value programmed in max_num_outstanding_xacts_at_hn will be ignored. The number of outstanding transactions issued by the sequence will be equal to max_num_outstanding_write_xacts_at_hn", max_num_outstanding_write_xacts_at_hn));
    end
    else
      NUM_OUTSTANDING_XACT = (max_num_outstanding_xacts_at_hn * 2);
    `svt_xvm_debug("body", $sformatf("Number of NUM_OUTSTANDING_XACT is %0d",NUM_OUTSTANDING_XACT));

    for(int i = 0; i < sequence_length; i++) begin

      /** Collecting txn_id */
      `ifdef SVT_CHI_ISSUE_E_ENABLE
        if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision >= svt_chi_node_configuration::ISSUE_E) begin
          for(int id=0; id <= `SVT_CHI_SPEC_PERMITTED_MAX_TXNID_VALUE_FOR_ISSUE_E; id++) begin
            rn_f_node_idx_0_txn_id_queue.push_back(id);
          end
        end
        else if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision >= svt_chi_node_configuration::ISSUE_D) begin
          for(int id=0; id <= `SVT_CHI_SPEC_PERMITTED_MAX_TXNID_VALUE_FOR_ISSUE_D; id++) begin
            rn_f_node_idx_0_txn_id_queue.push_back(id);
          end
        end else begin
          for(int id=0; id <= `SVT_CHI_SPEC_PERMITTED_MAX_TXNID_VALUE_UPTO_ISSUE_C; id++) begin
            rn_f_node_idx_0_txn_id_queue.push_back(id);
          end
        end
        if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision >= svt_chi_node_configuration::ISSUE_E) begin
          for(int id=0; id <= `SVT_CHI_SPEC_PERMITTED_MAX_TXNID_VALUE_FOR_ISSUE_E; id++) begin
            rn_f_node_idx_1_txn_id_queue.push_back(id);
          end
        end
        else if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision >= svt_chi_node_configuration::ISSUE_D) begin
          for(int id=0; id <= `SVT_CHI_SPEC_PERMITTED_MAX_TXNID_VALUE_FOR_ISSUE_D; id++) begin
            rn_f_node_idx_1_txn_id_queue.push_back(id);
          end
        end else begin
          for(int id=0; id <= `SVT_CHI_SPEC_PERMITTED_MAX_TXNID_VALUE_UPTO_ISSUE_C; id++) begin
            rn_f_node_idx_1_txn_id_queue.push_back(id);
          end
        end
      `elsif SVT_CHI_ISSUE_D_ENABLE
        if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision >= svt_chi_node_configuration::ISSUE_D) begin
          for(int id=0; id <= `SVT_CHI_SPEC_PERMITTED_MAX_TXNID_VALUE_FOR_ISSUE_D; id++) begin
            rn_f_node_idx_0_txn_id_queue.push_back(id);
          end
        end else begin
          for(int id=0; id <= `SVT_CHI_SPEC_PERMITTED_MAX_TXNID_VALUE_UPTO_ISSUE_C; id++) begin
            rn_f_node_idx_0_txn_id_queue.push_back(id);
          end
        end
        if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision >= svt_chi_node_configuration::ISSUE_D) begin
          for(int id=0; id <= `SVT_CHI_SPEC_PERMITTED_MAX_TXNID_VALUE_FOR_ISSUE_D; id++) begin
            rn_f_node_idx_1_txn_id_queue.push_back(id);
          end
        end else begin
          for(int id=0; id <= `SVT_CHI_SPEC_PERMITTED_MAX_TXNID_VALUE_UPTO_ISSUE_C; id++) begin
            rn_f_node_idx_1_txn_id_queue.push_back(id);
          end
        end
      `else
        for(int id=0; id <= `SVT_CHI_SPEC_PERMITTED_MAX_TXNID_VALUE_UPTO_ISSUE_C; id++) begin
          rn_f_node_idx_0_txn_id_queue.push_back(id);
          rn_f_node_idx_1_txn_id_queue.push_back(id);
        end
      `endif
      /** Shuffling all collected txn_id */
      rn_f_node_idx_0_txn_id_queue.shuffle;
      rn_f_node_idx_1_txn_id_queue.shuffle;

      /** Initiating outstanding MakeUnique transactions from different RN-Fs
       *  to initialise the cache line state to UD state for below transactions.  
       *   svt_chi_transaction::WRITEBACKFULL  
       *   svt_chi_transaction::WRITEBACKPTL  
       *   svt_chi_transaction::WRITECLEANFULL  
       *   svt_chi_transaction::WRITECLEANPTL 
       */
      for(int l=0; l<NUM_OUTSTANDING_XACT ; l++) begin
        automatic int initiating_rn_index;
        
        if (l%2)begin
          initiating_rn_index = initiating_rn_node_idx_1;
          initiating_rn_f_node_idx_1_queue.push_back(initiating_rn_index);
        end 
        else begin
          initiating_rn_index = initiating_rn_node_idx_0;
          initiating_rn_f_node_idx_0_queue.push_back(initiating_rn_index);
        end 

        `svt_xvm_do_on_with(makeunique_seq_0[l], p_sequencer.rn_virt_seqr[initiating_rn_index].rn_xact_seqr,{
          sequence_length    == 1;
          hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
          use_seq_is_non_secure_access == 0;
          if(l == 0)
          {
            seq_hn_node_idx    == target_hn_node_idx_0;                                        
          }
          else if (l < NUM_OUTSTANDING_XACT/4)
          {
            seq_hn_node_idx == makeunique_seq_0[0].seq_hn_node_idx;                                   
          }
          else if (l == NUM_OUTSTANDING_XACT/4)
          {
            seq_hn_node_idx    == target_hn_node_idx_1;                                        
          }
          else if (l < NUM_OUTSTANDING_XACT/2)
          {
            seq_hn_node_idx == makeunique_seq_0[NUM_OUTSTANDING_XACT/4].seq_hn_node_idx;                                   
          }
          else if ((l >= NUM_OUTSTANDING_XACT/2) && (l < NUM_OUTSTANDING_XACT*3/4))
          {
            seq_hn_node_idx == makeunique_seq_0[0].seq_hn_node_idx;                                   
          }
          else
          {
            seq_hn_node_idx == makeunique_seq_0[NUM_OUTSTANDING_XACT/4].seq_hn_node_idx;                                   
          }
        })
        
        /** Retrieving 512 addresses from output transactions generated by the sequence  */
        if (l%2)begin
          rn_f_node_idx_1_copyback_addr_queue.push_back(makeunique_seq_0[l].write_tran.addr);
          rn_f_node_idx_1_copyback_non_secure_queue.push_back(makeunique_seq_0[l].write_tran.is_non_secure_access);
        end 
        else begin
          rn_f_node_idx_0_copyback_addr_queue.push_back(makeunique_seq_0[l].write_tran.addr);
          rn_f_node_idx_0_copyback_non_secure_queue.push_back(makeunique_seq_0[l].write_tran.is_non_secure_access);
        end 
      end //forloop of 512 MakeUnique 

      /** Waiting for above MakeUnique transactions to complete */ 
      foreach(makeunique_seq_0[mu]) begin
         `svt_xvm_debug("body", $sformatf("%0s Waiting for MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) to end",`SVT_CHI_PRINT_PREFIX(makeunique_seq_0[mu].write_tran),mu, makeunique_seq_0[mu].write_tran.hn_node_idx, makeunique_seq_0[mu].write_tran.tgt_id));
         makeunique_seq_0[mu].write_tran.wait_end(); 
         `svt_xvm_debug("body", $sformatf("%0s MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) ended",`SVT_CHI_PRINT_PREFIX(makeunique_seq_0[mu].write_tran),mu, makeunique_seq_0[mu].write_tran.hn_node_idx, makeunique_seq_0[mu].write_tran.tgt_id));

         `svt_xvm_verbose("body", $sformatf("MakeUnique transaction [%0d]  is %0s", mu,makeunique_seq_0[mu].write_tran.sprint()));
      end 

      /** Initiating outstanding CopyBack transactions from different Random RN-F.  
       *  Initial cache line state is:
       *   UD :  svt_chi_transaction::WRITEBACKFULL  
       *         svt_chi_transaction::WRITEBACKPTL  
       *         svt_chi_transaction::WRITECLEANFULL  
       *         svt_chi_transaction::WRITECLEANPTL 
       */
      for(int j = 0; j < NUM_OUTSTANDING_XACT/2; j++) begin
        automatic int initiating_rn_index;

        fork
          begin
            automatic bit[`SVT_CHI_MAX_ADDR_WIDTH -1:0] txn_addr;                                      
            automatic bit txn_is_non_secure_access;
            automatic bit[(`SVT_CHI_TXN_ID_WIDTH-1):0]txn_id;
            txn_addr = rn_f_node_idx_1_copyback_addr_queue.pop_front();
            txn_is_non_secure_access = rn_f_node_idx_1_copyback_non_secure_queue.pop_front();
            txn_id = rn_f_node_idx_1_txn_id_queue.pop_front();
            
            `svt_xvm_do_on_with(copyback_seq[j], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,{
              sequence_length == 1;
              seq_txn_id == txn_id;
              seq_xact_type inside {svt_chi_transaction::WRITEBACKFULL,svt_chi_transaction::WRITEBACKPTL,svt_chi_transaction::WRITECLEANFULL,svt_chi_transaction::WRITECLEANPTL};
              seq_order_type  == svt_chi_transaction::NO_ORDERING_REQUIRED;
              seq_copyback_req_order_enable == 0;                                          
              hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
              min_addr           == txn_addr;
              max_addr           == txn_addr;     
              seq_is_non_secure_access == txn_is_non_secure_access;
              use_seq_is_non_secure_access == 1;       
              })
            `svt_xvm_debug("body", $sformatf("%0s Transmitting CopyBack Transaction [%0d] targeted to HN (idx %0d, id %0d)",`SVT_CHI_PRINT_PREFIX(copyback_seq[j].copyback_tran),j, copyback_seq[j].copyback_tran.hn_node_idx, copyback_seq[j].copyback_tran.tgt_id));
            `svt_xvm_verbose("body", $sformatf("CopyBack Transaction [%0d] is %0s", j,copyback_seq[j].copyback_tran.sprint()));
        end//begin
          begin
            automatic bit[`SVT_CHI_MAX_ADDR_WIDTH -1:0] txn_addr;                                      
            automatic bit txn_is_non_secure_access;
            automatic bit[(`SVT_CHI_TXN_ID_WIDTH-1):0]txn_id;
            txn_addr = rn_f_node_idx_0_copyback_addr_queue.pop_front();
            txn_is_non_secure_access = rn_f_node_idx_0_copyback_non_secure_queue.pop_front();
            txn_id = rn_f_node_idx_0_txn_id_queue.pop_front();
            `svt_xvm_do_on_with(copyback_seq[((NUM_OUTSTANDING_XACT/2) + j)], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,{
              sequence_length == 1;
              seq_txn_id == txn_id;
              seq_xact_type inside {svt_chi_transaction::WRITEBACKFULL,svt_chi_transaction::WRITEBACKPTL,svt_chi_transaction::WRITECLEANFULL,svt_chi_transaction::WRITECLEANPTL};
              seq_order_type  == svt_chi_transaction::NO_ORDERING_REQUIRED;
              seq_copyback_req_order_enable == 0;                                          
              hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
              min_addr           == txn_addr;
              max_addr           == txn_addr;     
              seq_is_non_secure_access == txn_is_non_secure_access;
              use_seq_is_non_secure_access == 1;       
              })
            `svt_xvm_debug("body", $sformatf("%0s Transmitting CopyBack Transaction [%0d] targeted to HN (idx %0d, id %0d)",`SVT_CHI_PRINT_PREFIX(copyback_seq[((NUM_OUTSTANDING_XACT/2) + j)].copyback_tran),((NUM_OUTSTANDING_XACT/2) + j), copyback_seq[((NUM_OUTSTANDING_XACT/2) + j)].copyback_tran.hn_node_idx, copyback_seq[((NUM_OUTSTANDING_XACT/2) + j)].copyback_tran.tgt_id));
            `svt_xvm_verbose("body", $sformatf("CopyBack Transaction [%0d] is %0s", ((NUM_OUTSTANDING_XACT/2) + j),copyback_seq[((NUM_OUTSTANDING_XACT/2) + j)].copyback_tran.sprint()));
          end//begin
        join       
      end//forloop of CopyBack

      /** Checking for the reception of all the CompDBIDResp from the Interconnect */
      foreach(copyback_seq[index_1]) begin
        fork
            automatic int _index_1 = index_1;
          begin
          `svt_xvm_debug("body", $sformatf("%0s CopyBack transaction [%0d] targeted to HN (idx %0d, id %0d), suspend_wr_data %0b: waiting for response from interconnect",`SVT_CHI_PRINT_PREFIX(copyback_seq[_index_1].copyback_tran),_index_1, copyback_seq[_index_1].copyback_tran.hn_node_idx, copyback_seq[_index_1].copyback_tran.tgt_id,copyback_seq[_index_1].copyback_tran.suspend_wr_data));
            
            //Wait until a CompDBIDResp/RetryAck is received for the generated Copybacks
            fork
            begin
              fork
                begin
                  copyback_seq[_index_1].copyback_tran.wait_for_tx_data_prereqs();
                end
                begin
                  wait(copyback_seq[_index_1].copyback_tran.req_status == svt_chi_transaction::RETRY);// begin
                end
              join_any
              disable fork;
            end
            join
            received_copyback_responses++;
            
            `svt_xvm_debug("body", $sformatf("%0s CopyBack transaction [%0d] targeted to HN (idx %0d, id %0d), suspend_wr_data %0b: waiting for response from interconnect. Total responses received %0d",`SVT_CHI_PRINT_PREFIX(copyback_seq[_index_1].copyback_tran),_index_1, copyback_seq[_index_1].copyback_tran.hn_node_idx, copyback_seq[_index_1].copyback_tran.tgt_id,copyback_seq[_index_1].copyback_tran.suspend_wr_data, received_copyback_responses));
          end
        join_none  
      end
     
      `svt_xvm_debug("body", $sformatf(" Waiting for the CompDBIDResp from HN to Resume the Suspended Response of Copyback transactions "));
      /** Waiting for the CompDBIDResp from HN to Resume the Suspended Response of all above Copyback transactions */ 
      wait(received_copyback_responses == NUM_OUTSTANDING_XACT); 
      
      /** Self Check1: To check suspend_wr_data should not be modified to zero by the VIP
       *  before reseting from test bench.
       */
      foreach (copyback_seq[self_check_idx1]) begin
        if(!copyback_seq[self_check_idx1].copyback_tran.is_terminated()) begin 
          if (copyback_seq[self_check_idx1].copyback_tran.suspend_wr_data == 0) begin
            `svt_xvm_error("body", $sformatf("%0s suspend_wr_data should be 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(copyback_seq[self_check_idx1].copyback_tran)));
          end
          else begin
            `svt_xvm_debug("body", $sformatf("%0s suspend_wr_data is 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(copyback_seq[self_check_idx1].copyback_tran)));
          end
        end  
      end

      /** Self Check2: To check transaction is not ended by the VIP before resuming the 
       *  suspend_wr_data to zero from the test bench<br>
       */
      foreach (copyback_seq[self_check_idx2]) begin
        if(!copyback_seq[self_check_idx2].copyback_tran.is_terminated()) begin 
          /** Fail  event has triggered */
          if (copyback_seq[self_check_idx2].copyback_tran.end_event.is_on() == 1) begin
            `svt_xvm_error("body", $sformatf("Unexpected: %0s Transaction's end_event triggered when suspend_wr_data is still 1.", `SVT_CHI_PRINT_PREFIX(copyback_seq[self_check_idx2].copyback_tran)));
          end
          /** Pass  event is not triggered */
          else begin
            `svt_xvm_debug("body", $sformatf("Expected: %0s Transaction's end_event is not triggered when suspend_wr_data is still 1.", `SVT_CHI_PRINT_PREFIX(copyback_seq[self_check_idx2].copyback_tran)));
          end
        end
      end
 
      /** Self Check 3: To check that the current_outstanding_*_xact_count in the RNs
       * are as per the transactions inititated by the sequence
       */
      /** Check if the total outstanding xact counter is set correctly in the shared status of the RN agent */
      if(copyback_seq[0].shared_status.prot_status.current_outstanding_xact_count != NUM_OUTSTANDING_XACT/2)
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding transactions from the sequence but the outstanding transaction count in the shared status of RN%0d is %0d", NUM_OUTSTANDING_XACT/2, initiating_rn_node_idx_0, copyback_seq[0].shared_status.prot_status.current_outstanding_xact_count));
      /** Check if the outstanding Write xact counter is set correctly in the shared status of the RN agent */
      if(copyback_seq[0].shared_status.prot_status.current_outstanding_write_xact_count != NUM_OUTSTANDING_XACT/2) begin
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding Copyback transactions from the sequence but the outstanding Write transaction count in the shared status of RN%0d is %0d", NUM_OUTSTANDING_XACT/2, initiating_rn_node_idx_0, copyback_seq[0].shared_status.prot_status.current_outstanding_write_xact_count));
      end
      /** Check if the total outstanding xact counter is set correctly in the shared status of the RN agent */
      if(copyback_seq[1].shared_status.prot_status.current_outstanding_xact_count != NUM_OUTSTANDING_XACT/2)
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding transactions from the sequence but the outstanding transaction count in the shared status of RN%0d is %0d", NUM_OUTSTANDING_XACT/2, initiating_rn_node_idx_1, copyback_seq[1].shared_status.prot_status.current_outstanding_xact_count));
      /** Check if the outstanding Write xact counter is set correctly in the shared status of the RN agent */
      if(copyback_seq[1].shared_status.prot_status.current_outstanding_write_xact_count != NUM_OUTSTANDING_XACT/2) begin
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding Copyback transactions from the sequence but the outstanding Write transaction count in the shared status of RN%0d is %0d", NUM_OUTSTANDING_XACT/2, initiating_rn_node_idx_1, copyback_seq[1].shared_status.prot_status.current_outstanding_write_xact_count));
      end

      `svt_xvm_debug("body", $sformatf("RN%0d: Number of outstanding transactions : %0d, Number of outstanding write xacts : %0d", initiating_rn_node_idx_0, copyback_seq[0].shared_status.prot_status.current_outstanding_xact_count, copyback_seq[0].shared_status.prot_status.current_outstanding_write_xact_count));
      `svt_xvm_debug("body", $sformatf("RN%0d: Number of outstanding transactions : %0d, Number of outstanding write xacts : %0d", initiating_rn_node_idx_1, copyback_seq[1].shared_status.prot_status.current_outstanding_xact_count, copyback_seq[1].shared_status.prot_status.current_outstanding_write_xact_count));

      /** Resuming the Suspended Response of all above Copyback transactions  */
      foreach(copyback_seq[wr]) begin
        `svt_xvm_debug("body",$sformatf("Received responses for all Copyback type transactions from interconnect, resuming the transactions by setting svt_chi_rn_transaction::suspend_wr_data set to 0 %0s",`SVT_CHI_PRINT_PREFIX(copyback_seq[wr].copyback_tran)));
        copyback_seq[wr].copyback_tran.suspend_wr_data=0; 
        `svt_xvm_debug("body", $sformatf("For iteration %0d : After Resume, received_cmo_responses is %0d,suspend_wr_data is %0b", wr,received_copyback_responses,copyback_seq[wr].copyback_tran.suspend_wr_data));
      end

      `svt_xvm_debug("body",$sformatf("Waiting for completion of all the outstanding copyback type transactions"));
      /** Waiting for above Copyback outstanding transactions to complete */ 
      foreach(copyback_seq[index_5]) begin
        `svt_xvm_debug("body", $sformatf("Waiting for above copyback[%0d] transaction %0s to end", index_5, `SVT_CHI_PRINT_PREFIX(copyback_seq[index_5].copyback_tran)));
        copyback_seq[index_5].copyback_tran.wait_end(); 
        /** Self Check4: To check suspend_wr_data should not be asserted after
         * the transaction completes as it is reseted from test bench
         */
        if(!copyback_seq[index_5].copyback_tran.is_terminated()) begin 
          if (copyback_seq[index_5].copyback_tran.suspend_wr_data == 1) begin
            `svt_xvm_error("body", $sformatf("%0s suspend_wr_data  should be 0 as it should be reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(copyback_seq[index_5].copyback_tran)));
          end
          else begin
            `svt_xvm_debug("body", $sformatf("%0s suspend_wr_data is 0 as it is reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(copyback_seq[index_5].copyback_tran)));
          end
        end
      end

      // Targetted HN IDs from both RNs should be different. This check is currently enabled only when
      // the number of outstanding transactions to be issued to an HN is a multiple of 4,ie, NUM_OUTSTANDING_XACT is a multiple of 8
      if((NUM_OUTSTANDING_XACT % 8) == 0) begin
        for(int i = 0; i<NUM_OUTSTANDING_XACT/2; i++)begin
          int hn_idx_0, hn_idx_1;
          hn_idx_0 = sys_cfg.get_hn_idx(copyback_seq[i].output_xacts[0].addr);
          hn_idx_1 = sys_cfg.get_hn_idx(copyback_seq[(NUM_OUTSTANDING_XACT/2) + i].output_xacts[0].addr);
          if((i < NUM_OUTSTANDING_XACT/8) || ((i >= NUM_OUTSTANDING_XACT/4) && (i < 3*NUM_OUTSTANDING_XACT/8))) begin
            if ((hn_idx_0 == hn_idx_1) && (hn_idx_0 == target_hn_node_idx_0)) begin
              `svt_xvm_debug("body", $sformatf("Targeted HN Index from both RNs are same as expected.  rn[%0d] to hn_idx[%0d], rn[%0d] to hn_idx[%0d] and they match with the target_hn_node_idx_0 %0d", initiating_rn_node_idx_0, hn_idx_0, initiating_rn_node_idx_1, hn_idx_1,target_hn_node_idx_0));
            end
            else begin
              `svt_xvm_error("body", $sformatf("Targeted HN Index from one or both of the RNs are different from first target node index, which is unexpected.  rn[%0d] %0s transaction to hn_idx[%0d], rn[%0d] %0s transaction to hn_idx[%0d] and the target_hn_node_idx_0 is %0d", initiating_rn_node_idx_0, `SVT_CHI_PRINT_PREFIX(copyback_seq[2*i].output_xacts[0]), hn_idx_0, initiating_rn_node_idx_1, `SVT_CHI_PRINT_PREFIX( copyback_seq[2*i + 1].output_xacts[0]), hn_idx_1,target_hn_node_idx_0));
            end
          end
          else if((i < NUM_OUTSTANDING_XACT/4) || ((i >= 3*NUM_OUTSTANDING_XACT/8) && (i < NUM_OUTSTANDING_XACT/2))) begin
            if ((hn_idx_0 == hn_idx_1) && (hn_idx_0 == target_hn_node_idx_1)) begin
              `svt_xvm_debug("body", $sformatf("Targeted HN Index from both RNs are same as expected.  rn[%0d] to hn_idx[%0d], rn[%0d] to hn_idx[%0d] and they match with the target_hn_node_idx_1 %0d", initiating_rn_node_idx_0, hn_idx_0, initiating_rn_node_idx_1, hn_idx_1,target_hn_node_idx_1));
            end
            else begin
              `svt_xvm_error("body", $sformatf("Targeted HN Index from one or both of the RNs are different from first target node index, which is unexpected.  rn[%0d] %0s transaction to hn_idx[%0d], rn[%0d] %0s transaction to hn_idx[%0d] and the target_hn_node_idx_1 is %0d", initiating_rn_node_idx_0,`SVT_CHI_PRINT_PREFIX(copyback_seq[2*i].output_xacts[0]),hn_idx_0, initiating_rn_node_idx_1, `SVT_CHI_PRINT_PREFIX(copyback_seq[2*i + 1].output_xacts[0]),hn_idx_1,target_hn_node_idx_1));
            end
          end
        end
      end

      /** Empty the address ,RN-F's and txn_id queues */
      rn_f_node_idx_0_copyback_addr_queue.delete();
      rn_f_node_idx_1_copyback_addr_queue.delete();
      rn_f_node_idx_0_copyback_non_secure_queue.delete();
      rn_f_node_idx_1_copyback_non_secure_queue.delete();
      rn_f_node_idx_0_txn_id_queue.delete();
      rn_f_node_idx_1_txn_id_queue.delete();    
      initiating_rn_f_node_idx_1_queue.delete();  
      initiating_rn_f_node_idx_0_queue.delete();

      /** Reset received_copyback_responses to Zero */
      received_copyback_responses = 0;

    end//forloop of sequence_length
    /** 
     * To check the Interconnect HN's shall responds properly for all outstanding
     *CopyBack transactions to particular RN.<br>
     * Check done by System monitor(List of checkers)<br>
     *  #- copyback_data_integrity_check 
     *  .  
     */
    `svt_xvm_debug("body", "Exiting...")
  endtask: body

  //-----------------------------------------------------------------------------
  virtual task post_start();
    super.post_start();
    drop_phase_objection();
  endtask

endclass: svt_chi_system_protocol_flow_ctrl_copyback_outstanding_diff_rn_diff_hn_virtual_sequence

//===============================================================================
function svt_chi_system_protocol_flow_ctrl_copyback_outstanding_diff_rn_diff_hn_virtual_sequence::new(string name="svt_chi_system_protocol_flow_ctrl_copyback_outstanding_diff_rn_diff_hn_virtual_sequence");
  super.new(name);
endfunction


/////////////////////////////
// CMO type
/////////////////////////////

//====================================================================================
/** 
 * @groupname CHI_OUTSTANDING_CMO_TYPE
 * #- This sequence requires at least one HN node to be present in the Interconnect. <br>
 * #- This sequence requires one initiating active and participating RN. <br>
 * #- If another active and participating RN-F exists, perform cache <br>
 *    initialization to a randomly selected HN. <br>
 * #- Initiate maximum number of CMO type transactions with <br>
 *    svt_chi_rn_transaction::suspend_comp_ack set  to 1 from initiating RN to randomly <br>
 *    selected HN in non blocking mode. <br>
 *    - Maximum number of outstanding transactions at the HN is as per either
 *      #max_num_outstanding_cmo_xacts_at_hn or #max_num_outstanding_xacts_at_hn, which can be controlled through config DB.   
 *    - This ensures that the maximum outstanding transaction limit is reached at the HN. <br> 
 *    - Also, the RN will not transmit CompAck corresponding to these transactions <br>
 *      until svt_chi_rn_transaction::suspend_comp_ack is set to 0 from the seqeunce. <br>
 *    .
 * #- The addresses of these CMO transactions are such that: <br>
 *    - Same as initialized cache line addresses if cache initialization is performed <br>
 *    - Otherwise, random addresses targeting the same HN <br>
 *    .
 * #- Once the RN receives the responses for all the outstanding transactions from <br>
 *    HN, svt_chi_rn_transaction::suspend_comp_ack is set to 0 for all the outstanding <br>
 *    transactions. <br>
 *    This ensures that the CompAck for these transactions can be resumed <br>
 *    from RN. <br>
 * #- Check that the HN responds properly for all outstanding CMO type transactions <br>
 *    and these are completed successfully. <br>
 * .
 */ 

class svt_chi_system_protocol_flow_ctrl_cmo_outstanding_same_rn_same_hn_virtual_sequence extends svt_chi_system_base_virtual_sequence;

  //-----------------------------------------------------------------------------  
  // Member attributes
  //-----------------------------------------------------------------------------  
  /** Parameter that controls the enabling of transactions in non-blocking mode from the sequence */
  bit enable_outstanding = 0;

  /** To display contents of Active Participating RN's nodes info. */
  string str_rn_node;

  /** To display contents of Active Participating RN-F's nodes info. */
  string str_rn_f_node;

  /** UVM/OVM Object Utility macro */
  `svt_xvm_object_utils(svt_chi_system_protocol_flow_ctrl_cmo_outstanding_same_rn_same_hn_virtual_sequence)

  //-----------------------------------------------------------------------------  
  // Methods
  //-----------------------------------------------------------------------------
  /** Constructor */
  extern function new(string name="svt_chi_system_protocol_flow_ctrl_cmo_outstanding_same_rn_same_hn_virtual_sequence"); 

  /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- Minimum required number of supporting request nodes = 1
   *  #- Minimum required number of HN nodes = 1   
   *  .
   */
  //-----------------------------------------------------------------------------  
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    
    /** local variables */
    int num_supporting_request_nodes;
    int num_hn_f_nodes;   
    int array_idx;
    bit is_rn_idx_0_participating;
    string str_is_supported_info_prefix = "";
    string str_is_supported_info = "";
    string str_idx0_info = "";
    /** Supporting any type of Request Nodes required */
    int required_num_supporting_request_nodes = 1;
    int required_num_hn_nodes = 1;
    
    `svt_xvm_debug("is_supported",$sformatf("Entering ..."));

    /** By default is_supported is 0 */
    is_supported = 0;

    /** Check for minimum required HN nodes */
    num_hn_f_nodes = hn_f_nodes.size();
    
    /** Check requirment of number of HN nodes needed */
    if (num_hn_f_nodes < required_num_hn_nodes) begin
      issue_is_supported_failure($sformatf("This sequence requires minimum %0d HN-F nodes to be present in the system. Number of HN-F nodes are %0d. Program number of HN nodes using svt_chi_system_configuration::num_hn. Program the HN interface type using svt_chi_system_configuration::chi_addr_cfg.hn_interface_type[].", required_num_hn_nodes, num_hn_f_nodes));
      return 0;      
    end

    /** Check for minimum required RN nodes.
     *  Also check whether the selected RN nodes are part of participating arrays or not.
     */    
    num_supporting_request_nodes = active_participating_rn_nodes.size();

    /** Check the requirements of RN nodes */
    if (num_supporting_request_nodes) begin
      /** Display the contents of Active Participating RN Nodes */
      foreach (active_participating_rn_nodes[j]) begin
        str_rn_node = {str_rn_node, $sformatf(" %0d", active_participating_rn_nodes[j])};
      end 
      `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_nodes are %0s", str_rn_node));
    end

    /** Display the contents of Active Participating RN-F Nodes */
    foreach (active_participating_rn_f_nodes[j]) begin
      str_rn_f_node = {str_rn_f_node, $sformatf(" %0d", active_participating_rn_f_nodes[j])};
    end 
    `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_f_nodes are %0s", str_rn_f_node));

    str_is_supported_info_prefix = $sformatf("Number of Supporting RN Node(s)  - Minimum Required : %0d Current : %0d", required_num_supporting_request_nodes, num_supporting_request_nodes);
    
    if ((initiating_rn_node_index_0_status==0)&&(valid_initiating_rn_node_index_0==0)) begin
        str_idx0_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN's that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F or RN_I)";
    end
    else begin
      is_rn_idx_0_participating = is_value_found_in_int_assoc_array(active_participating_rn_nodes, initiating_rn_node_idx_0, array_idx);
      if (!is_rn_idx_0_participating) begin
        str_idx0_info = $sformatf("initiating_rn_node_idx_0 %0d is not valid for this sequence. The RN corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuration::participating_rn_nodes[])", initiating_rn_node_idx_0, initiating_rn_node_idx_0);
      end
    end
    if (is_rn_idx_0_participating) begin
      is_supported = 1;
      if(max_num_outstanding_cmo_xacts_at_hn > 0) begin
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].num_outstanding_cmo_xact < max_num_outstanding_cmo_xacts_at_hn) begin
          str_idx0_info = $sformatf("Programmed value of max_num_outstanding_cmo_xacts_at_hn_status is %0d. But num_outstanding_cmo_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_cmo_xact of the initiating RN node must be equal to or greater than max_num_outstanding_cmo_xacts_at_hn_status of the target HN", max_num_outstanding_cmo_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_0_participating].num_outstanding_cmo_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
      end else begin
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].num_outstanding_xact < max_num_outstanding_xacts_at_hn) begin
          str_idx0_info = $sformatf("Programmed value of max_num_outstanding_xacts_at_hn_status is %0d. But num_outstanding_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_xact of the initiating RN node must be equal to or greater than max_num_outstanding_xacts_at_hn of the target HN", max_num_outstanding_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_0_participating].num_outstanding_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
      end
    end
    
`ifdef SVT_CHI_ISSUE_B_ENABLE
   /*******************************************************************
    * According to the specfication version ARM IHI 0050B exp_comp_ack is always
    * programmed to zero for all the CMO transactions.So this sequence is not
    * applicable when macro `SVT_CHI_ISSUE_B_ENABLE macro is defined.
    *
    *****************************************************************
    */    
    is_supported = 0;
`endif    

    if (!is_supported) begin
`ifdef SVT_CHI_ISSUE_B_ENABLE
      issue_is_supported_failure($sformatf("This sequence cannot be run based on the current system configuration.\n\
                                            when macro SVT_CHI_ISSUE_B_ENABLE or SVT_CHI_ISSUE_C_ENABLE is defined \n\
                                            Modify configurations through \n\
                                            svt_chi_node_configuration::chi_spec_revision::ISSUE_A \n\
                                            "));
`else
      str_is_supported_info = $sformatf("%0s",str_idx0_info);
      if (is_rn_idx_0_participating) begin
        issue_is_supported_failure($sformatf("This sequence cannot be run based on the current system configuration.\n\
                                              %0s\n\
                                              %0s \n\
                                              Modify configurations through \n\
                                              svt_chi_system_configuration::num_rn,\n\
                                              svt_chi_node_configuration::is_active,\n\
                                              svt_chi_system_configuration::participating_rn_nodes[]\n\
                                              ", str_is_supported_info_prefix, str_is_supported_info));
      end
      else begin
        issue_is_supported_failure($sformatf("This sequence cannot be run based on the current node configurations of RN%0d\n\
                                              %0s \n\
                                              Modify configuration through \n\
                                              svt_chi_node_configuration::num_outstanding_xact,\n\
                                              svt_chi_node_configuration::num_outstanding_cmo_xact,\n\
                                              ",str_is_supported_info, initiating_rn_node_idx_0));
      end
`endif      
    end      
    `svt_xvm_debug("is_supported",$sformatf("Exiting ..."));
    if (!is_target_hn_idx_valid_for_curr_cfg()) begin
      is_supported = 0;
      `svt_xvm_note("is_supported", "not a valid hn_idx based on random_tgt_id_enable for current cfg");
    end
  endfunction : is_supported

  //-----------------------------------------------------------------------------
  virtual task pre_start();
    bit enable_outstanding_status;
    `svt_xvm_debug("pre_start",$sformatf("Entering ..."));
    super.pre_start();
    raise_phase_objection();
    enable_outstanding_status = uvm_config_db#(bit)::get(m_sequencer, get_type_name(), "enable_outstanding", enable_outstanding);
    `svt_xvm_debug("body", $sformatf("enable_outstanding is %0b as a result of %0s", enable_outstanding, (enable_outstanding_status?"config DB":"default setting")));
    `svt_xvm_debug("pre_start",$sformatf("Exiting ..."));
  endtask // pre_start

  //-----------------------------------------------------------------------------  
  virtual task body();
    int received_cmo_responses;
    /** Queue of addresses, used by the transactions generated */
    bit[`SVT_CHI_MAX_ADDR_WIDTH -1:0]  addr_collection_queue[$];
    bit seq_is_non_secure_access_queue[$];
    /** Flag to track whether cache initialization needs to be performed or not*/
    bit                                perform_cache_initialization;

    int                                num_outstanding_xacts_to_generate;
    int                                array_idx;

    /** Sub CMO type transaction directed sequences initiated from this sequence */
    svt_chi_rn_cmo_type_transaction_directed_sequence cmo_seq[int];
   
    /** Sub Read type transaction cache initialization directed sequences initiated from this sequence */
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq[int];

    `svt_xvm_debug("body", "Entering ...");
    super.body();

    max_num_outstanding_xacts_at_hn_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(), "max_num_outstanding_xacts_at_hn", max_num_outstanding_xacts_at_hn);
    max_num_outstanding_cmo_xacts_at_hn_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(), "max_num_outstanding_cmo_xacts_at_hn", max_num_outstanding_cmo_xacts_at_hn);
    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :initiating_rn_node_index_0;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_node_index_0;

    `svt_xvm_debug("body", $sformatf("max_num_outstanding_xacts_at_hn is %0d as a result of %0s.", max_num_outstanding_xacts_at_hn, max_num_outstanding_xacts_at_hn_status ? "config DB" : "default"));
    `svt_xvm_debug("body", $sformatf("max_num_outstanding_cmo_xacts_at_hn is %0d as a result of %0s.", max_num_outstanding_cmo_xacts_at_hn, max_num_outstanding_cmo_xacts_at_hn_status ? "config DB" : "default"));
    `svt_xvm_debug("body", $sformatf("initiating_rn_node_idx_0 is %0d as a result of %0s.", initiating_rn_node_idx_0, initiating_rn_node_index_0_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("target_hn_node_idx_0 is %0d as a result of %0s.", target_hn_node_idx_0, target_hn_node_index_0_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("perform_cache_initialization is %0b, cache_line_init_rn_f_node_index is %0d, initiating_rn_node_idx_0 is %0d", perform_cache_initialization, cache_line_init_rn_f_node_index, initiating_rn_node_idx_0)); 

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end
    /**
     * If the cache_line_init_rn_f_node_index is same as the RN node index 
     * which are passed through config i.e initiating_rn_node_idx_0,
     * then re-assign the cache_line_init_rn_f_node_index with RN node index ,which is active,
     * participating and not equal to initiating_rn_node_idx_0.
     */
    if(initiating_rn_node_index_0_status)begin  
      if(cache_line_init_rn_f_node_index == initiating_rn_node_idx_0)begin  
        int active_participating_q [$];
        `svt_chi_xxm_debug("body",$sformatf("cache_line_init_rn_f_node_index= %0d is same as initiating_rn_node_idx_0=%0d active_participating_rn_f_nodes.size()= %0d",cache_line_init_rn_f_node_index,initiating_rn_node_idx_0,active_participating_rn_f_nodes.size()));
        if(active_participating_rn_f_nodes.size()>1)begin
          active_participating_q = active_participating_rn_f_nodes.find with (item != initiating_rn_node_idx_0);
          cache_line_init_rn_f_node_index = active_participating_q.pop_back();
          `svt_chi_xxm_debug("body", $sformatf("active_participating_q.size() is %0d and Selected different cache_line_init_rn_f_node_index=%0d", active_participating_q.size(),cache_line_init_rn_f_node_index));
          active_participating_q.delete();
        end else begin
          perform_cache_initialization=0;
          `svt_chi_xxm_debug("body",$sformatf("BYPASSING Cache Initialization as selected cache_line_init_rn_f_node_index= %0d is same as initiating_rn_node_index_0_from_config_db=%0d and active_participating_rn_f_nodes.size()= %0d",cache_line_init_rn_f_node_index,initiating_rn_node_index_0_from_config_db,active_participating_rn_f_nodes.size()));
        end
      end  
    end 

    /**
     * If the cache_line_init_rn_f_node_index is part of active_participating_rn_f_nodes array, and
     * it is not equal to initiating_rn_node_idx_0; then we can
     * perform cache initialization from the RN[cache_line_init_rn_f_node_index].
     */
    if ((is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, cache_line_init_rn_f_node_index, array_idx)) &&
        (cache_line_init_rn_f_node_index != initiating_rn_node_idx_0)) begin
      perform_cache_initialization = 1;
    end
   
    `svt_xvm_debug("body", $sformatf("perform_cache_initialization is %0b, cache_line_init_rn_f_node_index is %0d, initiating_rn_node_idx_0 is %0d", perform_cache_initialization, cache_line_init_rn_f_node_index, initiating_rn_node_idx_0));    

    //If max outstanding count for CMO transactions has been programmed, use that to generate the outstanding CMOs
    if(max_num_outstanding_cmo_xacts_at_hn > 0) begin
      num_outstanding_xacts_to_generate = max_num_outstanding_cmo_xacts_at_hn;
      `svt_xvm_debug("body",$sformatf("max_num_outstanding_cmo_xacts_at_hn is set to a non-zero value (%0d). Hence, the value programmed in max_num_outstanding_xacts_at_hn will be ignored. The number of outstanding transactions issued by the sequence will be equal to max_num_outstanding_cmo_xacts_at_hn", max_num_outstanding_cmo_xacts_at_hn));
    end
    //If not, use the max outstanding transaction count
    else
      num_outstanding_xacts_to_generate = max_num_outstanding_xacts_at_hn;
    
    for(int i = 0; i < sequence_length; i++) begin
      
      /** Following sequences will be executed based on configuration of RN Nodes */ 
      if(perform_cache_initialization) begin
        `svt_xvm_debug("body",$sformatf("Starting cache initialization for %0d addresses from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d",
                                        num_outstanding_xacts_to_generate, cache_line_init_rn_f_node_index, target_hn_node_idx_0));
        /** 
         * Write data into Cache of Randomly selected Second Request Node i.e RN-F with address of randomly
         * selected HN Node
         */
        for(int j=0; j<num_outstanding_xacts_to_generate; j++) begin
          `svt_xvm_do_on_with(makeunique_seq[j], p_sequencer.rn_virt_seqr[cache_line_init_rn_f_node_index].rn_xact_seqr,{
            sequence_length    == 1;
            set_unique_addr_value    == 1;
            hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
            seq_hn_node_idx    == target_hn_node_idx_0;
            use_seq_is_non_secure_access == 0;
          })

          /** Waiting for above MakeUnique transaction to complete */ 
          `svt_xvm_debug("body", $sformatf("%0s Waiting for MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) to end",`SVT_CHI_PRINT_PREFIX(makeunique_seq[j].write_tran),j, makeunique_seq[j].write_tran.hn_node_idx, makeunique_seq[j].write_tran.tgt_id));
          makeunique_seq[j].write_tran.wait_end();
          `svt_xvm_debug("body", $sformatf("%0s MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) ended",`SVT_CHI_PRINT_PREFIX(makeunique_seq[j].write_tran),j, makeunique_seq[j].write_tran.hn_node_idx, makeunique_seq[j].write_tran.tgt_id));

          `svt_xvm_verbose("body", $sformatf("MakeUnique transaction [%0d]  is %0s", j,makeunique_seq[j].write_tran.sprint()));
        end //forloop of MakeUnique 

        /** Retrieving addresses from output transactions generated by the sequence  */
        foreach(makeunique_seq[index2]) begin
          addr_collection_queue.push_back(makeunique_seq[index2].output_xacts[0].addr);
          seq_is_non_secure_access_queue.push_back(makeunique_seq[index2].output_xacts[0].is_non_secure_access);
        end
        `svt_xvm_debug("body",$sformatf("Ended cache initialization for %0d addresses from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d",
                                        num_outstanding_xacts_to_generate, cache_line_init_rn_f_node_index, target_hn_node_idx_0));

      end // if (perform_cache_initialization)

      `svt_xvm_debug("body",$sformatf("Starting transmission of CMO type transactions for %0d addresses from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d with suspend_comp_ack set to 1",
                                      num_outstanding_xacts_to_generate, initiating_rn_node_idx_0, target_hn_node_idx_0));

      /** 
       * Randomly selected First RN fires any CMO transactions with above
       * MakeUnique transaction address/randomly selected HN node,
       * depending on whetehr cache initialization is done or not
       */
      for(int k=0; k<num_outstanding_xacts_to_generate; k++) begin
        `svt_xvm_do_on_with(cmo_seq[k], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,{
          sequence_length    == 1;
          `ifdef SVT_CHI_ISSUE_E_ENABLE
           if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision >= svt_chi_node_configuration::ISSUE_E) {
            seq_txn_id         == (k*3);
           }
           else{
            seq_txn_id         == (k % num_outstanding_xacts_to_generate);
           }
          `else
            seq_txn_id         == (k % num_outstanding_xacts_to_generate);
          `endif
          if (perform_cache_initialization)
          {
            hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
            min_addr           == addr_collection_queue[k];
            max_addr           == addr_collection_queue[k];
            seq_is_non_secure_access == seq_is_non_secure_access_queue[k]; 
            use_seq_is_non_secure_access == 1;
          }
          else
          {
            hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
            seq_hn_node_idx    == target_hn_node_idx_0;
            use_seq_is_non_secure_access == 0;
          }
          `ifdef SVT_CHI_ISSUE_B_ENABLE
            if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) 
              {
                !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSIST, svt_chi_transaction::STASHONCEUNIQUE,svt_chi_transaction::STASHONCESHARED});
              }
              `ifdef SVT_CHI_ISSUE_E_ENABLE
              else if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision < svt_chi_node_configuration::ISSUE_E){
                !(seq_xact_type inside {svt_chi_transaction::STASHONCESEPUNIQUE, svt_chi_transaction::STASHONCESEPSHARED});
                if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision < svt_chi_node_configuration::ISSUE_D){
                  !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                  if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0)
                    !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                }
                else if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision >= svt_chi_node_configuration::ISSUE_D){
                  if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].cleansharedpersistsep_xact_enable ==0)
                    !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                  if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0)
                    !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                }
              }
              else if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision >= svt_chi_node_configuration::ISSUE_E){
                if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].cleansharedpersistsep_xact_enable == 0)
                  !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0)
                  !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED,svt_chi_transaction::STASHONCESEPUNIQUE, svt_chi_transaction::STASHONCESEPSHARED});
              }
            `elsif SVT_CHI_ISSUE_D_ENABLE
              else if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision < svt_chi_node_configuration::ISSUE_D){
                !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0)
                  !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
              }
              else if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision >= svt_chi_node_configuration::ISSUE_D){
                if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].cleansharedpersistsep_xact_enable ==0)
                  !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0){
                  !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                }
              }
              `endif //issue_d_enable
            else if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0){
                !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
              }
          `endif
        })
        `svt_xvm_debug("body", $sformatf("%0s Transmitting CMO Transaction [%0d] targeted to HN (idx %0d, id %0d) ",`SVT_CHI_PRINT_PREFIX(cmo_seq[k].cmo_tran),k, cmo_seq[k].cmo_tran.hn_node_idx, cmo_seq[k].cmo_tran.tgt_id));
        `svt_xvm_verbose("body", $sformatf("CMO Transaction [%0d] is %0s", k,cmo_seq[k].cmo_tran.sprint()));
      end //forloop of CMO

      /** Checking for the reception of all the CMO responses from the Interconnect */
      foreach(cmo_seq[index3]) begin
        fork
          automatic int _index3 = index3;
          begin
                `svt_xvm_debug("body", $sformatf("%0s CMO transaction [%0d] targeted to HN (idx %0d, id %0d), suspend_comp_ack %0b: waiting for response from interconnect",`SVT_CHI_PRINT_PREFIX(cmo_seq[_index3].cmo_tran),_index3, cmo_seq[_index3].cmo_tran.hn_node_idx, cmo_seq[_index3].cmo_tran.tgt_id,cmo_seq[_index3].cmo_tran.suspend_comp_ack));
            fork
            begin
              fork
                begin
                  cmo_seq[_index3].cmo_tran.wait_for_tx_compack_prereqs();
                end
                begin
                  wait(cmo_seq[_index3].cmo_tran.req_status == svt_chi_transaction::RETRY);// begin
                end
              join_any
              disable fork;
            end
            join
            received_cmo_responses++;
                      `svt_xvm_debug("body", $sformatf("%0s CMO transaction [%0d] targeted to HN (idx %0d, id %0d), suspend_comp_ack %0b: received response from interconnect. Total responses received %0d",`SVT_CHI_PRINT_PREFIX(cmo_seq[_index3].cmo_tran),_index3, cmo_seq[_index3].cmo_tran.hn_node_idx, cmo_seq[_index3].cmo_tran.tgt_id,cmo_seq[_index3].cmo_tran.suspend_comp_ack, received_cmo_responses));    
          end
        join_none
      end  

      /** Wait until All Comp responses are received at RN's */
      `svt_xvm_debug("body",$sformatf("Completed initiation of  CMO type transactions for %0d addresses from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d with suspend_comp_ack set to 1, and waiting to receive responses from interconnect.",
                                num_outstanding_xacts_to_generate, initiating_rn_node_idx_0, target_hn_node_idx_0));      
      wait(received_cmo_responses == num_outstanding_xacts_to_generate);
      outstanding_xact_count_reached = 1;
      `svt_xvm_debug("body",$sformatf("Received responses from interconnect to CMO type transactions for %0d addresses from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d with suspend_comp_ack set to 1",
                                      num_outstanding_xacts_to_generate, initiating_rn_node_idx_0, target_hn_node_idx_0));

      /** Self Check1: To check suspend_comp_ack should not be modified to zero by the VIP 
       *  before reseting from test bench.
       */ 
      foreach (cmo_seq[self_check_idx1]) begin
        if (!cmo_seq[self_check_idx1].cmo_tran.is_terminated()) begin
          if (cmo_seq[self_check_idx1].cmo_tran.suspend_comp_ack == 0) begin
            `svt_xvm_error("body", $sformatf("%0s suspend_comp_ack should be 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(cmo_seq[self_check_idx1].cmo_tran)));
          end
          else begin
            `svt_xvm_debug("body", $sformatf("%0s suspend_comp_ack is 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(cmo_seq[self_check_idx1].cmo_tran)));
          end
        end  
      end

      /** Self Check2: To check transaction is not ended by the VIP before resuming the 
       *  suspend_comp_ack to zero from the test bench 
       */ 
      foreach(cmo_seq[self_check_idx2]) begin
        if (!cmo_seq[self_check_idx2].cmo_tran.is_terminated()) begin
          if (cmo_seq[self_check_idx2].cmo_tran.end_event.is_on() == 1) begin
            // Fail  event has triggered
            `svt_xvm_error("body", $sformatf("Unexpected: %0s Transaction's end_event triggered when suspend_comp_ack is still 1.", `SVT_CHI_PRINT_PREFIX(cmo_seq[self_check_idx2].cmo_tran)));
          end
          else begin
            // Pass  event is not triggered
            `svt_xvm_debug("body", $sformatf("Expected: %0s Transaction's end_event is not triggered when suspend_comp_ack is still 1.", `SVT_CHI_PRINT_PREFIX(cmo_seq[self_check_idx2].cmo_tran)));
          end
        end  
      end
      
      if(use_seq_flag_to_resume_response_for_outstanding_xact) begin
        `svt_xvm_debug("body",$sformatf("Waiting for resume_response_for_outstanding_xact to be set to 1"));
        wait(resume_response_for_outstanding_xact == 1);
        `svt_xvm_debug("body",$sformatf("resume_response_for_outstanding_xact is set to 1"));
      end
 
      /** Resuming all CompAck responses of above CMO transactions */
      foreach(cmo_seq[index4]) begin
        `svt_xvm_debug("body",$sformatf("Received responses for all CMO type transactions from interconnect, resuming the transactions by setting svt_chi_rn_transaction::suspend_comp_ack set to 0 %0s",`SVT_CHI_PRINT_PREFIX(cmo_seq[index4].cmo_tran)));
        cmo_seq[index4].cmo_tran.suspend_comp_ack=0;
        `svt_xvm_debug("body", $sformatf("For iteration %0d : After Resume, received_cmo_responses is %0d,suspend_comp_ack is %b and exp_comp_ack is %b ", index4,received_cmo_responses,cmo_seq[index4].cmo_tran.suspend_comp_ack,cmo_seq[index4].cmo_tran.exp_comp_ack));
      end

      `svt_xvm_debug("body",$sformatf("Waiting for completion of all the outstanding CMO type transactions"));
      /** Waiting for above CMO outstanding transactions to complete */ 
      foreach(cmo_seq[index5]) begin
        `svt_xvm_debug("body", $sformatf("Waiting for above cmo_seq[%0d] transaction %0s to end", index5, `SVT_CHI_PRINT_PREFIX(cmo_seq[index5].cmo_tran)));
        cmo_seq[index5].cmo_tran.wait_end(); 
        
        /** Self Check3: To check suspend_comp_ack should not be asserted after the transaction completes 
         *  as it is reseted from test bench
         */
        if (!cmo_seq[index5].cmo_tran.is_terminated()) begin
          if (cmo_seq[index5].cmo_tran.suspend_comp_ack == 1) begin
            `svt_xvm_error("body", $sformatf("%0s suspend_comp_ack should be 0 as it should be reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(cmo_seq[index5].cmo_tran)));
          end
          else begin
            `svt_xvm_debug("body", $sformatf("%0s suspend_comp_ack is 0 as it is reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(cmo_seq[index5].cmo_tran)));
          end
        end
      end
      `svt_xvm_debug("body",$sformatf("Received completions for all CMO type outstanding transactions"));

      // Targeted HN ID from the RN should be same throughout 
      foreach(cmo_seq[index6]) begin
        int hn_idx_0;
        hn_idx_0 = sys_cfg.get_hn_idx(cmo_seq[index6].output_xacts[0].addr);
        if (hn_idx_0 == target_hn_node_idx_0) begin
          // pass
          `svt_xvm_debug("body", $sformatf("Targeted HN Index from the RN is same as expected.  rn[%0d] to hn_idx[%0d]", initiating_rn_node_idx_0, hn_idx_0));
        end
        else begin
          // fail
          `svt_xvm_error("body", $sformatf("Targeted HN Index from the RN is different, which is unexpected.  rn[%0d] %0s transaction to hn_idx[%0d]", 
                                           initiating_rn_node_idx_0, `SVT_CHI_PRINT_PREFIX( cmo_seq[index6].output_xacts[0]), hn_idx_0));
        end
      end

      /** Reset received_cmo_responses to Zero */
      received_cmo_responses = 0;

      /** Delete the contents of address collection queue */
      addr_collection_queue.delete();

    end//forloop of sequence_length
    /** 
     * To check the Interconnect HN shall responds properly for all outstanding
     * CMO transactions to particular RN.<br>
     * Check done by System monitor(List of checkers)<br>
     *  #- snoop_data_integrity_check 
     *  .  
     */
    `svt_xvm_debug("body", "Exiting...");
  endtask: body

  //-----------------------------------------------------------------------------  
  virtual task post_start();
    super.post_start();
    drop_phase_objection();
  endtask

endclass: svt_chi_system_protocol_flow_ctrl_cmo_outstanding_same_rn_same_hn_virtual_sequence

//-------------------------------------------------------------------------------  
function svt_chi_system_protocol_flow_ctrl_cmo_outstanding_same_rn_same_hn_virtual_sequence::new(string name="svt_chi_system_protocol_flow_ctrl_cmo_outstanding_same_rn_same_hn_virtual_sequence");
  super.new(name);
endfunction


//====================================================================================
/** 
 * @groupname CHI_OUTSTANDING_CMO_TYPE 
 * #- This sequence requires at least one HN node to be present in the Interconnect. <br>
 * #- This sequence requires two initiating active and participating RN. <br>
 * #- If another active and participating RN-F exists, perform cache <br>
 *    initialization to a randomly selected HN. <br>
 * #- Initiate #max_num_outstanding_cmo_xacts_at_hn/2 or #max_num_outstanding_xacts_at_hn/2 number of CMO type transactions with svt_chi_rn_transaction:: <br>
 *    suspend_comp_ack set  to 1 from selected initiating RN to randomly selected HN <br>
 *    in non blocking mode. <br>
 *    - Maximum number of outstanding transactions at the HN is as per
 *      #max_num_outstanding_cmo_xacts_at_hn or #max_num_outstanding_xacts_at_hn, which can be controlled through config DB.   
 *    - This ensures that the maximum outstanding transaction limit is reached at the HN. <br> 
 *    - Also, the selected RN will not transmit CompAck corresponding to these <br>
 *      transactions until svt_chi_rn_transaction::suspend_comp_ack is set to 0 from the <br>
 *      seqeunce. <br>
 *    .
 * #- The addresses of these CMO transactions are such that: <br>
 *    - Same as initialized cache line addresses if cache initialization is performed <br>
 *    - Otherwise, random addresses targeting the same HN <br>
 *    .
 * #- Once the selected RN receives the responses for all the outstanding transactions <br>
 *    from HN, svt_chi_rn_transaction::suspend_comp_ack is set to 0 for all the <br>
 *    outstanding transactions. <br>
 *    This ensures that the CompAck for these transactions can be resumed <br>
 *    from selected RN. <br>
 * #- Check that the HN responds properly for all outstanding CMO type transactions <br>
 *    and these are completed successfully. <br>
 * .
 */ 

class svt_chi_system_protocol_flow_ctrl_cmo_outstanding_diff_rn_same_hn_virtual_sequence extends svt_chi_system_base_virtual_sequence;

  //-----------------------------------------------------------------------------  
  // Member attributes
  //-----------------------------------------------------------------------------  
  /** Parameter that controls the enabling of transactions in non-blocking mode from the sequence */
  bit enable_outstanding = 0;

  /** To display contents of Active Participating RN's nodes info. */
  string str_rn_node;

  /** To display contents of Active Participating RN-F's nodes info. */
  string str_rn_f_node;

  /** UVM/OVM Object Utility macro */
  `svt_xvm_object_utils(svt_chi_system_protocol_flow_ctrl_cmo_outstanding_diff_rn_same_hn_virtual_sequence)
  
  //-----------------------------------------------------------------------------  
  // Methods
  //-----------------------------------------------------------------------------
  /** Constructor */
  extern function new(string name="svt_chi_system_protocol_flow_ctrl_cmo_outstanding_diff_rn_same_hn_virtual_sequence");

  /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- Minimum required number of supporting request nodes = 2
   *  #- Minimum required number of HN nodes = 1  
   */
  //-----------------------------------------------------------------------------  
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    
    /** local variables */
    int num_supporting_request_nodes;
    int num_hn_f_nodes;   
    int array_idx;
    bit is_rn_idx_0_participating, is_rn_idx_1_participating;
    string str_is_supported_info_prefix = "";
    string str_is_supported_info = "";
    string str_idx0_info = "";
    string str_idx1_info = "";    
    /** Supporting any type of Request Nodes required */
    int required_num_supporting_request_nodes = 2;
    int required_num_hn_nodes = 1;
    
    `svt_xvm_debug("is_supported",$sformatf("Entering ..."));

    /** By default is_supported is 0 */
    is_supported = 0;

    /** Check for minimum required HN nodes */
    num_hn_f_nodes = hn_f_nodes.size();
    
    /** Check requirment of number of HN nodes needed */ 
    if (num_hn_f_nodes < required_num_hn_nodes) begin
      issue_is_supported_failure($sformatf("This sequence requires minimum %0d HN-F nodes to be present in the system. Number of HN-F nodes are %0d. Program number of HN nodes using svt_chi_system_configuration::num_hn. Program the HN interface type using svt_chi_system_configuration::chi_addr_cfg.hn_interface_type[].", required_num_hn_nodes, num_hn_f_nodes));
      return 0;      
    end

    /** Check for minimum required RN nodes.
     *  Also check whether the selected RN nodes are part of participating arrays or not.
     */    
    num_supporting_request_nodes = active_participating_rn_nodes.size();

    /** Check the requirements of RN nodes */
    if (num_supporting_request_nodes) begin
      /** Display the contents of Active Participating RN Nodes */
      foreach (active_participating_rn_nodes[j]) begin
        str_rn_node = {str_rn_node, $sformatf(" %0d", active_participating_rn_nodes[j])};
      end 
      `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_nodes are %0s", str_rn_node));
    end

    /** Display the contents of Active Participating RN-F Nodes */
    foreach (active_participating_rn_f_nodes[j]) begin
      str_rn_f_node = {str_rn_f_node, $sformatf(" %0d", active_participating_rn_f_nodes[j])};
    end 
    `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_f_nodes are %0s", str_rn_f_node));

    str_is_supported_info_prefix = $sformatf("Number of Supporting RN Node(s)  - Minimum Required : %0d Current : %0d", required_num_supporting_request_nodes, num_supporting_request_nodes);
    
    if ((initiating_rn_node_index_0_status==0)&&(valid_initiating_rn_node_index_0==0)) begin
        str_idx0_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN's that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F or RN_I)";
    end
    else begin
      is_rn_idx_0_participating = is_value_found_in_int_assoc_array(active_participating_rn_nodes, initiating_rn_node_idx_0, array_idx);
      if (!is_rn_idx_0_participating) begin
        str_idx0_info = $sformatf("initiating_rn_node_idx_0 %0d is not valid for this sequence. The RN corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuration::participating_rn_nodes[])", initiating_rn_node_idx_0, initiating_rn_node_idx_0);
      end
    end
    if ((initiating_rn_node_index_1_status==0)&&(valid_initiating_rn_node_index_1==0)) begin
        str_idx1_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN's that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F or RN_I)";
    end
    else begin
      is_rn_idx_1_participating = is_value_found_in_int_assoc_array(active_participating_rn_nodes, initiating_rn_node_idx_1, array_idx);
      if (!is_rn_idx_1_participating) begin
        str_idx1_info = $sformatf("initiating_rn_node_idx_1 %0d is not valid for this sequence. The RN corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuration::participating_rn_nodes[])", initiating_rn_node_idx_1, initiating_rn_node_idx_1);
      end
    end

    if (is_rn_idx_0_participating && is_rn_idx_1_participating) begin
      is_supported = 1;
      if(max_num_outstanding_cmo_xacts_at_hn > 0) begin
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].num_outstanding_cmo_xact < (max_num_outstanding_cmo_xacts_at_hn/2)) begin
          str_idx0_info = $sformatf("Programmed value of max_num_outstanding_cmo_xacts_at_hn_status is %0d. But num_outstanding_cmo_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_cmo_xact of the initiating RN node must be equal to or greater than half of max_num_outstanding_cmo_xacts_at_hn_status of the target HN", max_num_outstanding_cmo_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_0_participating].num_outstanding_cmo_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].num_outstanding_cmo_xact < (max_num_outstanding_cmo_xacts_at_hn/2)) begin
          str_idx1_info = $sformatf("Programmed value of max_num_outstanding_cmo_xacts_at_hn_status is %0d. But num_outstanding_cmo_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_cmo_xact of the initiating RN node must be equal to or greater than half of max_num_outstanding_cmo_xacts_at_hn_status of the target HN", max_num_outstanding_cmo_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_1_participating].num_outstanding_cmo_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
      end else begin
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].num_outstanding_xact < (max_num_outstanding_xacts_at_hn/2)) begin
          str_idx0_info = $sformatf("Programmed value of max_num_outstanding_xacts_at_hn_status is %0d. But num_outstanding_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_xact of the initiating RN node must be equal to or greater than half of max_num_outstanding_xacts_at_hn of the target HN", max_num_outstanding_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_0_participating].num_outstanding_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].num_outstanding_xact < (max_num_outstanding_xacts_at_hn/2)) begin
          str_idx1_info = $sformatf("Programmed value of max_num_outstanding_xacts_at_hn_status is %0d. But num_outstanding_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_xact of the initiating RN node must be equal to or greater than half of max_num_outstanding_xacts_at_hn of the target HN", max_num_outstanding_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_1_participating].num_outstanding_xact, initiating_rn_node_idx_1);
          is_supported = 0;
        end
      end
    end
`ifdef SVT_CHI_ISSUE_B_ENABLE
   /*******************************************************************
    * According to the specfication version ARM IHI 0050B exp_comp_ack is always
    * programmed to zero for all the CMO transactions.So this sequence is not
    * applicable when macro `SVT_CHI_ISSUE_B_ENABLE macro is defined.
    *
    *****************************************************************
    */    
    is_supported = 0;
`endif    

    if (!is_supported) begin
`ifdef SVT_CHI_ISSUE_B_ENABLE
      issue_is_supported_failure($sformatf("This sequence cannot be run based on the current system configuration.\n\
                                            when macro SVT_CHI_ISSUE_B_ENABLE or SVT_CHI_ISSUE_C_ENABLE is defined \n\
                                            Modify configurations through \n\
                                            svt_chi_node_configuration::chi_spec_revision::ISSUE_A \n\
                                            "));
`else
      str_is_supported_info = $sformatf("%0s%0s",str_idx0_info, str_idx1_info);
      if (is_rn_idx_0_participating && is_rn_idx_1_participating) begin
        issue_is_supported_failure($sformatf("This sequence cannot be run based on the current system configuration.\n\
                                              %0s\n\
                                              %0s \n\
                                              Modify configurations through \n\
                                              svt_chi_system_configuration::num_rn,\n\
                                              svt_chi_node_configuration::is_active,\n\
                                              svt_chi_system_configuration::participating_rn_nodes[]\n\
                                              ", str_is_supported_info_prefix, str_is_supported_info));
      end
      else begin
        issue_is_supported_failure($sformatf("This sequence cannot be run based on the current node configurations of RN%0d and/or RN%0d.\n\
                                              %0s \n\
                                              Modify configuration through \n\
                                              svt_chi_node_configuration::num_outstanding_xact,\n\
                                              svt_chi_node_configuration::num_outstanding_cmo_xact,\n\
                                              ",str_is_supported_info, initiating_rn_node_idx_0, initiating_rn_node_idx_1));
      end
`endif    
    end      
    `svt_xvm_debug("is_supported",$sformatf("Exiting ..."));
    if (!is_target_hn_idx_valid_for_curr_cfg()) begin
      is_supported = 0;
      `svt_xvm_note("is_supported", "not a valid hn_idx based on random_tgt_id_enable for current cfg");
    end
  endfunction : is_supported

  //-----------------------------------------------------------------------------
  virtual task pre_start();
    bit enable_outstanding_status;
    `svt_xvm_debug("pre_start",$sformatf("Entering ..."));
    super.pre_start();
    raise_phase_objection();
    enable_outstanding_status = uvm_config_db#(bit)::get(m_sequencer, get_type_name(), "enable_outstanding", enable_outstanding);
    `svt_xvm_debug("body", $sformatf("enable_outstanding is %0b as a result of %0s", enable_outstanding, (enable_outstanding_status?"config DB":"default setting")));
    `svt_xvm_debug("pre_start",$sformatf("Exiting ..."));
  endtask // pre_start

  //-----------------------------------------------------------------------------  
  virtual task body();
    int received_cmo_responses;
    /** Queue of addresses, used by the transactions generated */
    bit[`SVT_CHI_MAX_ADDR_WIDTH -1:0]  addr_collection_queue[$];
    bit seq_is_non_secure_access_queue[$];                
    /** Flag to track whether cache initialization needs to be performed or not*/
    bit                                perform_cache_initialization;
    int                                num_outstanding_xacts_to_generate;

    int                                array_idx;

    /** Sub CMO type transaction directed sequences initiated from this sequence */
    svt_chi_rn_cmo_type_transaction_directed_sequence cmo_seq[int];

    /** Sub Read type transaction cache initialization directed sequences initiated from this sequence */
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq[int];

    `svt_xvm_debug("body", "Entering ...");
    super.body();
    
    max_num_outstanding_xacts_at_hn_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(), "max_num_outstanding_xacts_at_hn", max_num_outstanding_xacts_at_hn);
    max_num_outstanding_cmo_xacts_at_hn_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(), "max_num_outstanding_cmo_xacts_at_hn", max_num_outstanding_cmo_xacts_at_hn);
    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :initiating_rn_node_index_0;
    initiating_rn_node_idx_1 = initiating_rn_node_index_1_status ? initiating_rn_node_index_1_from_config_db :initiating_rn_node_index_1;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_node_index_0;

    `svt_xvm_debug("body", $sformatf("max_num_outstanding_xacts_at_hn is %0d as a result of %0s.", max_num_outstanding_xacts_at_hn, max_num_outstanding_xacts_at_hn_status ? "config DB" : "default"));
    `svt_xvm_debug("body", $sformatf("max_num_outstanding_cmo_xacts_at_hn is %0d as a result of %0s.", max_num_outstanding_cmo_xacts_at_hn, max_num_outstanding_cmo_xacts_at_hn_status ? "config DB" : "default"));
    `svt_xvm_debug("body", $sformatf("initiating_rn_node_idx_0 is %0d as a result of %0s.", initiating_rn_node_idx_0, initiating_rn_node_index_0_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("initiating_rn_node_idx_1 is %0d as a result of %0s.", initiating_rn_node_idx_1, initiating_rn_node_index_1_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("target_hn_node_idx_0 is %0d as a result of %0s.", target_hn_node_idx_0, target_hn_node_index_0_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("perform_cache_initialization is %0b, cache_line_init_rn_f_node_index is %0d, initiating_rn_node_idx_0 is %0d, initiating_rn_node_idx_1 is %0d", perform_cache_initialization, cache_line_init_rn_f_node_index, initiating_rn_node_idx_0, initiating_rn_node_idx_1)); 

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    //If there are participating RN-F nodes in the system, set the cache_line_init_rn_f_node_index to any one of them
    if(active_participating_rn_f_nodes.size()) begin
      cache_line_init_rn_f_node_index = active_participating_rn_f_nodes[0];
      perform_cache_initialization=1;
    end
    /**
     * If the cache_line_init_rn_f_node_index is same as any of the initiating RN node indices 
     * initiating_rn_node_idx_0,initiating_rn_node_idx_1,
     * then re-assign the cache_line_init_rn_f_node_index with RN node index ,which is active,
     * participating and not equal to initiating_rn_node_idx_0, initiating_rn_node_idx_1.
     */
      if((cache_line_init_rn_f_node_index == initiating_rn_node_idx_0)||(cache_line_init_rn_f_node_index == initiating_rn_node_idx_1))begin  
        int active_participating_q [$];
        `svt_chi_xxm_debug("body",$sformatf("cache_line_init_rn_f_node_index= %0d is same as initiating_rn_node_idx_0=%0d or initiating_rn_node_idx_1=%0d and active_participating_rn_f_nodes.size()= %0d",cache_line_init_rn_f_node_index,initiating_rn_node_idx_0,initiating_rn_node_idx_1,active_participating_rn_f_nodes.size()));
        active_participating_q = active_participating_rn_f_nodes.find with ((item != initiating_rn_node_idx_0) && (item != initiating_rn_node_idx_1));
        //If there are RN-Fs that do not coincide with initiating_rn_node_idx_0 and initiating_rn_node_idx_1, set one of them as cache_line_init_rn_f_node_index
        if(active_participating_q.size()>0)begin
          cache_line_init_rn_f_node_index = active_participating_q.pop_back();
          perform_cache_initialization=1;
          `svt_chi_xxm_debug("body", $sformatf("active_participating_q.size() is %0d and Selected different cache_line_init_rn_f_node_index=%0d", active_participating_q.size(),cache_line_init_rn_f_node_index));
          active_participating_q.delete();
        //If there are no other RN-Fs in the system, check if both initiating RN node index 0 and 1 are RN-Fs. If yes, then set cache_line_init_rn_f_node_index to one of the initiating RN nodes (we will initiate cache init transactions fromm both RN-Fs, so it does not matter which index we set cache_line_init_rn_f_node_index to). If no, then cache initialization cannot be performed.
        end else begin
          if((is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_node_idx_0, array_idx)) && (is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_node_idx_1, array_idx))) begin
            perform_cache_initialization=1;
            `svt_chi_xxm_debug("body",$sformatf("Selected cache_line_init_rn_f_node_index= %0d is same as initiating_rn_node_index_0=%0d or initiating_rn_node_index_1=%0d and active_participating_rn_f_nodes.size()= %0d. Cache initialization will be performed from initiating_rn_node_index_0 and initiating_rn_node_index_1",cache_line_init_rn_f_node_index,initiating_rn_node_index_0_from_config_db,initiating_rn_node_index_1_from_config_db,active_participating_rn_f_nodes.size()));
          end else begin
            perform_cache_initialization=0;
          end
        end
      end

    /**
     * If the cache_line_init_rn_f_node_index is not part of active_participating_rn_f_nodes array, then we cannot
     * perform cache initialization.
     */
    if (!(is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, cache_line_init_rn_f_node_index, array_idx))) begin
      perform_cache_initialization = 0;
    end
   
    `svt_chi_xxm_debug("body",$sformatf("Selected RN indices are cache_line_init_rn_f_node_index= %0d initiating_rn_node_idx_0=%0d initiating_rn_node_idx_1=%0d and perform_cache_initialization= %0d",cache_line_init_rn_f_node_index,initiating_rn_node_idx_0,initiating_rn_node_idx_1,perform_cache_initialization)); 

    //If max outstanding count for CMO transactions has been programmed, use that to generate the outstanding CMOs
    if(max_num_outstanding_cmo_xacts_at_hn > 0) begin
      num_outstanding_xacts_to_generate = max_num_outstanding_cmo_xacts_at_hn;
      `svt_xvm_debug("body",$sformatf("max_num_outstanding_cmo_xacts_at_hn is set to a non-zero value (%0d). Hence, the value programmed in max_num_outstanding_xacts_at_hn will be ignored. The number of outstanding transactions issued by the sequence will be equal to max_num_outstanding_cmo_xacts_at_hn", max_num_outstanding_cmo_xacts_at_hn));
    end
    //If not, use the max outstanding transaction count
    else
      num_outstanding_xacts_to_generate = max_num_outstanding_xacts_at_hn;

    for(int i = 0; i < sequence_length; i++) begin
      
      /** Following sequences will be executed based on configuration of RN Nodes */ 
      if(perform_cache_initialization) begin
        `svt_xvm_debug("body",$sformatf("Starting cache initialization for %0d addresses from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d",
                                        num_outstanding_xacts_to_generate, cache_line_init_rn_f_node_index, target_hn_node_idx_0));
        /** 
         * Write data into Cache of Randomly selected Third Request Node i.e RN-F with address of randomly
         * selected HN Node
         */
        for(int j=0; j<num_outstanding_xacts_to_generate; j++) begin
          //cache_line_init_rn_f_node_index will be set to initiating_rn_node_idx_1 or initiating_rn_node_idx_0 only when there are only 2 RN-Fs in the system. In such a case,
          //the cache init transactions must be issued alternately from initiating_rn_node_idx_1 and
          //initiating_rn_node_idx_0 respectively
          if(cache_line_init_rn_f_node_index == initiating_rn_node_idx_1 || cache_line_init_rn_f_node_index == initiating_rn_node_idx_0) begin
            if(j % 2 == 0) 
              cache_line_init_rn_f_node_index = initiating_rn_node_idx_1;
            else
              cache_line_init_rn_f_node_index = initiating_rn_node_idx_0; 
          end

          `svt_xvm_do_on_with(makeunique_seq[j], p_sequencer.rn_virt_seqr[cache_line_init_rn_f_node_index].rn_xact_seqr,{
            sequence_length    == 1;
            hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
            seq_hn_node_idx    == target_hn_node_idx_0;
            use_seq_is_non_secure_access == 0;
          })

          /** Waiting for above MakeUnique transaction to complete */ 
          `svt_xvm_debug("body", $sformatf("%0s Waiting for MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) to end",`SVT_CHI_PRINT_PREFIX(makeunique_seq[j].write_tran),j, makeunique_seq[j].write_tran.hn_node_idx, makeunique_seq[j].write_tran.tgt_id));
          makeunique_seq[j].write_tran.wait_end();
          `svt_xvm_debug("body", $sformatf("%0s MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) ended",`SVT_CHI_PRINT_PREFIX(makeunique_seq[j].write_tran),j, makeunique_seq[j].write_tran.hn_node_idx, makeunique_seq[j].write_tran.tgt_id));

          `svt_xvm_verbose("body", $sformatf("MakeUnique transaction [%0d]  is %0s", j,makeunique_seq[j].write_tran.sprint()));
        end //forloop of MakeUnique 

        /** Retrieving addresses from output transactions generated by the sequence  */
        foreach(makeunique_seq[index2]) begin
          addr_collection_queue.push_back(makeunique_seq[index2].output_xacts[0].addr);
          seq_is_non_secure_access_queue.push_back(makeunique_seq[index2].output_xacts[0].is_non_secure_access);
        end
        `svt_xvm_debug("body",$sformatf("Ended cache initialization for %0d addresses from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d",
                                        num_outstanding_xacts_to_generate, cache_line_init_rn_f_node_index, target_hn_node_idx_0));

      end // if (perform_cache_initialization)
      
      `svt_xvm_debug("body",$sformatf("Starting transmission of CMO type transactions for %0d addresses from two different p_sequencer.rn_virt_seqr[%0d] and p_sequencer.rn_virt_seqr[%0d] to HN idx %0d with suspend_comp_ack set to 1",
                                      (num_outstanding_xacts_to_generate/2), initiating_rn_node_idx_0, initiating_rn_node_idx_1, target_hn_node_idx_0));

      //for(int x=0; x < num_outstanding_xacts_to_generate/2; x++) begin
        fork
          begin
            /** 
             * Randomly selected First RN fires any 128 CMO transactions with above
             * MakeUnique transaction address/randomly selected HN node,
             * depending on whetehr cache initialization is done or not
             */
            for(int x=0; x < (num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2); x++) begin
              `svt_xvm_do_on_with(cmo_seq[2*x], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,{
                sequence_length    == 1;
                seq_txn_id         == x;
                if (perform_cache_initialization)
                {
                  hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                  min_addr           == addr_collection_queue[2*x];
                  max_addr           == addr_collection_queue[2*x];
                  seq_is_non_secure_access == seq_is_non_secure_access_queue[2*x]; 
                  use_seq_is_non_secure_access == 1;
                }
                else
                {
                  hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
                  seq_hn_node_idx    == target_hn_node_idx_0;
                  use_seq_is_non_secure_access == 0;
                }
                `ifdef SVT_CHI_ISSUE_B_ENABLE
                  if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) 
                    {
                      !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSIST, svt_chi_transaction::STASHONCEUNIQUE,svt_chi_transaction::STASHONCESHARED});
                    }
                  `ifdef SVT_CHI_ISSUE_E_ENABLE
                  else if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision < svt_chi_node_configuration::ISSUE_E){
                    !(seq_xact_type inside {svt_chi_transaction::STASHONCESEPUNIQUE, svt_chi_transaction::STASHONCESEPSHARED});
                    if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision < svt_chi_node_configuration::ISSUE_D){
                      !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                      if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0)
                        !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                    }
                    else if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision >= svt_chi_node_configuration::ISSUE_D){
                      if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].cleansharedpersistsep_xact_enable ==0)
                        !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                      if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0)
                        !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                    }
                  }
                  else if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision >= svt_chi_node_configuration::ISSUE_E){
                    if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].cleansharedpersistsep_xact_enable == 0)
                      !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                    if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0)
                      !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED,svt_chi_transaction::STASHONCESEPUNIQUE, svt_chi_transaction::STASHONCESEPSHARED});
                  }
                  `elsif SVT_CHI_ISSUE_D_ENABLE
                  else if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision < svt_chi_node_configuration::ISSUE_D){
                    !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                    if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0)
                    !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                    }
                  else if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision >= svt_chi_node_configuration::ISSUE_D){
                    if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].cleansharedpersistsep_xact_enable ==0)
                      !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                    if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0){
                      !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                     }
                  }
                  `endif //issue_d_enable
                  else if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0){
                      !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                    }
                `endif
              })
              `svt_xvm_debug("body", $sformatf("%0s Transmitting CMO Transaction [%0d] targeted to HN (idx %0d, id %0d) ",`SVT_CHI_PRINT_PREFIX(cmo_seq[2*x].cmo_tran),(2*x), cmo_seq[2*x].cmo_tran.hn_node_idx, cmo_seq[2*x].cmo_tran.tgt_id));
              `svt_xvm_verbose("body", $sformatf("CMO Transaction [%0d] is %0s", (2*x),cmo_seq[2*x].cmo_tran.sprint()));
            end 
          end 
          begin
            /** 
             * Randomly selected Second RN fires any 128 CMO transactions with above
             * MakeUnique transaction address/randomly selected HN node,
             * depending on whetehr cache initialization is done or not
             */
            for(int x=0; x < (num_outstanding_xacts_to_generate/2); x++) begin
              `svt_xvm_do_on_with(cmo_seq[2*x + 1], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,{
                sequence_length    == 1;
                seq_txn_id         == (x + (num_outstanding_xacts_to_generate/2));
                if (perform_cache_initialization)
                {
                  hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                  min_addr           == addr_collection_queue[2*x + 1];
                  max_addr           == addr_collection_queue[2*x + 1];
                  seq_is_non_secure_access == seq_is_non_secure_access_queue[2*x + 1]; 
                  use_seq_is_non_secure_access == 1;
                }
                else
                {
                  hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
                  seq_hn_node_idx    == target_hn_node_idx_0;
                  use_seq_is_non_secure_access == 0;
                }
                `ifdef SVT_CHI_ISSUE_B_ENABLE
                  if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) 
                    {
                      !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSIST, svt_chi_transaction::STASHONCEUNIQUE,svt_chi_transaction::STASHONCESHARED});
                    }
                  `ifdef SVT_CHI_ISSUE_E_ENABLE
                  else if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision < svt_chi_node_configuration::ISSUE_E){
                    !(seq_xact_type inside {svt_chi_transaction::STASHONCESEPUNIQUE, svt_chi_transaction::STASHONCESEPSHARED});
                    if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision < svt_chi_node_configuration::ISSUE_D){
                      !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                      if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 0)
                        !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                    }
                    else if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision >= svt_chi_node_configuration::ISSUE_D){
                      if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].cleansharedpersistsep_xact_enable ==0)
                        !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                      if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 0)
                        !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                    }
                  }
                  else if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision >= svt_chi_node_configuration::ISSUE_E){
                    if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].cleansharedpersistsep_xact_enable == 0)
                      !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                    if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 0)
                      !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED,svt_chi_transaction::STASHONCESEPUNIQUE, svt_chi_transaction::STASHONCESEPSHARED});
                  }
                `elsif SVT_CHI_ISSUE_D_ENABLE
                  else if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision < svt_chi_node_configuration::ISSUE_D){
                    !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                   if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 0)
                     !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                  }
                  else if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision >= svt_chi_node_configuration::ISSUE_D){
                    if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].cleansharedpersistsep_xact_enable ==0)
                      !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                    if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 0){
                      !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                    }
                  }
                `endif //issue_d_enable
                  else if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 0){
                      !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                    }
                `endif
              })
              `svt_xvm_debug("body", $sformatf("%0s Transmitting CMO Transaction [%0d] targeted to HN (idx %0d, id %0d) ",`SVT_CHI_PRINT_PREFIX(cmo_seq[2*x + 1].cmo_tran),(2*x + 1), cmo_seq[2*x + 1].cmo_tran.hn_node_idx, cmo_seq[2*x + 1].cmo_tran.tgt_id));
              `svt_xvm_verbose("body", $sformatf("CMO Transaction [%0d] is %0s", (2*x + 1),cmo_seq[2*x + 1].cmo_tran.sprint()));
            end  
          end  
        join  
      //end // forloop of 128 CMO from each selected RN

      /** Checking for the reception of all the CMO responses from the Interconnect */
      foreach(cmo_seq[index3]) begin
        fork
          automatic int _index3 = index3;
          begin
                `svt_xvm_debug("body", $sformatf("%0s CMO transaction [%0d] targeted to HN (idx %0d, id %0d), suspend_comp_ack %0b: waiting for response from interconnect",`SVT_CHI_PRINT_PREFIX(cmo_seq[_index3].cmo_tran),_index3, cmo_seq[_index3].cmo_tran.hn_node_idx, cmo_seq[_index3].cmo_tran.tgt_id,cmo_seq[_index3].cmo_tran.suspend_comp_ack));
            fork
            begin
              fork
                begin
                  cmo_seq[_index3].cmo_tran.wait_for_tx_compack_prereqs();
                end
                begin
                  wait(cmo_seq[_index3].cmo_tran.req_status == svt_chi_transaction::RETRY);// begin
                end
              join_any
              disable fork;
            end
            join
            received_cmo_responses++;
            `svt_xvm_debug("body", $sformatf("%0s CMO transaction [%0d] targeted to HN (idx %0d, id %0d), suspend_comp_ack %0b: received response from interconnect. Total responses received %0d",`SVT_CHI_PRINT_PREFIX(cmo_seq[_index3].cmo_tran),_index3, cmo_seq[_index3].cmo_tran.hn_node_idx, cmo_seq[_index3].cmo_tran.tgt_id,cmo_seq[_index3].cmo_tran.suspend_comp_ack, received_cmo_responses));    
          end
        join_none
      end  

      /** Wait until All 128 Comp responses are received at each selected RN's */ 
      `svt_xvm_debug("body",$sformatf("Completed initiation of  CMO type transactions for %0d addresses from two different p_sequencer.rn_virt_seqr[%0d] and p_sequencer.rn_virt_seqr[%0d] to HN idx %0d with suspend_comp_ack set to 1, and waiting to receive responses from interconnect.",
                                (num_outstanding_xacts_to_generate/2), initiating_rn_node_idx_0, initiating_rn_node_idx_1, target_hn_node_idx_0));      
      wait(received_cmo_responses == num_outstanding_xacts_to_generate);
      `svt_xvm_debug("body",$sformatf("Received responses from interconnect to CMO type transactions for %0d addresses from two different p_sequencer.rn_virt_seqr[%0d] and p_sequencer.rn_virt_seqr[%0d] to HN idx %0d with suspend_comp_ack set to 1",
                                      (num_outstanding_xacts_to_generate/2), initiating_rn_node_idx_0, initiating_rn_node_idx_1,target_hn_node_idx_0));
      
      /** Self Check1: To check suspend_comp_ack should not be modified to zero by the VIP 
       *  before reseting from test bench.
       */ 
      foreach (cmo_seq[self_check_idx1]) begin
        if (!cmo_seq[self_check_idx1].cmo_tran.is_terminated()) begin
          if (cmo_seq[self_check_idx1].cmo_tran.suspend_comp_ack == 0) begin
            `svt_xvm_error("body", $sformatf("%0s suspend_comp_ack should be 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(cmo_seq[self_check_idx1].cmo_tran)));
          end
          else begin
            `svt_xvm_debug("body", $sformatf("%0s suspend_comp_ack is 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(cmo_seq[self_check_idx1].cmo_tran)));
          end
        end  
      end

      /** Self Check2: To check transaction is not ended by the VIP before resuming the 
       *  suspend_comp_ack to zero from the test bench 
       */ 
      foreach(cmo_seq[self_check_idx2]) begin
        if (!cmo_seq[self_check_idx2].cmo_tran.is_terminated()) begin
          if (cmo_seq[self_check_idx2].cmo_tran.end_event.is_on() == 1) begin
            // Fail  event has triggered
            `svt_xvm_error("body", $sformatf("Unexpected: %0s Transaction's end_event triggered when suspend_comp_ack is still 1.", `SVT_CHI_PRINT_PREFIX(cmo_seq[self_check_idx2].cmo_tran)));
          end
          else begin
            // Pass  event is not triggered
            `svt_xvm_debug("body", $sformatf("Expected: %0s Transaction's end_event is not triggered when suspend_comp_ack is still 1.", `SVT_CHI_PRINT_PREFIX(cmo_seq[self_check_idx2].cmo_tran)));
          end
        end  
      end

      /** Self Check 3: To check that the current_outstanding_*_xact_count in the RNs
       * match the number of transactions inititated by the sequence
       */
      /** Check if the total outstanding xact counter is set correctly in the shared status of the RN agent */
      if(cmo_seq[0].shared_status.prot_status.current_outstanding_xact_count != (num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2))
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding transactions from the sequence but the outstanding transaction count in the shared status of RN%0d is %0d", (num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2), initiating_rn_node_idx_0, cmo_seq[0].shared_status.prot_status.current_outstanding_xact_count));
      /** Check if the outstanding CMO xact counter is set correctly in the shared status of the RN agent */
      if(cmo_seq[0].shared_status.prot_status.current_outstanding_cmo_xact_count != (num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2)) begin
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding CMO transactions from the sequence but the outstanding CMO transaction count in the shared status of RN%0d is %0d", (num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2), initiating_rn_node_idx_0, cmo_seq[0].shared_status.prot_status.current_outstanding_cmo_xact_count));
      end

      /** Check if the total outstanding xact counter is set correctly in the shared status of the second RN agent */
      if(cmo_seq[1].shared_status.prot_status.current_outstanding_xact_count != num_outstanding_xacts_to_generate/2)
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding transactions from the sequence but the outstanding transaction count in the shared status of RN%0d is %0d", num_outstanding_xacts_to_generate/2, initiating_rn_node_idx_1, cmo_seq[1].shared_status.prot_status.current_outstanding_xact_count));
      /** Check if the outstanding CMO xact counter is set correctly in the shared status of the RN agent */
      if(cmo_seq[1].shared_status.prot_status.current_outstanding_cmo_xact_count != num_outstanding_xacts_to_generate/2) begin
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding CMO transactions from the sequence but the outstanding CMO transaction count in the shared status of RN%0d is %0d", num_outstanding_xacts_to_generate/2, initiating_rn_node_idx_1, cmo_seq[1].shared_status.prot_status.current_outstanding_cmo_xact_count));
      end

      /** Resuming all 128 CompAck responses of above CMO transactions from each selected RN */
      foreach(cmo_seq[index4]) begin
        `svt_xvm_debug("body",$sformatf("Received responses for all CMO type transactions from interconnect, resuming the transactions by setting svt_chi_rn_transaction::suspend_comp_ack set to 0 %0s",`SVT_CHI_PRINT_PREFIX(cmo_seq[index4].cmo_tran)));
        cmo_seq[index4].cmo_tran.suspend_comp_ack=0;
        `svt_xvm_debug("body", $sformatf("For iteration %0d : After Resume, received_cmo_responses is %0d,suspend_comp_ack is %b and exp_comp_ack is %b ", index4,received_cmo_responses,cmo_seq[index4].cmo_tran.suspend_comp_ack,cmo_seq[index4].cmo_tran.exp_comp_ack));
      end

      `svt_xvm_debug("body",$sformatf("Waiting for completion of all the outstanding CMO type transactions"));
      /** Waiting for above 128 CMO outstanding transactions to complete from each selected RN */ 
      foreach(cmo_seq[index5]) begin
        `svt_xvm_debug("body", $sformatf("Waiting for above cmo_seq[%0d] transaction %0s to end", index5, `SVT_CHI_PRINT_PREFIX(cmo_seq[index5].cmo_tran)));
        cmo_seq[index5].cmo_tran.wait_end();
        
        /** Self Check4: To check suspend_comp_ack should not be asserted after the transaction completes 
         *  as it is reseted from test bench
         */
        if (!cmo_seq[index5].cmo_tran.is_terminated()) begin
          if (cmo_seq[index5].cmo_tran.suspend_comp_ack == 1) begin
            `svt_xvm_error("body", $sformatf("%0s suspend_comp_ack should be 0 as it should be reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(cmo_seq[index5].cmo_tran)));
          end
          else begin
            `svt_xvm_debug("body", $sformatf("%0s suspend_comp_ack is 0 as it is reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(cmo_seq[index5].cmo_tran)));
          end
        end
      end
      `svt_xvm_debug("body",$sformatf("Received completions for all CMO type outstanding transactions"));

      // Targeted HN IDs from both RNs should be same
      for(int index6 =0; index6 < num_outstanding_xacts_to_generate/2; index6++) begin
        int hn_idx_0, hn_idx_1;
        hn_idx_0 = sys_cfg.get_hn_idx(cmo_seq[2*index6].output_xacts[0].addr);
        hn_idx_1 = sys_cfg.get_hn_idx(cmo_seq[2*index6 +1].output_xacts[0].addr);
        if ((hn_idx_0 == target_hn_node_idx_0) && (hn_idx_0 == hn_idx_1)) begin
          // pass
          `svt_xvm_debug("body", $sformatf("Targeted HN Index from both RNs is same as expected.  rn[%0d] to hn_idx[%0d], rn[%0d] to hn_idx[%0d]", initiating_rn_node_idx_0, hn_idx_0, initiating_rn_node_idx_1, hn_idx_1));
        end
        else begin
          // fail
          `svt_xvm_error("body", $sformatf("Targeted HN Index from both RNs is different, which is unexpected.  rn[%0d] %0s transaction to hn_idx[%0d], rn[%0d] %0s transaction to hn_idx[%0d]", initiating_rn_node_idx_0, `SVT_CHI_PRINT_PREFIX( cmo_seq[2*index6].output_xacts[0]), hn_idx_0, initiating_rn_node_idx_1, `SVT_CHI_PRINT_PREFIX( cmo_seq[2*index6 +1].output_xacts[0]), hn_idx_1));
        end
      end

      /** Reset received_cmo_responses to zero */
      received_cmo_responses = 0;

      /** Delete the contents of address collection queue */
      addr_collection_queue.delete();

    end//forloop of sequence_length
    /** 
     * To check the Interconnect HN shall responds properly for all outstanding
     * CMO transactions to respective initiating RN.<br>
     * Check done by System monitor(List of checkers)<br>
     *  #- snoop_data_integrity_check 
     *  .  
     */
    `svt_xvm_debug("body", "Exiting...");
  endtask: body

  //-----------------------------------------------------------------------------  
  virtual task post_start();
    super.post_start();
    drop_phase_objection();
  endtask

endclass: svt_chi_system_protocol_flow_ctrl_cmo_outstanding_diff_rn_same_hn_virtual_sequence

//-------------------------------------------------------------------------------  
function svt_chi_system_protocol_flow_ctrl_cmo_outstanding_diff_rn_same_hn_virtual_sequence::new(string name="svt_chi_system_protocol_flow_ctrl_cmo_outstanding_diff_rn_same_hn_virtual_sequence");
  super.new(name);
endfunction
          

//====================================================================================
/** 
 * @groupname CHI_OUTSTANDING_CMO_TYPE 
 * #- This sequence requires at least two HN nodes to be present in the Interconnect. <br>
 * #- This sequence requires two initiating active and participating RN. <br>
 * #- If another active and participating RN-F exists, perform cache <br>
 *    initialization to a randomly selected different HN's. <br>
 * #- Initiate maximum number of CMO type transactions with svt_chi_rn_transaction:: <br>
 *    suspend_comp_ack set  to 1 from selected initiating RN to randomly selected <br>
 *    different HN's in non blocking mode. <br>
 *    - Maximum number of outstanding transactions at the HN is as per
 *      #max_num_outstanding_cmo_xacts_at_hn or #max_num_outstanding_xacts_at_hn, which can be controlled through config DB.  
 *    - This ensures that the maximum outstanding transaction limit is reached at the <br>
 *      selected HN. <br>
 *    - Also, the selected RN will not transmit CompAck corresponding to these <br>
 *      transactions until svt_chi_rn_transaction::suspend_comp_ack is set to 0 from the <br>
 *      seqeunce. <br>
 *    .
 * #- The addresses of these CMO transactions are such that: <br>
 *    - Same as initialized cache line addresses if cache initialization is performed <br>
 *    - Otherwise, random addresses targeting the different HN's <br>
 *    .
 * #- Once the selected RN receives the responses for all the outstanding transactions <br>
 *    from selected HN, svt_chi_rn_transaction::suspend_comp_ack is set to 0 for all the <br>
 *    outstanding transactions. <br>
 *    This ensures that the CompAck for these transactions can be resumed <br>
 *    from selected RN. <br>
 * #- Check that the selected HN responds properly for all outstanding CMO type <br>
 *    transactions and these are completed successfully. <br>
 * .
 */ 

class svt_chi_system_protocol_flow_ctrl_cmo_outstanding_diff_rn_diff_hn_virtual_sequence extends svt_chi_system_base_virtual_sequence;

  //-----------------------------------------------------------------------------  
  // Member attributes
  //-----------------------------------------------------------------------------  
  /** Parameter that controls the enabling of transactions in non-blocking mode from the sequence */
  bit enable_outstanding = 0;

  /** To display contents of Active Participating RN's nodes info. */
  string str_rn_node;

  /** To display contents of Active Participating RN-F's nodes info. */
  string str_rn_f_node;

  /** UVM/OVM Object Utility macro */
  `svt_xvm_object_utils(svt_chi_system_protocol_flow_ctrl_cmo_outstanding_diff_rn_diff_hn_virtual_sequence)
  
  //-----------------------------------------------------------------------------  
  // Methods
  //-----------------------------------------------------------------------------
  /** Constructor */
  extern function new(string name="svt_chi_system_protocol_flow_ctrl_cmo_outstanding_diff_rn_diff_hn_virtual_sequence");

  /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- Minimum required number of supporting request nodes = 2
   *  #- Minimum required number of HN nodes = 2
   */
  //-----------------------------------------------------------------------------  
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    
    /** local variables */
    int num_supporting_request_nodes;
    int num_hn_f_nodes;   
    int array_idx;
    bit is_rn_idx_0_participating, is_rn_idx_1_participating;
    string str_is_supported_info_prefix = "";
    string str_is_supported_info = "";
    string str_idx0_info = "";
    string str_idx1_info = "";    
    
    /** Supporting any type of Request Nodes required */
    int required_num_supporting_request_nodes = 2;
    int required_num_hn_nodes = 2;
    
    `svt_xvm_debug("is_supported",$sformatf("Entering ..."));

    /** By default is_supported is 0 */
    is_supported = 0;

    /** Check for minimum required HN nodes */
    num_hn_f_nodes = hn_f_nodes.size();
   
    /** Check requirment of number of HN nodes needed */
    if (num_hn_f_nodes < required_num_hn_nodes) begin
      issue_is_supported_failure($sformatf("This sequence requires minimum %0d HN-F nodes to be present in the system. Number of HN-F nodes are %0d. Program number of HN nodes using svt_chi_system_configuration::num_hn. Program the HN interface type using svt_chi_system_configuration::chi_addr_cfg.hn_interface_type[].", required_num_hn_nodes, num_hn_f_nodes));
      return 0;      
    end

    /** Check for minimum required RN nodes.
     *  Also check whether the selected RN nodes are part of participating arrays or not.
     */   
    num_supporting_request_nodes = active_participating_rn_nodes.size();

    /** Check the requirements of RN nodes */
    if (num_supporting_request_nodes) begin
      /** Display the contents of Active Participating RN Nodes */
      foreach (active_participating_rn_nodes[j]) begin
        str_rn_node = {str_rn_node, $sformatf(" %0d", active_participating_rn_nodes[j])};
      end 
      `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_nodes are %0s", str_rn_node));
    end

    /** Display the contents of Active Participating RN-F Nodes */
    foreach (active_participating_rn_f_nodes[j]) begin
      str_rn_f_node = {str_rn_f_node, $sformatf(" %0d", active_participating_rn_f_nodes[j])};
    end 
    `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_f_nodes are %0s", str_rn_f_node));

    str_is_supported_info_prefix = $sformatf("Number of Supporting RN Node(s)  - Minimum Required : %0d Current : %0d", required_num_supporting_request_nodes, num_supporting_request_nodes);
    
     if ((initiating_rn_node_index_0_status==0)&&(valid_initiating_rn_node_index_0==0)) begin
        str_idx0_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN's that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F or RN_I)";
    end
    else begin
      is_rn_idx_0_participating = is_value_found_in_int_assoc_array(active_participating_rn_nodes, initiating_rn_node_idx_0, array_idx);
      if (!is_rn_idx_0_participating) begin
        str_idx0_info = $sformatf("initiating_rn_node_idx_0 %0d is not valid for this sequence. The RN corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuration::participating_rn_nodes[])", initiating_rn_node_idx_0, initiating_rn_node_idx_0);
      end
    end
    if ((initiating_rn_node_index_1_status==0)&&(valid_initiating_rn_node_index_1==0)) begin
        str_idx1_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN's that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F or RN_I)";
    end
    else begin
      is_rn_idx_1_participating = is_value_found_in_int_assoc_array(active_participating_rn_nodes, initiating_rn_node_idx_1, array_idx);
      if (!is_rn_idx_1_participating) begin
        str_idx1_info = $sformatf("initiating_rn_node_idx_1 %0d is not valid for this sequence. The RN corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuration::participating_rn_nodes[])", initiating_rn_node_idx_1, initiating_rn_node_idx_1);
      end
    end

    if (is_rn_idx_0_participating && is_rn_idx_1_participating) begin
      is_supported = 1;
      if(max_num_outstanding_cmo_xacts_at_hn > 0) begin
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].num_outstanding_cmo_xact < max_num_outstanding_cmo_xacts_at_hn) begin
          str_idx0_info = $sformatf("Programmed value of max_num_outstanding_cmo_xacts_at_hn_status is %0d. But num_outstanding_cmo_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_cmo_xact of the initiating RN node must be equal to or greater than max_num_outstanding_cmo_xacts_at_hn_status of the target HN", max_num_outstanding_cmo_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_0_participating].num_outstanding_cmo_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].num_outstanding_cmo_xact < max_num_outstanding_cmo_xacts_at_hn) begin
          str_idx1_info = $sformatf("Programmed value of max_num_outstanding_cmo_xacts_at_hn_status is %0d. But num_outstanding_cmo_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_cmo_xact of the initiating RN node must be equal to or greater than max_num_outstanding_cmo_xacts_at_hn_status of the target HN", max_num_outstanding_cmo_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_1_participating].num_outstanding_cmo_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
      end else begin
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].num_outstanding_xact < max_num_outstanding_xacts_at_hn) begin
          str_idx0_info = $sformatf("Programmed value of max_num_outstanding_xacts_at_hn_status is %0d. But num_outstanding_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_xact of the initiating RN node must be equal to or greater than max_num_outstanding_xacts_at_hn of the target HN", max_num_outstanding_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_0_participating].num_outstanding_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].num_outstanding_xact < max_num_outstanding_xacts_at_hn) begin
          str_idx1_info = $sformatf("Programmed value of max_num_outstanding_xacts_at_hn_status is %0d. But num_outstanding_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_xact of the initiating RN node must be equal to or greater than max_num_outstanding_xacts_at_hn of the target HN", max_num_outstanding_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_1_participating].num_outstanding_xact, initiating_rn_node_idx_1);
          is_supported = 0;
        end
      end
    end
    
`ifdef SVT_CHI_ISSUE_B_ENABLE
   /*******************************************************************
    * According to the specfication version ARM IHI 0050B exp_comp_ack is always
    * programmed to zero for all the CMO transactions.So this sequence is not
    * applicable when macro `SVT_CHI_ISSUE_B_ENABLE macro is defined.
    *
    *****************************************************************
    */    
    is_supported = 0;
`endif    

    if (!is_supported) begin

`ifdef SVT_CHI_ISSUE_B_ENABLE
      issue_is_supported_failure($sformatf("This sequence cannot be run based on the current system configuration.\n\
                                            Macro SVT_CHI_ISSUE_B_ENABLE or SVT_CHI_ISSUE_C_ENABLE is defined, but in CHI-B or later, ExpCompAck cannot be asserted for CMO transactions \n\
                                            "));
`else      
      str_is_supported_info = $sformatf("%0s%0s",str_idx0_info, str_idx1_info);
      if (is_rn_idx_0_participating && is_rn_idx_1_participating) begin
        issue_is_supported_failure($sformatf("This sequence cannot be run based on the current system configuration.\n\
                                              %0s\n\
                                              %0s \n\
                                              Modify configurations through \n\
                                              svt_chi_system_configuration::num_rn,\n\
                                              svt_chi_node_configuration::is_active,\n\
                                              svt_chi_system_configuration::participating_rn_nodes[]\n\
                                              ", str_is_supported_info_prefix, str_is_supported_info));
      end
      else begin
        issue_is_supported_failure($sformatf("This sequence cannot be run based on the current node configurations of RN%0d and/or RN%0d.\n\
                                              %0s \n\
                                              Modify configuration through \n\
                                              svt_chi_node_configuration::num_outstanding_xact,\n\
                                              svt_chi_node_configuration::num_outstanding_cmo_xact,\n\
                                              ",str_is_supported_info, initiating_rn_node_idx_0, initiating_rn_node_idx_1));
      end
`endif      
    end      
    `svt_xvm_debug("is_supported",$sformatf("Exiting ..."));
    if (!is_target_hn_idx_valid_for_curr_cfg()) begin
      is_supported = 0;
      `svt_xvm_note("is_supported", "not a valid hn_idx based on random_tgt_id_enable for current cfg");
    end
  endfunction : is_supported

  //-----------------------------------------------------------------------------
  virtual task pre_start();
    bit enable_outstanding_status;
    `svt_xvm_debug("pre_start",$sformatf("Entering ..."));
    super.pre_start();
    raise_phase_objection();
    enable_outstanding_status = uvm_config_db#(bit)::get(m_sequencer, get_type_name(), "enable_outstanding", enable_outstanding);
    `svt_xvm_debug("body", $sformatf("enable_outstanding is %0b as a result of %0s", enable_outstanding, (enable_outstanding_status?"config DB":"default setting")));
    `svt_xvm_debug("pre_start",$sformatf("Exiting ..."));
  endtask // pre_start

  //-----------------------------------------------------------------------------  
  virtual task body();

    int received_cmo_seq1_responses, received_cmo_seq2_responses;
    /** Queues of addresses, used by the transactions generated */
    bit[`SVT_CHI_MAX_ADDR_WIDTH -1:0] addr_collection_queue1[$], addr_collection_queue2[$];
    bit seq_is_non_secure_access_queue1[$], seq_is_non_secure_access_queue2[$];
    /** Flag to track whether cache initialization needs to be performed or not*/
    bit                                perform_cache_initialization;
    int                                num_outstanding_xacts_to_generate;

    int                                array_idx;

    /** Sub CMO type transaction directed sequences initiated from this sequence */
    svt_chi_rn_cmo_type_transaction_directed_sequence cmo_seq1[int], cmo_seq2[int] ;

    /** Sub Read type transaction cache initialization directed sequences initiated from this sequence */
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq1[int], makeunique_seq2[int];

    `svt_xvm_debug("body", "Entering ...");
    super.body();

    max_num_outstanding_xacts_at_hn_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(), "max_num_outstanding_xacts_at_hn", max_num_outstanding_xacts_at_hn);
    max_num_outstanding_cmo_xacts_at_hn_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(), "max_num_outstanding_cmo_xacts_at_hn", max_num_outstanding_cmo_xacts_at_hn);
    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :initiating_rn_node_index_0;
    initiating_rn_node_idx_1 = initiating_rn_node_index_1_status ? initiating_rn_node_index_1_from_config_db :initiating_rn_node_index_1;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_node_index_0;
    target_hn_node_idx_1 = target_hn_node_index_1_status ? target_hn_node_index_1_from_config_db :target_hn_node_index_1;

    `svt_xvm_debug("body", $sformatf("max_num_outstanding_xacts_at_hn is %0d as a result of %0s.", max_num_outstanding_xacts_at_hn, max_num_outstanding_xacts_at_hn_status ? "config DB" : "default"));
    `svt_xvm_debug("body", $sformatf("max_num_outstanding_cmo_xacts_at_hn is %0d as a result of %0s.", max_num_outstanding_cmo_xacts_at_hn, max_num_outstanding_cmo_xacts_at_hn_status ? "config DB" : "default"));
    `svt_xvm_debug("body", $sformatf("initiating_rn_node_idx_0 is %0d as a result of %0s.", initiating_rn_node_idx_0, initiating_rn_node_index_0_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("initiating_rn_node_idx_1 is %0d as a result of %0s.", initiating_rn_node_idx_1, initiating_rn_node_index_1_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("target_hn_node_idx_0 is %0d as a result of %0s.", target_hn_node_idx_0, target_hn_node_index_0_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("target_hn_node_idx_1 is %0d as a result of %0s.", target_hn_node_idx_1, target_hn_node_index_1_status ? "config DB" : "Randomization"));  
    `svt_xvm_debug("body", $sformatf("perform_cache_initialization is %0b, cache_line_init_rn_f_node_index is %0d, initiating_rn_node_idx_0 is %0d, initiating_rn_node_idx_1 is %0d", perform_cache_initialization, cache_line_init_rn_f_node_index, initiating_rn_node_idx_0, initiating_rn_node_idx_1)); 

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end
   
    //If there are participating RN-F nodes in the system, set the cache_line_init_rn_f_node_index to any one of them
    if(active_participating_rn_f_nodes.size()) begin
      cache_line_init_rn_f_node_index = active_participating_rn_f_nodes[0];
      perform_cache_initialization=1;
    end
    /**
     * If the cache_line_init_rn_f_node_index is same as any of the initiating RN node indices 
     * initiating_rn_node_idx_0,initiating_rn_node_idx_1,
     * then re-assign the cache_line_init_rn_f_node_index with RN node index ,which is active,
     * participating and not equal to initiating_rn_node_idx_0, initiating_rn_node_idx_1.
     */
      if((cache_line_init_rn_f_node_index == initiating_rn_node_idx_0)||(cache_line_init_rn_f_node_index == initiating_rn_node_idx_1))begin  
        int active_participating_q [$];
        `svt_chi_xxm_debug("body",$sformatf("cache_line_init_rn_f_node_index= %0d is same as initiating_rn_node_idx_0=%0d or initiating_rn_node_idx_1=%0d and active_participating_rn_f_nodes.size()= %0d",cache_line_init_rn_f_node_index,initiating_rn_node_idx_0,initiating_rn_node_idx_1,active_participating_rn_f_nodes.size()));
        active_participating_q = active_participating_rn_f_nodes.find with ((item != initiating_rn_node_idx_0) && (item != initiating_rn_node_idx_1));
        //If there are RN-Fs that do not coincide with initiating_rn_node_idx_0 and initiating_rn_node_idx_1, set one of them as cache_line_init_rn_f_node_index
        if(active_participating_q.size()>0)begin
          cache_line_init_rn_f_node_index = active_participating_q.pop_back();
          perform_cache_initialization=1;
          `svt_chi_xxm_debug("body", $sformatf("active_participating_q.size() is %0d and Selected different cache_line_init_rn_f_node_index=%0d", active_participating_q.size(),cache_line_init_rn_f_node_index));
          active_participating_q.delete();
        //If there are no other RN-Fs in the system, check if both initiating RN node index 0 and 1 are RN-Fs. If yes, then set cache_line_init_rn_f_node_index to one of the initiating RN nodes (we will initiate cache init transactions fromm both RN-Fs, so it does not matter which index we set cache_line_init_rn_f_node_index to). If no, then cache initialization cannot be performed.
        end else begin
          if((is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_node_idx_0, array_idx)) && (is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_node_idx_1, array_idx))) begin
            perform_cache_initialization=1;
            `svt_chi_xxm_debug("body",$sformatf("Selected cache_line_init_rn_f_node_index= %0d is same as initiating_rn_node_index_0=%0d or initiating_rn_node_index_1=%0d and active_participating_rn_f_nodes.size()= %0d. Cache initialization will be performed from initiating_rn_node_index_0 and initiating_rn_node_index_1",cache_line_init_rn_f_node_index,initiating_rn_node_index_0_from_config_db,initiating_rn_node_index_1_from_config_db,active_participating_rn_f_nodes.size()));
          end else begin
            perform_cache_initialization=0;
          end
        end
      end

    /**
     * If the cache_line_init_rn_f_node_index is not part of active_participating_rn_f_nodes array, then we cannot
     * perform cache initialization.
     */
    if (!(is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, cache_line_init_rn_f_node_index, array_idx))) begin
      perform_cache_initialization = 0;
    end

    `svt_chi_xxm_debug("body",$sformatf("Selected RN indices are cache_line_init_rn_f_node_index= %0d initiating_rn_node_idx_0=%0d initiating_rn_node_idx_1=%0d and perform_cache_initialization= %0d",cache_line_init_rn_f_node_index,initiating_rn_node_idx_0,initiating_rn_node_idx_1,perform_cache_initialization));

    //If max outstanding count for CMO transactions has been programmed, use that to generate the outstanding CMOs
    if(max_num_outstanding_cmo_xacts_at_hn > 0) begin
      num_outstanding_xacts_to_generate = max_num_outstanding_cmo_xacts_at_hn;
      `svt_xvm_debug("body",$sformatf("max_num_outstanding_cmo_xacts_at_hn is set to a non-zero value (%0d). Hence, the value programmed in max_num_outstanding_xacts_at_hn will be ignored. The number of outstanding transactions issued by the sequence will be equal to max_num_outstanding_cmo_xacts_at_hn", max_num_outstanding_cmo_xacts_at_hn));
    end
    //If not, use the max outstanding transaction count
    else
      num_outstanding_xacts_to_generate = max_num_outstanding_xacts_at_hn;
   
    for(int i = 0; i < sequence_length; i++) begin
     
      /** Following sequences will be executed based on configuration of RN Nodes */
      if(perform_cache_initialization) begin
        `svt_xvm_debug("body",$sformatf("Starting cache initialization for %0d addresses from p_sequencer.rn_virt_seqr[%0d] to different HN idxs %0d and %0d", (2*num_outstanding_xacts_to_generate), cache_line_init_rn_f_node_index, target_hn_node_idx_0,target_hn_node_idx_1));

        /** 
         * Write data into Cache of Randomly selected Third Request Node i.e RN-F with 
         * address of randomly selected different HN Nodes
         */
        for(int j=0; j<num_outstanding_xacts_to_generate; j++) begin
          //If cache_line_init_rn_f_node_index is initiating_rn_node_idx_1 or initiating_rn_node_idx_0, it means that there are only 2 RN-Fs in
          //the system. As the following cache init transactions correspond to the coherent transactions that are to be issued from initiating_rn_node_idx_0, the
          //cache init node index should be set to the other RN-F (initiating_rn_node_idx_1)
          if(cache_line_init_rn_f_node_index == initiating_rn_node_idx_1 || cache_line_init_rn_f_node_index == initiating_rn_node_idx_0)
              cache_line_init_rn_f_node_index = initiating_rn_node_idx_1;
          `svt_xvm_do_on_with(makeunique_seq1[j], p_sequencer.rn_virt_seqr[cache_line_init_rn_f_node_index].rn_xact_seqr,{
            sequence_length    == 1;
            hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
            use_seq_is_non_secure_access == 0;
            if(j%2 == 0) {
              seq_hn_node_idx  == target_hn_node_idx_0;
            }
            else {
              seq_hn_node_idx  == target_hn_node_idx_1;
            }
          })

          /** Waiting for above first set of MakeUnique transaction to complete */ 
          `svt_xvm_debug("body", $sformatf("%0s Waiting for First set of MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) to end",`SVT_CHI_PRINT_PREFIX(makeunique_seq1[j].write_tran),j, makeunique_seq1[j].write_tran.hn_node_idx, makeunique_seq1[j].write_tran.tgt_id));
          makeunique_seq1[j].write_tran.wait_end();

          if (makeunique_seq1[j].output_xacts[0].is_xact_dropped) begin
           `svt_xvm_debug("body", $sformatf("%0s First set of MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) is Droppped. Re-randomizing the transaction.",`SVT_CHI_PRINT_PREFIX(makeunique_seq1[j].write_tran),j, makeunique_seq1[j].write_tran.hn_node_idx, makeunique_seq1[j].write_tran.tgt_id));
           j--;
         end
         else begin
        
          `svt_xvm_debug("body", $sformatf("%0s First set of MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) ended",`SVT_CHI_PRINT_PREFIX(makeunique_seq1[j].write_tran),j, makeunique_seq1[j].write_tran.hn_node_idx, makeunique_seq1[j].write_tran.tgt_id));

          `svt_xvm_verbose("body", $sformatf("First set of MakeUnique transaction [%0d]  is %0s", j,makeunique_seq1[j].write_tran.sprint()));
        end //end of else condition of cache state check
        end // forloop of 1st set MakeUnique

        /** Retrieving addresses from output transactions generated by the sequence */
        foreach(makeunique_seq1[index1]) begin
          addr_collection_queue1.push_back(makeunique_seq1[index1].output_xacts[0].addr);
          seq_is_non_secure_access_queue1.push_back(makeunique_seq1[index1].output_xacts[0].is_non_secure_access);
        end  
          
        /** 
         * Write data into Cache of Randomly selected Third Request Node i.e RN-F with
         * address of randomly selected above different HN Nodes
         */
        for(int k=0; k<num_outstanding_xacts_to_generate; k++) begin
          //If cache_line_init_rn_f_node_index is initiating_rn_node_idx_1 or initiating_rn_node_idx_0, it means that there are only 2 RN-Fs in
          //the system. As the following cache init transactions correspond to the coherent transactions that are to be issued from initiating_rn_node_idx_1, the
          //cache init node index should be set to the other RN-F (initiating_rn_node_idx_0)
          if(cache_line_init_rn_f_node_index == initiating_rn_node_idx_1 || cache_line_init_rn_f_node_index == initiating_rn_node_idx_0)
              cache_line_init_rn_f_node_index = initiating_rn_node_idx_0;
          `svt_xvm_do_on_with(makeunique_seq2[k], p_sequencer.rn_virt_seqr[cache_line_init_rn_f_node_index].rn_xact_seqr,{
            sequence_length    == 1;
            hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
            use_seq_is_non_secure_access == 0;
            if(k%2 == 0) {
              seq_hn_node_idx  == target_hn_node_idx_1;
            }
            else {
              seq_hn_node_idx  == target_hn_node_idx_0;
            }
          })

          /** Waiting for above second set of MakeUnique transaction to complete */ 
          `svt_xvm_debug("body", $sformatf("%0s Waiting for Second set of MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) to end",`SVT_CHI_PRINT_PREFIX(makeunique_seq2[k].write_tran),k, makeunique_seq2[k].write_tran.hn_node_idx, makeunique_seq2[k].write_tran.tgt_id));
          makeunique_seq2[k].write_tran.wait_end();
         if (makeunique_seq2[k].output_xacts[0].is_xact_dropped) begin
          `svt_xvm_debug("body", $sformatf("%0s Waiting for Second set of MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) is Dropped. Re-randomizing the transaction. ",`SVT_CHI_PRINT_PREFIX(makeunique_seq2[k].write_tran),k, makeunique_seq2[k].write_tran.hn_node_idx, makeunique_seq2[k].write_tran.tgt_id));
            k--;
          end
          else begin

          `svt_xvm_debug("body", $sformatf("%0s Second set of MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) ended",`SVT_CHI_PRINT_PREFIX(makeunique_seq2[k].write_tran),k, makeunique_seq2[k].write_tran.hn_node_idx, makeunique_seq2[k].write_tran.tgt_id));

          `svt_xvm_verbose("body", $sformatf("Second set of MakeUnique transaction [%0d]  is %0s", k,makeunique_seq2[k].write_tran.sprint()));
        end //end of else condition of cache state check

        end // forloop of 2nd set of MakeUnique 

        /** Retrieving addresses from output transactions generated by the sequence */
        foreach(makeunique_seq2[index2]) begin
          addr_collection_queue2.push_back(makeunique_seq2[index2].output_xacts[0].addr);
          seq_is_non_secure_access_queue2.push_back(makeunique_seq2[index2].output_xacts[0].is_non_secure_access);
        end 
        `svt_xvm_debug("body",$sformatf("Ended cache initialization for %0d addresses from p_sequencer.rn_virt_seqr[%0d] to different HN idxs %0d and %0d", (2*num_outstanding_xacts_to_generate), cache_line_init_rn_f_node_index, target_hn_node_idx_0,target_hn_node_idx_1));

      end // if (perform_cache_initialization)

      `svt_xvm_debug("body",$sformatf("Starting transmission of CMO type transactions for %0d addresses from two different p_sequencer.rn_virt_seqr[%0d] and p_sequencer.rn_virt_seqr[%0d] to different HN idxs %0d and %0d with suspend_comp_ack set to 1",
                                      num_outstanding_xacts_to_generate, initiating_rn_node_idx_0, initiating_rn_node_idx_1, target_hn_node_idx_0,target_hn_node_idx_1));
        
      for(int x=0; x < num_outstanding_xacts_to_generate; x++) begin
        fork
          begin
            /** 
             * Randomly selected First RN fires any CMO transactions with above
             * MakeUnique transaction address/randomly selected different HN nodes,
             * depending on whetehr cache initialization is done or not
             */
            `svt_xvm_do_on_with(cmo_seq1[x], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,{
              sequence_length    == 1; 
              `ifdef SVT_CHI_ISSUE_E_ENABLE
               if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision >= svt_chi_node_configuration::ISSUE_E) {
                seq_txn_id         == (x*3);
               }
               else{
                seq_txn_id         == (x % num_outstanding_xacts_to_generate);
               }
              `else
                seq_txn_id         == (x % num_outstanding_xacts_to_generate);
              `endif
              if (perform_cache_initialization)
              {
                hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                min_addr           == addr_collection_queue1[x];
                max_addr           == addr_collection_queue1[x];
                seq_is_non_secure_access == seq_is_non_secure_access_queue1[x]; 
                use_seq_is_non_secure_access == 1;
              }
              else
              {
                hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
                use_seq_is_non_secure_access == 0;
                if(x%2 == 0) {
                  seq_hn_node_idx  == target_hn_node_idx_0;
                }
                else { 
                  seq_hn_node_idx  == target_hn_node_idx_1;
                }
              }
              `ifdef SVT_CHI_ISSUE_B_ENABLE
                if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) 
                  {
                    !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSIST, svt_chi_transaction::STASHONCEUNIQUE,svt_chi_transaction::STASHONCESHARED});
                  }
                `ifdef SVT_CHI_ISSUE_E_ENABLE
                else if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision < svt_chi_node_configuration::ISSUE_E){
                  !(seq_xact_type inside {svt_chi_transaction::STASHONCESEPUNIQUE, svt_chi_transaction::STASHONCESEPSHARED});
                  if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision < svt_chi_node_configuration::ISSUE_D){
                    !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                    if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0)
                      !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                  }
                  else if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision >= svt_chi_node_configuration::ISSUE_D){
                    if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].cleansharedpersistsep_xact_enable ==0)
                      !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                    if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0)
                      !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                  }
                }
                else if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision >= svt_chi_node_configuration::ISSUE_E){
                  if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].cleansharedpersistsep_xact_enable == 0)
                    !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                  if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0)
                    !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED,svt_chi_transaction::STASHONCESEPUNIQUE, svt_chi_transaction::STASHONCESEPSHARED});
                }
              `elsif SVT_CHI_ISSUE_D_ENABLE
                else if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision < svt_chi_node_configuration::ISSUE_D){
                  !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                  if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0)
                    !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                }
                else if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision >= svt_chi_node_configuration::ISSUE_D){
                  if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].cleansharedpersistsep_xact_enable ==0)
                    !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                  if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0){
                    !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                  }
                }
              `endif //issue_d_enable
                else if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0){
                    !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                  }
              `endif
            })
            `svt_xvm_debug("body", $sformatf("%0s First RN Transmitting CMO Transaction [%0d] targeted to HN (idx %0d, id %0d) ",`SVT_CHI_PRINT_PREFIX(cmo_seq1[x].cmo_tran),x, cmo_seq1[x].cmo_tran.hn_node_idx, cmo_seq1[x].cmo_tran.tgt_id));
            `svt_xvm_verbose("body", $sformatf("First RN CMO Transaction [%0d] is %0s", x,cmo_seq1[x].cmo_tran.sprint()));
          end 
          begin
            /** 
             * Randomly selected Second RN fires any CMO transactions with above 
             * another MakeUnique transaction address/randomly selected different HN 
             * nodes, depending on whetehr cache initialization is done or not
             */
            `svt_xvm_do_on_with(cmo_seq2[x], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,{
              sequence_length    == 1; 
              seq_txn_id         == (x % num_outstanding_xacts_to_generate);
              if (perform_cache_initialization)
              {
                hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                min_addr           == addr_collection_queue2[x];
                max_addr           == addr_collection_queue2[x];
                seq_is_non_secure_access == seq_is_non_secure_access_queue2[x]; 
                use_seq_is_non_secure_access == 1;
              }
              else
              {
                hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
                use_seq_is_non_secure_access == 0;
                if(x%2 == 0) {
                  seq_hn_node_idx  == target_hn_node_idx_1;
                }
                else {
                  seq_hn_node_idx  == target_hn_node_idx_0;
                }
              }
              `ifdef SVT_CHI_ISSUE_B_ENABLE
                if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) 
                  {
                    !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSIST, svt_chi_transaction::STASHONCEUNIQUE,svt_chi_transaction::STASHONCESHARED});
                  }
                `ifdef SVT_CHI_ISSUE_E_ENABLE
                else if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision < svt_chi_node_configuration::ISSUE_E){
                  !(seq_xact_type inside {svt_chi_transaction::STASHONCESEPUNIQUE, svt_chi_transaction::STASHONCESEPSHARED});
                  if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision < svt_chi_node_configuration::ISSUE_D){
                    !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                    if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 0)
                      !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                  }
                  else if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision >= svt_chi_node_configuration::ISSUE_D){
                    if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].cleansharedpersistsep_xact_enable ==0)
                      !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                    if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 0)
                      !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                  }
                }
                else if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision >= svt_chi_node_configuration::ISSUE_E){
                  if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].cleansharedpersistsep_xact_enable == 0)
                    !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                  if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 0)
                    !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED,svt_chi_transaction::STASHONCESEPUNIQUE, svt_chi_transaction::STASHONCESEPSHARED});
                }
              `elsif SVT_CHI_ISSUE_D_ENABLE
                else if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision < svt_chi_node_configuration::ISSUE_D){
                  !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                  if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 0)
                    !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                }
                else if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision >= svt_chi_node_configuration::ISSUE_D){
                  if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].cleansharedpersistsep_xact_enable ==0)
                    !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                  if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 0){
                    !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                  }
                }
              `endif //issue_d_enable
                else if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 0){
                    !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                  }
              `endif
            })
            `svt_xvm_debug("body", $sformatf("%0s Second RN Transmitting CMO Transaction [%0d] targeted to HN (idx %0d, id %0d) ",`SVT_CHI_PRINT_PREFIX(cmo_seq2[x].cmo_tran),x, cmo_seq2[x].cmo_tran.hn_node_idx, cmo_seq2[x].cmo_tran.tgt_id));
            `svt_xvm_verbose("body", $sformatf("Second RN CMO Transaction [%0d] is %0s", x,cmo_seq2[x].cmo_tran.sprint()));
          end  
        join  
      end // forloop of CMO from each selected RN 

      /**
       * Waiting for Request status to be Accepted for above  CMO transactions
       * from each selected RN
       */
      fork
        begin
          foreach(cmo_seq1[index3]) begin
            automatic int _index3 = index3;
                `svt_xvm_debug("body", $sformatf("%0s First RN CMO transaction [%0d] targeted to HN (idx %0d, id %0d), suspend_comp_ack %0b: waiting for response from interconnect",`SVT_CHI_PRINT_PREFIX(cmo_seq1[_index3].cmo_tran),_index3, cmo_seq1[_index3].cmo_tran.hn_node_idx, cmo_seq1[_index3].cmo_tran.tgt_id,cmo_seq1[_index3].cmo_tran.suspend_comp_ack));
            fork
            begin
              fork
                begin
                  cmo_seq1[_index3].cmo_tran.wait_for_tx_compack_prereqs();
                end
                begin
                  wait(cmo_seq1[_index3].cmo_tran.req_status == svt_chi_transaction::RETRY);// begin
                end
              join_any
              disable fork;
            end
            join
            received_cmo_seq1_responses++;
                      `svt_xvm_debug("body", $sformatf("%0s First RN CMO transaction [%0d] targeted to HN (idx %0d, id %0d), suspend_comp_ack %0b: received response from interconnect. Total responses received %0d",`SVT_CHI_PRINT_PREFIX(cmo_seq1[_index3].cmo_tran),_index3, cmo_seq1[_index3].cmo_tran.hn_node_idx, cmo_seq1[_index3].cmo_tran.tgt_id,cmo_seq1[_index3].cmo_tran.suspend_comp_ack, received_cmo_seq1_responses));          
          end
        end
        begin
          foreach(cmo_seq2[index4]) begin
            automatic int _index4 = index4;
                `svt_xvm_debug("body", $sformatf("%0s Second RN CMO transaction [%0d] targeted to HN (idx %0d, id %0d), suspend_comp_ack %0b: waiting for response from interconnect",`SVT_CHI_PRINT_PREFIX(cmo_seq2[_index4].cmo_tran),_index4, cmo_seq2[_index4].cmo_tran.hn_node_idx, cmo_seq2[_index4].cmo_tran.tgt_id,cmo_seq2[_index4].cmo_tran.suspend_comp_ack));
            fork
            begin
              fork
                begin
                  cmo_seq2[_index4].cmo_tran.wait_for_tx_compack_prereqs();
                end
                begin
                  wait(cmo_seq2[_index4].cmo_tran.req_status == svt_chi_transaction::RETRY);// begin
                end
              join_any
              disable fork;
            end
            join
            received_cmo_seq2_responses++;
                      `svt_xvm_debug("body", $sformatf("%0s Second RN CMO transaction [%0d] targeted to HN (idx %0d, id %0d), suspend_comp_ack %0b: received response from interconnect. Total responses received %0d",`SVT_CHI_PRINT_PREFIX(cmo_seq2[_index4].cmo_tran),_index4, cmo_seq2[_index4].cmo_tran.hn_node_idx, cmo_seq2[_index4].cmo_tran.tgt_id,cmo_seq2[_index4].cmo_tran.suspend_comp_ack, received_cmo_seq2_responses));         
          end
        end  
      join_none

      /** Wait until All Comp responses are received at each selected RN */
      fork
        begin
          `svt_xvm_debug("body",$sformatf("Completed initiation of First RN CMO type transactions for %0d addresses from two different p_sequencer.rn_virt_seqr[%0d] and p_sequencer.rn_virt_seqr[%0d] to different HN idxs %0d and %0d with suspend_comp_ack set to 1, and waiting to receive responses from interconnect.", num_outstanding_xacts_to_generate, initiating_rn_node_idx_0, initiating_rn_node_idx_1, target_hn_node_idx_0,target_hn_node_idx_1)); 
          wait(received_cmo_seq1_responses == num_outstanding_xacts_to_generate);
          `svt_xvm_debug("body",$sformatf("Received responses from interconnect to First RN CMO type transactions for %0d addresses from two different p_sequencer.rn_virt_seqr[%0d] and p_sequencer.rn_virt_seqr[%0d] to different HN idxs %0d and %0d with suspend_comp_ack set to 1",num_outstanding_xacts_to_generate, initiating_rn_node_idx_0, initiating_rn_node_idx_1,target_hn_node_idx_0,target_hn_node_idx_1));
        end
        begin
          `svt_xvm_debug("body",$sformatf("Completed initiation of Second RN CMO type transactions for %0d addresses from two different p_sequencer.rn_virt_seqr[%0d] and p_sequencer.rn_virt_seqr[%0d] to different HN idxs %0d and %0d with suspend_comp_ack set to 1, and waiting to receive responses from interconnect.", num_outstanding_xacts_to_generate, initiating_rn_node_idx_0, initiating_rn_node_idx_1, target_hn_node_idx_0,target_hn_node_idx_1)); 
          wait(received_cmo_seq2_responses == num_outstanding_xacts_to_generate);  
          `svt_xvm_debug("body",$sformatf("Received responses from interconnect to Second RN CMO type transactions for %0d addresses from two different p_sequencer.rn_virt_seqr[%0d] and p_sequencer.rn_virt_seqr[%0d] to different HN idxs %0d and %0d with suspend_comp_ack set to 1",num_outstanding_xacts_to_generate, initiating_rn_node_idx_0, initiating_rn_node_idx_1,target_hn_node_idx_0,target_hn_node_idx_1));
        end
      join  

      /** Self Check1: To check suspend_comp_ack should not be modified to zero by the VIP 
       *  before reseting from test bench.
       */ 
      fork
        begin
          foreach (cmo_seq1[self_check_idx1]) begin
            if (!cmo_seq1[self_check_idx1].cmo_tran.is_terminated()) begin
              if (cmo_seq1[self_check_idx1].cmo_tran.suspend_comp_ack == 0) begin
                `svt_xvm_error("body", $sformatf("%0s Firsr RN CMO_SEQ suspend_comp_ack should be 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(cmo_seq1[self_check_idx1].cmo_tran)));
              end
              else begin
                `svt_xvm_debug("body", $sformatf("%0s Firsr RN CMO_SEQ suspend_comp_ack is 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(cmo_seq1[self_check_idx1].cmo_tran)));
              end
            end  
          end
        end 
        begin
          foreach (cmo_seq2[self_check_idx4]) begin
            if (!cmo_seq2[self_check_idx4].cmo_tran.is_terminated()) begin
              if (cmo_seq2[self_check_idx4].cmo_tran.suspend_comp_ack == 0) begin
                `svt_xvm_error("body", $sformatf("%0s Second RN CMO_SEQ suspend_comp_ack should be 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(cmo_seq2[self_check_idx4].cmo_tran)));
              end
              else begin
                `svt_xvm_debug("body", $sformatf("%0s Second RN CMO_SEQ suspend_comp_ack is 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(cmo_seq2[self_check_idx4].cmo_tran)));
              end
            end  
          end
        end
      join
        
      /** Self Check2: To check transaction is not ended by the VIP before resuming the 
       *  suspend_comp_ack to zero from the test bench 
       */ 
      fork
        begin
          foreach(cmo_seq1[self_check_idx2]) begin
            if (!cmo_seq1[self_check_idx2].cmo_tran.is_terminated()) begin
              if (cmo_seq1[self_check_idx2].cmo_tran.end_event.is_on() == 1) begin
                // Fail  event has triggered
                `svt_xvm_error("body", $sformatf("First RN CMO_SEQ Unexpected: %0s Transaction's end_event triggered when suspend_comp_ack is still 1.", `SVT_CHI_PRINT_PREFIX(cmo_seq1[self_check_idx2].cmo_tran)));
              end
              else begin
                // Pass  event is not triggered
                `svt_xvm_debug("body", $sformatf("First RN CMO_SEQ Expected: %0s Transaction's end_event is not triggered when suspend_comp_ack is still 1.", `SVT_CHI_PRINT_PREFIX(cmo_seq1[self_check_idx2].cmo_tran)));
              end
            end  
          end
        end
        begin
          foreach(cmo_seq2[self_check_idx6]) begin
            if (!cmo_seq2[self_check_idx6].cmo_tran.is_terminated()) begin
              if (cmo_seq2[self_check_idx6].cmo_tran.end_event.is_on() == 1) begin
                // Fail  event has triggered
                `svt_xvm_error("body", $sformatf("Second RN CMO_SEQ Unexpected: %0s Transaction's end_event triggered when suspend_comp_ack is still 1.", `SVT_CHI_PRINT_PREFIX(cmo_seq2[self_check_idx6].cmo_tran)));
              end
              else begin
                // Pass  event is not triggered
                `svt_xvm_debug("body", $sformatf("Second RN CMO_SEQ Expected: %0s Transaction's end_event is not triggered when suspend_comp_ack is still 1.", `SVT_CHI_PRINT_PREFIX(cmo_seq2[self_check_idx6].cmo_tran)));
              end
            end  
          end
        end
      join
      
      /** Resuming all CompAck responses of above CMO transactions at each selected RN */
      fork
        begin
          foreach(cmo_seq1[index5]) begin
            `svt_xvm_debug("body",$sformatf("Received responses for all First RN CMO type transactions from interconnect, resuming the transactions by setting svt_chi_rn_transaction::suspend_comp_ack set to 0 %0s",`SVT_CHI_PRINT_PREFIX(cmo_seq1[index5].cmo_tran)));
            cmo_seq1[index5].cmo_tran.suspend_comp_ack=0;
            `svt_xvm_debug("body", $sformatf("For iteration %0d : After Resume, received_cmo_seq1_responses is %0d,suspend_comp_ack is %b and exp_comp_ack is %b", index5,received_cmo_seq1_responses,cmo_seq1[index5].cmo_tran.suspend_comp_ack,cmo_seq1[index5].cmo_tran.exp_comp_ack));
          end
        end
        begin
          foreach(cmo_seq2[index6]) begin
            `svt_xvm_debug("body",$sformatf("Received responses for all Second RN CMO type transactions from interconnect, resuming the transactions by setting svt_chi_rn_transaction::suspend_comp_ack set to 0 %0s",`SVT_CHI_PRINT_PREFIX(cmo_seq2[index6].cmo_tran)));
            cmo_seq2[index6].cmo_tran.suspend_comp_ack=0;
            `svt_xvm_debug("body", $sformatf("For iteration %0d : After Resume, received_cmo_seq2_responses is %0d,suspend_comp_ack is %b and exp_comp_ack is %b", index6,received_cmo_seq2_responses,cmo_seq2[index6].cmo_tran.suspend_comp_ack,cmo_seq2[index6].cmo_tran.exp_comp_ack));
          end
        end
      join
        
      `svt_xvm_debug("body",$sformatf("Waiting for completion of all the outstanding CMO type transactions"));   
      /** Waiting for above CMO outstanding transactions to complete for each selected RN */ 
      fork
        begin
          foreach(cmo_seq1[index7]) begin
            `svt_xvm_debug("body", $sformatf("Waiting for above cmo_seq1[%0d] transaction %0s to end", index7, `SVT_CHI_PRINT_PREFIX(cmo_seq1[index7].cmo_tran)));
            cmo_seq1[index7].cmo_tran.wait_end();
            
            /** Self Check3: To check suspend_comp_ack should not be asserted after the transaction completes 
             *  as it is reseted from test bench
             */
            if (!cmo_seq1[index7].cmo_tran.is_terminated()) begin
              if (cmo_seq1[index7].cmo_tran.suspend_comp_ack == 1) begin
                `svt_xvm_error("body", $sformatf("%0s Firsr RN CMO_SEQ suspend_comp_ack should be 0 as it should be reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(cmo_seq1[index7].cmo_tran)));
              end
              else begin
                `svt_xvm_debug("body", $sformatf("%0s Firsr RN CMO_SEQ suspend_comp_ack is 0 as it is reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(cmo_seq1[index7].cmo_tran)));
              end
            end
          end
        end
        begin
          foreach(cmo_seq2[index8]) begin
            `svt_xvm_debug("body", $sformatf("Waiting for above cmo_seq2[%0d] transaction %0s to end", index8, `SVT_CHI_PRINT_PREFIX(cmo_seq2[index8].cmo_tran)));
            cmo_seq2[index8].cmo_tran.wait_end(); 
            
            /** Self Check3: To check suspend_comp_ack should not be asserted after the transaction completes 
             *  as it is reseted from test bench
             */
            if (!cmo_seq2[index8].cmo_tran.is_terminated()) begin
              if (cmo_seq2[index8].cmo_tran.suspend_comp_ack == 1) begin
                `svt_xvm_error("body", $sformatf("%0s Second RN CMO_SEQ suspend_comp_ack should be 0 as it should be reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(cmo_seq2[index8].cmo_tran)));
              end
              else begin
                `svt_xvm_debug("body", $sformatf("%0s Second RN CMO_SEQ suspend_comp_ack is 0 as it is reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(cmo_seq2[index8].cmo_tran)));
              end
            end
          end
        end
      join  
      `svt_xvm_debug("body",$sformatf("Received completions for all CMO type outstanding transactions"));
 
      // Targeted HN IDs from both RNs should be different
      for(int index9=0; index9 < num_outstanding_xacts_to_generate; index9++) begin
        int hn_idx_0, hn_idx_1;
        hn_idx_0 = sys_cfg.get_hn_idx(cmo_seq1[index9].output_xacts[0].addr);
        hn_idx_1 = sys_cfg.get_hn_idx(cmo_seq2[index9].output_xacts[0].addr);
        if (hn_idx_0 != hn_idx_1) begin
          // pass
          `svt_xvm_debug("body", $sformatf("Targeted HN Index from both RNs is different as expected.  rn[%0d] to hn_idx[%0d], rn[%0d] to hn_idx[%0d]", initiating_rn_node_idx_0, hn_idx_0, initiating_rn_node_idx_1, hn_idx_1));
        end
        else begin
          // fail
          `svt_xvm_error("body", $sformatf("Targeted HN Index from both RNs is same, which is unexpected.  rn[%0d] %0s transaction to hn_idx[%0d], rn[%0d] %0s transaction to hn_idx[%0d]", initiating_rn_node_idx_0, `SVT_CHI_PRINT_PREFIX( cmo_seq1[index9].output_xacts[0]), hn_idx_0, initiating_rn_node_idx_1, `SVT_CHI_PRINT_PREFIX( cmo_seq2[index9].output_xacts[0]), hn_idx_1));
        end
      end
 
      /** Reset received_cmo_seq1_responses to Zero */
      received_cmo_seq1_responses = 0;

      /** Reset received_cmo_seq2_responses to Zero */
      received_cmo_seq2_responses = 0;

      /** Delete the contents of both address collection queues */
      addr_collection_queue1.delete();
      addr_collection_queue2.delete();
      
    end //for sequence_length
    /** 
     * To check the Interconnect HN's shall responds properly for all outstanding
     * CMO transactions to respective initiating RN.<br>
     * Check done by System monitor(List of checkers)<br>
     *  #- snoop_data_integrity_check 
     *  .  
     */
    `svt_xvm_debug("body", "Exiting...");
  endtask: body
  
  //-----------------------------------------------------------------------------  
  virtual task post_start();
    super.post_start();
    drop_phase_objection();
  endtask

endclass: svt_chi_system_protocol_flow_ctrl_cmo_outstanding_diff_rn_diff_hn_virtual_sequence

//-------------------------------------------------------------------------------  
function svt_chi_system_protocol_flow_ctrl_cmo_outstanding_diff_rn_diff_hn_virtual_sequence::new(string name="svt_chi_system_protocol_flow_ctrl_cmo_outstanding_diff_rn_diff_hn_virtual_sequence");
  super.new(name);
endfunction

`ifndef GUARD_CHI_RN_BARRIER_DIRECTED_VIRTUAL_SEQUENCE_SV
`define GUARD_CHI_RN_BARRIER_DIRECTED_VIRTUAL_SEQUENCE_SV
/**
 * Abstract:
 * chi_rn_barrier_directed_virtual_sequence is used by test to provide initiator
 * scenario information to the RN agent present in the System Env.
 * This class defines a sequence in which a CHI WRITE followed by a CHI READ
 * sequence is generated by assigning values to the transactions rather than
 * randomization, and then transmitted using `uvm_send.
 *
 * Execution phase: main_phase
 * Sequencer: Master agent sequencer
 */
class chi_rn_barrier_directed_virtual_sequence extends svt_chi_system_base_virtual_sequence;
  /** Parameter that controls the number of transactions that will be generated */
  rand int unsigned sequence_length = 10;
  bit enable_outstanding = 0;
  bit enable_eob_ecb_back_to_back = 0;
  bit go_before_barrier = 1;
  
  /** Sub sequences initiated from this sequence */
  chi_rn_barrier_directed_sequence rn0_eo_barrier_seq[];
  chi_rn_barrier_directed_sequence rn0_ec_barrier_seq[];
  chi_rn_directed_noncoherent_xact_sequence rn0_normal_read_tran_seq[];
  chi_rn_directed_noncoherent_xact_sequence rn0_pb_normal_read_tran_seq[];
  chi_rn_directed_noncoherent_xact_sequence rn0_normal_write_tran_seq[];
  chi_rn_directed_noncoherent_xact_sequence rn0_pb_normal_write_tran_seq[];
  bit rn0_eo_barrier_sent[], rn0_ec_barrier_sent[];
  svt_chi_rn_transaction last_barrier_req;
  /** Constrain the sequence length to a reasonable value */
  constraint reasonable_sequence_length
  {
    sequence_length <= 50;
  }
  
  /** UVM Object Utility macro */
  `uvm_object_utils(chi_rn_barrier_directed_virtual_sequence)
  
  /** Constructor */
  function new (string name="chi_rn_barrier_directed_virtual_sequence");
    super.new(name);
  endfunction
  
  /** pre_body() task for raising the pbjection */
  virtual task pre_body();
    raise_phase_objection();
  endtask:pre_body

  /** The body() task is the actual logic of the sequence */
  virtual task body();
    
    svt_configuration get_cfg;
    svt_chi_system_configuration cfg;
    svt_chi_rn_transaction tr;

    bit status;
    bit enable_outstanding_status;
    bit enable_eob_ecb_back_to_back_status;
    bit go_before_barrier_status;
    
    /** stores the data written in cache */
    bit[511:0] cache_data[];
    /** Transaction address */
    bit[(`SVT_CHI_MAX_ADDR_WIDTH-1):0] cache_addr[];
    bit [(`SVT_CHI_TXN_ID_WIDTH-1):0] _txn_id = 0;    
  
    // Address of post barrier store which is polled by observers 
    bit [(`SVT_CHI_MAX_ADDR_WIDTH-1):0] local_store_address;


    `uvm_info("body", "Entered....", UVM_HIGH);
    
    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :initiating_rn_f_node_index_0;

    `svt_xvm_debug("body", $sformatf("initiating_rn_node_idx_0 is %0d as a result of %0s.", initiating_rn_node_idx_0, initiating_rn_node_index_0_status ? "config DB" : "Randomization"));

    /** Obtain a handle to the port configuration */
    p_sequencer.get_cfg(get_cfg);
    if (!$cast(cfg, get_cfg)) begin
      `uvm_fatal("body", "Unable to $cast the configuration to a svt_chi_system_configuration class");
    end
    
    status = uvm_config_db #(int unsigned)::get(null, get_full_name(), "sequence_length", sequence_length);
    `uvm_info("body", $sformatf("sequence_length is %0d as a result of %0s.", sequence_length, status ? "config DB" : "randomization"), UVM_HIGH);
    enable_outstanding_status = uvm_config_db#(bit)::get(null, get_full_name(), "enable_outstanding", enable_outstanding);
    `uvm_info("body", $sformatf("enable_outstanding is %0b as a result of %0s", enable_outstanding, (enable_outstanding_status?"config DB":"default setting")), UVM_HIGH);

    enable_eob_ecb_back_to_back_status = uvm_config_db#(bit)::get(null, get_full_name(), "enable_eob_ecb_back_to_back", enable_eob_ecb_back_to_back);
    `uvm_info("body", $sformatf("enable_eob_ecb_back_to_back is %0b as a result of %0s", enable_eob_ecb_back_to_back, (enable_eob_ecb_back_to_back_status?"config DB":"default setting")), UVM_HIGH);

     go_before_barrier_status = uvm_config_db#(bit)::get(null, get_full_name(), "go_before_barrier", go_before_barrier);
    `uvm_info("body", $sformatf("go_before_barrier is %0b as a result of %0s", go_before_barrier, (go_before_barrier_status?"config DB":"default setting")), UVM_HIGH);   
    
    cache_addr = new[sequence_length];
    cache_data = new[sequence_length];
    rn0_eo_barrier_seq = new[sequence_length];
    rn0_ec_barrier_seq = new[sequence_length];
    rn0_normal_read_tran_seq = new[sequence_length];
    rn0_pb_normal_read_tran_seq = new[sequence_length];
    rn0_normal_write_tran_seq = new[sequence_length];
    rn0_pb_normal_write_tran_seq = new[sequence_length];
    rn0_eo_barrier_sent = new[sequence_length];
    rn0_ec_barrier_sent = new[sequence_length];
    
    /** Send 1 WriteNoSnp Pre barrier transaction followed by a ReadNoSnp */
    for(int i=0; i<sequence_length; i++) begin          
      /** send READNOSNP and WRITENOSNPFULL pre-barrier transactions those need global observability */
       `svt_xvm_create_on(rn0_normal_write_tran_seq[i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr)
       void'(rn0_normal_write_tran_seq[i].randomize() with {
         sequence_length == 1;
       `ifdef TB_CHI_4RNF_3MASTER_2HNF_3HNI_5AXISLAVE
          addr == (`SVT_CHI_MAX_ADDR_WIDTH'h0FF_C000_01C0 | ('h100 << i));
       `else
          addr == (`SVT_CHI_MAX_ADDR_WIDTH'h100_0000_01C0 | ('h100 << i));
       `endif
         txn_id==_txn_id;
         xact_type == svt_chi_transaction::WRITENOSNPFULL;
         requires_go_before_barrier == go_before_barrier;    
         is_cacheable == 0;
         is_barrier_associated == 0;
         seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;    
       });
      rn0_normal_write_tran_seq[i].start(p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr);
      _txn_id++;
      
       `svt_xvm_create_on(rn0_normal_read_tran_seq[i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr)
       void'(rn0_normal_read_tran_seq[i].randomize() with {
         sequence_length == 1;
       `ifdef TB_CHI_4RNF_3MASTER_2HNF_3HNI_5AXISLAVE
          addr == (`SVT_CHI_MAX_ADDR_WIDTH'h0FF_C000_0100 | ('h100 << i));
       `else
          addr == (`SVT_CHI_MAX_ADDR_WIDTH'h100_0000_0100 | ('h100 << i));
       `endif
         txn_id==_txn_id;
         xact_type == svt_chi_transaction::READNOSNP;
         requires_go_before_barrier == 0;
         is_cacheable == 0;
         is_barrier_associated == 0;
         seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
       });
      rn0_normal_read_tran_seq[i].start(p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr);
      _txn_id++;
     
      fork
       begin
         /** send barrier transaction */
 
         // EOB is sent in first iteration; ECB is sent in next iteration.
         if (i%2) begin
            `svt_xvm_create_on(rn0_ec_barrier_seq[i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr)
            void'(rn0_ec_barrier_seq[i].randomize() with {
               sequence_length == 1;
               txn_id==_txn_id;
               xact_type == svt_chi_transaction::ECBARRIER;
             });
           rn0_ec_barrier_seq[i].start(p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr);
           _txn_id++;
           rn0_ec_barrier_sent[i] = 1;  
         end
         else begin   
            `svt_xvm_create_on(rn0_eo_barrier_seq[i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr)
            void'(rn0_eo_barrier_seq[i].randomize() with {
               sequence_length == 1;
               txn_id==_txn_id;
               xact_type == svt_chi_transaction::EOBARRIER;
             });
           rn0_eo_barrier_seq[i].start(p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr);
           _txn_id++;
           rn0_eo_barrier_sent[i] = 1;
         end

         if (!$cast(last_barrier_req, p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr.last_req())) begin
           `uvm_fatal("body", $sformatf("Unable to cast last_req from seqr"))
         end
         else begin
           `uvm_info("body", $sformatf("Got the last_req %0s from seqr", `SVT_CHI_PRINT_PREFIX(last_barrier_req)), UVM_HIGH)
         end
       end 

       begin
         /** Send Post barrier transactions */
          `svt_xvm_create_on(rn0_pb_normal_read_tran_seq[i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr)
          void'(rn0_pb_normal_read_tran_seq[i].randomize() with {
            sequence_length == 1;

          `ifdef TB_CHI_4RNF_3MASTER_2HNF_3HNI_5AXISLAVE
             addr == (`SVT_CHI_MAX_ADDR_WIDTH'h0FF_C000_1100 | ('h100 << i));
          `else
             addr == (`SVT_CHI_MAX_ADDR_WIDTH'h100_0000_1100 | ('h100 << i));
          `endif
            txn_id==_txn_id;
            xact_type == svt_chi_transaction::READNOSNP;
            requires_go_before_barrier == 0;
            is_cacheable == 0;
            is_barrier_associated == 1;
            seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;    
          });
         rn0_pb_normal_read_tran_seq[i].start(p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr);
         _txn_id++;
         
          `svt_xvm_create_on(rn0_pb_normal_write_tran_seq[i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr)
          void'(rn0_pb_normal_write_tran_seq[i].randomize() with {
            sequence_length == 1;
          `ifdef TB_CHI_4RNF_3MASTER_2HNF_3HNI_5AXISLAVE
             addr == (`SVT_CHI_MAX_ADDR_WIDTH'h0FF_C000_11C0 | ('h100 << i));
          `else
             addr == (`SVT_CHI_MAX_ADDR_WIDTH'h100_0000_11C0 | ('h100 << i));
          `endif
            txn_id==_txn_id;
            xact_type == svt_chi_transaction::WRITENOSNPFULL;
            requires_go_before_barrier == 0;    
            is_cacheable == 0;
            is_barrier_associated == 1;
            seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;        
          });
         rn0_pb_normal_write_tran_seq[i].start(p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr);
         _txn_id++;
       end 
      join 
    
    end

    `uvm_info("body", "Exiting...", UVM_HIGH);
  endtask:body

  virtual function void mid_do(uvm_sequence_item this_item);
    chi_rn_directed_noncoherent_xact_sequence rdwr_seq;
    if ($cast(rdwr_seq, this_item)) begin
      if (rdwr_seq.is_barrier_associated) begin
        rdwr_seq.associated_barrier_xact = last_barrier_req;
      end
      else begin
        rdwr_seq.associated_barrier_xact = null;
      end
    end
    
  endfunction
  
  /** post_body() task */
  virtual task post_body();
    fork
      begin
        foreach(rn0_normal_read_tran_seq[i]) begin
          `uvm_info("post_body", $sformatf("Waiting for response of rn0_normal_read_tran_seq[%0d]", i), UVM_HIGH)
          wait (rn0_normal_read_tran_seq[i].received_responses == 1);
          `uvm_info("post_body", $sformatf("Response of sequence rn0_normal_read_tran_seq[%0d] received", i), UVM_HIGH)
        end
      end       
      begin
        foreach(rn0_normal_write_tran_seq[i]) begin
          `uvm_info("post_body", $sformatf("Waiting for response of rn0_normal_write_tran_seq[%0d]", i), UVM_HIGH)
          wait (rn0_normal_write_tran_seq[i].received_responses == 1);
          `uvm_info("post_body", $sformatf("Response of sequence rn0_normal_write_tran_seq[%0d] received", i), UVM_HIGH)
        end
      end     
      begin
        foreach(rn0_pb_normal_read_tran_seq[i]) begin
          `uvm_info("post_body", $sformatf("Waiting for response of rn0_pb_normal_read_tran_seq[%0d]", i), UVM_HIGH)
          wait (rn0_pb_normal_read_tran_seq[i].received_responses == 1);
          `uvm_info("post_body", $sformatf("Response of sequence rn0_pb_normal_read_tran_seq[%0d] received", i), UVM_HIGH)
        end
      end       
      begin
        foreach(rn0_pb_normal_write_tran_seq[i]) begin
          `uvm_info("post_body", $sformatf("Waiting for response of rn0_pb_normal_write_tran_seq[%0d]", i), UVM_HIGH)
          wait (rn0_pb_normal_write_tran_seq[i].received_responses == 1);
          `uvm_info("post_body", $sformatf("Response of sequence rn0_pb_normal_write_tran_seq[%0d] received", i), UVM_HIGH)
        end
      end     
      begin
        foreach(rn0_eo_barrier_seq[i]) begin
          if (rn0_eo_barrier_sent[i]) begin
            `uvm_info("post_body", $sformatf("Waiting for response of rn0_eo_barrier_seq[%0d]", i), UVM_HIGH)
            wait (rn0_eo_barrier_seq[i].received_responses == 1);
            `uvm_info("post_body", $sformatf("Response of sequence rn0_eo_barrier_seq[%0d] received", i), UVM_HIGH)
          end
        end
      end  
      begin
        foreach(rn0_ec_barrier_seq[i]) begin
          if (rn0_ec_barrier_sent[i]) begin
            `uvm_info("post_body", $sformatf("Waiting for response of rn0_ec_barrier_seq[%0d]", i), UVM_HIGH)
            wait (rn0_ec_barrier_seq[i].received_responses == 1);
            `uvm_info("post_body", $sformatf("Response of sequence rn0_ec_barrier_seq[%0d] received", i), UVM_HIGH)
          end
        end
      end
    join
    drop_phase_objection();
  endtask:post_body

endclass:chi_rn_barrier_directed_virtual_sequence
`endif // GUARD_CHI_RN_BARRIER_DIRECTED_VIRTUAL_SEQUENCE_SV

/**
 * @groupname CHI_SYS_HAZARD
 * Abstract:
 * svt_chi_system_protocol_flow_ctrl_hn_read_read_hazard_directed_virtual_sequence
 * provides a sequence to test how components handle various hazard conditions
 * applicable for read transactions
 * 1. Send MAKEUNIQUE transaction to random address from random RN
 * 2. Send read type of transactions to the above same address from two different RN's.
 * 3. Check the order in which the two requests are processed by HN.
 * .
 */

class svt_chi_system_protocol_flow_ctrl_hn_read_read_hazard_directed_virtual_sequence extends svt_chi_system_protocol_flow_ctrl_xact_hazard_virtual_sequence;

  /** Parameter that controls the number of transactions that will be generated */
  rand int unsigned sequence_length = 10;

  rand bit enable_outstanding = 0;

  bit enable_outstanding_status = 0;

  /** Constrain the sequence length to a reasonable value */
  constraint reasonable_sequence_length {
    sequence_length <= 100;
  }

  /** UVM Object Utility macro */
  `uvm_object_utils(svt_chi_system_protocol_flow_ctrl_hn_read_read_hazard_directed_virtual_sequence)

  extern function new(string name="svt_chi_system_protocol_flow_ctrl_hn_read_read_hazard_directed_virtual_sequence"); 

  virtual task pre_body();
    raise_phase_objection();
  endtask
  
  virtual task body();
    bit                           status;
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0] txn_address;
    bit [`SVT_CHI_MAX_DATA_WIDTH -1:0] txn_data;
    bit txn_mem_attr_allocate_hint, txn_snp_attr_snp_domain_type, txn_is_non_secure_access;

    /** Sub sequences initiated from this sequence */
    svt_chi_rn_read_type_transaction_directed_sequence read_seq_0[int],read_seq_1[int];

    /** Sub sequences initiated from this sequence */
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq;
    svt_chi_rn_copyback_type_transaction_directed_sequence copyback_seq;

    `uvm_info("body", "Entered ...", UVM_HIGH)
    super.body();
    // Default
    enable_outstanding = 0;
    status = uvm_config_db #(int unsigned)::get(null, get_full_name(), "sequence_length", sequence_length);
    `uvm_info("body", $sformatf("sequence_length is %0d as a result of %0s.", sequence_length, status ? "config DB" : "randomization"), UVM_HIGH);

    enable_outstanding_status = uvm_config_db#(bit)::get(m_sequencer, get_type_name(), "enable_outstanding", enable_outstanding);
    `uvm_info("body", $sformatf("enable_outstanding is %0b as a result of %0s", enable_outstanding, (enable_outstanding_status?"config DB":"default setting")), UVM_HIGH);

    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :initiating_rn_f_node_index_0;
    initiating_rn_node_idx_1 = initiating_rn_node_index_1_status ? initiating_rn_node_index_1_from_config_db :initiating_rn_f_node_index_1;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_f_node_index_0;

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /** 
     * If the number of active_participating_rn_f_nodes are greater than 2, then
     * we can initialize the cache/memory from the RN having node index 
     * initiating_rn_f_node_index_2.
     * If the number of active_participating_rn_f_nodes are equal to 2, then
     * we can initialize the cache/memory from the RN having node index 
     * initiating_rn_node_idx_0.
     *  
     */
    if((active_participating_rn_f_nodes.size()>2) && (valid_initiating_rn_f_node_index_2))begin
      cache_initializing_rn_node_index = initiating_rn_f_node_index_2;
      /**
       * If the cache_initializing_rn_node_index is same as any of the RN node indices 
       * which are passed through config i.e initiating_rn_node_idx_0,initiating_rn_node_idx_1,
       * then assert perform_initialization_from_rn_used_for_hazard to 1, so that RN will be
       * in valid state to initilize the respective transaction.
       */
      if(initiating_rn_node_index_0_status || initiating_rn_node_index_1_status)begin
         if((cache_initializing_rn_node_index == initiating_rn_node_idx_0)||(cache_initializing_rn_node_index == initiating_rn_node_idx_1))begin
           perform_initialization_from_rn_used_for_hazard =  1;
         end
         else begin
           perform_initialization_from_rn_used_for_hazard =  0;
         end  
      end  
    end else begin
      cache_initializing_rn_node_index = initiating_rn_node_idx_0;
      perform_initialization_from_rn_used_for_hazard =  1;
    end

    str_initiating_rn_node_indices = "";
    /** Display the contents of Active Participating RN-F Nodes */
    foreach (active_participating_rn_f_nodes[j]) begin
      str_initiating_rn_node_indices = {str_initiating_rn_node_indices, $sformatf(" %0d", active_participating_rn_f_nodes[j])};
    end 
    str_initiating_rn_node_indices = {str_initiating_rn_node_indices, $sformatf("\n RN nodes used to initiate the transactions are initiating_rn_node_idx_0 : %0d, initiating_rn_node_idx_1 : %0d,cache_initializing_rn_node_index : %0d ", initiating_rn_node_idx_0, initiating_rn_node_idx_1, cache_initializing_rn_node_index)};
    `svt_xvm_debug("body", $sformatf("contents of active_participating_rn_f_nodes and RN nodes used to initiate the transactions are %0s", str_initiating_rn_node_indices));

    for(int i = 0; i < sequence_length; i++) begin
      bit rn0_is_unique, rn0_is_clean, rn1_is_unique, rn1_is_clean, rn0_read_status, rn1_read_status;
      bit rn_cache_dirty_state,rn_cache_unique_state;

      /** Write data into Cache of Randomly selected first RN with address of randomly selected HN Node */
      `svt_xvm_do_on_with(makeunique_seq, p_sequencer.rn_virt_seqr[cache_initializing_rn_node_index].rn_xact_seqr,
      {
        sequence_length == 1;
        hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
        seq_hn_node_idx == target_hn_node_idx_0;
        use_seq_is_non_secure_access == 0;        
      })

      /** Wait for MakeUnique transactions to finish */ 
      makeunique_seq.write_tran.wait_end();
      txn_address = makeunique_seq.output_xacts[0].addr;
      txn_data = makeunique_seq.data_in_cache;
      txn_mem_attr_allocate_hint = makeunique_seq.output_xacts[0].mem_attr_allocate_hint;
      txn_snp_attr_snp_domain_type = makeunique_seq.output_xacts[0].snp_attr_snp_domain_type;
      txn_is_non_secure_access = makeunique_seq.output_xacts[0].is_non_secure_access;

      /** Writeback the data to the main memory at the respective address. */ 
      if(perform_initialization_from_rn_used_for_hazard) begin
        `svt_xvm_do_on_with(copyback_seq, p_sequencer.rn_virt_seqr[cache_initializing_rn_node_index].rn_xact_seqr,
        {
          sequence_length == 1;
          data_in_cache == txn_data;
          seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
          hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
          min_addr == txn_address;
          max_addr == txn_address;
          seq_xact_type == svt_chi_transaction::WRITEBACKFULL;
          seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
          seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
          seq_is_non_secure_access == txn_is_non_secure_access;
          use_seq_is_non_secure_access == 1;        
        }
        )
        /** Waiting for copyback transaction to complete */ 
        copyback_seq.copyback_tran.wait_end();
      end 

      /* READ-READ hazard at HN **/
      fork 
        begin      
`ifndef SVT_CHI_ENABLE_MULTI_CLOCK
          @ (posedge sys_cfg.chi_if.clk);
`else
          @ (posedge sys_cfg.chi_if.rn_clk[initiating_rn_node_idx_0]);
`endif          
          xact_hazard_sema_0.get();
          /** Randomly selected first RN-F fires a read transaction with MAKEUNIQUE 
           *  transaction address of randomly selected HN Node.
           */
          `svt_xvm_do_on_with(read_seq_0[i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
          {
            sequence_length == 1;
            data_in_cache == txn_data;
            seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
            hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
            min_addr == txn_address;
            max_addr == txn_address;
            by_pass_read_data_check == 1;
            seq_xact_type != svt_chi_transaction::READNOSNP;
            seq_xact_type != svt_chi_transaction::CLEANUNIQUE;
            seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
            seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
            seq_is_non_secure_access == txn_is_non_secure_access;
            use_seq_is_non_secure_access == 1;        
            `ifdef SVT_CHI_ISSUE_B_ENABLE
              if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type != svt_chi_transaction::READNOTSHAREDDIRTY;
              if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A || sys_cfg.readspec_enable == 0) seq_xact_type != svt_chi_transaction::READSPEC;
              if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type != svt_chi_transaction::READONCECLEANINVALID;
              if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type != svt_chi_transaction::READONCEMAKEINVALID;
            `endif
            `ifdef SVT_CHI_ISSUE_E_ENABLE
              if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision <= svt_chi_node_configuration::ISSUE_D) seq_xact_type != svt_chi_transaction::READPREFERUNIQUE;
            `endif
          }
          )
          xact_hazard_sema_0.put();
          /** Waiting for Read type transaction to complete */ 
          read_seq_0[i].read_tran.wait_end(); 
        end
        begin
`ifndef SVT_CHI_ENABLE_MULTI_CLOCK
          @ (posedge sys_cfg.chi_if.clk);
`else
          @ (posedge sys_cfg.chi_if.rn_clk[initiating_rn_node_idx_1]);
`endif          
          xact_hazard_sema_1.get();
          /** Randomly selected second RN-F fires a read transaction with MAKEUNIQUE 
           *  transaction address of randomly selected HN Node.
           */
          `svt_xvm_do_on_with(read_seq_1[i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,
          {
            sequence_length == 1;
            data_in_cache == txn_data;
            seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
            hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
            min_addr == txn_address;
            max_addr == txn_address;
            by_pass_read_data_check == 1;
            seq_xact_type != svt_chi_transaction::READNOSNP;
            seq_xact_type != svt_chi_transaction::CLEANUNIQUE;
            seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
            seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
            seq_is_non_secure_access == txn_is_non_secure_access;
            use_seq_is_non_secure_access == 1;        
            `ifdef SVT_CHI_ISSUE_B_ENABLE
              if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type != svt_chi_transaction::READNOTSHAREDDIRTY;
              if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision == svt_chi_node_configuration::ISSUE_A || sys_cfg.readspec_enable == 0) seq_xact_type != svt_chi_transaction::READSPEC;
              if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type != svt_chi_transaction::READONCECLEANINVALID;
              if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type != svt_chi_transaction::READONCEMAKEINVALID;
            `endif
            `ifdef SVT_CHI_ISSUE_E_ENABLE
              if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision <= svt_chi_node_configuration::ISSUE_D) seq_xact_type != svt_chi_transaction::READPREFERUNIQUE;
            `endif
          }
          )
          xact_hazard_sema_1.put();
          /** Waiting for Read type transaction to complete */ 
          read_seq_1[i].read_tran.wait_end(); 
        end
      join

    end

    `uvm_info("body", "Exiting...", UVM_HIGH)
  endtask: body

  virtual task post_body();
    drop_phase_objection();
  endtask

endclass: svt_chi_system_protocol_flow_ctrl_hn_read_read_hazard_directed_virtual_sequence

function svt_chi_system_protocol_flow_ctrl_hn_read_read_hazard_directed_virtual_sequence::new(string name="svt_chi_system_protocol_flow_ctrl_hn_read_read_hazard_directed_virtual_sequence");
  super.new(name);
endfunction

/**
 * @groupname CHI_SYS_HAZARD
 * Abstract:
 * svt_chi_system_protocol_flow_ctrl_hn_makeunique_makeunique_hazard_directed_virtual_sequence
 * provides a sequence to test the ability of components to handle hazard conditions:
 * 1. Initialize the cacheline using MAKEUNIQUE followed by WRITEBACKFULL transaction
 * from RN to the random address.
 * 2. Send a MAKEUNIQUE transaction from both RN0 and RN1 to the same address.
 * The interconnect should sequence these transactions correctly
 * 3. Check the order in which the two requests are processed by HN.
 * 4. If sequenced correctly, both RNs should not be in UD state; only one
 * RN should be in UD state. This is checked in the sequence.
 * .
 */

class svt_chi_system_protocol_flow_ctrl_hn_makeunique_makeunique_hazard_directed_virtual_sequence extends svt_chi_system_protocol_flow_ctrl_xact_hazard_virtual_sequence;

  /** Parameter that controls the number of transactions that will be generated */
  rand int unsigned sequence_length = 10;

  rand bit enable_outstanding = 0;

  bit enable_outstanding_status = 0;

  /** Constrain the sequence length to a reasonable value */
  constraint reasonable_sequence_length {
    sequence_length <= 100;
  }

  /** UVM Object Utility macro */
  `uvm_object_utils(svt_chi_system_protocol_flow_ctrl_hn_makeunique_makeunique_hazard_directed_virtual_sequence)

  extern function new(string name="svt_chi_system_protocol_flow_ctrl_hn_makeunique_makeunique_hazard_directed_virtual_sequence"); 

  virtual task pre_body();
    raise_phase_objection();
  endtask
  
  virtual task body();
    bit                           status;
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0] txn_address;
    bit [`SVT_CHI_MAX_DATA_WIDTH -1:0] txn_data;
    bit rn0_is_unique, rn0_is_clean, rn1_is_unique, rn1_is_clean, rn0_read_status, rn1_read_status;
    bit rn_cache_dirty_state,rn_cache_unique_state;
    bit txn_mem_attr_allocate_hint, txn_snp_attr_snp_domain_type, txn_is_non_secure_access;

    /** Sub sequences initiated from this sequence */
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq, makeunique_seq_0[int], makeunique_seq_1[int];
    svt_chi_rn_copyback_type_transaction_directed_sequence copyback_seq;

    `uvm_info("body", "Entered ...", UVM_HIGH)

    super.body();
    // Default
    enable_outstanding = 0;
    status = uvm_config_db #(int unsigned)::get(null, get_full_name(), "sequence_length", sequence_length);
    `uvm_info("body", $sformatf("sequence_length is %0d as a result of %0s.", sequence_length, status ? "config DB" : "randomization"), UVM_HIGH);

    enable_outstanding_status = uvm_config_db#(bit)::get(m_sequencer, get_type_name(), "enable_outstanding", enable_outstanding);
    `uvm_info("body", $sformatf("enable_outstanding is %0b as a result of %0s", enable_outstanding, (enable_outstanding_status?"config DB":"default setting")), UVM_HIGH);

    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :initiating_rn_f_node_index_0;
    initiating_rn_node_idx_1 = initiating_rn_node_index_1_status ? initiating_rn_node_index_1_from_config_db :initiating_rn_f_node_index_1;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_f_node_index_0;

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /** 
     * If the number of active_participating_rn_f_nodes are greater than 2, then
     * we can initialize the cache/memory from the RN having node index 
     * initiating_rn_f_node_index_2.
     * If the number of active_participating_rn_f_nodes are equal to 2, then
     * we can initialize the cache/memory from the RN having node index 
     * initiating_rn_node_idx_0.
     *  
     */
    if((active_participating_rn_f_nodes.size()>2) && (valid_initiating_rn_f_node_index_2))begin
      cache_initializing_rn_node_index = initiating_rn_f_node_index_2;
      /**
       * If the cache_initializing_rn_node_index is same as any of the RN node indices 
       * which are passed through config i.e initiating_rn_node_idx_0,initiating_rn_node_idx_1,
       * then assert perform_initialization_from_rn_used_for_hazard to 1, so that RN will be
       * in valid state to initilize the respective transaction.
       */
      if(initiating_rn_node_index_0_status || initiating_rn_node_index_1_status)begin
         if((cache_initializing_rn_node_index == initiating_rn_node_idx_0)||(cache_initializing_rn_node_index == initiating_rn_node_idx_1))begin
           perform_initialization_from_rn_used_for_hazard =  1;
         end
         else begin
           perform_initialization_from_rn_used_for_hazard =  0;
         end  
      end  
    end else begin
      cache_initializing_rn_node_index = initiating_rn_node_idx_0;
      perform_initialization_from_rn_used_for_hazard =  1;
    end

    str_initiating_rn_node_indices = "";
    /** Display the contents of Active Participating RN-F Nodes */
    foreach (active_participating_rn_f_nodes[j]) begin
      str_initiating_rn_node_indices = {str_initiating_rn_node_indices, $sformatf(" %0d", active_participating_rn_f_nodes[j])};
    end 
    str_initiating_rn_node_indices = {str_initiating_rn_node_indices, $sformatf("\n RN nodes used to initiate the transactions are initiating_rn_node_idx_0 : %0d, initiating_rn_node_idx_1 : %0d,cache_initializing_rn_node_index : %0d ", initiating_rn_node_idx_0, initiating_rn_node_idx_1, cache_initializing_rn_node_index)};
    `svt_xvm_debug("body", $sformatf("contents of active_participating_rn_f_nodes and RN nodes used to initiate the transactions are %0s", str_initiating_rn_node_indices));

    for(int i = 0; i < sequence_length; i++) begin

      /** Write data into Cache of Randomly selected first RN with address of randomly selected HN Node */
      `svt_xvm_do_on_with(makeunique_seq, p_sequencer.rn_virt_seqr[cache_initializing_rn_node_index].rn_xact_seqr,
      {
        sequence_length == 1;
        hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
        seq_hn_node_idx == target_hn_node_idx_0;
        use_seq_is_non_secure_access == 0;        
      })

      /** Wait for MakeUnique transactions to finish */ 
      makeunique_seq.write_tran.wait_end();
      txn_address = makeunique_seq.output_xacts[0].addr;
      txn_data = makeunique_seq.data_in_cache;
      txn_mem_attr_allocate_hint = makeunique_seq.output_xacts[0].mem_attr_allocate_hint;
      txn_snp_attr_snp_domain_type = makeunique_seq.output_xacts[0].snp_attr_snp_domain_type;
      txn_is_non_secure_access = makeunique_seq.output_xacts[0].is_non_secure_access;

      `svt_xvm_do_on_with(copyback_seq, p_sequencer.rn_virt_seqr[cache_initializing_rn_node_index].rn_xact_seqr,
      {
        sequence_length == 1;
        data_in_cache == txn_data;
        seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
        hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
        min_addr == txn_address;
        max_addr == txn_address;
        seq_xact_type == svt_chi_transaction::WRITEBACKFULL;
        seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
        seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
        seq_is_non_secure_access == txn_is_non_secure_access;
        use_seq_is_non_secure_access == 1;        
      }
      )
      /** Waiting for copyback transaction to complete */ 
      copyback_seq.copyback_tran.wait_end();

      /* MAKEUNIQUE-MAKEUNIQUE hazard at HN **/
      fork 
        begin      
`ifndef SVT_CHI_ENABLE_MULTI_CLOCK
          @ (posedge sys_cfg.chi_if.clk);
`else
          @ (posedge sys_cfg.chi_if.rn_clk[initiating_rn_node_idx_0]);
`endif
          xact_hazard_sema_0.get();
          /** Randomly selected first RN-F fires a MAKEUNIQUE 
           *  transaction address of randomly selected HN Node.
           */
          `svt_xvm_do_on_with(makeunique_seq_0[i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
          {
            sequence_length == 1;
            data_in_cache == txn_data;
            hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
            min_addr == txn_address;
            max_addr == txn_address;
            seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
            seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
            seq_is_non_secure_access == txn_is_non_secure_access;
            use_seq_is_non_secure_access == 1;        
          }
          )
          xact_hazard_sema_0.put();
          /** Wait for MakeUnique transactions to finish */ 
          makeunique_seq_0[i].write_tran.wait_end();
        end
        begin
`ifndef SVT_CHI_ENABLE_MULTI_CLOCK
          @ (posedge sys_cfg.chi_if.clk);
`else
          @ (posedge sys_cfg.chi_if.rn_clk[initiating_rn_node_idx_1]);
`endif
          xact_hazard_sema_1.get();
          /** Randomly selected second RN-F fires a MAKEUNIQUE 
           *  transaction address of randomly selected HN Node.
           */
          `svt_xvm_do_on_with(makeunique_seq_1[i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,
          {
            sequence_length == 1;
            data_in_cache == txn_data;
            hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
            min_addr == txn_address;
            max_addr == txn_address;
            seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
            seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
            seq_is_non_secure_access == txn_is_non_secure_access;
            use_seq_is_non_secure_access == 1;        
          }
          )
          xact_hazard_sema_1.put();
          /** Wait for MakeUnique transactions to finish */ 
          makeunique_seq_1[i].write_tran.wait_end();
        end
      join

      /** Check the initial cache line state corresponding to txn_address */
      rn0_read_status = get_cache_status(initiating_rn_node_idx_0, txn_address, rn0_is_unique, rn0_is_clean);
      `svt_xvm_debug("body", $psprintf(" Initial cache state for Address :: txn_address - %0h, rn0_read_status - %0b, rn0_is_unique - %0b, rn0_is_clean - %0b",txn_address, rn0_read_status, rn0_is_unique, rn0_is_clean));
      rn1_read_status = get_cache_status(initiating_rn_node_idx_1, txn_address, rn1_is_unique, rn1_is_clean);
      `svt_xvm_debug("body", $psprintf(" Initial cache state for Address :: txn_address - %0h, rn1_read_status - %0b, rn1_is_unique - %0b, rn1_is_clean - %0b",txn_address, rn1_read_status, rn1_is_unique, rn1_is_clean));
      // Not more than one RN should be in UNIQUE and DIRTY state. 
      rn_cache_unique_state = 1'b0;
      rn_cache_dirty_state = 1'b0;
      
      if (rn1_read_status && rn0_read_status && (rn0_is_unique == 1'b1) && (rn1_is_unique == 1'b1)) begin
        rn_cache_unique_state = 1'b1;
      end
      if (rn1_read_status && rn0_read_status && (rn1_is_clean == 1'b0) && (rn0_is_clean == 1'b0)) begin
        rn_cache_dirty_state = 1'b1;
      end

      // Final state of both RN1 and RN0 cache should not be in UNIQUE state
      if (rn_cache_unique_state) begin
        `uvm_error("body","Final state of both RN1 and RN0 cache is in UNIQUE state which is a protocol violation")
      end
      // Final state of both RN1 and RN0 cache should not be in DIRTY state
      if (rn_cache_dirty_state) begin
        `uvm_error("body","Final state of both RN1 and RN0 cache is in DIRTY state which is a protocol violation")
      end
    end

    `uvm_info("body", "Exiting...", UVM_HIGH)
  endtask: body

  virtual task post_body();
    drop_phase_objection();
  endtask
endclass: svt_chi_system_protocol_flow_ctrl_hn_makeunique_makeunique_hazard_directed_virtual_sequence

function svt_chi_system_protocol_flow_ctrl_hn_makeunique_makeunique_hazard_directed_virtual_sequence::new(string name="svt_chi_system_protocol_flow_ctrl_hn_makeunique_makeunique_hazard_directed_virtual_sequence");
  super.new(name);
endfunction

/**
 * @groupname CHI_SYS_HAZARD
 * Abstract:
 * svt_chi_system_protocol_flow_ctrl_hn_copyback_snoop_hazard_directed_virtual_sequence
 * provides a sequence to test how components handle various hazard conditions
 * applicable for copyback and snoop transactions
 * 1. Send MAKEUNIQUE transaction to random address from random RN
 * 2. Send read type of transaction to the same address from different RN
 * 3. Send copyback type of transaction to the same address from the same
 *    RN from which MAKEUNIQUE transaction initiated.
 * 4. Check the order in which the two requests are processed by HN.
 * .
 */
class svt_chi_system_protocol_flow_ctrl_hn_copyback_snoop_hazard_directed_virtual_sequence extends svt_chi_system_protocol_flow_ctrl_xact_hazard_virtual_sequence;

  /** Parameter that controls the number of transactions that will be generated */
  rand int unsigned sequence_length = 10;

  rand bit enable_outstanding = 0;

  bit enable_outstanding_status = 0;

  /** Constrain the sequence length to a reasonable value */
  constraint reasonable_sequence_length {
    sequence_length <= 100;
  }

  /** UVM Object Utility macro */
  `uvm_object_utils(svt_chi_system_protocol_flow_ctrl_hn_copyback_snoop_hazard_directed_virtual_sequence)

  extern function new(string name="svt_chi_system_protocol_flow_ctrl_hn_copyback_snoop_hazard_directed_virtual_sequence"); 

  virtual task pre_body();
    raise_phase_objection();
  endtask
  
  virtual task body();
    bit                           status;
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0] txn_address;
    bit [`SVT_CHI_MAX_DATA_WIDTH -1:0] txn_data;
    bit txn_mem_attr_allocate_hint, txn_snp_attr_snp_domain_type, txn_is_non_secure_access;
    event read_type_txn_ended;

    /** Sub sequences initiated from this sequence */
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq;

    /** Sub sequences initiated from this sequence */
    svt_chi_rn_read_type_transaction_directed_sequence read_seq_0[int],read_seq_1[int];
    svt_chi_rn_copyback_type_transaction_directed_sequence copyback_seq[int];

    `uvm_info("body", "Entered ...", UVM_HIGH)

    super.body();
    // Default
    enable_outstanding = 0;
    status = uvm_config_db #(int unsigned)::get(null, get_full_name(), "sequence_length", sequence_length);
    `uvm_info("body", $sformatf("sequence_length is %0d as a result of %0s.", sequence_length, status ? "config DB" : "randomization"), UVM_HIGH);

    enable_outstanding_status = uvm_config_db#(bit)::get(m_sequencer, get_type_name(), "enable_outstanding", enable_outstanding);
    `uvm_info("body", $sformatf("enable_outstanding is %0b as a result of %0s", enable_outstanding, (enable_outstanding_status?"config DB":"default setting")), UVM_HIGH);

    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :initiating_rn_f_node_index_0;
    initiating_rn_node_idx_1 = initiating_rn_node_index_1_status ? initiating_rn_node_index_1_from_config_db :initiating_rn_f_node_index_1;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_f_node_index_0;

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    str_initiating_rn_node_indices = "";
    /** Display the contents of Active Participating RN-F Nodes */
    foreach (active_participating_rn_f_nodes[j]) begin
      str_initiating_rn_node_indices = {str_initiating_rn_node_indices, $sformatf(" %0d", active_participating_rn_f_nodes[j])};
    end 
    str_initiating_rn_node_indices = {str_initiating_rn_node_indices, $sformatf("\n RN nodes used to initiate the transactions are initiating_rn_node_idx_0 : %0d, initiating_rn_node_idx_1 : %0d", initiating_rn_node_idx_0, initiating_rn_node_idx_1)};
    `svt_xvm_debug("body", $sformatf("contents of active_participating_rn_f_nodes and RN nodes used to initiate the transactions are %0s", str_initiating_rn_node_indices));

    for(int i = 0; i < sequence_length; i++) begin
      bit rn0_is_unique, rn0_is_clean, rn1_is_unique, rn1_is_clean, rn0_read_status, rn1_read_status;
      bit rn_cache_dirty_state,rn_cache_unique_state;

      /** Write data into Cache of Randomly selected first RN with address of randomly selected HN Node */
      `svt_xvm_do_on_with(makeunique_seq, p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,
      {
        sequence_length == 1;
        hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
        seq_hn_node_idx == target_hn_node_idx_0;
        use_seq_is_non_secure_access == 0;        
      })

      /** Wait for MakeUnique transactions to finish */ 
      makeunique_seq.write_tran.wait_end();
      txn_address = makeunique_seq.output_xacts[0].addr;
      txn_data = makeunique_seq.data_in_cache;
      txn_mem_attr_allocate_hint = makeunique_seq.output_xacts[0].mem_attr_allocate_hint;
      txn_snp_attr_snp_domain_type = makeunique_seq.output_xacts[0].snp_attr_snp_domain_type;
      txn_is_non_secure_access = makeunique_seq.output_xacts[0].is_non_secure_access;

      /* COPYBACK-SNOOP hazard at RN **/
      fork 
        begin      
          // Do a READSHARED transaction from initiating_rn_node_idx_0, followed by WRITEBACK
          // transaction from initiating_rn_node_idx_1 after a delay of 1 clock cycle.
          `svt_xvm_do_on_with(read_seq_0[i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
          {
            sequence_length == 1;
            data_in_cache == txn_data;
            seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
            hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
            min_addr == txn_address;
            max_addr == txn_address;
            seq_xact_type == svt_chi_transaction::READSHARED;
            seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
            seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
            seq_is_non_secure_access == txn_is_non_secure_access;
            use_seq_is_non_secure_access == 1;        
          }
          )
          /** Waiting for Read type transaction to complete */ 
          read_seq_0[i].read_tran.wait_end(); 
          ->read_type_txn_ended;
        end
        begin
          repeat (2)begin
`ifndef SVT_CHI_ENABLE_MULTI_CLOCK
            @ (posedge sys_cfg.chi_if.clk);
`else
            @ (posedge sys_cfg.chi_if.rn_clk[initiating_rn_node_idx_1]);
`endif
          end  
          wait (read_seq_0[i] != null);
          read_seq_0[i].read_tran.wait_begin(); 
          /** Initiate a WRITEBACKFULL transaction from initiating_rn_node_idx_1 to txn_address. */ 
          `svt_xvm_do_on_with(copyback_seq[i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,
          {
            sequence_length == 1;
            data_in_cache == txn_data;
            seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
            hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
            min_addr == txn_address;
            max_addr == txn_address;
            seq_xact_type == svt_chi_transaction::WRITEBACKFULL;
            seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
            seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
            seq_is_non_secure_access == txn_is_non_secure_access;
            use_seq_is_non_secure_access == 1;               
          }
          )
          /** Waiting for copyback transaction to complete */ 
          copyback_seq[i].copyback_tran.wait_end(); 
        end
        begin
          @read_type_txn_ended;
          `svt_xvm_debug("body", $psprintf("Read transaction %0s ended succesfully. Transaction req_status :: %0s , data_status :: %0s",`SVT_CHI_PRINT_PREFIX(read_seq_0[i].read_tran),read_seq_0[i].read_tran.req_status, read_seq_0[i].read_tran.data_status));
          `svt_xvm_debug("body", $psprintf("Checking the req_status :: %0s and data_status :: %0s of a Copyback transaction :: %0s",copyback_seq[i].copyback_tran.req_status, copyback_seq[i].copyback_tran.data_status,`SVT_CHI_PRINT_PREFIX(copyback_seq[i].copyback_tran)));
          if((copyback_seq[i].copyback_tran.req_status == svt_chi_transaction::ACCEPT)||
             (copyback_seq[i].copyback_tran.req_status == svt_chi_transaction::PARTIAL_ACCEPT)||
             (copyback_seq[i].copyback_tran.req_status == svt_chi_transaction::ABORTED)||
             (copyback_seq[i].copyback_tran.data_status == svt_chi_transaction::ACCEPT))begin
            `svt_xvm_error("body", $psprintf("Copyback transaction :: %0s is not expected to complete before read type transaction - %0s",`SVT_CHI_PRINT_PREFIX(copyback_seq[i].copyback_tran),`SVT_CHI_PRINT_PREFIX(read_seq_0[i].read_tran)));
          end
          else begin
            `svt_xvm_debug("body", $psprintf("read transaction :: %0s completed first and it is followed by copyback type transaction - %0s",`SVT_CHI_PRINT_PREFIX(read_seq_0[i].read_tran),`SVT_CHI_PRINT_PREFIX(copyback_seq[i].copyback_tran)));
          end
        end
      join

    end

    `uvm_info("body", "Exiting...", UVM_HIGH)
  endtask: body

  virtual task post_body();
    drop_phase_objection();
  endtask

endclass: svt_chi_system_protocol_flow_ctrl_hn_copyback_snoop_hazard_directed_virtual_sequence

function svt_chi_system_protocol_flow_ctrl_hn_copyback_snoop_hazard_directed_virtual_sequence::new(string name="svt_chi_system_protocol_flow_ctrl_hn_copyback_snoop_hazard_directed_virtual_sequence");
  super.new(name);
endfunction

/**
 * @groupname CHI_SYS_HAZARD
 * Abstract:
 * svt_chi_system_protocol_flow_ctrl_hn_write_write_hazard_directed_virtual_sequence
 * provides a sequence to test how components handle various hazard conditions
 * applicable for read transactions
 * 1. Initialize the cacheline using MAKEUNIQUE followed by WRITEBACKFULL transaction
 * from RN to the random address.
 * 2. Send different types of write transactions to the same address
 * from different RN's.
 * 3. Check the order in which the two requests are processed by HN.
 * .
 */

class svt_chi_system_protocol_flow_ctrl_hn_write_write_hazard_directed_virtual_sequence extends svt_chi_system_protocol_flow_ctrl_xact_hazard_virtual_sequence;

  /** Parameter that controls the number of transactions that will be generated */
  rand int unsigned sequence_length = 10;

  rand bit enable_outstanding = 0;

  bit enable_outstanding_status = 0;

  /** Constrain the sequence length to a reasonable value */
  constraint reasonable_sequence_length {
    sequence_length <= 100;
  }

  /** UVM Object Utility macro */
  `uvm_object_utils(svt_chi_system_protocol_flow_ctrl_hn_write_write_hazard_directed_virtual_sequence)

  extern function new(string name="svt_chi_system_protocol_flow_ctrl_hn_write_write_hazard_directed_virtual_sequence"); 

  virtual task pre_body();
    raise_phase_objection();
  endtask
  
  virtual task body();
    bit                           status;
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0] txn_address;
    bit [`SVT_CHI_MAX_DATA_WIDTH -1:0] txn_data;
    bit txn_mem_attr_allocate_hint, txn_snp_attr_snp_domain_type, txn_is_non_secure_access;

    /** Sub sequences initiated from this sequence */
    svt_chi_rn_write_type_transaction_directed_sequence write_seq_0[int],write_seq_1[int];
    svt_chi_rn_copyback_type_transaction_directed_sequence copyback_seq;
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq;

    `uvm_info("body", "Entered ...", UVM_HIGH)
    super.body();

    // Default
    enable_outstanding = 0;
    status = uvm_config_db #(int unsigned)::get(null, get_full_name(), "sequence_length", sequence_length);
    `uvm_info("body", $sformatf("sequence_length is %0d as a result of %0s.", sequence_length, status ? "config DB" : "randomization"), UVM_HIGH);

    enable_outstanding_status = uvm_config_db#(bit)::get(m_sequencer, get_type_name(), "enable_outstanding", enable_outstanding);
    `uvm_info("body", $sformatf("enable_outstanding is %0b as a result of %0s", enable_outstanding, (enable_outstanding_status?"config DB":"default setting")), UVM_HIGH);

    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :initiating_rn_f_node_index_0;
    initiating_rn_node_idx_1 = initiating_rn_node_index_1_status ? initiating_rn_node_index_1_from_config_db :initiating_rn_f_node_index_1;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_f_node_index_0;

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /** 
     * If the number of active_participating_rn_f_nodes are greater than 2, then
     * we can initialize the cache/memory from the RN having node index 
     * initiating_rn_f_node_index_2.
     * If the number of active_participating_rn_f_nodes are equal to 2, then
     * we can initialize the cache/memory from the RN having node index 
     * initiating_rn_node_idx_0.
     *  
     */
    if((active_participating_rn_f_nodes.size()>2) && (valid_initiating_rn_f_node_index_2))begin
      cache_initializing_rn_node_index = initiating_rn_f_node_index_2;
      /**
       * If the cache_initializing_rn_node_index is same as any of the RN node indices 
       * which are passed through config i.e initiating_rn_node_idx_0,initiating_rn_node_idx_1,
       * then assert perform_initialization_from_rn_used_for_hazard to 1, so that RN will be
       * in valid state to initilize the respective transaction.
       */
      if(initiating_rn_node_index_0_status || initiating_rn_node_index_1_status)begin
         if((cache_initializing_rn_node_index == initiating_rn_node_idx_0)||(cache_initializing_rn_node_index == initiating_rn_node_idx_1))begin
           perform_initialization_from_rn_used_for_hazard =  1;
         end
         else begin
           perform_initialization_from_rn_used_for_hazard =  0;
         end  
      end  
    end else begin
      cache_initializing_rn_node_index = initiating_rn_node_idx_0;
      perform_initialization_from_rn_used_for_hazard =  1;
    end

    str_initiating_rn_node_indices = "";
    /** Display the contents of Active Participating RN-F Nodes */
    foreach (active_participating_rn_f_nodes[j]) begin
      str_initiating_rn_node_indices = {str_initiating_rn_node_indices, $sformatf(" %0d", active_participating_rn_f_nodes[j])};
    end 
    str_initiating_rn_node_indices = {str_initiating_rn_node_indices, $sformatf("\n RN nodes used to initiate the transactions are initiating_rn_node_idx_0 : %0d, initiating_rn_node_idx_1 : %0d,cache_initializing_rn_node_index : %0d ", initiating_rn_node_idx_0, initiating_rn_node_idx_1, cache_initializing_rn_node_index)};
    `svt_xvm_debug("body", $sformatf("contents of active_participating_rn_f_nodes and RN nodes used to initiate the transactions are %0s", str_initiating_rn_node_indices));

    for(int i = 0; i < sequence_length; i++) begin
      bit rn0_is_unique, rn0_is_clean, rn1_is_unique, rn1_is_clean, rn0_read_status, rn1_read_status;
      bit rn_cache_dirty_state,rn_cache_unique_state;

      /** Write data into Cache of Randomly selected first RN with address of randomly selected HN Node */
      `svt_xvm_do_on_with(makeunique_seq, p_sequencer.rn_virt_seqr[cache_initializing_rn_node_index].rn_xact_seqr,
      {
        sequence_length == 1;
        hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
        seq_hn_node_idx == target_hn_node_idx_0;
        use_seq_is_non_secure_access == 0;
      })

      /** Wait for MakeUnique transactions to finish */ 
      makeunique_seq.write_tran.wait_end();
      txn_address = makeunique_seq.output_xacts[0].addr;
      txn_data = makeunique_seq.data_in_cache;
      txn_mem_attr_allocate_hint = makeunique_seq.output_xacts[0].mem_attr_allocate_hint;
      txn_snp_attr_snp_domain_type = makeunique_seq.output_xacts[0].snp_attr_snp_domain_type;
      txn_is_non_secure_access = makeunique_seq.output_xacts[0].is_non_secure_access;

      `svt_xvm_do_on_with(copyback_seq, p_sequencer.rn_virt_seqr[cache_initializing_rn_node_index].rn_xact_seqr,
      {
        sequence_length == 1;
        data_in_cache == txn_data;
        seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
        hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
        min_addr == txn_address;
        max_addr == txn_address;
        seq_xact_type == svt_chi_transaction::WRITEBACKFULL;
        seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
        seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
        seq_is_non_secure_access == txn_is_non_secure_access;
        use_seq_is_non_secure_access == 1;               
      }
      )
      /** Waiting for copyback transaction to complete */ 
      copyback_seq.copyback_tran.wait_end();

      /* WRITE-WRITE hazard at HN **/
      fork 
        begin      
`ifndef SVT_CHI_ENABLE_MULTI_CLOCK
          @ (posedge sys_cfg.chi_if.clk);
`else
          @ (posedge sys_cfg.chi_if.rn_clk[initiating_rn_node_idx_0]);
`endif
          xact_hazard_sema_0.get();
          /** Randomly selected first RN-F fires a write type transaction to txn_address */
          `svt_xvm_do_on_with(write_seq_0[i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
            {
            `ifdef SVT_CHI_ISSUE_E_ENABLE
             if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A ){
               seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL};
             }            
             else if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision >= svt_chi_node_configuration::ISSUE_E ) {
               if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0) {
                 seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEZERO, svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL};
               }   
               else if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 1){
                 seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEZERO, svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL, svt_chi_transaction::WRITEUNIQUEFULLSTASH, svt_chi_transaction::WRITEUNIQUEPTLSTASH};
               }        
             }
             else if ((sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision < svt_chi_node_configuration::ISSUE_E ) && (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision > svt_chi_node_configuration::ISSUE_A )){
               if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0) {
                 seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL};
               }
               else if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 1) {
                 seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL, svt_chi_transaction::WRITEUNIQUEFULLSTASH, svt_chi_transaction::WRITEUNIQUEPTLSTASH};
               }
             }
            `elsif SVT_CHI_ISSUE_B_ENABLE                    
             if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A || sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0) {
               seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL};
             }
             else{
               seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL, svt_chi_transaction::WRITEUNIQUEFULLSTASH, svt_chi_transaction::WRITEUNIQUEPTLSTASH};
             }
            `else
               seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL};
            `endif
             sequence_length               == 1;
             seq_order_type   != svt_chi_transaction::NO_ORDERING_REQUIRED;
             hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
             min_addr          == txn_address;
             max_addr          == txn_address;
             seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
             seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
             seq_is_non_secure_access == txn_is_non_secure_access;
             use_seq_is_non_secure_access == 1;               
            }
          )
          /** Wait for write type transactions to finish */ 
          write_seq_0[i].write_tran.wait_end();
          xact_hazard_sema_0.put();
        end
        begin
`ifndef SVT_CHI_ENABLE_MULTI_CLOCK
          @ (posedge sys_cfg.chi_if.clk);
`else
          @ (posedge sys_cfg.chi_if.rn_clk[initiating_rn_node_idx_1]);
`endif
          xact_hazard_sema_1.get();
          /** Randomly selected different RN-F fires a write type transaction to txn_address */
          `svt_xvm_do_on_with(write_seq_1[i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,
            {
            `ifdef SVT_CHI_ISSUE_E_ENABLE
             if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision == svt_chi_node_configuration::ISSUE_A ){
               seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL};
             }            
             else if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision >= svt_chi_node_configuration::ISSUE_E ) {
               if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 0) {
                 seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEZERO, svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL};
               }   
               else if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 1){
                 seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEZERO, svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL, svt_chi_transaction::WRITEUNIQUEFULLSTASH, svt_chi_transaction::WRITEUNIQUEPTLSTASH};
               }        
             }
             else if ((sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision < svt_chi_node_configuration::ISSUE_E ) && (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision > svt_chi_node_configuration::ISSUE_A )){
               if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 0) {
                 seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL};
               }
               else if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 1) {
                 seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL, svt_chi_transaction::WRITEUNIQUEFULLSTASH, svt_chi_transaction::WRITEUNIQUEPTLSTASH};
               }
             }
            `elsif SVT_CHI_ISSUE_B_ENABLE                    
             if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision == svt_chi_node_configuration::ISSUE_A || sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 0) {
               seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL};
             }
             else{
               seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL, svt_chi_transaction::WRITEUNIQUEFULLSTASH, svt_chi_transaction::WRITEUNIQUEPTLSTASH};
             }
            `else
               seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL};
            `endif
             sequence_length               == 1;
             seq_order_type   != svt_chi_transaction::NO_ORDERING_REQUIRED;
             hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
             min_addr          == txn_address;
             max_addr          == txn_address;
             seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
             seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
             seq_is_non_secure_access == txn_is_non_secure_access;
             use_seq_is_non_secure_access == 1;               
            }
          )
          xact_hazard_sema_1.put();
          /** Wait for write type transactions to finish */ 
          write_seq_1[i].write_tran.wait_end();
        end
      join
    end

    `uvm_info("body", "Exiting...", UVM_HIGH)
  endtask: body

  virtual task post_body();
    drop_phase_objection();
  endtask

endclass: svt_chi_system_protocol_flow_ctrl_hn_write_write_hazard_directed_virtual_sequence

function svt_chi_system_protocol_flow_ctrl_hn_write_write_hazard_directed_virtual_sequence::new(string name="svt_chi_system_protocol_flow_ctrl_hn_write_write_hazard_directed_virtual_sequence");
  super.new(name);
endfunction

/**
 * @groupname CHI_SYS_HAZARD
 * Abstract:
 * svt_chi_system_protocol_flow_ctrl_hn_write_copyback_hazard_directed_virtual_sequence
 * provides a sequence to test how components handle various hazard conditions
 * applicable for write and copyback transactions
 * 1. Initialize the cacheline using MAKEUNIQUE transaction from RN
 * 2. Send write type of transaction to the same address from different RN.
 * 3. Send Copyback type of transaction to the same address from same RN
 * from which the MAKEUNIQUE transaction initiated.
 * 4. Check the order in which the two requests are processed by HN.
 * .
 */

class svt_chi_system_protocol_flow_ctrl_hn_write_copyback_hazard_directed_virtual_sequence extends svt_chi_system_protocol_flow_ctrl_xact_hazard_virtual_sequence;

  /** Parameter that controls the number of transactions that will be generated */
  rand int unsigned sequence_length = 10;

  rand bit enable_outstanding = 0;

  bit enable_outstanding_status = 0;

  /** Constrain the sequence length to a reasonable value */
  constraint reasonable_sequence_length {
    sequence_length <= 100;
  }

  /** UVM Object Utility macro */
  `uvm_object_utils(svt_chi_system_protocol_flow_ctrl_hn_write_copyback_hazard_directed_virtual_sequence)

  extern function new(string name="svt_chi_system_protocol_flow_ctrl_hn_write_copyback_hazard_directed_virtual_sequence"); 

  virtual task pre_body();
    raise_phase_objection();
  endtask
  
  virtual task body();
    bit                           status;
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0] txn_address;
    bit [`SVT_CHI_MAX_DATA_WIDTH -1:0] txn_data;
    bit txn_mem_attr_allocate_hint, txn_snp_attr_snp_domain_type, txn_is_non_secure_access;

    event copyback_txn_initiated;
    /** Sub sequences initiated from this sequence */
    svt_chi_rn_write_type_transaction_directed_sequence write_seq_0[int];
    svt_chi_rn_copyback_type_transaction_directed_sequence copyback_seq[int];
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq;

    `uvm_info("body", "Entered ...", UVM_HIGH)

    super.body(); 
    // Default
    enable_outstanding = 0;
    status = uvm_config_db #(int unsigned)::get(null, get_full_name(), "sequence_length", sequence_length);
    `uvm_info("body", $sformatf("sequence_length is %0d as a result of %0s.", sequence_length, status ? "config DB" : "randomization"), UVM_HIGH);

    enable_outstanding_status = uvm_config_db#(bit)::get(m_sequencer, get_type_name(), "enable_outstanding", enable_outstanding);
    `uvm_info("body", $sformatf("enable_outstanding is %0b as a result of %0s", enable_outstanding, (enable_outstanding_status?"config DB":"default setting")), UVM_HIGH);

    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :initiating_rn_f_node_index_0;
    initiating_rn_node_idx_1 = initiating_rn_node_index_1_status ? initiating_rn_node_index_1_from_config_db :initiating_rn_f_node_index_1;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_f_node_index_0;

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    str_initiating_rn_node_indices = "";
    /** Display the contents of Active Participating RN-F Nodes */
    foreach (active_participating_rn_f_nodes[j]) begin
      str_initiating_rn_node_indices = {str_initiating_rn_node_indices, $sformatf(" %0d", active_participating_rn_f_nodes[j])};
    end 
    str_initiating_rn_node_indices = {str_initiating_rn_node_indices, $sformatf("\n RN nodes used to initiate the transactions are initiating_rn_node_idx_0 : %0d, initiating_rn_node_idx_1 : %0d", initiating_rn_node_idx_0, initiating_rn_node_idx_1)};
    `svt_xvm_debug("body", $sformatf("contents of active_participating_rn_f_nodes and RN nodes used to initiate the transactions are %0s", str_initiating_rn_node_indices));

    for(int i = 0; i < sequence_length; i++) begin
      bit rn0_is_unique, rn0_is_clean, rn1_is_unique, rn1_is_clean, rn0_read_status, rn1_read_status;
      bit rn_cache_dirty_state,rn_cache_unique_state;

      /** Write data into Cache of Randomly selected first RN with address of randomly selected HN Node */
      `svt_xvm_do_on_with(makeunique_seq, p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,
      {
        sequence_length == 1;
        hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
        seq_hn_node_idx == target_hn_node_idx_0;
        use_seq_is_non_secure_access == 0;               
      })

      /** Wait for MakeUnique transactions to finish */ 
      makeunique_seq.write_tran.wait_end();
      txn_address = makeunique_seq.output_xacts[0].addr;
      txn_data = makeunique_seq.data_in_cache;
      txn_mem_attr_allocate_hint = makeunique_seq.output_xacts[0].mem_attr_allocate_hint;
      txn_snp_attr_snp_domain_type = makeunique_seq.output_xacts[0].snp_attr_snp_domain_type;
      txn_is_non_secure_access = makeunique_seq.output_xacts[0].is_non_secure_access;

      /* WRITE-COPYBACK hazard at HN **/
      fork 
        begin      
`ifndef SVT_CHI_ENABLE_MULTI_CLOCK
          @ (posedge sys_cfg.chi_if.clk);
`else
          @ (posedge sys_cfg.chi_if.rn_clk[initiating_rn_node_idx_0]);
`endif          
          xact_hazard_sema_0.get();
          /** Initiate a Write type transaction from initiating_rn_node_idx_0 to txn_address. */
          `svt_xvm_do_on_with(write_seq_0[i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
            {
            `ifdef SVT_CHI_ISSUE_E_ENABLE
             if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A ){
               seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL};
             }            
             else if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision >= svt_chi_node_configuration::ISSUE_E ) {
               if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0) {
                 seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEZERO, svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL};
               }   
               else if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 1){
                 seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEZERO, svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL, svt_chi_transaction::WRITEUNIQUEFULLSTASH, svt_chi_transaction::WRITEUNIQUEPTLSTASH};
               }        
             }
             else if ((sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision < svt_chi_node_configuration::ISSUE_E ) && (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision > svt_chi_node_configuration::ISSUE_A )){
               if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0) {
                 seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL};
               }
               else if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 1) {
                 seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL, svt_chi_transaction::WRITEUNIQUEFULLSTASH, svt_chi_transaction::WRITEUNIQUEPTLSTASH};
               }
             }
            `elsif SVT_CHI_ISSUE_B_ENABLE
             if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A || sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0) {
               seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL};
             }
             else{
               seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEFULLSTASH};
             }
            `else
               seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL};
            `endif
             sequence_length               == 1;
             seq_order_type   != svt_chi_transaction::NO_ORDERING_REQUIRED;
             hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
             min_addr          == txn_address;
             max_addr          == txn_address;
             seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
             seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
             seq_is_non_secure_access == txn_is_non_secure_access;
             use_seq_is_non_secure_access == 1;               
            }
          )
          xact_hazard_sema_0.put();
          /** Wait for write type transactions to finish */ 
          write_seq_0[i].write_tran.wait_end();
        end
        begin
`ifndef SVT_CHI_ENABLE_MULTI_CLOCK
          @ (posedge sys_cfg.chi_if.clk);
`else
          @ (posedge sys_cfg.chi_if.rn_clk[initiating_rn_node_idx_1]);
`endif          
          xact_hazard_sema_1.get();
          /** Initiate a Copyback type transaction from initiating_rn_node_idx_1 to txn_address. */
          `svt_xvm_do_on_with(copyback_seq[i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,
          {
            sequence_length == 1;
            seq_xact_type != svt_chi_transaction::WRITEBACKPTL;
            seq_xact_type != svt_chi_transaction::WRITECLEANPTL;
            seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
            seq_copyback_req_order_enable == 0;                        
            hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
            min_addr == txn_address;
            max_addr == txn_address;
            seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
            seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
            seq_is_non_secure_access == txn_is_non_secure_access;
            use_seq_is_non_secure_access == 1;               
          }
          )
          xact_hazard_sema_1.put();
          /** Waiting for copyback transaction to complete */ 
          copyback_seq[i].copyback_tran.wait_end(); 
        end
      join
    end

    `uvm_info("body", "Exiting...", UVM_HIGH)
  endtask: body

  virtual task post_body();
    drop_phase_objection();
  endtask

endclass: svt_chi_system_protocol_flow_ctrl_hn_write_copyback_hazard_directed_virtual_sequence

function svt_chi_system_protocol_flow_ctrl_hn_write_copyback_hazard_directed_virtual_sequence::new(string name="svt_chi_system_protocol_flow_ctrl_hn_write_copyback_hazard_directed_virtual_sequence");
  super.new(name);
endfunction

/**
 * @groupname CHI_SYS_HAZARD
 * Abstract:
 * svt_chi_system_protocol_flow_ctrl_hn_read_write_hazard_directed_virtual_sequence
 * provides a sequence to test how components handle various hazard conditions
 * applicable for read and write transactions
 * 1. Send MAKEUNIQUE transaction to random address from random RN
 * 2. Send read type of transaction to the same address from different RN
 * 3. Send write type of transaction to the same address from different RN
 * 4. Check the order in which the two requests are processed by HN.
 * .
 */

class svt_chi_system_protocol_flow_ctrl_hn_read_write_hazard_directed_virtual_sequence extends svt_chi_system_protocol_flow_ctrl_xact_hazard_virtual_sequence;

  /** Parameter that controls the number of transactions that will be generated */
  rand int unsigned sequence_length = 10;

  rand bit enable_outstanding = 0;

  bit enable_outstanding_status = 0;

  /** Constrain the sequence length to a reasonable value */
  constraint reasonable_sequence_length {
    sequence_length <= 100;
  }

  /** UVM Object Utility macro */
  `uvm_object_utils(svt_chi_system_protocol_flow_ctrl_hn_read_write_hazard_directed_virtual_sequence)

  extern function new(string name="svt_chi_system_protocol_flow_ctrl_hn_read_write_hazard_directed_virtual_sequence"); 

  virtual task pre_body();
    raise_phase_objection();
  endtask
  
  virtual task body();
    bit                           status;
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0] txn_address;
    bit [`SVT_CHI_MAX_DATA_WIDTH -1:0] txn_data;
    bit txn_mem_attr_allocate_hint, txn_snp_attr_snp_domain_type, txn_is_non_secure_access;

    /** Sub sequences initiated from this sequence */
    svt_chi_rn_write_type_transaction_directed_sequence write_seq_0[int];
    svt_chi_rn_read_type_transaction_directed_sequence read_seq_0[int];
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq;
    svt_chi_rn_copyback_type_transaction_directed_sequence copyback_seq;

    `uvm_info("body", "Entered ...", UVM_HIGH)

    super.body();
    // Default
    enable_outstanding = 0;
    status = uvm_config_db #(int unsigned)::get(null, get_full_name(), "sequence_length", sequence_length);
    `uvm_info("body", $sformatf("sequence_length is %0d as a result of %0s.", sequence_length, status ? "config DB" : "randomization"), UVM_HIGH);

    enable_outstanding_status = uvm_config_db#(bit)::get(m_sequencer, get_type_name(), "enable_outstanding", enable_outstanding);
    `uvm_info("body", $sformatf("enable_outstanding is %0b as a result of %0s", enable_outstanding, (enable_outstanding_status?"config DB":"default setting")), UVM_HIGH);

    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :initiating_rn_f_node_index_0;
    initiating_rn_node_idx_1 = initiating_rn_node_index_1_status ? initiating_rn_node_index_1_from_config_db :initiating_rn_f_node_index_1;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_f_node_index_0;

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /** 
     * If the number of active_participating_rn_f_nodes are greater than 2, then
     * we can initialize the cache/memory from the RN having node index 
     * initiating_rn_f_node_index_2.
     * If the number of active_participating_rn_f_nodes are equal to 2, then
     * we can initialize the cache/memory from the RN having node index 
     * initiating_rn_node_idx_0.
     *  
     */
    if((active_participating_rn_f_nodes.size()>2) && (valid_initiating_rn_f_node_index_2))begin
      cache_initializing_rn_node_index = initiating_rn_f_node_index_2;
      /**
       * If the cache_initializing_rn_node_index is same as any of the RN node indices 
       * which are passed through config i.e initiating_rn_node_idx_0,initiating_rn_node_idx_1,
       * then assert perform_initialization_from_rn_used_for_hazard to 1, so that RN will be
       * in valid state to initilize the respective transaction.
       */
      if(initiating_rn_node_index_0_status || initiating_rn_node_index_1_status)begin
         if((cache_initializing_rn_node_index == initiating_rn_node_idx_0)||(cache_initializing_rn_node_index == initiating_rn_node_idx_1))begin
           perform_initialization_from_rn_used_for_hazard =  1;
         end
         else begin
           perform_initialization_from_rn_used_for_hazard =  0;
         end  
      end  
    end else begin
      cache_initializing_rn_node_index = initiating_rn_node_idx_0;
      perform_initialization_from_rn_used_for_hazard =  1;
    end

    str_initiating_rn_node_indices = "";
    /** Display the contents of Active Participating RN-F Nodes */
    foreach (active_participating_rn_f_nodes[j]) begin
      str_initiating_rn_node_indices = {str_initiating_rn_node_indices, $sformatf(" %0d", active_participating_rn_f_nodes[j])};
    end 
    str_initiating_rn_node_indices = {str_initiating_rn_node_indices, $sformatf("\n RN nodes used to initiate the transactions are initiating_rn_node_idx_0 : %0d, initiating_rn_node_idx_1 : %0d,cache_initializing_rn_node_index : %0d ", initiating_rn_node_idx_0, initiating_rn_node_idx_1, cache_initializing_rn_node_index)};
    `svt_xvm_debug("body", $sformatf("contents of active_participating_rn_f_nodes and RN nodes used to initiate the transactions are %0s", str_initiating_rn_node_indices));

    for(int i = 0; i < sequence_length; i++) begin
      bit rn0_is_unique, rn0_is_clean, rn1_is_unique, rn1_is_clean, rn0_read_status, rn1_read_status;
      bit rn_cache_dirty_state,rn_cache_unique_state;

      /** Write data into Cache of Randomly selected first RN with address of randomly selected HN Node */
      `svt_xvm_do_on_with(makeunique_seq, p_sequencer.rn_virt_seqr[cache_initializing_rn_node_index].rn_xact_seqr,
      {
        sequence_length == 1;
        hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
        seq_hn_node_idx == target_hn_node_idx_0;
        use_seq_is_non_secure_access == 0;
      })

      /** Wait for MakeUnique transactions to finish */ 
      makeunique_seq.write_tran.wait_end();
      txn_address = makeunique_seq.output_xacts[0].addr;
      txn_data = makeunique_seq.data_in_cache;
      txn_mem_attr_allocate_hint = makeunique_seq.output_xacts[0].mem_attr_allocate_hint;
      txn_snp_attr_snp_domain_type = makeunique_seq.output_xacts[0].snp_attr_snp_domain_type;
      txn_is_non_secure_access = makeunique_seq.output_xacts[0].is_non_secure_access;

      /** Writeback the data to the main memory at the respective address. */ 
      if(perform_initialization_from_rn_used_for_hazard) begin
        `svt_xvm_do_on_with(copyback_seq, p_sequencer.rn_virt_seqr[cache_initializing_rn_node_index].rn_xact_seqr,
        {
          sequence_length == 1;
          data_in_cache == txn_data;
          seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
          hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
          min_addr == txn_address;
          max_addr == txn_address;
          seq_xact_type == svt_chi_transaction::WRITEBACKFULL;
          seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
          seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
          seq_is_non_secure_access == txn_is_non_secure_access;
          use_seq_is_non_secure_access == 1;               
        }
        )
        /** Waiting for copyback transaction to complete */ 
        copyback_seq.copyback_tran.wait_end();
      end 

      /* READ-WRITE hazard at HN **/
      fork 
        begin      
`ifndef SVT_CHI_ENABLE_MULTI_CLOCK
          @ (posedge sys_cfg.chi_if.clk);
`else
          @ (posedge sys_cfg.chi_if.rn_clk[initiating_rn_node_idx_0]);
`endif          
          xact_hazard_sema_0.get();
          /** Initiate a read type transaction from initiating_rn_node_idx_0 to txn_address. */ 
          `svt_xvm_do_on_with(read_seq_0[i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
          {
            sequence_length == 1;
            data_in_cache == txn_data;
            seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
            hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
            min_addr == txn_address;
            max_addr == txn_address;
            by_pass_read_data_check == 1;
            seq_xact_type != svt_chi_transaction::READNOSNP;
            seq_xact_type != svt_chi_transaction::CLEANUNIQUE;
            seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
            seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
            seq_is_non_secure_access == txn_is_non_secure_access;
            use_seq_is_non_secure_access == 1;               
            `ifdef SVT_CHI_ISSUE_B_ENABLE
              if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type != svt_chi_transaction::READNOTSHAREDDIRTY;
              if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A || sys_cfg.readspec_enable == 0) seq_xact_type != svt_chi_transaction::READSPEC;
              if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type != svt_chi_transaction::READONCECLEANINVALID;
              if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type != svt_chi_transaction::READONCEMAKEINVALID;
            `endif
            `ifdef SVT_CHI_ISSUE_E_ENABLE
              if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision <= svt_chi_node_configuration::ISSUE_D) seq_xact_type != svt_chi_transaction::READPREFERUNIQUE;
            `endif
          }
          )
          xact_hazard_sema_0.put();
          /** Waiting for Read type transaction to complete */ 
          read_seq_0[i].read_tran.wait_end(); 
        end
        begin
`ifndef SVT_CHI_ENABLE_MULTI_CLOCK
          @ (posedge sys_cfg.chi_if.clk);
`else
          @ (posedge sys_cfg.chi_if.rn_clk[initiating_rn_node_idx_1]);
`endif          
          xact_hazard_sema_1.get();
          /** Initiate a write type transaction from initiating_rn_node_idx_1 to txn_address. */ 
          `svt_xvm_do_on_with(write_seq_0[i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,
            {
            `ifdef SVT_CHI_ISSUE_E_ENABLE
             if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision == svt_chi_node_configuration::ISSUE_A ){
               seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL};
             }            
             else if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision >= svt_chi_node_configuration::ISSUE_E ) {
               if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 0) {
                 seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEZERO, svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL};
               }   
               else if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 1){
                 seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEZERO, svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL, svt_chi_transaction::WRITEUNIQUEFULLSTASH, svt_chi_transaction::WRITEUNIQUEPTLSTASH};
               }        
             }
             else if ((sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision < svt_chi_node_configuration::ISSUE_E ) && (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision > svt_chi_node_configuration::ISSUE_A )){
               if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 0) {
                 seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL};
               }
               else if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 1) {
                 seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL, svt_chi_transaction::WRITEUNIQUEFULLSTASH, svt_chi_transaction::WRITEUNIQUEPTLSTASH};
               }
             }
            `elsif SVT_CHI_ISSUE_B_ENABLE
             if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision == svt_chi_node_configuration::ISSUE_A || sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 0) {
               seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL};
             }
             else{
               seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL, svt_chi_transaction::WRITEUNIQUEFULLSTASH, svt_chi_transaction::WRITEUNIQUEPTLSTASH};
             }
            `else
               seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL};
            `endif
             sequence_length               == 1;
             seq_order_type   != svt_chi_transaction::NO_ORDERING_REQUIRED;
             hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
             min_addr          == txn_address;
             max_addr          == txn_address;
             seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
             seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
             seq_is_non_secure_access == txn_is_non_secure_access;
             use_seq_is_non_secure_access == 1;               
            }
          )
          xact_hazard_sema_1.put();
          /** Wait for write type transactions to finish */ 
          write_seq_0[i].write_tran.wait_end();
        end
      join
    end

    `uvm_info("body", "Exiting...", UVM_HIGH)
  endtask: body

  virtual task post_body();
    drop_phase_objection();
  endtask

endclass: svt_chi_system_protocol_flow_ctrl_hn_read_write_hazard_directed_virtual_sequence

function svt_chi_system_protocol_flow_ctrl_hn_read_write_hazard_directed_virtual_sequence::new(string name="svt_chi_system_protocol_flow_ctrl_hn_read_write_hazard_directed_virtual_sequence");
  super.new(name);
endfunction

/**
 * @groupname CHI_SYS_HAZARD
 * Abstract:
 * svt_chi_system_protocol_flow_ctrl_hn_cmo_cmo_hazard_directed_virtual_sequence
 * provides a sequence to test how components handle various hazard conditions
 * applicable for CMO transactions
 * 1. Initialize the cacheline using MAKEUNIQUE followed by WRITEBACKFULL transaction
 * from RN to the random address.
 * 2. Send different types of cmo transactions to the same address from RN0
 * and RN1.
 * 3. Check the order in which the two requests are processed by HN.
 * .
 */

class svt_chi_system_protocol_flow_ctrl_hn_cmo_cmo_hazard_directed_virtual_sequence extends svt_chi_system_protocol_flow_ctrl_xact_hazard_virtual_sequence;

  /** Parameter that controls the number of transactions that will be generated */
  rand int unsigned sequence_length = 10;

  rand bit enable_outstanding = 0;

  bit enable_outstanding_status = 0;

  /** Constrain the sequence length to a reasonable value */
  constraint reasonable_sequence_length {
    sequence_length <= 100;
  }

  /** UVM Object Utility macro */
  `uvm_object_utils(svt_chi_system_protocol_flow_ctrl_hn_cmo_cmo_hazard_directed_virtual_sequence)

  extern function new(string name="svt_chi_system_protocol_flow_ctrl_hn_cmo_cmo_hazard_directed_virtual_sequence"); 

  virtual task pre_body();
    raise_phase_objection();
  endtask
  
  virtual task body();
    bit status;
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0] txn_address;
    bit [`SVT_CHI_MAX_DATA_WIDTH -1:0] txn_data;
    bit txn_mem_attr_allocate_hint, txn_snp_attr_is_snoopable, txn_snp_attr_snp_domain_type, txn_is_non_secure_access;

    /** Sub sequences initiated from this sequence */
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq;
    svt_chi_rn_copyback_type_transaction_directed_sequence copyback_seq;

    /** Sub CMO type transaction directed sequences initiated from this sequence */
    svt_chi_rn_cmo_type_transaction_directed_sequence cmo_seq_0[int],cmo_seq_1[int];

    `uvm_info("body", "Entered ...", UVM_HIGH)

    super.body();
    // Default
    enable_outstanding = 0;
    status = uvm_config_db #(int unsigned)::get(null, get_full_name(), "sequence_length", sequence_length);
    `uvm_info("body", $sformatf("sequence_length is %0d as a result of %0s.", sequence_length, status ? "config DB" : "randomization"), UVM_HIGH);

    enable_outstanding_status = uvm_config_db#(bit)::get(m_sequencer, get_type_name(), "enable_outstanding", enable_outstanding);
    `uvm_info("body", $sformatf("enable_outstanding is %0b as a result of %0s", enable_outstanding, (enable_outstanding_status?"config DB":"default setting")), UVM_HIGH);

    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :initiating_rn_f_node_index_0;
    initiating_rn_node_idx_1 = initiating_rn_node_index_1_status ? initiating_rn_node_index_1_from_config_db :initiating_rn_f_node_index_1;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_f_node_index_0;

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /** 
     * If the number of active_participating_rn_f_nodes are greater than 2, then
     * we can initialize the cache/memory from the RN having node index 
     * initiating_rn_f_node_index_2.
     * If the number of active_participating_rn_f_nodes are equal to 2, then
     * we can initialize the cache/memory from the RN having node index 
     * initiating_rn_node_idx_0.
     *  
     */
    if((active_participating_rn_f_nodes.size()>2) && (valid_initiating_rn_f_node_index_2))begin
      cache_initializing_rn_node_index = initiating_rn_f_node_index_2;
      /**
       * If the cache_initializing_rn_node_index is same as any of the RN node indices 
       * which are passed through config i.e initiating_rn_node_idx_0,initiating_rn_node_idx_1,
       * then assert perform_initialization_from_rn_used_for_hazard to 1, so that RN will be
       * in valid state to initilize the respective transaction.
       */
      if(initiating_rn_node_index_0_status || initiating_rn_node_index_1_status)begin
         if((cache_initializing_rn_node_index == initiating_rn_node_idx_0)||(cache_initializing_rn_node_index == initiating_rn_node_idx_1))begin
           perform_initialization_from_rn_used_for_hazard =  1;
         end
         else begin
           perform_initialization_from_rn_used_for_hazard =  0;
         end  
      end  
    end else begin
      cache_initializing_rn_node_index = initiating_rn_node_idx_0;
      perform_initialization_from_rn_used_for_hazard =  1;
    end

    str_initiating_rn_node_indices = "";
    /** Display the contents of Active Participating RN-F Nodes */
    foreach (active_participating_rn_f_nodes[j]) begin
      str_initiating_rn_node_indices = {str_initiating_rn_node_indices, $sformatf(" %0d", active_participating_rn_f_nodes[j])};
    end 
    str_initiating_rn_node_indices = {str_initiating_rn_node_indices, $sformatf("\n RN nodes used to initiate the transactions are initiating_rn_node_idx_0 : %0d, initiating_rn_node_idx_1 : %0d,cache_initializing_rn_node_index : %0d ", initiating_rn_node_idx_0, initiating_rn_node_idx_1, cache_initializing_rn_node_index)};
    `svt_xvm_debug("body", $sformatf("contents of active_participating_rn_f_nodes and RN nodes used to initiate the transactions are %0s", str_initiating_rn_node_indices));

    for(int i = 0; i < sequence_length; i++) begin

      /** Initiate MAKEUNIQUE transaction from cache_initializing_rn_node_index to randomly selected HN Node. */ 
      `svt_xvm_do_on_with(makeunique_seq, p_sequencer.rn_virt_seqr[cache_initializing_rn_node_index].rn_xact_seqr,
      {
        sequence_length == 1;
        hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
        seq_hn_node_idx == target_hn_node_idx_0;
        use_seq_is_non_secure_access == 0;               
      })

      /** Wait for MakeUnique transactions to finish */ 
      makeunique_seq.write_tran.wait_end();
      txn_address = makeunique_seq.output_xacts[0].addr;
      txn_data = makeunique_seq.data_in_cache;
      txn_mem_attr_allocate_hint = makeunique_seq.output_xacts[0].mem_attr_allocate_hint;
      txn_snp_attr_is_snoopable = makeunique_seq.output_xacts[0].snp_attr_is_snoopable;
      txn_snp_attr_snp_domain_type = makeunique_seq.output_xacts[0].snp_attr_snp_domain_type;
      txn_is_non_secure_access = makeunique_seq.output_xacts[0].is_non_secure_access;

      /** Writeback the data to the main memory at the respective address. */ 
      if(perform_initialization_from_rn_used_for_hazard) begin
        `svt_xvm_do_on_with(copyback_seq, p_sequencer.rn_virt_seqr[cache_initializing_rn_node_index].rn_xact_seqr,
        {
          sequence_length == 1;
          data_in_cache == txn_data;
          seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
          hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
          min_addr == txn_address;
          max_addr == txn_address;
          seq_xact_type == svt_chi_transaction::WRITEBACKFULL;
          seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
          seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
          seq_is_non_secure_access == txn_is_non_secure_access;
          use_seq_is_non_secure_access == 1;               
        }
        )
        /** Waiting for copyback transaction to complete */ 
        copyback_seq.copyback_tran.wait_end();
      end 

      /* CMO-CMO hazard at HN **/
      fork 
        begin      
`ifndef SVT_CHI_ENABLE_MULTI_CLOCK
          @ (posedge sys_cfg.chi_if.clk);
`else
          @ (posedge sys_cfg.chi_if.rn_clk[initiating_rn_node_idx_0]);
`endif          
          xact_hazard_sema_0.get();
          /** Initiate CMO type of transaction from initiating_rn_node_idx_0 to txn_address. */ 
          `svt_xvm_do_on_with(cmo_seq_0[i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
          {
            sequence_length == 1;
            hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
            min_addr == txn_address;
            max_addr == txn_address;
            seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
            seq_snp_attr_is_snoopable == txn_snp_attr_is_snoopable;
            seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
            seq_is_non_secure_access == txn_is_non_secure_access;
            use_seq_is_non_secure_access == 1;               
            `ifdef SVT_CHI_ISSUE_B_ENABLE
              if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) 
                {
                  !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSIST, svt_chi_transaction::STASHONCEUNIQUE,svt_chi_transaction::STASHONCESHARED});
                }
              `ifdef SVT_CHI_ISSUE_E_ENABLE
              else if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision < svt_chi_node_configuration::ISSUE_E){
                !(seq_xact_type inside {svt_chi_transaction::STASHONCESEPUNIQUE, svt_chi_transaction::STASHONCESEPSHARED});
                if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision < svt_chi_node_configuration::ISSUE_D){
                  !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                  if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0)
                    !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                }
                else if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision >= svt_chi_node_configuration::ISSUE_D){
                  if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].cleansharedpersistsep_xact_enable ==0)
                    !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                  if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0)
                    !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                }
              }
              else if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision >= svt_chi_node_configuration::ISSUE_E){
                if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].cleansharedpersistsep_xact_enable == 0)
                  !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0)
                  !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED,svt_chi_transaction::STASHONCESEPUNIQUE, svt_chi_transaction::STASHONCESEPSHARED});
              }
              `elsif SVT_CHI_ISSUE_D_ENABLE
              else if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision < svt_chi_node_configuration::ISSUE_D){
                !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0)
                  !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
              }
              else if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision >= svt_chi_node_configuration::ISSUE_D){
                if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].cleansharedpersistsep_xact_enable ==0)
                  !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0){
                  !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                }
              }
              `endif //issue_d_enable
              else if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0){
                  !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                }
            `endif
          }
          )
          xact_hazard_sema_0.put();
          /** Waiting for CMO type transaction to complete */ 
          cmo_seq_0[i].cmo_tran.wait_end(); 
        end
        begin
`ifndef SVT_CHI_ENABLE_MULTI_CLOCK
          @ (posedge sys_cfg.chi_if.clk);
`else
          @ (posedge sys_cfg.chi_if.rn_clk[initiating_rn_node_idx_1]);
`endif        
          xact_hazard_sema_1.get();
          /** Initiate CMO type of transaction from initiating_rn_node_idx_1 to txn_address. */ 
          `svt_xvm_do_on_with(cmo_seq_1[i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,
          {
            sequence_length == 1;
            hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
            min_addr == txn_address;
            max_addr == txn_address;
            seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
            seq_snp_attr_is_snoopable == txn_snp_attr_is_snoopable;
            seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
            seq_is_non_secure_access == txn_is_non_secure_access;
            use_seq_is_non_secure_access == 1;               
            `ifdef SVT_CHI_ISSUE_B_ENABLE
              if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) 
                {
                  !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSIST, svt_chi_transaction::STASHONCEUNIQUE,svt_chi_transaction::STASHONCESHARED});
                }
              `ifdef SVT_CHI_ISSUE_E_ENABLE
              else if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision < svt_chi_node_configuration::ISSUE_E){
                !(seq_xact_type inside {svt_chi_transaction::STASHONCESEPUNIQUE, svt_chi_transaction::STASHONCESEPSHARED});
                if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision < svt_chi_node_configuration::ISSUE_D){
                  !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                  if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 0)
                    !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                }
                else if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision >= svt_chi_node_configuration::ISSUE_D){
                  if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].cleansharedpersistsep_xact_enable ==0)
                    !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                  if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 0)
                    !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                }
              }
              else if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision >= svt_chi_node_configuration::ISSUE_E){
                if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].cleansharedpersistsep_xact_enable == 0)
                  !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 0)
                  !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED,svt_chi_transaction::STASHONCESEPUNIQUE, svt_chi_transaction::STASHONCESEPSHARED});
              }
              `elsif SVT_CHI_ISSUE_D_ENABLE
              else if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision < svt_chi_node_configuration::ISSUE_D){
                !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 0)
                  !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
              }
              else if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision >= svt_chi_node_configuration::ISSUE_D){
                if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].cleansharedpersistsep_xact_enable ==0)
                  !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 0){
                  !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                }
              }
              `endif //issue_d_enable
              else if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 0){
                  !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                }
            `endif
          }
          )
          xact_hazard_sema_1.put();
          /** Waiting for CMO type transaction to complete */ 
          cmo_seq_1[i].cmo_tran.wait_end(); 
        end
      join
    end

    `uvm_info("body", "Exiting...", UVM_HIGH)
  endtask: body

  virtual task post_body();
    drop_phase_objection();
  endtask

endclass: svt_chi_system_protocol_flow_ctrl_hn_cmo_cmo_hazard_directed_virtual_sequence

function svt_chi_system_protocol_flow_ctrl_hn_cmo_cmo_hazard_directed_virtual_sequence::new(string name="svt_chi_system_protocol_flow_ctrl_hn_cmo_cmo_hazard_directed_virtual_sequence");
  super.new(name);
endfunction

/**
 * @groupname CHI_SYS_HAZARD
 * Abstract:
 * svt_chi_system_protocol_flow_ctrl_hn_cmo_write_hazard_directed_virtual_sequence
 * provides a sequence to test how components handle various hazard conditions
 * applicable for CMO and write transactions
 * 1. Initialize the cacheline using MAKEUNIQUE transaction
 * from RN to the random address.
 * 2. Send cmo type of transaction to the same address from different RN
 * 3. Send write type of transaction to the same address from different RN
 * 4. Check the order in which the two requests are processed by HN.
 * .
 */

class svt_chi_system_protocol_flow_ctrl_hn_cmo_write_hazard_directed_virtual_sequence extends svt_chi_system_protocol_flow_ctrl_xact_hazard_virtual_sequence;

  /** Parameter that controls the number of transactions that will be generated */
  rand int unsigned sequence_length = 10;

  rand bit enable_outstanding = 0;

  bit enable_outstanding_status = 0;

  /** Constrain the sequence length to a reasonable value */
  constraint reasonable_sequence_length {
    sequence_length <= 100;
  }

  /** UVM Object Utility macro */
  `uvm_object_utils(svt_chi_system_protocol_flow_ctrl_hn_cmo_write_hazard_directed_virtual_sequence)

  extern function new(string name="svt_chi_system_protocol_flow_ctrl_hn_cmo_write_hazard_directed_virtual_sequence"); 

  virtual task pre_body();
    raise_phase_objection();
  endtask
  
  virtual task body();
    bit                           status;
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0] txn_address;
    bit [`SVT_CHI_MAX_DATA_WIDTH -1:0] txn_data;
    bit txn_mem_attr_allocate_hint, txn_snp_attr_is_snoopable, txn_snp_attr_snp_domain_type, txn_is_non_secure_access;

    /** Sub CMO type transaction directed sequences initiated from this sequence */
    svt_chi_rn_cmo_type_transaction_directed_sequence cmo_seq_0[int],cmo_seq_1[int];
    svt_chi_rn_write_type_transaction_directed_sequence write_seq_0[int];

    /** Sub sequences initiated from this sequence */
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq;
    svt_chi_rn_copyback_type_transaction_directed_sequence copyback_seq;

    `uvm_info("body", "Entered ...", UVM_HIGH)

    super.body();
    // Default
    enable_outstanding = 0;
    status = uvm_config_db #(int unsigned)::get(null, get_full_name(), "sequence_length", sequence_length);
    `uvm_info("body", $sformatf("sequence_length is %0d as a result of %0s.", sequence_length, status ? "config DB" : "randomization"), UVM_HIGH);

    enable_outstanding_status = uvm_config_db#(bit)::get(m_sequencer, get_type_name(), "enable_outstanding", enable_outstanding);
    `uvm_info("body", $sformatf("enable_outstanding is %0b as a result of %0s", enable_outstanding, (enable_outstanding_status?"config DB":"default setting")), UVM_HIGH);

    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :initiating_rn_f_node_index_0;
    initiating_rn_node_idx_1 = initiating_rn_node_index_1_status ? initiating_rn_node_index_1_from_config_db :initiating_rn_f_node_index_1;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_f_node_index_0;

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /** 
     * If the number of active_participating_rn_f_nodes are greater than 2, then
     * we can initialize the cache/memory from the RN having node index 
     * initiating_rn_f_node_index_2.
     * If the number of active_participating_rn_f_nodes are equal to 2, then
     * we can initialize the cache/memory from the RN having node index 
     * initiating_rn_node_idx_0.
     *  
     */
    if((active_participating_rn_f_nodes.size()>2) && (valid_initiating_rn_f_node_index_2))begin
      cache_initializing_rn_node_index = initiating_rn_f_node_index_2;
      /**
       * If the cache_initializing_rn_node_index is same as any of the RN node indices 
       * which are passed through config i.e initiating_rn_node_idx_0,initiating_rn_node_idx_1,
       * then assert perform_initialization_from_rn_used_for_hazard to 1, so that RN will be
       * in valid state to initilize the respective transaction.
       */
      if(initiating_rn_node_index_0_status || initiating_rn_node_index_1_status)begin
         if((cache_initializing_rn_node_index == initiating_rn_node_idx_0)||(cache_initializing_rn_node_index == initiating_rn_node_idx_1))begin
           perform_initialization_from_rn_used_for_hazard =  1;
         end
         else begin
           perform_initialization_from_rn_used_for_hazard =  0;
         end  
      end  
    end else begin
      cache_initializing_rn_node_index = initiating_rn_node_idx_0;
      perform_initialization_from_rn_used_for_hazard =  1;
    end

    str_initiating_rn_node_indices = "";
    /** Display the contents of Active Participating RN-F Nodes */
    foreach (active_participating_rn_f_nodes[j]) begin
      str_initiating_rn_node_indices = {str_initiating_rn_node_indices, $sformatf(" %0d", active_participating_rn_f_nodes[j])};
    end 
    str_initiating_rn_node_indices = {str_initiating_rn_node_indices, $sformatf("\n RN nodes used to initiate the transactions are initiating_rn_node_idx_0 : %0d, initiating_rn_node_idx_1 : %0d,cache_initializing_rn_node_index : %0d ", initiating_rn_node_idx_0, initiating_rn_node_idx_1, cache_initializing_rn_node_index)};
    `svt_xvm_debug("body", $sformatf("contents of active_participating_rn_f_nodes and RN nodes used to initiate the transactions are %0s", str_initiating_rn_node_indices));

    for(int i = 0; i < sequence_length; i++) begin

      /** Initiate MAKEUNIQUE transaction from cache_initializing_rn_node_index to randomly selected HN Node. */ 
      `svt_xvm_do_on_with(makeunique_seq, p_sequencer.rn_virt_seqr[cache_initializing_rn_node_index].rn_xact_seqr,
      {
        sequence_length == 1;
        hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
        seq_hn_node_idx == target_hn_node_idx_0;
        use_seq_is_non_secure_access == 0;               
      })

      /** Wait for MakeUnique transactions to finish */ 
      makeunique_seq.write_tran.wait_end();
      txn_address = makeunique_seq.output_xacts[0].addr;
      txn_data = makeunique_seq.data_in_cache;
      txn_mem_attr_allocate_hint = makeunique_seq.output_xacts[0].mem_attr_allocate_hint;
      txn_snp_attr_is_snoopable = makeunique_seq.output_xacts[0].snp_attr_is_snoopable;
      txn_snp_attr_snp_domain_type = makeunique_seq.output_xacts[0].snp_attr_snp_domain_type;
      txn_is_non_secure_access = makeunique_seq.output_xacts[0].is_non_secure_access;

      /** Writeback the data to the main memory at the respective address. */ 
      if(perform_initialization_from_rn_used_for_hazard) begin
        `svt_xvm_do_on_with(copyback_seq, p_sequencer.rn_virt_seqr[cache_initializing_rn_node_index].rn_xact_seqr,
        {
          sequence_length == 1;
          data_in_cache == txn_data;
          seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
          hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
          min_addr == txn_address;
          max_addr == txn_address;
          seq_xact_type == svt_chi_transaction::WRITEBACKFULL;
          seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
          seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
          seq_is_non_secure_access == txn_is_non_secure_access;
          use_seq_is_non_secure_access == 1;               
        }
        )
        /** Waiting for copyback transaction to complete */ 
        copyback_seq.copyback_tran.wait_end();
      end 

      /* CMO-WRITE hazard at HN **/
      fork 
        begin      
`ifndef SVT_CHI_ENABLE_MULTI_CLOCK
          @ (posedge sys_cfg.chi_if.clk);
`else
          @ (posedge sys_cfg.chi_if.rn_clk[initiating_rn_node_idx_0]);
`endif          
          xact_hazard_sema_0.get();
          /** Initiate CMO type of transaction from initiating_rn_node_idx_0 to txn_address. */ 
          `svt_xvm_do_on_with(cmo_seq_0[i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
          {
            sequence_length == 1;
            hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
            min_addr == txn_address;
            max_addr == txn_address;
            seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
            seq_snp_attr_is_snoopable == txn_snp_attr_is_snoopable;
            seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
            seq_is_non_secure_access == txn_is_non_secure_access;
            use_seq_is_non_secure_access == 1;               
            `ifdef SVT_CHI_ISSUE_B_ENABLE
              if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A)
                {
                  !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSIST, svt_chi_transaction::STASHONCEUNIQUE,svt_chi_transaction::STASHONCESHARED});
                }
              `ifdef SVT_CHI_ISSUE_E_ENABLE
              else if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision < svt_chi_node_configuration::ISSUE_E){
                !(seq_xact_type inside {svt_chi_transaction::STASHONCESEPUNIQUE, svt_chi_transaction::STASHONCESEPSHARED});
                if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision < svt_chi_node_configuration::ISSUE_D){
                  !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                  if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0)
                    !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                }
                else if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision >= svt_chi_node_configuration::ISSUE_D){
                  if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].cleansharedpersistsep_xact_enable ==0)
                    !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                  if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0)
                    !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                }
              }
              else if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision >= svt_chi_node_configuration::ISSUE_E){
                if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].cleansharedpersistsep_xact_enable == 0)
                  !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0)
                  !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED,svt_chi_transaction::STASHONCESEPUNIQUE, svt_chi_transaction::STASHONCESEPSHARED});
              }
              `elsif SVT_CHI_ISSUE_D_ENABLE
              else if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision < svt_chi_node_configuration::ISSUE_D){
                !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0)
                  !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
              }
              else if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision >= svt_chi_node_configuration::ISSUE_D){
                if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].cleansharedpersistsep_xact_enable ==0)
                  !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0){
                  !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                }
              }
              `endif //issue_d_enable
              else if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0){
                  !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                }
            `endif
          }
          )
          xact_hazard_sema_0.put();
          /** Waiting for CMO type transaction to complete */ 
          cmo_seq_0[i].cmo_tran.wait_end(); 
        end
        begin
`ifndef SVT_CHI_ENABLE_MULTI_CLOCK
          @ (posedge sys_cfg.chi_if.clk);
`else
          @ (posedge sys_cfg.chi_if.rn_clk[initiating_rn_node_idx_1]);
`endif          
          xact_hazard_sema_1.get();
          /** Initiate a write type transaction from initiating_rn_node_idx_1 to txn_address. */ 
          `svt_xvm_do_on_with(write_seq_0[i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,
            {
            `ifdef SVT_CHI_ISSUE_E_ENABLE
             if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision == svt_chi_node_configuration::ISSUE_A ){
               seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL};
             }            
             else if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision >= svt_chi_node_configuration::ISSUE_E ) {
               if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 0) {
                 seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEZERO, svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL};
               }   
               else if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 1){
                 seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEZERO, svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL, svt_chi_transaction::WRITEUNIQUEFULLSTASH, svt_chi_transaction::WRITEUNIQUEPTLSTASH};
               }        
             }
             else if ((sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision < svt_chi_node_configuration::ISSUE_E ) && (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision > svt_chi_node_configuration::ISSUE_A )){
               if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 0) {
                 seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL};
               }
               else if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 1) {
                 seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL, svt_chi_transaction::WRITEUNIQUEFULLSTASH, svt_chi_transaction::WRITEUNIQUEPTLSTASH};
               }
             }
            `elsif SVT_CHI_ISSUE_B_ENABLE
             if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision == svt_chi_node_configuration::ISSUE_A || sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 0) {
               seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL};
             }
             else{
               seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL, svt_chi_transaction::WRITEUNIQUEFULLSTASH, svt_chi_transaction::WRITEUNIQUEPTLSTASH};
             }
            `else
               seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL};
            `endif
             sequence_length               == 1;
             seq_order_type   != svt_chi_transaction::NO_ORDERING_REQUIRED;
             hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
             min_addr          == txn_address;
             max_addr          == txn_address;
             seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
             seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
             seq_is_non_secure_access == txn_is_non_secure_access;
             use_seq_is_non_secure_access == 1;               
            }
          )
          xact_hazard_sema_1.put();
          /** Wait for write type transactions to finish */ 
          write_seq_0[i].write_tran.wait_end();
        end
      join
    end

    `uvm_info("body", "Exiting...", UVM_HIGH)
  endtask: body

  virtual task post_body();
    drop_phase_objection();
  endtask

endclass: svt_chi_system_protocol_flow_ctrl_hn_cmo_write_hazard_directed_virtual_sequence

function svt_chi_system_protocol_flow_ctrl_hn_cmo_write_hazard_directed_virtual_sequence::new(string name="svt_chi_system_protocol_flow_ctrl_hn_cmo_write_hazard_directed_virtual_sequence");
  super.new(name);
endfunction

/**
 * @groupname CHI_SYS_HAZARD
 * Abstract:
 * svt_chi_system_protocol_flow_ctrl_hn_cmo_read_hazard_directed_virtual_sequence
 * provides a sequence to test how components handle various hazard conditions
 * applicable for CMO and read transactions
 * 1. Initialize the cacheline using MAKEUNIQUE transaction
 * from RN to the random address.
 * 2. Send cmo type of transaction to the same address from different RN
 * 3. Send read type of transaction to the same address from different RN
 * 4. Check the order in which the two requests are processed by HN.
 * .
 */

class svt_chi_system_protocol_flow_ctrl_hn_cmo_read_hazard_directed_virtual_sequence extends svt_chi_system_protocol_flow_ctrl_xact_hazard_virtual_sequence;

  /** Parameter that controls the number of transactions that will be generated */
  rand int unsigned sequence_length = 10;

  rand bit enable_outstanding = 0;

  bit enable_outstanding_status = 0;

  /** Constrain the sequence length to a reasonable value */
  constraint reasonable_sequence_length {
    sequence_length <= 100;
  }

  /** UVM Object Utility macro */
  `uvm_object_utils(svt_chi_system_protocol_flow_ctrl_hn_cmo_read_hazard_directed_virtual_sequence)

  extern function new(string name="svt_chi_system_protocol_flow_ctrl_hn_cmo_read_hazard_directed_virtual_sequence"); 

  virtual task pre_body();
    raise_phase_objection();
  endtask
  
  virtual task body();
    bit                           status;
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0] txn_address;
    bit [`SVT_CHI_MAX_DATA_WIDTH -1:0] txn_data;
    bit txn_mem_attr_allocate_hint, txn_snp_attr_is_snoopable, txn_snp_attr_snp_domain_type, txn_is_non_secure_access;

    /** Sub CMO type transaction directed sequences initiated from this sequence */
    svt_chi_rn_cmo_type_transaction_directed_sequence cmo_seq_0[int];
    svt_chi_rn_read_type_transaction_directed_sequence read_seq_0[int];

    /** Sub sequences initiated from this sequence */
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq;
    svt_chi_rn_copyback_type_transaction_directed_sequence copyback_seq;

    `uvm_info("body", "Entered ...", UVM_HIGH)

    super.body();
    // Default
    enable_outstanding = 0;
    status = uvm_config_db #(int unsigned)::get(null, get_full_name(), "sequence_length", sequence_length);
    `uvm_info("body", $sformatf("sequence_length is %0d as a result of %0s.", sequence_length, status ? "config DB" : "randomization"), UVM_HIGH);

    enable_outstanding_status = uvm_config_db#(bit)::get(m_sequencer, get_type_name(), "enable_outstanding", enable_outstanding);
    `uvm_info("body", $sformatf("enable_outstanding is %0b as a result of %0s", enable_outstanding, (enable_outstanding_status?"config DB":"default setting")), UVM_HIGH);

    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :initiating_rn_f_node_index_0;
    initiating_rn_node_idx_1 = initiating_rn_node_index_1_status ? initiating_rn_node_index_1_from_config_db :initiating_rn_f_node_index_1;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_f_node_index_0;

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /** 
     * If the number of active_participating_rn_f_nodes are greater than 2, then
     * we can initialize the cache/memory from the RN having node index 
     * initiating_rn_f_node_index_2.
     * If the number of active_participating_rn_f_nodes are equal to 2, then
     * we can initialize the cache/memory from the RN having node index 
     * initiating_rn_node_idx_0.
     *  
     */
    if((active_participating_rn_f_nodes.size()>2) && (valid_initiating_rn_f_node_index_2))begin
      cache_initializing_rn_node_index = initiating_rn_f_node_index_2;
      /**
       * If the cache_initializing_rn_node_index is same as any of the RN node indices 
       * which are passed through config i.e initiating_rn_node_idx_0,initiating_rn_node_idx_1,
       * then assert perform_initialization_from_rn_used_for_hazard to 1, so that RN will be
       * in valid state to initilize the respective transaction.
       */
      if(initiating_rn_node_index_0_status || initiating_rn_node_index_1_status)begin
         if((cache_initializing_rn_node_index == initiating_rn_node_idx_0)||(cache_initializing_rn_node_index == initiating_rn_node_idx_1))begin
           perform_initialization_from_rn_used_for_hazard =  1;
         end
         else begin
           perform_initialization_from_rn_used_for_hazard =  0;
         end  
      end  
    end else begin
      cache_initializing_rn_node_index = initiating_rn_node_idx_0;
      perform_initialization_from_rn_used_for_hazard =  1;
    end

    str_initiating_rn_node_indices = "";
    /** Display the contents of Active Participating RN-F Nodes */
    foreach (active_participating_rn_f_nodes[j]) begin
      str_initiating_rn_node_indices = {str_initiating_rn_node_indices, $sformatf(" %0d", active_participating_rn_f_nodes[j])};
    end 
    str_initiating_rn_node_indices = {str_initiating_rn_node_indices, $sformatf("\n RN nodes used to initiate the transactions are initiating_rn_node_idx_0 : %0d, initiating_rn_node_idx_1 : %0d,cache_initializing_rn_node_index : %0d ", initiating_rn_node_idx_0, initiating_rn_node_idx_1, cache_initializing_rn_node_index)};
    `svt_xvm_debug("body", $sformatf("contents of active_participating_rn_f_nodes and RN nodes used to initiate the transactions are %0s", str_initiating_rn_node_indices));

    for(int i = 0; i < sequence_length; i++) begin

      /** Initiate MAKEUNIQUE transaction from cache_initializing_rn_node_index to randomly selected HN Node. */ 
      `svt_xvm_do_on_with(makeunique_seq, p_sequencer.rn_virt_seqr[cache_initializing_rn_node_index].rn_xact_seqr,
      {
        sequence_length == 1;
        hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
        seq_hn_node_idx == target_hn_node_idx_0;
        use_seq_is_non_secure_access == 0;               
      })

      /** Wait for MakeUnique transactions to finish */ 
      makeunique_seq.write_tran.wait_end();
      txn_address = makeunique_seq.output_xacts[0].addr;
      txn_data = makeunique_seq.data_in_cache;
      txn_mem_attr_allocate_hint = makeunique_seq.output_xacts[0].mem_attr_allocate_hint;
      txn_snp_attr_is_snoopable = makeunique_seq.output_xacts[0].snp_attr_is_snoopable;
      txn_snp_attr_snp_domain_type = makeunique_seq.output_xacts[0].snp_attr_snp_domain_type;
      txn_is_non_secure_access = makeunique_seq.output_xacts[0].is_non_secure_access;

      /** Writeback the data to the main memory at the respective address. */ 
      if(perform_initialization_from_rn_used_for_hazard) begin
        `svt_xvm_do_on_with(copyback_seq, p_sequencer.rn_virt_seqr[cache_initializing_rn_node_index].rn_xact_seqr,
        {
          sequence_length == 1;
          data_in_cache == txn_data;
          seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
          hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
          min_addr == txn_address;
          max_addr == txn_address;
          seq_xact_type == svt_chi_transaction::WRITEBACKFULL;
          seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
          seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
          seq_is_non_secure_access == txn_is_non_secure_access;
          use_seq_is_non_secure_access == 1;               
        }
        )
        /** Waiting for copyback transaction to complete */ 
        copyback_seq.copyback_tran.wait_end();
      end 

      /* CMO-READ hazard at HN **/
      fork 
        begin      
`ifndef SVT_CHI_ENABLE_MULTI_CLOCK
          @ (posedge sys_cfg.chi_if.clk);
`else
          @ (posedge sys_cfg.chi_if.rn_clk[initiating_rn_node_idx_0]);
`endif          
          xact_hazard_sema_0.get();
          /** Initiate CMO type of transaction from initiating_rn_node_idx_0 to txn_address. */ 
          `svt_xvm_do_on_with(cmo_seq_0[i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
          {
            sequence_length == 1;
            hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
            min_addr == txn_address;
            max_addr == txn_address;
            seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
            seq_snp_attr_is_snoopable == txn_snp_attr_is_snoopable;
            seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
            seq_is_non_secure_access == txn_is_non_secure_access;
            use_seq_is_non_secure_access == 1;               
            `ifdef SVT_CHI_ISSUE_B_ENABLE
              if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A)
                {
                  !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSIST, svt_chi_transaction::STASHONCEUNIQUE,svt_chi_transaction::STASHONCESHARED});
                }
              `ifdef SVT_CHI_ISSUE_E_ENABLE
              else if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision < svt_chi_node_configuration::ISSUE_E){
                !(seq_xact_type inside {svt_chi_transaction::STASHONCESEPUNIQUE, svt_chi_transaction::STASHONCESEPSHARED});
                if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision < svt_chi_node_configuration::ISSUE_D){
                  !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                  if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0)
                    !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                }
                else if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision >= svt_chi_node_configuration::ISSUE_D){
                  if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].cleansharedpersistsep_xact_enable ==0)
                    !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                  if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0)
                    !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                }
              }
              else if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision >= svt_chi_node_configuration::ISSUE_E){
                if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].cleansharedpersistsep_xact_enable == 0)
                  !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0)
                  !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED,svt_chi_transaction::STASHONCESEPUNIQUE, svt_chi_transaction::STASHONCESEPSHARED});
              }
              `elsif SVT_CHI_ISSUE_D_ENABLE
              else if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision < svt_chi_node_configuration::ISSUE_D){
                !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0)
                  !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
              }
              else if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision >= svt_chi_node_configuration::ISSUE_D){
                if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].cleansharedpersistsep_xact_enable ==0)
                  !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0){
                  !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                }
              }
              `endif //issue_d_enable
              else if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0){
                  !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                }
            `endif
          }
          )
          xact_hazard_sema_0.put();
          /** Waiting for CMO type transaction to complete */ 
          cmo_seq_0[i].cmo_tran.wait_end(); 
        end
        begin
`ifndef SVT_CHI_ENABLE_MULTI_CLOCK
          @ (posedge sys_cfg.chi_if.clk);
`else
          @ (posedge sys_cfg.chi_if.rn_clk[initiating_rn_node_idx_1]);
`endif          
          xact_hazard_sema_1.get();
          /** Initiate a read type transaction from initiating_rn_node_idx_1 to txn_address. */ 
          `svt_xvm_do_on_with(read_seq_0[i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,
          {
            sequence_length == 1;
            data_in_cache == txn_data;
            seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
            hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
            min_addr == txn_address;
            max_addr == txn_address;
            by_pass_read_data_check == 1;
            seq_xact_type != svt_chi_transaction::READNOSNP;
            seq_xact_type != svt_chi_transaction::CLEANUNIQUE;
            seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
            seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
            seq_is_non_secure_access == txn_is_non_secure_access;
            use_seq_is_non_secure_access == 1;               
            `ifdef SVT_CHI_ISSUE_B_ENABLE
              if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type != svt_chi_transaction::READNOTSHAREDDIRTY;
              if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision == svt_chi_node_configuration::ISSUE_A || sys_cfg.readspec_enable == 0) seq_xact_type != svt_chi_transaction::READSPEC;
              if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type != svt_chi_transaction::READONCECLEANINVALID;
              if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type != svt_chi_transaction::READONCEMAKEINVALID;
            `endif
            `ifdef SVT_CHI_ISSUE_E_ENABLE
              if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision <= svt_chi_node_configuration::ISSUE_D) seq_xact_type != svt_chi_transaction::READPREFERUNIQUE;
            `endif
          }
          )
          xact_hazard_sema_1.put();
          /** Waiting for Read type transaction to complete */ 
          read_seq_0[i].read_tran.wait_end();
        end
      join
    end

    `uvm_info("body", "Exiting...", UVM_HIGH)
  endtask: body

  virtual task post_body();
    drop_phase_objection();
  endtask

endclass: svt_chi_system_protocol_flow_ctrl_hn_cmo_read_hazard_directed_virtual_sequence

function svt_chi_system_protocol_flow_ctrl_hn_cmo_read_hazard_directed_virtual_sequence::new(string name="svt_chi_system_protocol_flow_ctrl_hn_cmo_read_hazard_directed_virtual_sequence");
  super.new(name);
endfunction

/**
 * @groupname CHI_SYS_HAZARD
 * Abstract:
 * svt_chi_system_protocol_flow_ctrl_hn_read_copyback_hazard_directed_virtual_sequence
 * provides a sequence to test how components handle various hazard conditions
 * applicable for copyback and snoop transactions
 * 1. Send MAKEUNIQUE transaction to random address from random RN
 * 2. Send read type of transaction to the same address from different RN
 * 3. Send copyback type of transaction to the same address from the same
 *    RN from which MAKEUNIQUE transaction initiated.
 * 4. Check the order in which the two requests are processed by HN.
 * .
 */
class svt_chi_system_protocol_flow_ctrl_hn_read_copyback_hazard_directed_virtual_sequence extends svt_chi_system_protocol_flow_ctrl_xact_hazard_virtual_sequence;

  /** Parameter that controls the number of transactions that will be generated */
  rand int unsigned sequence_length = 10;

  rand bit enable_outstanding = 0;

  bit enable_outstanding_status = 0;

  /** Constrain the sequence length to a reasonable value */
  constraint reasonable_sequence_length {
    sequence_length <= 100;
  }

  /** UVM Object Utility macro */
  `uvm_object_utils(svt_chi_system_protocol_flow_ctrl_hn_read_copyback_hazard_directed_virtual_sequence)

  extern function new(string name="svt_chi_system_protocol_flow_ctrl_hn_read_copyback_hazard_directed_virtual_sequence"); 

  virtual task pre_body();
    raise_phase_objection();
  endtask
  
  virtual task body();
    bit                           status;
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0] txn_address;
    bit [`SVT_CHI_MAX_DATA_WIDTH -1:0] txn_data;
    bit txn_mem_attr_allocate_hint, txn_snp_attr_snp_domain_type, txn_is_non_secure_access;

    /** Sub sequences initiated from this sequence */
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq;

    /** Sub sequences initiated from this sequence */
    svt_chi_rn_read_type_transaction_directed_sequence read_seq_0[int],read_seq_1[int];
    svt_chi_rn_copyback_type_transaction_directed_sequence copyback_seq[int];

    `uvm_info("body", "Entered ...", UVM_HIGH)

    super.body();
    // Default
    enable_outstanding = 0;
    status = uvm_config_db #(int unsigned)::get(null, get_full_name(), "sequence_length", sequence_length);
    `uvm_info("body", $sformatf("sequence_length is %0d as a result of %0s.", sequence_length, status ? "config DB" : "randomization"), UVM_HIGH);

    enable_outstanding_status = uvm_config_db#(bit)::get(m_sequencer, get_type_name(), "enable_outstanding", enable_outstanding);
    `uvm_info("body", $sformatf("enable_outstanding is %0b as a result of %0s", enable_outstanding, (enable_outstanding_status?"config DB":"default setting")), UVM_HIGH);

    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :initiating_rn_f_node_index_0;
    initiating_rn_node_idx_1 = initiating_rn_node_index_1_status ? initiating_rn_node_index_1_from_config_db :initiating_rn_f_node_index_1;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_f_node_index_0;

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    str_initiating_rn_node_indices = "";
    /** Display the contents of Active Participating RN-F Nodes */
    foreach (active_participating_rn_f_nodes[j]) begin
      str_initiating_rn_node_indices = {str_initiating_rn_node_indices, $sformatf(" %0d", active_participating_rn_f_nodes[j])};
    end 
    str_initiating_rn_node_indices = {str_initiating_rn_node_indices, $sformatf("\n RN nodes used to initiate the transactions are initiating_rn_node_idx_0 : %0d, initiating_rn_node_idx_1 : %0d", initiating_rn_node_idx_0, initiating_rn_node_idx_1)};
    `svt_xvm_debug("body", $sformatf("contents of active_participating_rn_f_nodes and RN nodes used to initiate the transactions are %0s", str_initiating_rn_node_indices));

    for(int i = 0; i < sequence_length; i++) begin
      bit rn0_is_unique, rn0_is_clean, rn1_is_unique, rn1_is_clean, rn0_read_status, rn1_read_status;
      bit rn_cache_dirty_state,rn_cache_unique_state;

      /** Write data into Cache of Randomly selected first RN with address of randomly selected HN Node */
      `svt_xvm_do_on_with(makeunique_seq, p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,
      {
        sequence_length == 1;
        hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
        seq_hn_node_idx == target_hn_node_idx_0;
        use_seq_is_non_secure_access == 0;
      })

      /** Wait for MakeUnique transactions to finish */ 
      makeunique_seq.write_tran.wait_end();
      txn_address = makeunique_seq.output_xacts[0].addr;
      txn_data = makeunique_seq.data_in_cache;
      txn_mem_attr_allocate_hint = makeunique_seq.output_xacts[0].mem_attr_allocate_hint;
      txn_snp_attr_snp_domain_type = makeunique_seq.output_xacts[0].snp_attr_snp_domain_type;
      txn_is_non_secure_access = makeunique_seq.output_xacts[0].is_non_secure_access;

      /* READ-COPYBACK hazard at HN **/
      fork 
        begin      
`ifndef SVT_CHI_ENABLE_MULTI_CLOCK
          @ (posedge sys_cfg.chi_if.clk);
`else
          @ (posedge sys_cfg.chi_if.rn_clk[initiating_rn_node_idx_0]);
`endif
          xact_hazard_sema_0.get();
         // Do a READSHARED transaction from initiating_rn_node_idx_0, followed by WRITEBACK
         // transaction from initiating_rn_node_idx_1 after a delay of 1 clock cycle.
          `svt_xvm_do_on_with(read_seq_0[i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
          {
            sequence_length == 1;
            data_in_cache == txn_data;
            seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
            hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
            min_addr == txn_address;
            max_addr == txn_address;
            by_pass_read_data_check == 1;
            seq_xact_type == svt_chi_transaction::READSHARED;
            seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
            seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
            seq_is_non_secure_access == txn_is_non_secure_access;
            use_seq_is_non_secure_access == 1;               
          }
          )
          xact_hazard_sema_0.put();

          /** Waiting for Read type transaction to complete */ 
          read_seq_0[i].read_tran.wait_end(); 
        end
        begin
`ifndef SVT_CHI_ENABLE_MULTI_CLOCK
          @ (posedge sys_cfg.chi_if.clk);
`else
          @ (posedge sys_cfg.chi_if.rn_clk[initiating_rn_node_idx_1]);
`endif
          xact_hazard_sema_1.get();
          /** Initiate a WRITEBACKFULL transaction from initiating_rn_node_idx_1 to txn_address. */ 
          `svt_xvm_do_on_with(copyback_seq[i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,
          {
            sequence_length == 1;
            data_in_cache == txn_data;
            seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
            hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
            min_addr == txn_address;
            max_addr == txn_address;
            seq_xact_type == svt_chi_transaction::WRITEBACKFULL;
            seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
            seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
            seq_is_non_secure_access == txn_is_non_secure_access;
            use_seq_is_non_secure_access == 1;               
          }
          )
          xact_hazard_sema_1.put();
          /** Waiting for copyback transaction to complete */ 
          copyback_seq[i].copyback_tran.wait_end(); 
        end
      join
    end

    `uvm_info("body", "Exiting...", UVM_HIGH)
  endtask: body

  virtual task post_body();
    drop_phase_objection();
  endtask

endclass: svt_chi_system_protocol_flow_ctrl_hn_read_copyback_hazard_directed_virtual_sequence

function svt_chi_system_protocol_flow_ctrl_hn_read_copyback_hazard_directed_virtual_sequence::new(string name="svt_chi_system_protocol_flow_ctrl_hn_read_copyback_hazard_directed_virtual_sequence");
  super.new(name);
endfunction

/**
 * @groupname CHI_SYS_HAZARD
 * Abstract:
 * svt_chi_system_protocol_flow_ctrl_hn_cmo_copyback_hazard_directed_virtual_sequence
 * provides a sequence to test how components handle various hazard conditions
 * applicable for copyback and snoop transactions
 * 1. Send MAKEUNIQUE transaction to random address from random RN
 * 2. Send CMO type of transaction to the same address from different RN
 * 3. Send copyback type of transaction to the same address from the same
 *    RN from which MAKEUNIQUE transaction initiated.
 * 4. Check the order in which the two requests are processed by HN.
 * .
 */
class svt_chi_system_protocol_flow_ctrl_hn_cmo_copyback_hazard_directed_virtual_sequence extends svt_chi_system_protocol_flow_ctrl_xact_hazard_virtual_sequence;

  /** Parameter that controls the number of transactions that will be generated */
  rand int unsigned sequence_length = 10;

  rand bit enable_outstanding = 0;

  bit enable_outstanding_status = 0;

  /** Constrain the sequence length to a reasonable value */
  constraint reasonable_sequence_length {
    sequence_length <= 100;
  }

  /** UVM Object Utility macro */
  `uvm_object_utils(svt_chi_system_protocol_flow_ctrl_hn_cmo_copyback_hazard_directed_virtual_sequence)

  extern function new(string name="svt_chi_system_protocol_flow_ctrl_hn_cmo_copyback_hazard_directed_virtual_sequence"); 

  virtual task pre_body();
    raise_phase_objection();
  endtask
  
  virtual task body();
    bit                           status;
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0] txn_address;
    bit [`SVT_CHI_MAX_DATA_WIDTH -1:0] txn_data;
    bit txn_mem_attr_allocate_hint, txn_snp_attr_is_snoopable, txn_snp_attr_snp_domain_type, txn_is_non_secure_access;

    /** Sub sequences initiated from this sequence */
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq;

    /** Sub CMO type transaction directed sequences initiated from this sequence */
    svt_chi_rn_cmo_type_transaction_directed_sequence cmo_seq[int];
    svt_chi_rn_copyback_type_transaction_directed_sequence copyback_seq[int];

    `uvm_info("body", "Entered ...", UVM_HIGH)

    super.body();
    // Default
    enable_outstanding = 0;
    status = uvm_config_db #(int unsigned)::get(null, get_full_name(), "sequence_length", sequence_length);
    `uvm_info("body", $sformatf("sequence_length is %0d as a result of %0s.", sequence_length, status ? "config DB" : "randomization"), UVM_HIGH);

    enable_outstanding_status = uvm_config_db#(bit)::get(m_sequencer, get_type_name(), "enable_outstanding", enable_outstanding);
    `uvm_info("body", $sformatf("enable_outstanding is %0b as a result of %0s", enable_outstanding, (enable_outstanding_status?"config DB":"default setting")), UVM_HIGH);

    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :initiating_rn_f_node_index_0;
    initiating_rn_node_idx_1 = initiating_rn_node_index_1_status ? initiating_rn_node_index_1_from_config_db :initiating_rn_f_node_index_1;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_f_node_index_0;

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    str_initiating_rn_node_indices = "";
    /** Display the contents of Active Participating RN-F Nodes */
    foreach (active_participating_rn_f_nodes[j]) begin
      str_initiating_rn_node_indices = {str_initiating_rn_node_indices, $sformatf(" %0d", active_participating_rn_f_nodes[j])};
    end 
    str_initiating_rn_node_indices = {str_initiating_rn_node_indices, $sformatf("\n RN nodes used to initiate the transactions are initiating_rn_node_idx_0 : %0d, initiating_rn_node_idx_1 : %0d", initiating_rn_node_idx_0, initiating_rn_node_idx_1)};
    `svt_xvm_debug("body", $sformatf("contents of active_participating_rn_f_nodes and RN nodes used to initiate the transactions are %0s", str_initiating_rn_node_indices));

    for(int i = 0; i < sequence_length; i++) begin
      bit rn0_is_unique, rn0_is_clean, rn1_is_unique, rn1_is_clean, rn0_read_status, rn1_read_status;
      bit rn_cache_dirty_state,rn_cache_unique_state;

      /** Write data into Cache of Randomly selected first RN with address of randomly selected HN Node */
      `svt_xvm_do_on_with(makeunique_seq, p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,
      {
        sequence_length == 1;
        hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
        seq_hn_node_idx == target_hn_node_idx_0;
        use_seq_is_non_secure_access == 0;
      })

      /** Wait for MakeUnique transactions to finish */ 
      makeunique_seq.write_tran.wait_end();
      txn_address = makeunique_seq.output_xacts[0].addr;
      txn_data = makeunique_seq.data_in_cache;
      txn_mem_attr_allocate_hint = makeunique_seq.output_xacts[0].mem_attr_allocate_hint;
      txn_snp_attr_is_snoopable = makeunique_seq.output_xacts[0].snp_attr_is_snoopable;
      txn_snp_attr_snp_domain_type = makeunique_seq.output_xacts[0].snp_attr_snp_domain_type;
      txn_is_non_secure_access = makeunique_seq.output_xacts[0].is_non_secure_access;

      /* CMO-COPYBACK hazard at HN **/
      fork 
        begin      
`ifndef SVT_CHI_ENABLE_MULTI_CLOCK
          @ (posedge sys_cfg.chi_if.clk);
`else
          @ (posedge sys_cfg.chi_if.rn_clk[initiating_rn_node_idx_0]);
`endif          
          xact_hazard_sema_0.get();
         // Do a CMO transaction from initiating_rn_node_idx_0, followed by WRITEBACK
         // transaction from initiating_rn_node_idx_1 after a delay of 1 clock cycle.
          `svt_xvm_do_on_with(cmo_seq[i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
          {
            sequence_length == 1;
            hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
            min_addr == txn_address;
            max_addr == txn_address;
            seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
            seq_snp_attr_is_snoopable == txn_snp_attr_is_snoopable;
            seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
            seq_is_non_secure_access == txn_is_non_secure_access;
            use_seq_is_non_secure_access == 1;        
            `ifdef SVT_CHI_ISSUE_B_ENABLE
              if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A)
                {
                  !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSIST, svt_chi_transaction::STASHONCEUNIQUE,svt_chi_transaction::STASHONCESHARED});
                }
              `ifdef SVT_CHI_ISSUE_E_ENABLE
              else if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision < svt_chi_node_configuration::ISSUE_E){
                !(seq_xact_type inside {svt_chi_transaction::STASHONCESEPUNIQUE, svt_chi_transaction::STASHONCESEPSHARED});
                if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision < svt_chi_node_configuration::ISSUE_D){
                  !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                  if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0)
                    !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                }
                else if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision >= svt_chi_node_configuration::ISSUE_D){
                  if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].cleansharedpersistsep_xact_enable ==0)
                    !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                  if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0)
                    !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                }
              }
              else if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision >= svt_chi_node_configuration::ISSUE_E){
                if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].cleansharedpersistsep_xact_enable == 0)
                  !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0)
                  !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED,svt_chi_transaction::STASHONCESEPUNIQUE, svt_chi_transaction::STASHONCESEPSHARED});
              }
              `elsif SVT_CHI_ISSUE_D_ENABLE
              else if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision < svt_chi_node_configuration::ISSUE_D) {
                !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0){
                  !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                }
              }
              else if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision >= svt_chi_node_configuration::ISSUE_D){
                if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].cleansharedpersistsep_xact_enable ==0)
                 !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0){
                  !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                }
              }
              `endif //issue_d_enable
              else if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].cache_stashing_enable == 0){
                  !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                }
            `endif
          }
          )
          xact_hazard_sema_0.put();

          /** Waiting for CMO type transaction to complete */ 
          cmo_seq[i].cmo_tran.wait_end(); 
        end
        begin
`ifndef SVT_CHI_ENABLE_MULTI_CLOCK
          @ (posedge sys_cfg.chi_if.clk);
`else
          @ (posedge sys_cfg.chi_if.rn_clk[initiating_rn_node_idx_1]);
`endif          

          xact_hazard_sema_1.get();

          /** Initiate a WRITEBACKFULL transaction from initiating_rn_node_idx_1 to txn_address. */ 
          `svt_xvm_do_on_with(copyback_seq[i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,
          {
            sequence_length == 1;
            data_in_cache == txn_data;
            seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
            hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
            min_addr == txn_address;
            max_addr == txn_address;
            seq_xact_type != svt_chi_transaction::WRITEBACKPTL;
            seq_xact_type != svt_chi_transaction::WRITECLEANPTL;
            seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
            seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
            seq_is_non_secure_access == txn_is_non_secure_access;
            use_seq_is_non_secure_access == 1;               
          }
          )
          xact_hazard_sema_1.put();
          /** Waiting for copyback transaction to complete */ 
          copyback_seq[i].copyback_tran.wait_end(); 
        end
      join
    end

    `uvm_info("body", "Exiting...", UVM_HIGH)
  endtask: body

  virtual task post_body();
    drop_phase_objection();
  endtask

endclass: svt_chi_system_protocol_flow_ctrl_hn_cmo_copyback_hazard_directed_virtual_sequence

function svt_chi_system_protocol_flow_ctrl_hn_cmo_copyback_hazard_directed_virtual_sequence::new(string name="svt_chi_system_protocol_flow_ctrl_hn_cmo_copyback_hazard_directed_virtual_sequence");
  super.new(name);
endfunction

`ifdef SVT_CHI_ISSUE_E_ENABLE

/**
 * @groupname CHI_SYS_HAZARD
 * Abstract:
 * svt_chi_e_protocol_flow_ctrl_combined_write_cmo_hazard_base_sequence
 * acts as a base sequence for various combined_write_cmo hazard sequences.
 */
class svt_chi_e_protocol_flow_ctrl_combined_write_cmo_hazard_base_sequence extends svt_chi_system_protocol_flow_ctrl_xact_hazard_virtual_sequence;

`svt_xvm_object_utils(svt_chi_e_protocol_flow_ctrl_combined_write_cmo_hazard_base_sequence)

  function new(string name="svt_chi_e_protocol_flow_ctrl_combined_write_cmo_hazard_base_sequence");
    super.new(name);
  endfunction : new

  virtual task body();
    super.body();
  endtask: body

  /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting Request Nodes = 2
   *  #- minimum supporting Home Nodes = 1
   *  #- The chi_spec_version for all participating nodes should be ISSUE_E onwards.
   */
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    string str_is_supported_info_prefix = "This sequence cannot be run based on the current configuration.\n";
    string str_is_supported_info = "";
    string str_is_supported_info_suffix = "Modify configurations through svt_chi_node_configuration::chi_spec_revision\n";

    is_supported = super.is_supported(cfg, silent);

    if(is_supported) begin
      //check spec version for node 0 and node 1
      if((sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision < svt_chi_node_configuration::ISSUE_E) || (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision < svt_chi_node_configuration::ISSUE_E)) begin
        is_supported = 0;
        str_is_supported_info = $sformatf("svt_chi_node_configuration::chi_spec_revision is not set to svt_chi_node_configuration::ISSUE_E or later for initiating requester node %0d and node %0d. This sequence can only be initiated from RN when svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_E or later ", initiating_rn_node_idx_0,initiating_rn_node_idx_1);
      end else begin
        is_supported = 1;
      end  
  
      if (!is_supported) begin
        string str_complete_is_supported_info = {str_is_supported_info_prefix, str_is_supported_info, str_is_supported_info_suffix};
        issue_is_supported_failure(str_complete_is_supported_info);
      end
    end
  endfunction
endclass:svt_chi_e_protocol_flow_ctrl_combined_write_cmo_hazard_base_sequence

/**
 * @groupname CHI_SYS_HAZARD
 * Abstract:
 * svt_chi_e_protocol_flow_ctrl_hn_combined_coherent_noncopyback_write_cmo_hazard_sequence
 * provides a sequence to test how components handle various hazard conditions between noncopyback combined write cmo
 * transaction and standalone noncopyback writes or  combined write cmo transaction
 * 1. Send MAKEUNIQUE transaction to random address from random RN
 * 2. Send coherent noncopyback combined write CMO type of transaction to the same address RN
 * 3. Send standalone noncopyback transaction or noncopyback combined write cmo transaction to same address to from different RN
 * 4. Check the order in which the two requests are processed by HN.
 * .
 */
class svt_chi_e_protocol_flow_ctrl_hn_combined_coherent_noncopyback_write_cmo_hazard_sequence extends svt_chi_e_protocol_flow_ctrl_combined_write_cmo_hazard_base_sequence;

  /** Parameter that controls the number of transactions that will be generated */
  rand int unsigned sequence_length = 10;

  rand bit enable_outstanding = 0;

  bit enable_outstanding_status = 0;

  /** Constrain the sequence length to a reasonable value */
  constraint reasonable_sequence_length {
    sequence_length <= 100;
  }
  `svt_xvm_object_utils(svt_chi_e_protocol_flow_ctrl_hn_combined_coherent_noncopyback_write_cmo_hazard_sequence)

  function new(string name="svt_chi_e_protocol_flow_ctrl_hn_combined_coherent_noncopyback_write_cmo_hazard_sequence");
    super.new(name);
  endfunction

  virtual task pre_body();
    raise_phase_objection();
  endtask

  virtual task body();
    bit                           status;
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0] txn_address;
    bit [`SVT_CHI_MAX_DATA_WIDTH -1:0] txn_data;
    bit txn_mem_attr_allocate_hint, txn_snp_attr_snp_domain_type, txn_is_non_secure_access;

    /** Sub sequences initiated from this sequence */
    svt_chi_rn_write_type_transaction_directed_sequence write_seq_0[int],write_seq_1[int];
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq;

    `uvm_info("body", "Entered ...", UVM_HIGH)
    super.body();

    // Default
    status = uvm_config_db #(int unsigned)::get(null, get_full_name(), "sequence_length", sequence_length);
    `uvm_info("body", $sformatf("sequence_length is %0d as a result of %0s.", sequence_length, status ? "config DB" : "randomization"), UVM_HIGH);
    enable_outstanding =0;
    enable_outstanding_status = uvm_config_db#(bit)::get(m_sequencer, get_type_name(), "enable_outstanding", enable_outstanding);
    `uvm_info("body", $sformatf("enable_outstanding is %0b as a result of %0s", enable_outstanding, (enable_outstanding_status?"config DB":"default setting")), UVM_HIGH);

    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :initiating_rn_f_node_index_0;
    initiating_rn_node_idx_1 = initiating_rn_node_index_1_status ? initiating_rn_node_index_1_from_config_db :initiating_rn_f_node_index_1;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_f_node_index_0;

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /** 
     * If the number of active_participating_rn_f_nodes are greater than 2, then
     * we can initialize the cache/memory from the RN having node index 
     * initiating_rn_f_node_index_2.
     * If the number of active_participating_rn_f_nodes are equal to 2, then
     * we can initialize the cache/memory from the RN having node index 
     * initiating_rn_node_idx_0.
     *  
     */
    if((active_participating_rn_f_nodes.size()>2) && (valid_initiating_rn_f_node_index_2))begin
      cache_initializing_rn_node_index = initiating_rn_f_node_index_2;
      /**
       * If the cache_initializing_rn_node_index is same as any of the RN node indices 
       * which are passed through config i.e initiating_rn_node_idx_0,initiating_rn_node_idx_1,
       * then assert perform_initialization_from_rn_used_for_hazard to 1, so that RN will be
       * in valid state to initilize the respective transaction.
       */
      if(initiating_rn_node_index_0_status || initiating_rn_node_index_1_status)begin
         if((cache_initializing_rn_node_index == initiating_rn_node_idx_0)||(cache_initializing_rn_node_index == initiating_rn_node_idx_1))begin
           perform_initialization_from_rn_used_for_hazard =  1;
         end
         else begin
           perform_initialization_from_rn_used_for_hazard =  0;
         end  
      end  
    end else begin
      cache_initializing_rn_node_index = initiating_rn_node_idx_0;
      perform_initialization_from_rn_used_for_hazard =  1;
    end

    str_initiating_rn_node_indices = "";
    /** Display the contents of Active Participating RN-F Nodes */
    foreach (active_participating_rn_f_nodes[j]) begin
      str_initiating_rn_node_indices = {str_initiating_rn_node_indices, $sformatf(" %0d", active_participating_rn_f_nodes[j])};
    end 
    str_initiating_rn_node_indices = {str_initiating_rn_node_indices, $sformatf("\n RN nodes used to initiate the transactions are initiating_rn_node_idx_0 : %0d, initiating_rn_node_idx_1 : %0d,cache_initializing_rn_node_index : %0d ", initiating_rn_node_idx_0, initiating_rn_node_idx_1, cache_initializing_rn_node_index)};
    `svt_xvm_debug("body", $sformatf("contents of active_participating_rn_f_nodes and RN nodes used to initiate the transactions are %0s", str_initiating_rn_node_indices));

    for(int i = 0; i < sequence_length; i++) begin
      bit rn0_is_unique, rn0_is_clean, rn1_is_unique, rn1_is_clean, rn0_read_status, rn1_read_status;
      bit rn_cache_dirty_state,rn_cache_unique_state;

      /** Write data into Cache of Randomly selected first RN with address of randomly selected HN Node */
      `svt_xvm_do_on_with(makeunique_seq, p_sequencer.rn_virt_seqr[cache_initializing_rn_node_index].rn_xact_seqr,
      {
        sequence_length == 1;
        hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
        seq_hn_node_idx == target_hn_node_idx_0;
        use_seq_is_non_secure_access == 0;
      })

      /** Wait for MakeUnique transactions to finish */ 
      makeunique_seq.write_tran.wait_end();
      txn_address = makeunique_seq.output_xacts[0].addr;
      txn_data = makeunique_seq.data_in_cache;
      txn_mem_attr_allocate_hint = makeunique_seq.output_xacts[0].mem_attr_allocate_hint;
      txn_snp_attr_snp_domain_type = makeunique_seq.output_xacts[0].snp_attr_snp_domain_type;
      txn_is_non_secure_access = makeunique_seq.output_xacts[0].is_non_secure_access;

      /* CMO WRITE hazard at HN **/
      fork 
        begin      
`ifndef SVT_CHI_ENABLE_MULTI_CLOCK
          @ (posedge sys_cfg.chi_if.clk);
`else
          @ (posedge sys_cfg.chi_if.rn_clk[initiating_rn_node_idx_0]);
`endif
          xact_hazard_sema_0.get();
          /** Randomly selected first RN-F fires a write type transaction to txn_address */
          `svt_xvm_do_on_with(write_seq_0[i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
            {
             if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].cleansharedpersistsep_xact_enable == 1) {
               seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL_CLEANSHARED, svt_chi_transaction::WRITEUNIQUEFULL_CLEANSHAREDPERSISTSEP, svt_chi_transaction::WRITEUNIQUEPTL_CLEANSHARED, svt_chi_transaction::WRITEUNIQUEPTL_CLEANSHAREDPERSISTSEP};             
             }
             else {
               seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL_CLEANSHARED, svt_chi_transaction::WRITEUNIQUEPTL_CLEANSHARED};             
             }
             sequence_length               == 1;
             seq_order_type   != svt_chi_transaction::NO_ORDERING_REQUIRED;
             hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
             min_addr          == txn_address;
             max_addr          == txn_address;
             seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
             seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
             seq_is_non_secure_access == txn_is_non_secure_access;
             use_seq_is_non_secure_access == 1;               
            }
          )
          xact_hazard_sema_0.put();
          /** Wait for write type transactions to finish */ 
          write_seq_0[i].write_tran.wait_end();
        end
        begin
`ifndef SVT_CHI_ENABLE_MULTI_CLOCK
          @ (posedge sys_cfg.chi_if.clk);
`else
          @ (posedge sys_cfg.chi_if.rn_clk[initiating_rn_node_idx_1]);
`endif
          xact_hazard_sema_1.get();
          /** Randomly selected different RN-F fires a write type transaction to txn_address */
          `svt_xvm_do_on_with(write_seq_1[i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,
            {
             if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].cleansharedpersistsep_xact_enable == 1) {
               seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL_CLEANSHARED, svt_chi_transaction::WRITEUNIQUEFULL_CLEANSHAREDPERSISTSEP, svt_chi_transaction::WRITEUNIQUEPTL_CLEANSHARED, svt_chi_transaction::WRITEUNIQUEPTL_CLEANSHAREDPERSISTSEP, svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL};             
             }
             else {
               seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL_CLEANSHARED, svt_chi_transaction::WRITEUNIQUEPTL_CLEANSHARED,svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL};             
             }
             sequence_length               == 1;
             seq_order_type   != svt_chi_transaction::NO_ORDERING_REQUIRED;
             hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
             min_addr          == txn_address;
             max_addr          == txn_address;
             seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
             seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
             seq_is_non_secure_access == txn_is_non_secure_access;
             use_seq_is_non_secure_access == 1;               
            }
          )
          xact_hazard_sema_1.put();
          /** Wait for write type transactions to finish */ 
          write_seq_1[i].write_tran.wait_end();
        end
      join
    end

    `uvm_info("body", "Exiting...", UVM_HIGH)
  endtask: body

  virtual task post_body();
    drop_phase_objection();
  endtask

endclass:svt_chi_e_protocol_flow_ctrl_hn_combined_coherent_noncopyback_write_cmo_hazard_sequence

/**
 * @groupname CHI_SYS_HAZARD
 * Abstract:
 * svt_chi_e_protocol_flow_ctrl_hn_combined_coherent_copyback_write_cmo_with_noncopyback_write_hazard_sequence
 * provides a sequence to test how components handle various hazard conditions
 * applicable for coherent copyback combined write cmo transactions
 * 1. Send MAKEUNIQUE transaction to random address from random RN
 * 2. Send coherent copyback combined write CMO type of transaction to the same address from  RN
 * 3. Send noncopyback write transaction to same address from different RN
 * 4. Check the order in which the two requests are processed by HN.
 * .
 */
class svt_chi_e_protocol_flow_ctrl_hn_combined_coherent_copyback_write_cmo_with_noncopyback_write_hazard_sequence extends svt_chi_e_protocol_flow_ctrl_combined_write_cmo_hazard_base_sequence;

  /** Parameter that controls the number of transactions that will be generated */
  rand int unsigned sequence_length = 10;

  rand bit enable_outstanding = 0;

  bit enable_outstanding_status = 0;

  /** Constrain the sequence length to a reasonable value */
  constraint reasonable_sequence_length {
    sequence_length <= 100;
  }
  `svt_xvm_object_utils(svt_chi_e_protocol_flow_ctrl_hn_combined_coherent_copyback_write_cmo_with_noncopyback_write_hazard_sequence)

  function new(string name="svt_chi_e_protocol_flow_ctrl_hn_combined_coherent_copyback_write_cmo_with_noncopyback_write_hazard_sequence");
    super.new(name);
  endfunction

  virtual task pre_body();
    raise_phase_objection();
  endtask

  virtual task body();
    bit                           status;
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0] txn_address;
    bit [`SVT_CHI_MAX_DATA_WIDTH -1:0] txn_data;
    bit txn_mem_attr_allocate_hint, txn_snp_attr_snp_domain_type, txn_is_non_secure_access;

    /** Sub sequences initiated from this sequence */
    svt_chi_rn_copyback_type_transaction_directed_sequence copyback_write[int];
     svt_chi_rn_write_type_transaction_directed_sequence write_seq[int];
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq;

    `uvm_info("body", "Entered ...", UVM_HIGH)
    super.body();

    // Default
    status = uvm_config_db #(int unsigned)::get(null, get_full_name(), "sequence_length", sequence_length);
    `uvm_info("body", $sformatf("sequence_length is %0d as a result of %0s.", sequence_length, status ? "config DB" : "randomization"), UVM_HIGH);
    enable_outstanding =0;
    enable_outstanding_status = uvm_config_db#(bit)::get(m_sequencer, get_type_name(), "enable_outstanding", enable_outstanding);
    `uvm_info("body", $sformatf("enable_outstanding is %0b as a result of %0s", enable_outstanding, (enable_outstanding_status?"config DB":"default setting")), UVM_HIGH);

    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :initiating_rn_f_node_index_0;
    initiating_rn_node_idx_1 = initiating_rn_node_index_1_status ? initiating_rn_node_index_1_from_config_db :initiating_rn_f_node_index_1;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_f_node_index_0;

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /** 
     * If the number of active_participating_rn_f_nodes are greater than 2, then
     * we can initialize the cache/memory from the RN having node index 
     * initiating_rn_f_node_index_2.
     * If the number of active_participating_rn_f_nodes are equal to 2, then
     * we can initialize the cache/memory from the RN having node index 
     * initiating_rn_node_idx_0.
     *  
     */
    if((active_participating_rn_f_nodes.size()>2) && (valid_initiating_rn_f_node_index_2))begin
      cache_initializing_rn_node_index = initiating_rn_f_node_index_2;
      /**
       * If the cache_initializing_rn_node_index is same as any of the RN node indices 
       * which are passed through config i.e initiating_rn_node_idx_0,initiating_rn_node_idx_1,
       * then assert perform_initialization_from_rn_used_for_hazard to 1, so that RN will be
       * in valid state to initilize the respective transaction.
       */
      if(initiating_rn_node_index_0_status || initiating_rn_node_index_1_status)begin
         if((cache_initializing_rn_node_index == initiating_rn_node_idx_0)||(cache_initializing_rn_node_index == initiating_rn_node_idx_1))begin
           perform_initialization_from_rn_used_for_hazard =  1;
         end
         else begin
           perform_initialization_from_rn_used_for_hazard =  0;
         end  
      end  
    end else begin
      cache_initializing_rn_node_index = initiating_rn_node_idx_0;
      perform_initialization_from_rn_used_for_hazard =  1;
    end

    str_initiating_rn_node_indices = "";
    /** Display the contents of Active Participating RN-F Nodes */
    foreach (active_participating_rn_f_nodes[j]) begin
      str_initiating_rn_node_indices = {str_initiating_rn_node_indices, $sformatf(" %0d", active_participating_rn_f_nodes[j])};
    end 
    str_initiating_rn_node_indices = {str_initiating_rn_node_indices, $sformatf("\n RN nodes used to initiate the transactions are initiating_rn_node_idx_0 : %0d, initiating_rn_node_idx_1 : %0d,cache_initializing_rn_node_index : %0d ", initiating_rn_node_idx_0, initiating_rn_node_idx_1, cache_initializing_rn_node_index)};
    `svt_xvm_debug("body", $sformatf("contents of active_participating_rn_f_nodes and RN nodes used to initiate the transactions are %0s", str_initiating_rn_node_indices));

    for(int i = 0; i < sequence_length; i++) begin
      bit rn0_is_unique, rn0_is_clean, rn1_is_unique, rn1_is_clean, rn0_read_status, rn1_read_status;
      bit rn_cache_dirty_state,rn_cache_unique_state;

      /** Write data into Cache of Randomly selected first RN with address of randomly selected HN Node */
      `svt_xvm_do_on_with(makeunique_seq, p_sequencer.rn_virt_seqr[cache_initializing_rn_node_index].rn_xact_seqr,
      {
        sequence_length == 1;
        hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
        seq_hn_node_idx == target_hn_node_idx_0;
        use_seq_is_non_secure_access == 0;
      })

      /** Wait for MakeUnique transactions to finish */ 
      makeunique_seq.write_tran.wait_end();
      txn_address = makeunique_seq.output_xacts[0].addr;
      txn_data = makeunique_seq.data_in_cache;
      txn_mem_attr_allocate_hint = makeunique_seq.output_xacts[0].mem_attr_allocate_hint;
      txn_snp_attr_snp_domain_type = makeunique_seq.output_xacts[0].snp_attr_snp_domain_type;
      txn_is_non_secure_access = makeunique_seq.output_xacts[0].is_non_secure_access;

      /* CMO WRITE hazard at HN **/
      fork 
        begin      
`ifndef SVT_CHI_ENABLE_MULTI_CLOCK
          @ (posedge sys_cfg.chi_if.clk);
`else
          @ (posedge sys_cfg.chi_if.rn_clk[initiating_rn_node_idx_0]);
`endif
          xact_hazard_sema_0.get();
          /** Randomly selected first RN-F fires a write type transaction to txn_address */
          `svt_xvm_do_on_with(copyback_write[i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
            {
             if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].cleansharedpersistsep_xact_enable == 1) {
               seq_xact_type inside{svt_chi_transaction::WRITECLEANFULL_CLEANSHARED,svt_chi_transaction::WRITECLEANFULL_CLEANSHAREDPERSISTSEP, svt_chi_transaction::WRITEBACKFULL_CLEANSHARED,svt_chi_transaction::WRITEBACKFULL_CLEANSHAREDPERSISTSEP, svt_chi_transaction::WRITEBACKFULL_CLEANINVALID};
             }
             else {
               seq_xact_type inside{svt_chi_transaction::WRITECLEANFULL_CLEANSHARED, svt_chi_transaction::WRITEBACKFULL_CLEANSHARED, svt_chi_transaction::WRITEBACKFULL_CLEANINVALID};
             }
             sequence_length               == 1;
             seq_order_type   == svt_chi_transaction::NO_ORDERING_REQUIRED;
             hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
             min_addr          == txn_address;
             max_addr          == txn_address;
             seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
             seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
             seq_is_non_secure_access == txn_is_non_secure_access;
             use_seq_is_non_secure_access == 1;               
            }
          )
          xact_hazard_sema_0.put();
          /** Wait for write type transactions to finish */ 
          copyback_write[i].copyback_tran.wait_end();
        end
        begin
`ifndef SVT_CHI_ENABLE_MULTI_CLOCK
          @ (posedge sys_cfg.chi_if.clk);
`else
          @ (posedge sys_cfg.chi_if.rn_clk[initiating_rn_node_idx_1]);
`endif
          xact_hazard_sema_1.get();
          /** Randomly selected different RN-F fires a write type transaction to txn_address */
          `svt_xvm_do_on_with(write_seq[i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,
            {
             if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].cleansharedpersistsep_xact_enable == 1) {
               seq_xact_type inside  {svt_chi_transaction::WRITEUNIQUEFULL_CLEANSHARED, svt_chi_transaction::WRITEUNIQUEFULL_CLEANSHAREDPERSISTSEP, svt_chi_transaction::WRITEUNIQUEPTL_CLEANSHARED,svt_chi_transaction::WRITEUNIQUEPTL_CLEANSHAREDPERSISTSEP,svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL};
             }
             else {
               seq_xact_type inside  {svt_chi_transaction::WRITEUNIQUEFULL_CLEANSHARED, svt_chi_transaction::WRITEUNIQUEPTL_CLEANSHARED,svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL};
             }
             sequence_length               == 1;
             seq_order_type   != svt_chi_transaction::NO_ORDERING_REQUIRED;
             hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
             min_addr          == txn_address;
             max_addr          == txn_address;
             seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
             seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
             seq_is_non_secure_access == txn_is_non_secure_access;
             use_seq_is_non_secure_access == 1;               
            }
          )
          xact_hazard_sema_1.put();
          /** Wait for write type transactions to finish */ 
          write_seq[i].write_tran.wait_end();
        end
      join
    end

    `uvm_info("body", "Exiting...", UVM_HIGH)
  endtask: body

  virtual task post_body();
    drop_phase_objection();
  endtask

endclass:svt_chi_e_protocol_flow_ctrl_hn_combined_coherent_copyback_write_cmo_with_noncopyback_write_hazard_sequence   

/**
 * @groupname CHI_SYS_HAZARD
 * Abstract:
 * svt_chi_e_protocol_flow_ctrl_hn_combined_coherent_noncopyback_write_cmo_with_copyback_write_hazard_sequence
 * provides a sequence to test how components handle various hazard conditions
 * applicable for coherent noncopyback combined write cmo and copyback write transactions
 * 1. Send MAKEUNIQUE transaction to random address from random RN
 * 2. Send coherent noncopyback combined write CMO type of transaction to the same address from  RN
 $ 3. Send copyback write transaction to same address from different RN.
 * 4. Check the order in which the two requests are processed by HN.
 * .
 */
class svt_chi_e_protocol_flow_ctrl_hn_combined_coherent_noncopyback_write_cmo_with_copyback_write_hazard_sequence extends svt_chi_e_protocol_flow_ctrl_combined_write_cmo_hazard_base_sequence;

  /** Parameter that controls the number of transactions that will be generated */
  rand int unsigned sequence_length = 10;

  rand bit enable_outstanding = 0;

  bit enable_outstanding_status = 0;

  /** Constrain the sequence length to a reasonable value */
  constraint reasonable_sequence_length {
    sequence_length <= 100;
  }
  `svt_xvm_object_utils(svt_chi_e_protocol_flow_ctrl_hn_combined_coherent_noncopyback_write_cmo_with_copyback_write_hazard_sequence)

  function new(string name="svt_chi_e_protocol_flow_ctrl_hn_combined_coherent_noncopyback_write_cmo_with_copyback_write_hazard_sequence");
    super.new(name);
  endfunction

  virtual task pre_body();
    raise_phase_objection();
  endtask

  virtual task body();
    /** Sub sequences initiated from this sequence */
    svt_chi_rn_copyback_type_transaction_directed_sequence copyback_seq[int];
    svt_chi_rn_write_type_transaction_directed_sequence write_seq[int];
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq;
    bit                           status;
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0] txn_address;
    bit [`SVT_CHI_MAX_DATA_WIDTH -1:0] txn_data;
    bit txn_mem_attr_allocate_hint, txn_snp_attr_snp_domain_type, txn_is_non_secure_access;

    // Default
    enable_outstanding = 0;
    status = uvm_config_db #(int unsigned)::get(null, get_full_name(), "sequence_length", sequence_length);
    `uvm_info("body", $sformatf("sequence_length is %0d as a result of %0s.", sequence_length, status ? "config DB" : "randomization"), UVM_HIGH);

    enable_outstanding_status = uvm_config_db#(bit)::get(m_sequencer, get_type_name(), "enable_outstanding", enable_outstanding);
    `uvm_info("body", $sformatf("enable_outstanding is %0b as a result of %0s", enable_outstanding, (enable_outstanding_status?"config DB":"default setting")), UVM_HIGH);

    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :initiating_rn_f_node_index_0;
    initiating_rn_node_idx_1 = initiating_rn_node_index_1_status ? initiating_rn_node_index_1_from_config_db :initiating_rn_f_node_index_1;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_f_node_index_0;

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    str_initiating_rn_node_indices = "";
    /** Display the contents of Active Participating RN-F Nodes */
    foreach (active_participating_rn_f_nodes[j]) begin
      str_initiating_rn_node_indices = {str_initiating_rn_node_indices, $sformatf(" %0d", active_participating_rn_f_nodes[j])};
    end 
    str_initiating_rn_node_indices = {str_initiating_rn_node_indices, $sformatf("\n RN nodes used to initiate the transactions are initiating_rn_node_idx_0 : %0d, initiating_rn_node_idx_1 : %0d", initiating_rn_node_idx_0, initiating_rn_node_idx_1)};
    `svt_xvm_debug("body", $sformatf("contents of active_participating_rn_f_nodes and RN nodes used to initiate the transactions are %0s", str_initiating_rn_node_indices));

    for(int i = 0; i < sequence_length; i++) begin
      bit rn0_is_unique, rn0_is_clean, rn1_is_unique, rn1_is_clean, rn0_read_status, rn1_read_status;
      bit rn_cache_dirty_state,rn_cache_unique_state;

      /** Write data into Cache of Randomly selected first RN with address of randomly selected HN Node */
      `svt_xvm_do_on_with(makeunique_seq, p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,
      {
        sequence_length == 1;
        hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
        seq_hn_node_idx == target_hn_node_idx_0;
        use_seq_is_non_secure_access == 0;               
      })

      /** Wait for MakeUnique transactions to finish */ 
      makeunique_seq.write_tran.wait_end();
      txn_address = makeunique_seq.output_xacts[0].addr;
      txn_data = makeunique_seq.data_in_cache;
      txn_mem_attr_allocate_hint = makeunique_seq.output_xacts[0].mem_attr_allocate_hint;
      txn_snp_attr_snp_domain_type = makeunique_seq.output_xacts[0].snp_attr_snp_domain_type;
      txn_is_non_secure_access = makeunique_seq.output_xacts[0].is_non_secure_access;

      /* WRITE-COPYBACK hazard at HN **/
      fork 
        begin      
`ifndef SVT_CHI_ENABLE_MULTI_CLOCK
          @ (posedge sys_cfg.chi_if.clk);
`else
          @ (posedge sys_cfg.chi_if.rn_clk[initiating_rn_node_idx_0]);
`endif          
          xact_hazard_sema_0.get();
          /** Initiate a Combined Write CMO type transaction from initiating_rn_node_idx_0 to txn_address. */
          `svt_xvm_do_on_with(write_seq[i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
            {
             if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].cleansharedpersistsep_xact_enable == 1) {
               seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL_CLEANSHARED, svt_chi_transaction::WRITEUNIQUEFULL_CLEANSHAREDPERSISTSEP, svt_chi_transaction::WRITEUNIQUEPTL_CLEANSHARED,svt_chi_transaction::WRITEUNIQUEPTL_CLEANSHAREDPERSISTSEP};
             }
             else {
               seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL_CLEANSHARED, svt_chi_transaction::WRITEUNIQUEPTL_CLEANSHARED};
             }
             sequence_length               == 1;
             seq_order_type   != svt_chi_transaction::NO_ORDERING_REQUIRED;
             hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
             min_addr          == txn_address;
             max_addr          == txn_address;
             seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
             seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
             seq_is_non_secure_access == txn_is_non_secure_access;
             use_seq_is_non_secure_access == 1;               
            }
          )
          xact_hazard_sema_0.put();
          /** Wait for write type transactions to finish */ 
          write_seq[i].write_tran.wait_end();
        end
        begin
`ifndef SVT_CHI_ENABLE_MULTI_CLOCK
          @ (posedge sys_cfg.chi_if.clk);
`else
          @ (posedge sys_cfg.chi_if.rn_clk[initiating_rn_node_idx_1]);
`endif          
          xact_hazard_sema_1.get();
          /** Initiate a Copyback type transaction from initiating_rn_node_idx_1 to txn_address. */
         `svt_xvm_do_on_with(copyback_seq[i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,
          {
            sequence_length == 1;
            if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].cleansharedpersistsep_xact_enable == 1) {
              seq_xact_type inside{svt_chi_transaction::WRITECLEANFULL_CLEANSHARED,svt_chi_transaction::WRITECLEANFULL_CLEANSHAREDPERSISTSEP, svt_chi_transaction::WRITEBACKFULL_CLEANSHARED, svt_chi_transaction::WRITEBACKFULL_CLEANSHAREDPERSISTSEP,svt_chi_transaction::WRITEBACKFULL_CLEANINVALID,svt_chi_transaction::WRITEBACKFULL, svt_chi_transaction::WRITEBACKPTL, svt_chi_transaction::WRITECLEANFULL, svt_chi_transaction::WRITECLEANPTL};
            }
            else {
              seq_xact_type inside{svt_chi_transaction::WRITECLEANFULL_CLEANSHARED, svt_chi_transaction::WRITEBACKFULL_CLEANSHARED, svt_chi_transaction::WRITEBACKFULL_CLEANINVALID, svt_chi_transaction::WRITEBACKFULL, svt_chi_transaction::WRITEBACKPTL, svt_chi_transaction::WRITECLEANFULL, svt_chi_transaction::WRITECLEANPTL};
            }
            seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
            seq_copyback_req_order_enable == 0;                        
            hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
            min_addr == txn_address;
            max_addr == txn_address;
            seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
            seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
            seq_is_non_secure_access == txn_is_non_secure_access;
            use_seq_is_non_secure_access == 1;               
          }
          )
          xact_hazard_sema_1.put();
          /** Waiting for copyback transaction to complete */ 
          copyback_seq[i].copyback_tran.wait_end(); 
        end
      join
    end

    `uvm_info("body", "Exiting...", UVM_HIGH)
  endtask: body

  virtual task post_body();
    drop_phase_objection();
  endtask

endclass:svt_chi_e_protocol_flow_ctrl_hn_combined_coherent_noncopyback_write_cmo_with_copyback_write_hazard_sequence

/**
 * @groupname CHI_SYS_HAZARD
 * Abstract:
 * svt_chi_e_protocol_flow_ctrl_hn_combined_coherent_copyback_write_cmo_with_standalone_cmo_hazard_sequence
 * provides a sequence to test how components handle various hazard conditions
 * applicable for coherent copyback combined write cmo transactions
 * 1. Send MAKEUNIQUE transaction to random address from random RN
 * 2. Send Combined coherent  copyback write CMO transaction to the address from an RN
 * 3. Send standalone CMO type of transaction to the same address from different RN
 * 4. Check the order in which the two requests are processed by HN.
 * .
 */
class svt_chi_e_protocol_flow_ctrl_hn_combined_coherent_copyback_write_cmo_with_standalone_cmo_hazard_sequence extends svt_chi_e_protocol_flow_ctrl_combined_write_cmo_hazard_base_sequence;

  /** Parameter that controls the number of transactions that will be generated */
  rand int unsigned sequence_length = 10;

  rand bit enable_outstanding = 0;

  bit enable_outstanding_status = 0;

  /** Constrain the sequence length to a reasonable value */
  constraint reasonable_sequence_length {
    sequence_length <= 100;
  }
  `svt_xvm_object_utils(svt_chi_e_protocol_flow_ctrl_hn_combined_coherent_copyback_write_cmo_with_standalone_cmo_hazard_sequence)

  function new(string name="svt_chi_e_protocol_flow_ctrl_hn_combined_coherent_copyback_write_cmo_with_standalone_cmo_hazard_sequence");
    super.new(name);
  endfunction

  virtual task pre_body();
    raise_phase_objection();
  endtask

  virtual task body();
    bit                           status;
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0] txn_address;
    bit [`SVT_CHI_MAX_DATA_WIDTH -1:0] txn_data;
    bit txn_mem_attr_allocate_hint, txn_snp_attr_snp_domain_type, txn_is_non_secure_access/*, seq_snp_attr_is_snoopable*/;

    /** Sub sequences initiated from this sequence */
    svt_chi_rn_copyback_type_transaction_directed_sequence copyback_write[int];
    svt_chi_rn_cmo_type_transaction_directed_sequence cmo_seq[int];
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq;

    `uvm_info("body", "Entered ...", UVM_HIGH)
    super.body();

    // Default
    status = uvm_config_db #(int unsigned)::get(null, get_full_name(), "sequence_length", sequence_length);
    `uvm_info("body", $sformatf("sequence_length is %0d as a result of %0s.", sequence_length, status ? "config DB" : "randomization"), UVM_HIGH);
    enable_outstanding =0;
    enable_outstanding_status = uvm_config_db#(bit)::get(m_sequencer, get_type_name(), "enable_outstanding", enable_outstanding);
    `uvm_info("body", $sformatf("enable_outstanding is %0b as a result of %0s", enable_outstanding, (enable_outstanding_status?"config DB":"default setting")), UVM_HIGH);

    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :initiating_rn_f_node_index_0;
    initiating_rn_node_idx_1 = initiating_rn_node_index_1_status ? initiating_rn_node_index_1_from_config_db :initiating_rn_f_node_index_1;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_f_node_index_0;

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /** 
     * If the number of active_participating_rn_f_nodes are greater than 2, then
     * we can initialize the cache/memory from the RN having node index 
     * initiating_rn_f_node_index_2.
     * If the number of active_participating_rn_f_nodes are equal to 2, then
     * we can initialize the cache/memory from the RN having node index 
     * initiating_rn_node_idx_0.
     *  
     */
    if((active_participating_rn_f_nodes.size()>2) && (valid_initiating_rn_f_node_index_2))begin
      cache_initializing_rn_node_index = initiating_rn_f_node_index_2;
      /**
       * If the cache_initializing_rn_node_index is same as any of the RN node indices 
       * which are passed through config i.e initiating_rn_node_idx_0,initiating_rn_node_idx_1,
       * then assert perform_initialization_from_rn_used_for_hazard to 1, so that RN will be
       * in valid state to initilize the respective transaction.
       */
      if(initiating_rn_node_index_0_status || initiating_rn_node_index_1_status)begin
         if((cache_initializing_rn_node_index == initiating_rn_node_idx_0)||(cache_initializing_rn_node_index == initiating_rn_node_idx_1))begin
           perform_initialization_from_rn_used_for_hazard =  1;
         end
         else begin
           perform_initialization_from_rn_used_for_hazard =  0;
         end  
      end  
    end else begin
      cache_initializing_rn_node_index = initiating_rn_node_idx_0;
      perform_initialization_from_rn_used_for_hazard =  1;
    end

    str_initiating_rn_node_indices = "";
    /** Display the contents of Active Participating RN-F Nodes */
    foreach (active_participating_rn_f_nodes[j]) begin
      str_initiating_rn_node_indices = {str_initiating_rn_node_indices, $sformatf(" %0d", active_participating_rn_f_nodes[j])};
    end 
    str_initiating_rn_node_indices = {str_initiating_rn_node_indices, $sformatf("\n RN nodes used to initiate the transactions are initiating_rn_node_idx_0 : %0d, initiating_rn_node_idx_1 : %0d,cache_initializing_rn_node_index : %0d ", initiating_rn_node_idx_0, initiating_rn_node_idx_1, cache_initializing_rn_node_index)};
    `svt_xvm_debug("body", $sformatf("contents of active_participating_rn_f_nodes and RN nodes used to initiate the transactions are %0s", str_initiating_rn_node_indices));

    for(int i = 0; i < sequence_length; i++) begin
      bit rn0_is_unique, rn0_is_clean, rn1_is_unique, rn1_is_clean, rn0_read_status, rn1_read_status;
      bit rn_cache_dirty_state,rn_cache_unique_state;

      /** Write data into Cache of Randomly selected first RN with address of randomly selected HN Node */
      `svt_xvm_do_on_with(makeunique_seq, p_sequencer.rn_virt_seqr[cache_initializing_rn_node_index].rn_xact_seqr,
      {
        sequence_length == 1;
        hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
        seq_hn_node_idx == target_hn_node_idx_0;
        use_seq_is_non_secure_access == 0;
      })

      /** Wait for MakeUnique transactions to finish */ 
      makeunique_seq.write_tran.wait_end();
      txn_address = makeunique_seq.output_xacts[0].addr;
      txn_data = makeunique_seq.data_in_cache;
      txn_mem_attr_allocate_hint = makeunique_seq.output_xacts[0].mem_attr_allocate_hint;
      txn_snp_attr_snp_domain_type = makeunique_seq.output_xacts[0].snp_attr_snp_domain_type;
      txn_is_non_secure_access = makeunique_seq.output_xacts[0].is_non_secure_access;
      //seq_snp_attr_is_snoopable = makeunique_seq.output_xacts[0].seq_snp_attr_is_snoopable;

      /* CMO WRITE hazard at HN **/
      fork 
        begin      
`ifndef SVT_CHI_ENABLE_MULTI_CLOCK
          @ (posedge sys_cfg.chi_if.clk);
`else
          @ (posedge sys_cfg.chi_if.rn_clk[initiating_rn_node_idx_0]);
`endif
          xact_hazard_sema_0.get();
          /** Randomly selected first RN-F fires a write-cmo type transaction to txn_address */
          `svt_xvm_do_on_with(copyback_write[i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
            {
             if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].cleansharedpersistsep_xact_enable == 1) {
                seq_xact_type inside{svt_chi_transaction::WRITECLEANFULL_CLEANSHARED, svt_chi_transaction::WRITECLEANFULL_CLEANSHAREDPERSISTSEP,svt_chi_transaction::WRITEBACKFULL_CLEANSHARED, svt_chi_transaction::WRITEBACKFULL_CLEANSHAREDPERSISTSEP,svt_chi_transaction::WRITEBACKFULL_CLEANINVALID};
             }
             else {
                seq_xact_type inside{svt_chi_transaction::WRITECLEANFULL_CLEANSHARED,svt_chi_transaction::WRITEBACKFULL_CLEANSHARED,svt_chi_transaction::WRITEBACKFULL_CLEANINVALID};
             }
             sequence_length               == 1;
             seq_order_type   == svt_chi_transaction::NO_ORDERING_REQUIRED;
             hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
             min_addr          == txn_address;
             max_addr          == txn_address;
             seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
             seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
             seq_is_non_secure_access == txn_is_non_secure_access;
             use_seq_is_non_secure_access == 1;
            }
          )
          xact_hazard_sema_0.put();
          /** Wait for write type transactions to finish */ 
          copyback_write[i].copyback_tran.wait_end();
        end
        begin
`ifndef SVT_CHI_ENABLE_MULTI_CLOCK
          @ (posedge sys_cfg.chi_if.clk);
`else
          @ (posedge sys_cfg.chi_if.rn_clk[initiating_rn_node_idx_1]);
`endif
          xact_hazard_sema_1.get();
          /** Initiate CMO type of transaction from initiating_rn_node_idx_1 to txn_address. */ 
          `svt_xvm_do_on_with(cmo_seq[i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,
          { 
            seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSIST, svt_chi_transaction::CLEANSHARED, 
            svt_chi_transaction::CLEANINVALID, svt_chi_transaction::MAKEINVALID};
            sequence_length == 1;
            hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
            min_addr == txn_address;
            max_addr == txn_address;
            seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
           // seq_snp_attr_is_snoopable == txn_snp_attr_is_snoopable;
            seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
            seq_is_non_secure_access == txn_is_non_secure_access;
            use_seq_is_non_secure_access == 1;               
          }
          )
          xact_hazard_sema_1.put();
          /** Waiting for CMO type transaction to complete */ 
          cmo_seq[i].cmo_tran.wait_end(); 
        end
      join
    end

    `uvm_info("body", "Exiting...", UVM_HIGH)
  endtask: body

  virtual task post_body();
    drop_phase_objection();
  endtask

endclass:svt_chi_e_protocol_flow_ctrl_hn_combined_coherent_copyback_write_cmo_with_standalone_cmo_hazard_sequence

/**
 * @groupname CHI_SYS_HAZARD
 * Abstract:
 * svt_chi_e_protocol_flow_ctrl_hn_combined_coherent_noncopyback_write_cmo_with_standalone_cmo_hazard_sequence
 * provides a sequence to test how components handle various hazard conditions
 * applicable for coherent noncopyback combined write cmo transactions
 * 1. Send MAKEUNIQUE transaction to random address from random RN
 * 2. Send Combined coherent noncopyback write CMO transaction to the address from an RN
 * 3. Send standalone CMO type of transaction to the same address from different RN
 * 4. Check the order in which the two requests are processed by HN.
 * .
 */
class svt_chi_e_protocol_flow_ctrl_hn_combined_coherent_noncopyback_write_cmo_with_standalone_cmo_hazard_sequence extends svt_chi_e_protocol_flow_ctrl_combined_write_cmo_hazard_base_sequence;

  /** Parameter that controls the number of transactions that will be generated */
  rand int unsigned sequence_length = 10;

  rand bit enable_outstanding = 0;

  bit enable_outstanding_status = 0;

  /** Constrain the sequence length to a reasonable value */
  constraint reasonable_sequence_length {
    sequence_length <= 100;
  }
  `svt_xvm_object_utils(svt_chi_e_protocol_flow_ctrl_hn_combined_coherent_noncopyback_write_cmo_with_standalone_cmo_hazard_sequence)

  function new(string name="svt_chi_e_protocol_flow_ctrl_hn_combined_coherent_noncopyback_write_cmo_with_standalone_cmo_hazard_sequence");
    super.new(name);
  endfunction

  virtual task pre_body();
    raise_phase_objection();
  endtask

  virtual task body();
    bit                           status;
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0] txn_address;
    bit [`SVT_CHI_MAX_DATA_WIDTH -1:0] txn_data;
    bit txn_mem_attr_allocate_hint, txn_snp_attr_snp_domain_type, txn_is_non_secure_access/*, seq_snp_attr_is_snoopable*/;

    /** Sub sequences initiated from this sequence */
    svt_chi_rn_write_type_transaction_directed_sequence write_seq[int];
    svt_chi_rn_cmo_type_transaction_directed_sequence cmo_seq[int];
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq;

    `uvm_info("body", "Entered ...", UVM_HIGH)
    super.body();

    // Default
    status = uvm_config_db #(int unsigned)::get(null, get_full_name(), "sequence_length", sequence_length);
    `uvm_info("body", $sformatf("sequence_length is %0d as a result of %0s.", sequence_length, status ? "config DB" : "randomization"), UVM_HIGH);
    enable_outstanding =0;
    enable_outstanding_status = uvm_config_db#(bit)::get(m_sequencer, get_type_name(), "enable_outstanding", enable_outstanding);
    `uvm_info("body", $sformatf("enable_outstanding is %0b as a result of %0s", enable_outstanding, (enable_outstanding_status?"config DB":"default setting")), UVM_HIGH);

    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :initiating_rn_f_node_index_0;
    initiating_rn_node_idx_1 = initiating_rn_node_index_1_status ? initiating_rn_node_index_1_from_config_db :initiating_rn_f_node_index_1;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_f_node_index_0;

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /** 
     * If the number of active_participating_rn_f_nodes are greater than 2, then
     * we can initialize the cache/memory from the RN having node index 
     * initiating_rn_f_node_index_2.
     * If the number of active_participating_rn_f_nodes are equal to 2, then
     * we can initialize the cache/memory from the RN having node index 
     * initiating_rn_node_idx_0.
     *  
     */
    if((active_participating_rn_f_nodes.size()>2) && (valid_initiating_rn_f_node_index_2))begin
      cache_initializing_rn_node_index = initiating_rn_f_node_index_2;
      /**
       * If the cache_initializing_rn_node_index is same as any of the RN node indices 
       * which are passed through config i.e initiating_rn_node_idx_0,initiating_rn_node_idx_1,
       * then assert perform_initialization_from_rn_used_for_hazard to 1, so that RN will be
       * in valid state to initilize the respective transaction.
       */
      if(initiating_rn_node_index_0_status || initiating_rn_node_index_1_status)begin
         if((cache_initializing_rn_node_index == initiating_rn_node_idx_0)||(cache_initializing_rn_node_index == initiating_rn_node_idx_1))begin
           perform_initialization_from_rn_used_for_hazard =  1;
         end
         else begin
           perform_initialization_from_rn_used_for_hazard =  0;
         end  
      end  
    end else begin
      cache_initializing_rn_node_index = initiating_rn_node_idx_0;
      perform_initialization_from_rn_used_for_hazard =  1;
    end

    str_initiating_rn_node_indices = "";
    /** Display the contents of Active Participating RN-F Nodes */
    foreach (active_participating_rn_f_nodes[j]) begin
      str_initiating_rn_node_indices = {str_initiating_rn_node_indices, $sformatf(" %0d", active_participating_rn_f_nodes[j])};
    end 
    str_initiating_rn_node_indices = {str_initiating_rn_node_indices, $sformatf("\n RN nodes used to initiate the transactions are initiating_rn_node_idx_0 : %0d, initiating_rn_node_idx_1 : %0d,cache_initializing_rn_node_index : %0d ", initiating_rn_node_idx_0, initiating_rn_node_idx_1, cache_initializing_rn_node_index)};
    `svt_xvm_debug("body", $sformatf("contents of active_participating_rn_f_nodes and RN nodes used to initiate the transactions are %0s", str_initiating_rn_node_indices));

    for(int i = 0; i < sequence_length; i++) begin
      bit rn0_is_unique, rn0_is_clean, rn1_is_unique, rn1_is_clean, rn0_read_status, rn1_read_status;
      bit rn_cache_dirty_state,rn_cache_unique_state;

      /** Write data into Cache of Randomly selected first RN with address of randomly selected HN Node */
      `svt_xvm_do_on_with(makeunique_seq, p_sequencer.rn_virt_seqr[cache_initializing_rn_node_index].rn_xact_seqr,
      {
        sequence_length == 1;
        hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
        seq_hn_node_idx == target_hn_node_idx_0;
        use_seq_is_non_secure_access == 0;
      })

      /** Wait for MakeUnique transactions to finish */ 
      makeunique_seq.write_tran.wait_end();
      txn_address = makeunique_seq.output_xacts[0].addr;
      txn_data = makeunique_seq.data_in_cache;
      txn_mem_attr_allocate_hint = makeunique_seq.output_xacts[0].mem_attr_allocate_hint;
      txn_snp_attr_snp_domain_type = makeunique_seq.output_xacts[0].snp_attr_snp_domain_type;
      txn_is_non_secure_access = makeunique_seq.output_xacts[0].is_non_secure_access;
      //seq_snp_attr_is_snoopable = makeunique_seq.output_xacts[0].seq_snp_attr_is_snoopable;

      /* CMO WRITE hazard at HN **/
      fork 
        begin      
`ifndef SVT_CHI_ENABLE_MULTI_CLOCK
          @ (posedge sys_cfg.chi_if.clk);
`else
          @ (posedge sys_cfg.chi_if.rn_clk[initiating_rn_node_idx_0]);
`endif
          xact_hazard_sema_0.get();
          /** Initiate a Combined Write CMO type transaction from initiating_rn_node_idx_0 to txn_address. */
          `svt_xvm_do_on_with(write_seq[i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
            {
             if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].cleansharedpersistsep_xact_enable == 1) {
               seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL_CLEANSHARED, svt_chi_transaction::WRITEUNIQUEFULL_CLEANSHAREDPERSISTSEP, svt_chi_transaction::WRITEUNIQUEPTL_CLEANSHARED, svt_chi_transaction::WRITEUNIQUEPTL_CLEANSHAREDPERSISTSEP};
             }
             else {
               seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL_CLEANSHARED, svt_chi_transaction::WRITEUNIQUEPTL_CLEANSHARED};
             }
             sequence_length               == 1;
             seq_order_type   != svt_chi_transaction::NO_ORDERING_REQUIRED;
             hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
             min_addr          == txn_address;
             max_addr          == txn_address;
             seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
             seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
             seq_is_non_secure_access == txn_is_non_secure_access;
             use_seq_is_non_secure_access == 1;               
            }
          )
          xact_hazard_sema_0.put();
          /** Wait for write type transactions to finish */ 
          write_seq[i].write_tran.wait_end();
        end
        begin
`ifndef SVT_CHI_ENABLE_MULTI_CLOCK
          @ (posedge sys_cfg.chi_if.clk);
`else
          @ (posedge sys_cfg.chi_if.rn_clk[initiating_rn_node_idx_1]);
`endif
          xact_hazard_sema_1.get();
          /** Initiate CMO type of transaction from initiating_rn_node_idx_1 to txn_address. */ 
          `svt_xvm_do_on_with(cmo_seq[i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,
          { 
            seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSIST,  svt_chi_transaction::CLEANSHARED, 
            svt_chi_transaction::CLEANINVALID, svt_chi_transaction::MAKEINVALID};
            sequence_length == 1;
            hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
            min_addr == txn_address;
            max_addr == txn_address;
            seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
           // seq_snp_attr_is_snoopable == txn_snp_attr_is_snoopable;
            seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
            seq_is_non_secure_access == txn_is_non_secure_access;
            use_seq_is_non_secure_access == 1;               
          }
          )
          xact_hazard_sema_1.put();
          /** Waiting for CMO type transaction to complete */ 
          cmo_seq[i].cmo_tran.wait_end(); 
        end
      join
    end

    `uvm_info("body", "Exiting...", UVM_HIGH)
  endtask: body

  virtual task post_body();
    drop_phase_objection();
  endtask

endclass:svt_chi_e_protocol_flow_ctrl_hn_combined_coherent_noncopyback_write_cmo_with_standalone_cmo_hazard_sequence

/**
 * @groupname CHI_SYS_HAZARD
 * Abstract:
 * svt_chi_e_protocol_flow_ctrl_hn_combined_coherent_noncopyback_write_cmo_with_read_hazard_sequence
 * provides a sequence to test how components handle various hazard conditions
 * applicable for coherent noncopyback combined write cmo transactions
 * 1. Send MAKEUNIQUE transaction to random address from random RN
 * 2. Send Combined coherent noncopyback write CMO transaction to the address from an RN
 * 3. Send READ type of transaction to the same address from different RN
 * 4. Check the order in which the two requests are processed by HN.
 * .
 */
class svt_chi_e_protocol_flow_ctrl_hn_combined_coherent_noncopyback_write_cmo_with_read_hazard_sequence extends svt_chi_e_protocol_flow_ctrl_combined_write_cmo_hazard_base_sequence;

  /** Parameter that controls the number of transactions that will be generated */
  rand int unsigned sequence_length = 10;

  rand bit enable_outstanding = 0;

  bit enable_outstanding_status = 0;

  /** Constrain the sequence length to a reasonable value */
  constraint reasonable_sequence_length {
    sequence_length <= 100;
  }
  `svt_xvm_object_utils(svt_chi_e_protocol_flow_ctrl_hn_combined_coherent_noncopyback_write_cmo_with_read_hazard_sequence)

  function new(string name="svt_chi_e_protocol_flow_ctrl_hn_combined_coherent_noncopyback_write_cmo_with_read_hazard_sequence");
    super.new(name);
  endfunction

  virtual task pre_body();
    raise_phase_objection();
  endtask

  virtual task body();
    bit                           status;
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0] txn_address;
    bit [`SVT_CHI_MAX_DATA_WIDTH -1:0] txn_data;
    bit txn_mem_attr_allocate_hint, txn_snp_attr_snp_domain_type, txn_is_non_secure_access/*, seq_snp_attr_is_snoopable*/;

    /** Sub sequences initiated from this sequence */
    svt_chi_rn_write_type_transaction_directed_sequence write_seq[int];
    svt_chi_rn_read_type_transaction_directed_sequence read_seq[int];
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq;

    `uvm_info("body", "Entered ...", UVM_HIGH)
    super.body();

    // Default
    status = uvm_config_db #(int unsigned)::get(null, get_full_name(), "sequence_length", sequence_length);
    `uvm_info("body", $sformatf("sequence_length is %0d as a result of %0s.", sequence_length, status ? "config DB" : "randomization"), UVM_HIGH);
    enable_outstanding =0;
    enable_outstanding_status = uvm_config_db#(bit)::get(m_sequencer, get_type_name(), "enable_outstanding", enable_outstanding);
    `uvm_info("body", $sformatf("enable_outstanding is %0b as a result of %0s", enable_outstanding, (enable_outstanding_status?"config DB":"default setting")), UVM_HIGH);

    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :initiating_rn_f_node_index_0;
    initiating_rn_node_idx_1 = initiating_rn_node_index_1_status ? initiating_rn_node_index_1_from_config_db :initiating_rn_f_node_index_1;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_f_node_index_0;

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /** 
     * If the number of active_participating_rn_f_nodes are greater than 2, then
     * we can initialize the cache/memory from the RN having node index 
     * initiating_rn_f_node_index_2.
     * If the number of active_participating_rn_f_nodes are equal to 2, then
     * we can initialize the cache/memory from the RN having node index 
     * initiating_rn_node_idx_0.
     *  
     */
    if((active_participating_rn_f_nodes.size()>2) && (valid_initiating_rn_f_node_index_2))begin
      cache_initializing_rn_node_index = initiating_rn_f_node_index_2;
      /**
       * If the cache_initializing_rn_node_index is same as any of the RN node indices 
       * which are passed through config i.e initiating_rn_node_idx_0,initiating_rn_node_idx_1,
       * then assert perform_initialization_from_rn_used_for_hazard to 1, so that RN will be
       * in valid state to initilize the respective transaction.
       */
      if(initiating_rn_node_index_0_status || initiating_rn_node_index_1_status)begin
         if((cache_initializing_rn_node_index == initiating_rn_node_idx_0)||(cache_initializing_rn_node_index == initiating_rn_node_idx_1))begin
           perform_initialization_from_rn_used_for_hazard =  1;
         end
         else begin
           perform_initialization_from_rn_used_for_hazard =  0;
         end  
      end  
    end else begin
      cache_initializing_rn_node_index = initiating_rn_node_idx_0;
      perform_initialization_from_rn_used_for_hazard =  1;
    end

    str_initiating_rn_node_indices = "";
    /** Display the contents of Active Participating RN-F Nodes */
    foreach (active_participating_rn_f_nodes[j]) begin
      str_initiating_rn_node_indices = {str_initiating_rn_node_indices, $sformatf(" %0d", active_participating_rn_f_nodes[j])};
    end 
    str_initiating_rn_node_indices = {str_initiating_rn_node_indices, $sformatf("\n RN nodes used to initiate the transactions are initiating_rn_node_idx_0 : %0d, initiating_rn_node_idx_1 : %0d,cache_initializing_rn_node_index : %0d ", initiating_rn_node_idx_0, initiating_rn_node_idx_1, cache_initializing_rn_node_index)};
    `svt_xvm_debug("body", $sformatf("contents of active_participating_rn_f_nodes and RN nodes used to initiate the transactions are %0s", str_initiating_rn_node_indices));

    for(int i = 0; i < sequence_length; i++) begin
      bit rn0_is_unique, rn0_is_clean, rn1_is_unique, rn1_is_clean, rn0_read_status, rn1_read_status;
      bit rn_cache_dirty_state,rn_cache_unique_state;

      /** Write data into Cache of Randomly selected first RN with address of randomly selected HN Node */
      `svt_xvm_do_on_with(makeunique_seq, p_sequencer.rn_virt_seqr[cache_initializing_rn_node_index].rn_xact_seqr,
      {
        sequence_length == 1;
        hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
        seq_hn_node_idx == target_hn_node_idx_0;
        use_seq_is_non_secure_access == 0;
      })

      /** Wait for MakeUnique transactions to finish */ 
      makeunique_seq.write_tran.wait_end();
      txn_address = makeunique_seq.output_xacts[0].addr;
      txn_data = makeunique_seq.data_in_cache;
      txn_mem_attr_allocate_hint = makeunique_seq.output_xacts[0].mem_attr_allocate_hint;
      txn_snp_attr_snp_domain_type = makeunique_seq.output_xacts[0].snp_attr_snp_domain_type;
      txn_is_non_secure_access = makeunique_seq.output_xacts[0].is_non_secure_access;

      /* CMO WRITE hazard at HN **/
      fork 
        begin      
`ifndef SVT_CHI_ENABLE_MULTI_CLOCK
          @ (posedge sys_cfg.chi_if.clk);
`else
          @ (posedge sys_cfg.chi_if.rn_clk[initiating_rn_node_idx_0]);
`endif
          xact_hazard_sema_0.get();
          /** Initiate a Combined Write CMO type transaction from initiating_rn_node_idx_0 to txn_address. */
          `svt_xvm_do_on_with(write_seq[i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
            {
             if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].cleansharedpersistsep_xact_enable == 1) {
               seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL_CLEANSHARED, svt_chi_transaction::WRITEUNIQUEFULL_CLEANSHAREDPERSISTSEP, svt_chi_transaction::WRITEUNIQUEPTL_CLEANSHARED, svt_chi_transaction::WRITEUNIQUEPTL_CLEANSHAREDPERSISTSEP};
             }
             else {
               seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL_CLEANSHARED, svt_chi_transaction::WRITEUNIQUEPTL_CLEANSHARED};
             }
             sequence_length               == 1;
             seq_order_type   != svt_chi_transaction::NO_ORDERING_REQUIRED;
             hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
             min_addr          == txn_address;
             max_addr          == txn_address;
             seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
             seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
             seq_is_non_secure_access == txn_is_non_secure_access;
             use_seq_is_non_secure_access == 1;               
            }
          )
          xact_hazard_sema_0.put();
          /** Wait for write type transactions to finish */ 
          write_seq[i].write_tran.wait_end();
        end
        begin
`ifndef SVT_CHI_ENABLE_MULTI_CLOCK
          @ (posedge sys_cfg.chi_if.clk);
`else
          @ (posedge sys_cfg.chi_if.rn_clk[initiating_rn_node_idx_1]);
`endif
          xact_hazard_sema_1.get();
          /** Initiate READ type of transaction from initiating_rn_node_idx_1 to txn_address. */ 
          `svt_xvm_do_on_with(read_seq[i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,
          { 
            seq_xact_type inside {svt_chi_transaction::READONCE,  svt_chi_transaction::READSHARED};
            sequence_length == 1;
            seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
            hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
            min_addr == txn_address;
            max_addr == txn_address;
            seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
            seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
            seq_is_non_secure_access == txn_is_non_secure_access;
            use_seq_is_non_secure_access == 1;
            by_pass_read_data_check == 1;
          }
          )
          xact_hazard_sema_1.put();
          /** Waiting for read type transaction to complete */ 
          read_seq[i].read_tran.wait_end(); 
        end
      join
    end

    `uvm_info("body", "Exiting...", UVM_HIGH)
  endtask: body

  virtual task post_body();
    drop_phase_objection();
  endtask

endclass:svt_chi_e_protocol_flow_ctrl_hn_combined_coherent_noncopyback_write_cmo_with_read_hazard_sequence

/**
 * @groupname CHI_SYS_HAZARD
 * Abstract:
 * svt_chi_e_protocol_flow_ctrl_hn_combined_coherent_copyback_write_cmo_with_read_hazard_sequence
 * provides a sequence to test how components handle various hazard conditions
 * applicable for coherent noncopyback combined write cmo transactions
 * 1. Send MAKEUNIQUE transaction to random address from random RN
 * 2. Send Combined coherent copyback write CMO transaction to the address from an RN
 * 3. Send READ type of transaction to the same address from different RN
 * 4. Check the order in which the two requests are processed by HN.
 * .
 */
class svt_chi_e_protocol_flow_ctrl_hn_combined_coherent_copyback_write_cmo_with_read_hazard_sequence extends svt_chi_e_protocol_flow_ctrl_combined_write_cmo_hazard_base_sequence;

  /** Parameter that controls the number of transactions that will be generated */
  rand int unsigned sequence_length = 10;

  rand bit enable_outstanding = 0;

  bit enable_outstanding_status = 0;

  /** Constrain the sequence length to a reasonable value */
  constraint reasonable_sequence_length {
    sequence_length <= 100;
  }
  `svt_xvm_object_utils(svt_chi_e_protocol_flow_ctrl_hn_combined_coherent_copyback_write_cmo_with_read_hazard_sequence)

  function new(string name="svt_chi_e_protocol_flow_ctrl_hn_combined_coherent_copyback_write_cmo_with_read_hazard_sequence");
    super.new(name);
  endfunction

  virtual task pre_body();
    raise_phase_objection();
  endtask

  virtual task body();
    bit                           status;
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0] txn_address;
    bit [`SVT_CHI_MAX_DATA_WIDTH -1:0] txn_data;
    bit txn_mem_attr_allocate_hint, txn_snp_attr_snp_domain_type, txn_is_non_secure_access/*, seq_snp_attr_is_snoopable*/;

    /** Sub sequences initiated from this sequence */
    svt_chi_rn_copyback_type_transaction_directed_sequence copyback_write[int];
    svt_chi_rn_read_type_transaction_directed_sequence read_seq[int];
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq;

    `uvm_info("body", "Entered ...", UVM_HIGH)
    super.body();

    // Default
    status = uvm_config_db #(int unsigned)::get(null, get_full_name(), "sequence_length", sequence_length);
    `uvm_info("body", $sformatf("sequence_length is %0d as a result of %0s.", sequence_length, status ? "config DB" : "randomization"), UVM_HIGH);
    enable_outstanding =0;
    enable_outstanding_status = uvm_config_db#(bit)::get(m_sequencer, get_type_name(), "enable_outstanding", enable_outstanding);
    `uvm_info("body", $sformatf("enable_outstanding is %0b as a result of %0s", enable_outstanding, (enable_outstanding_status?"config DB":"default setting")), UVM_HIGH);

    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :initiating_rn_f_node_index_0;
    initiating_rn_node_idx_1 = initiating_rn_node_index_1_status ? initiating_rn_node_index_1_from_config_db :initiating_rn_f_node_index_1;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_f_node_index_0;

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /** 
     * If the number of active_participating_rn_f_nodes are greater than 2, then
     * we can initialize the cache/memory from the RN having node index 
     * initiating_rn_f_node_index_2.
     * If the number of active_participating_rn_f_nodes are equal to 2, then
     * we can initialize the cache/memory from the RN having node index 
     * initiating_rn_node_idx_0.
     *  
     */
    if((active_participating_rn_f_nodes.size()>2) && (valid_initiating_rn_f_node_index_2))begin
      cache_initializing_rn_node_index = initiating_rn_f_node_index_2;
      /**
       * If the cache_initializing_rn_node_index is same as any of the RN node indices 
       * which are passed through config i.e initiating_rn_node_idx_0,initiating_rn_node_idx_1,
       * then assert perform_initialization_from_rn_used_for_hazard to 1, so that RN will be
       * in valid state to initilize the respective transaction.
       */
      if(initiating_rn_node_index_0_status || initiating_rn_node_index_1_status)begin
         if((cache_initializing_rn_node_index == initiating_rn_node_idx_0)||(cache_initializing_rn_node_index == initiating_rn_node_idx_1))begin
           perform_initialization_from_rn_used_for_hazard =  1;
         end
         else begin
           perform_initialization_from_rn_used_for_hazard =  0;
         end  
      end  
    end else begin
      cache_initializing_rn_node_index = initiating_rn_node_idx_0;
      perform_initialization_from_rn_used_for_hazard =  1;
    end

    str_initiating_rn_node_indices = "";
    /** Display the contents of Active Participating RN-F Nodes */
    foreach (active_participating_rn_f_nodes[j]) begin
      str_initiating_rn_node_indices = {str_initiating_rn_node_indices, $sformatf(" %0d", active_participating_rn_f_nodes[j])};
    end 
    str_initiating_rn_node_indices = {str_initiating_rn_node_indices, $sformatf("\n RN nodes used to initiate the transactions are initiating_rn_node_idx_0 : %0d, initiating_rn_node_idx_1 : %0d,cache_initializing_rn_node_index : %0d ", initiating_rn_node_idx_0, initiating_rn_node_idx_1, cache_initializing_rn_node_index)};
    `svt_xvm_debug("body", $sformatf("contents of active_participating_rn_f_nodes and RN nodes used to initiate the transactions are %0s", str_initiating_rn_node_indices));

    for(int i = 0; i < sequence_length; i++) begin
      bit rn0_is_unique, rn0_is_clean, rn1_is_unique, rn1_is_clean, rn0_read_status, rn1_read_status;
      bit rn_cache_dirty_state,rn_cache_unique_state;

      /** Write data into Cache of Randomly selected first RN with address of randomly selected HN Node */
      `svt_xvm_do_on_with(makeunique_seq, p_sequencer.rn_virt_seqr[cache_initializing_rn_node_index].rn_xact_seqr,
      {
        sequence_length == 1;
        hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
        seq_hn_node_idx == target_hn_node_idx_0;
        use_seq_is_non_secure_access == 0;
      })

      /** Wait for MakeUnique transactions to finish */ 
      makeunique_seq.write_tran.wait_end();
      txn_address = makeunique_seq.output_xacts[0].addr;
      txn_data = makeunique_seq.data_in_cache;
      txn_mem_attr_allocate_hint = makeunique_seq.output_xacts[0].mem_attr_allocate_hint;
      txn_snp_attr_snp_domain_type = makeunique_seq.output_xacts[0].snp_attr_snp_domain_type;
      txn_is_non_secure_access = makeunique_seq.output_xacts[0].is_non_secure_access;

      /* CMO WRITE hazard at HN **/
      fork 
        begin      
`ifndef SVT_CHI_ENABLE_MULTI_CLOCK
          @ (posedge sys_cfg.chi_if.clk);
`else
          @ (posedge sys_cfg.chi_if.rn_clk[initiating_rn_node_idx_0]);
`endif
          xact_hazard_sema_0.get();
          /** Randomly selected first RN-F fires a write-cmo type transaction to txn_address */
          `svt_xvm_do_on_with(copyback_write[i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
            {
             if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].cleansharedpersistsep_xact_enable == 1) {
               seq_xact_type inside{svt_chi_transaction::WRITEBACKFULL_CLEANSHARED, svt_chi_transaction::WRITEBACKFULL_CLEANSHAREDPERSISTSEP,svt_chi_transaction::WRITEBACKFULL_CLEANINVALID};
             }
             else {
               seq_xact_type inside{svt_chi_transaction::WRITEBACKFULL_CLEANSHARED,svt_chi_transaction::WRITEBACKFULL_CLEANINVALID};
             }
             sequence_length               == 1;
             seq_order_type   == svt_chi_transaction::NO_ORDERING_REQUIRED;
             hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
             min_addr          == txn_address;
             max_addr          == txn_address;
             seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
             seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
             seq_is_non_secure_access == txn_is_non_secure_access;
             use_seq_is_non_secure_access == 1;
            }
          )
          xact_hazard_sema_0.put();
          /** Wait for write type transactions to finish */ 
          copyback_write[i].copyback_tran.wait_end();
        end
        begin
`ifndef SVT_CHI_ENABLE_MULTI_CLOCK
          @ (posedge sys_cfg.chi_if.clk);
`else
          @ (posedge sys_cfg.chi_if.rn_clk[initiating_rn_node_idx_1]);
`endif
          xact_hazard_sema_1.get();
          /** Initiate READ type of transaction from initiating_rn_node_idx_1 to txn_address. */ 
          `svt_xvm_do_on_with(read_seq[i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,
          { 
            seq_xact_type inside {svt_chi_transaction::READONCE,  svt_chi_transaction::READSHARED};
            sequence_length == 1;
            seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
            hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
            min_addr == txn_address;
            max_addr == txn_address;
            seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
            seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
            seq_is_non_secure_access == txn_is_non_secure_access;
            use_seq_is_non_secure_access == 1;
            by_pass_read_data_check == 1;
          }
          )
          xact_hazard_sema_1.put();
          /** Waiting for read type transaction to complete */ 
          read_seq[i].read_tran.wait_end(); 
        end
      join
    end

    `uvm_info("body", "Exiting...", UVM_HIGH)
  endtask: body

  virtual task post_body();
    drop_phase_objection();
  endtask

endclass:svt_chi_e_protocol_flow_ctrl_hn_combined_coherent_copyback_write_cmo_with_read_hazard_sequence

`endif //CHI_ISSUE_E

/**
 * @groupname CHI_SINGLE_RN_ORDERED_NONCOHERENT_TYPE    
 * svt_chi_system_req_order_noncoherent_xact_directed_virtual_sequence is used by test to provide initiator
 * scenario information to the RN agent present in the System Env.
 * This sequence generates an Ordered CHI WRITENOSNP followed by an Ordered CHI READNOSNP
 * If the number of request order streams > 1, READs are sent with stream ID 0, while the
 * WRITEs are sent with stream ID 1.
 * Users can configure the number of streams by programming the parameter svt_chi_node_configuration::num_req_order_streams for the RN.
 */

class svt_chi_system_req_order_noncoherent_xact_directed_virtual_sequence extends svt_chi_system_single_node_rn_coherent_transaction_base_virtual_sequence;

  /** Indicates if multiple streams must be exercised in case the number of order streams programmed in the RN is greater than 1*/
  int use_multiple_order_streams = 1;
  
  /** Sub sequences initiated from this sequence */
  chi_rn_noncoherent_transaction_base_sequence noncoherent_xact_seq;

  /** Constrain the sequence length to a reasonable value */
  constraint reasonable_sequence_length
  {
    sequence_length <= 50;
  }
  
  /** UVM Object Utility macro */
  `uvm_object_utils(svt_chi_system_req_order_noncoherent_xact_directed_virtual_sequence)
  
  /** Constructor */
  function new (string name="svt_chi_system_req_order_noncoherent_xact_directed_virtual_sequence");
    super.new(name);
    is_xact_type_valid_for_rn_i = 1;
    is_xact_type_valid_for_rn_d = 1;
  endfunction
  
  /** The body() task is the actual logic of the sequence */
  virtual task body();
    super.body();

    noncoherent_xact_seq = new();

    request_ordering = 1;
    
    /** Send Ordered WriteNoSnp followed by ReadNoSnp transaction */
    fork
      begin
        for(int i=0; i<sequence_length; i++) begin          
          /** send READNOSNP and WRITENOSNPFULL transactions those need request ordering */
          send_noncoherent_transaction(svt_chi_common_transaction::WRITENOSNPFULL);
          if (use_multiple_order_streams == 0) 
            send_noncoherent_transaction(svt_chi_common_transaction::READNOSNP);
          else 
            send_noncoherent_transaction(svt_chi_common_transaction::READNOSNP, 1);
        end
      end // fork begin
    join
    noncoherent_xact_seq.wait_for_active_xacts_to_end();

    `uvm_info("body", "Exiting...", UVM_HIGH);
  endtask:body

  task send_noncoherent_transaction(svt_chi_common_transaction::xact_type_enum rn_xact_type, int req_order_stream_id = 0);
    `svt_xvm_create_on(noncoherent_xact_seq, p_sequencer.rn_virt_seqr[node_index].rn_xact_seqr)    
    noncoherent_xact_seq.disable_all_weights();
    noncoherent_xact_seq.assign_xact_weights(rn_xact_type);
    if (hn_index_status) begin
      noncoherent_xact_seq.addr_mode = svt_chi_rn_coherent_transaction_base_sequence::TARGET_HN_INDEX;
    end
    // addr_mode_programmed is set to 1 for the following address modes
    // svt_chi_rn_coherent_transaction_base_sequence::SEQUENTIAL_NONOVERLAPPED_ADDRESS
    // svt_chi_rn_coherent_transaction_base_sequence::RANDOM_ADDRESS
    else if (addr_mode_programmed) begin
      noncoherent_xact_seq.addr_mode = this.addr_mode;
    end
    else if (addr_ranges_programmed) begin
      noncoherent_xact_seq.addr_mode = svt_chi_rn_coherent_transaction_base_sequence::RANDOM_ADDRESS_IN_RANGE;
    end

    void'(noncoherent_xact_seq.randomize with {
                                   use_directed_addr == 0;
                                   sequence_length==1;
                                   if (hn_index_status) seq_hn_node_idx==local::hn_index;
                                   if (addr_ranges_programmed) start_addr==local::start_addr;
                                   if (addr_ranges_programmed) end_addr==local::end_addr;
                                   if (request_ordering == 1) seq_order_type != svt_chi_transaction::NO_ORDERING_REQUIRED;
                                   `ifdef SVT_CHI_ISSUE_B_ENABLE
                                     if (request_ordering == 1) seq_order_type != svt_chi_transaction::REQ_ACCEPTED;
                                   `endif
                                   if (request_ordering == 0) seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
                                   seq_req_order_stream_id == req_order_stream_id;
                                });
    noncoherent_xact_seq.start(p_sequencer.rn_virt_seqr[node_index].rn_xact_seqr);
   endtask

endclass:svt_chi_system_req_order_noncoherent_xact_directed_virtual_sequence

`ifdef SVT_CHI_ISSUE_B_ENABLE
/////////////////////////////
// ATOMIC type
/////////////////////////////
/** 
 * This sequence setups the basic attributes and methods which are used by
 * the derived sequences to initiate atomic tranasctions.<br>
 */
class svt_chi_system_single_node_rn_atomic_transaction_base_virtual_sequence extends svt_chi_system_single_node_rn_coherent_transaction_base_virtual_sequence;

  rand svt_chi_transaction::atomic_transaction_type_enum atomic_xact_type;
  rand svt_chi_common_transaction::xact_type_enum selected_atomic_xact_type;

  svt_chi_common_transaction::xact_type_enum selected_atomic_xact_type_config_db;
  bit select_atomic_xact_type_config_db_status = 0;

  constraint atomic_xact_type_c1 {atomic_xact_type != svt_chi_transaction::NON_ATOMIC;}
  constraint atomic_operation_type_c {
    (atomic_xact_type == svt_chi_transaction::STORE) -> selected_atomic_xact_type inside {
            svt_chi_common_transaction::ATOMICSTORE_ADD,
            svt_chi_common_transaction::ATOMICSTORE_CLR,
            svt_chi_common_transaction::ATOMICSTORE_EOR,
            svt_chi_common_transaction::ATOMICSTORE_SET,
            svt_chi_common_transaction::ATOMICSTORE_SMAX,
            svt_chi_common_transaction::ATOMICSTORE_SMIN,
            svt_chi_common_transaction::ATOMICSTORE_UMAX,
            svt_chi_common_transaction::ATOMICSTORE_UMIN
            };
    (atomic_xact_type == svt_chi_transaction::LOAD) -> selected_atomic_xact_type inside {
            svt_chi_common_transaction::ATOMICLOAD_ADD,
            svt_chi_common_transaction::ATOMICLOAD_CLR,
            svt_chi_common_transaction::ATOMICLOAD_EOR,
            svt_chi_common_transaction::ATOMICLOAD_SET,
            svt_chi_common_transaction::ATOMICLOAD_SMAX,
            svt_chi_common_transaction::ATOMICLOAD_SMIN,
            svt_chi_common_transaction::ATOMICLOAD_UMAX,
            svt_chi_common_transaction::ATOMICLOAD_UMIN
            };            
    (atomic_xact_type == svt_chi_transaction::SWAP) -> selected_atomic_xact_type == svt_chi_common_transaction::ATOMICSWAP;
    (atomic_xact_type == svt_chi_transaction::COMPARE) -> selected_atomic_xact_type == svt_chi_common_transaction::ATOMICCOMPARE;

    solve atomic_xact_type before selected_atomic_xact_type;
  }

  `svt_xvm_object_utils(svt_chi_system_single_node_rn_atomic_transaction_base_virtual_sequence)

  function new(string name = "svt_chi_system_single_node_rn_atomic_transaction_base_virtual_sequence");
    super.new(name);
  endfunction  

  virtual task pre_start();
    bit status;
    super.pre_start();
    raise_phase_objection();

    `svt_xvm_debug("pre_start", $sformatf("hn_index_status is 'd%0d as a result of config DB. Any values programmed for start_addr and end_addr will be ignored.", hn_index));

    if(!hn_index_status)begin
      hn_index_status = 1;
      hn_index = target_hn_f_node_index_0;
      `svt_xvm_debug("pre_start", $sformatf("Re-programming the hn_index to %0d and hn_index_status to %0d, as it is not programmed by the user.",hn_index,hn_index_status));
    end

    /** Get the user sequence_length. */
    `ifdef SVT_UVM_TECHNOLOGY
      select_atomic_xact_type_config_db_status = uvm_config_db#(svt_chi_common_transaction::xact_type_enum)::get(m_sequencer, get_type_name(), "selected_atomic_xact_type_config_db", selected_atomic_xact_type_config_db);
    `else
      select_atomic_xact_type_config_db_status = m_sequencer.get_config_int({get_type_name(), ".selected_atomic_xact_type_config_db"}, selected_atomic_xact_type_config_db);

    `endif
  endtask // pre_start

  /** Drop objection */
  virtual task post_start();
    super.post_start();
    drop_phase_objection();
  endtask: post_start

  virtual task body();
    super.body();
  endtask

endclass

//====================================================================================
/** 
 * @groupname CHI_SINGLE_RN_ATOMICSTORE_TYPE  
 * #- This sequence requires one initiating active and participating RN-F.<br>
 * #- If one or more active and participating RN-F exists, perform cache<br>
 *    initialization to a randomly selected HN.<br>
 * #- Program the RN to initiate random Atomic Store transaction from randomly selected RN_F.<br>
 * .
 */
class svt_chi_system_single_node_atomicstore_transaction_virtual_sequence extends svt_chi_system_single_node_rn_atomic_transaction_base_virtual_sequence;

  constraint atomic_store_operation_type_c {
    selected_atomic_xact_type inside {svt_chi_common_transaction::ATOMICSTORE_ADD,
                                      svt_chi_common_transaction::ATOMICSTORE_CLR,
                                      svt_chi_common_transaction::ATOMICSTORE_EOR,
                                      svt_chi_common_transaction::ATOMICSTORE_SET,
                                      svt_chi_common_transaction::ATOMICSTORE_SMAX,
                                      svt_chi_common_transaction::ATOMICSTORE_SMIN,
                                      svt_chi_common_transaction::ATOMICSTORE_UMAX,
                                      svt_chi_common_transaction::ATOMICSTORE_UMIN};
  }

  `svt_xvm_object_utils(svt_chi_system_single_node_atomicstore_transaction_virtual_sequence)


  function new(string name = "svt_chi_system_single_node_atomicstore_transaction_virtual_sequence");
    super.new(name);
  endfunction 

  virtual task pre_start();
    bit status;
    super.pre_start();
`ifdef SVT_UVM_TECHNOLOGY
    snoop_me_status = uvm_config_db#(int unsigned)::get(null, get_full_name(), "snoopme",snoop_me_config_db);
    endian_status = uvm_config_db#(svt_chi_common_transaction::endian_enum)::get(m_sequencer, get_type_name(), "endian", endian_config_db);
`elsif SVT_OVM_TECHNOLOGY
    snoop_me_status = m_sequencer.get_config_int({get_type_name(), ".snoopme"}, snoop_me_config_db);
    endian_status = m_sequencer.get_config_int({get_type_name(), ".endian"}, endian_config_db);
`endif
    `svt_xvm_debug("pre_start", $sformatf("snoop_me_config_db is %0d as a result of %0s.", snoop_me_config_db, snoop_me_status ? "config DB" : "default value"));
    `svt_xvm_debug("pre_start", $sformatf("endian_config_db is %0s as a result of %0s.", endian_config_db.name(), endian_status ? "config DB" : "default value"));
endtask

  /**
   * Initializes cachelines and sends WriteUniqueFull from node "node_index"
   */
  virtual task body();
    super.body();

    selected_atomic_xact_type = select_atomic_xact_type_config_db_status ? selected_atomic_xact_type_config_db : selected_atomic_xact_type;
  `svt_xvm_debug("body", $sformatf("selected_atomic_xact_type is %s as a result of %0s.", selected_atomic_xact_type.name(), select_atomic_xact_type_config_db_status ? "the config DB" : "randomization"));

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /**
     * If the selected node is RN-F/RN-I/RN-D node, do cache line initialization
     * In case of selected node is RN-I/RN-D, the cache initialization happens
     * from one of the peer RN-F nodes. 
     */
    send_coherent_transactions(selected_atomic_xact_type, 1);

    /** Wait for readshared transactions to finish */
    coherent_seq.wait_for_active_xacts_to_end();
    print_caches();
  endtask: body

  /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting Request Nodes = 1
   *  #- Valid Atomic Store operation type
   */
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    string str_is_supported_info_prefix = "";
    string str_is_supported_info_postfix = "";
    string str_is_supported_info = "";
    int num_supporting_rn_f_nodes;
    bit is_rn_idx_0_participating;
    string str_rn_f_node = "";
    int array_idx;
    string str_idx0_info = "";

    /** Supporting RN-F Nodes required */
    int required_num_supporting_rn_f_nodes = 1;
    bit supported_atomic_store_xact = 0;
    `svt_xvm_debug("is_supported",$sformatf("Entering ..."));

    /** By default is_supported is 0 */
    is_supported = 0;

    /** Check for minimum required RN-F nodes.
     *  Also check whether the selected RN-F nodes are part of participating arrays or not.
     */ 
    num_supporting_rn_f_nodes = active_participating_rn_f_nodes.size();

    /** Check the requirements of RN-F nodes */  
    if (num_supporting_rn_f_nodes) begin
      /** Display the contents of Active Participating RN-F Nodes */
      foreach (active_participating_rn_f_nodes[j]) begin
        str_rn_f_node = {str_rn_f_node, $sformatf(" %0d", active_participating_rn_f_nodes[j])};
      end 
      `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_f_nodes are %0s", str_rn_f_node));
    end

    str_is_supported_info_prefix = $sformatf("Number of Supporting RN-F Node(s)  - Minimum Required : %0d Current : %0d", required_num_supporting_rn_f_nodes, num_supporting_rn_f_nodes);

    if ((initiating_rn_node_index_0_status==0)&&(valid_initiating_rn_f_node_index_0==0)) begin
        str_idx0_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN-Fs that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)";
    end
    else begin
      is_rn_idx_0_participating = is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_node_idx_0, array_idx);
      if (!is_rn_idx_0_participating) begin
        str_idx0_info = $sformatf("initiating_rn_node_idx_0 %0d is not valid for this sequence. The RN-F corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)", initiating_rn_node_idx_0, initiating_rn_node_idx_0);
      end
    end

    if (is_rn_idx_0_participating ) begin
      is_supported = 1;
    end

    str_is_supported_info_postfix = $sformatf("Atomic Store operation should be one of the following below transactions ATOMICSTORE_ADD,ATOMICSTORE_CLR, ATOMICSTORE_EOR, ATOMICSTORE_SET, ATOMICSTORE_SMAX, ATOMICSTORE_SMIN, ATOMICSTORE_UMAX, ATOMICSTORE_UMIN");

    if((selected_atomic_xact_type == svt_chi_common_transaction::ATOMICSTORE_ADD) ||
       (selected_atomic_xact_type == svt_chi_common_transaction::ATOMICSTORE_CLR) ||
       (selected_atomic_xact_type == svt_chi_common_transaction::ATOMICSTORE_EOR) ||
       (selected_atomic_xact_type == svt_chi_common_transaction::ATOMICSTORE_SET) ||
       (selected_atomic_xact_type == svt_chi_common_transaction::ATOMICSTORE_SMAX) ||
       (selected_atomic_xact_type == svt_chi_common_transaction::ATOMICSTORE_SMIN) ||
       (selected_atomic_xact_type == svt_chi_common_transaction::ATOMICSTORE_UMAX) ||
       (selected_atomic_xact_type == svt_chi_common_transaction::ATOMICSTORE_UMIN)) begin

      supported_atomic_store_xact = 1;
    end
    else begin
      supported_atomic_store_xact = 0;
    end 

    if (!is_supported) begin
      str_is_supported_info = $sformatf("%0s",str_idx0_info);
      issue_is_supported_failure($sformatf("This sequence cannot be run based on the current system configuration.\n\
                                            %0s \n\
                                            %0s \n\
                                            Modify configurations through \n\
                                            svt_chi_system_configuration::num_rn,\n\
                                            svt_chi_node_configuration::is_active,\n\
                                            svt_chi_system_configuration::participating_request_nodes\n\
                                            ", str_is_supported_info_prefix, str_is_supported_info));
    end  

    if (!supported_atomic_store_xact) begin
      issue_is_supported_failure($sformatf("Invalid Store transaction type attempted.\n%0s \n",str_is_supported_info_postfix));
    end  

  endfunction

endclass

//====================================================================================
/** 
 * @groupname CHI_SINGLE_RN_ATOMICLOAD_TYPE   
 * #- This sequence requires one initiating active and participating RN-F.<br>
 * #- If one or more active and participating RN-F exists, perform cache<br>
 *    initialization to a randomly selected HN.<br>
 * #- Program the RN to initiate random Atomic Load transaction from randomly selected RN_F.<br>
 * .
 */
class svt_chi_system_single_node_atomicload_transaction_virtual_sequence extends svt_chi_system_single_node_rn_atomic_transaction_base_virtual_sequence;

  constraint atomic_load_operation_type_c {
    selected_atomic_xact_type inside {svt_chi_common_transaction::ATOMICLOAD_ADD,
                                      svt_chi_common_transaction::ATOMICLOAD_CLR,
                                      svt_chi_common_transaction::ATOMICLOAD_EOR,
                                      svt_chi_common_transaction::ATOMICLOAD_SET,
                                      svt_chi_common_transaction::ATOMICLOAD_SMAX,
                                      svt_chi_common_transaction::ATOMICLOAD_SMIN,
                                      svt_chi_common_transaction::ATOMICLOAD_UMAX,
                                      svt_chi_common_transaction::ATOMICLOAD_UMIN};
  }

  `svt_xvm_object_utils(svt_chi_system_single_node_atomicload_transaction_virtual_sequence)


  function new(string name = "svt_chi_system_single_node_atomicload_transaction_virtual_sequence");
    super.new(name);
  endfunction 

  virtual task pre_start();
    bit status;
    super.pre_start();
`ifdef SVT_UVM_TECHNOLOGY
    snoop_me_status = uvm_config_db#(int unsigned)::get(null, get_full_name(), "snoopme",snoop_me_config_db);
    endian_status = uvm_config_db#(svt_chi_common_transaction::endian_enum)::get(m_sequencer, get_type_name(), "endian", endian_config_db);
`elsif SVT_OVM_TECHNOLOGY
    snoop_me_status = m_sequencer.get_config_int({get_type_name(), ".snoopme"}, snoop_me_config_db);
    endian_status = m_sequencer.get_config_int({get_type_name(), ".endian"}, endian_config_db);
`endif
    `svt_xvm_debug("pre_start", $sformatf("snoop_me_config_db is %0d as a result of %0s.", snoop_me_config_db, snoop_me_status ? "config DB" : "default value"));
    `svt_xvm_debug("pre_start", $sformatf("endian_config_db is %0s as a result of %0s.", endian_config_db.name(), endian_status ? "config DB" : "default value"));
  endtask

  /**
   * Initializes cachelines and sends WriteUniqueFull from node "node_index"
   */
  virtual task body();
    super.body();

    selected_atomic_xact_type = select_atomic_xact_type_config_db_status ? selected_atomic_xact_type_config_db : selected_atomic_xact_type;
  `svt_xvm_debug("body", $sformatf("selected_atomic_xact_type is %s as a result of %0s.", selected_atomic_xact_type.name(), select_atomic_xact_type_config_db_status ? "the config DB" : "randomization"));

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /**
     * If the selected node is RN-F/RN-I/RN-D node, do cache line initialization
     * In case of selected node is RN-I/RN-D, the cache initialization happens
     * from one of the peer RN-F nodes. 
     */
    send_coherent_transactions(selected_atomic_xact_type, 1);

    /** Wait for readshared transactions to finish */
    coherent_seq.wait_for_active_xacts_to_end();
    print_caches();
  endtask: body

  /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting Request Nodes = 1
   *  #- Valid Atomic Store operation type
   */
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    string str_is_supported_info_prefix = "";
    string str_is_supported_info_postfix = "";
    string str_is_supported_info = "";
    int num_supporting_rn_f_nodes;
    bit is_rn_idx_0_participating;
    string str_rn_f_node = "";
    int array_idx;
    string str_idx0_info = "";

    /** Supporting RN-F Nodes required */
    int required_num_supporting_rn_f_nodes = 1;
    bit supported_atomic_load_xact = 0;
    `svt_xvm_debug("is_supported",$sformatf("Entering ..."));

    /** By default is_supported is 0 */
    is_supported = 0;

    /** Check for minimum required RN-F nodes.
     *  Also check whether the selected RN-F nodes are part of participating arrays or not.
     */ 
    num_supporting_rn_f_nodes = active_participating_rn_f_nodes.size();

    /** Check the requirements of RN-F nodes */  
    if (num_supporting_rn_f_nodes) begin
      /** Display the contents of Active Participating RN-F Nodes */
      foreach (active_participating_rn_f_nodes[j]) begin
        str_rn_f_node = {str_rn_f_node, $sformatf(" %0d", active_participating_rn_f_nodes[j])};
      end 
      `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_f_nodes are %0s", str_rn_f_node));
    end

    str_is_supported_info_prefix = $sformatf("Number of Supporting RN-F Node(s)  - Minimum Required : %0d Current : %0d", required_num_supporting_rn_f_nodes, num_supporting_rn_f_nodes);

    if ((initiating_rn_node_index_0_status==0)&&(valid_initiating_rn_f_node_index_0==0)) begin
        str_idx0_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN-Fs that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)";
    end
    else begin
      is_rn_idx_0_participating = is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_node_idx_0, array_idx);
      if (!is_rn_idx_0_participating) begin
        str_idx0_info = $sformatf("initiating_rn_node_idx_0 %0d is not valid for this sequence. The RN-F corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)", initiating_rn_node_idx_0, initiating_rn_node_idx_0);
      end
    end

    if (is_rn_idx_0_participating ) begin
      is_supported = 1;
    end

    str_is_supported_info_postfix = $sformatf("Atomic Load operation should be one of the following below transactions ATOMICLOAD_ADD,ATOMICLOAD_CLR, ATOMICLOAD_EOR, ATOMICLOAD_SET, ATOMICLOAD_SMAX, ATOMICLOAD_SMIN, ATOMICLOAD_UMAX, ATOMICLOAD_UMIN");

    if((selected_atomic_xact_type == svt_chi_common_transaction::ATOMICLOAD_ADD) ||
       (selected_atomic_xact_type == svt_chi_common_transaction::ATOMICLOAD_CLR) ||
       (selected_atomic_xact_type == svt_chi_common_transaction::ATOMICLOAD_EOR) ||
       (selected_atomic_xact_type == svt_chi_common_transaction::ATOMICLOAD_SET) ||
       (selected_atomic_xact_type == svt_chi_common_transaction::ATOMICLOAD_SMAX) ||
       (selected_atomic_xact_type == svt_chi_common_transaction::ATOMICLOAD_SMIN) ||
       (selected_atomic_xact_type == svt_chi_common_transaction::ATOMICLOAD_UMAX) ||
       (selected_atomic_xact_type == svt_chi_common_transaction::ATOMICLOAD_UMIN)) begin

      supported_atomic_load_xact = 1;
    end
    else begin
      supported_atomic_load_xact = 0;
    end 

    if (!is_supported) begin
      str_is_supported_info = $sformatf("%0s",str_idx0_info);
      issue_is_supported_failure($sformatf("This sequence cannot be run based on the current system configuration.\n\
                                            %0s \n\
                                            %0s \n\
                                            Modify configurations through \n\
                                            svt_chi_system_configuration::num_rn,\n\
                                            svt_chi_node_configuration::is_active,\n\
                                            svt_chi_system_configuration::participating_request_nodes\n\
                                            ", str_is_supported_info_prefix, str_is_supported_info));
    end  

    if (!supported_atomic_load_xact) begin
      issue_is_supported_failure($sformatf("Invalid Load transaction type attempted.\n%0s \n",str_is_supported_info_postfix));
    end  

  endfunction

endclass

//====================================================================================
/** 
 * @groupname CHI_SINGLE_RN_ATOMICSWAP_TYPE
 * #- This sequence requires one initiating active and participating RN-F.<br>
 * #- If one or more active and participating RN-F exists, perform cache<br>
 *    initialization to a randomly selected HN.<br>
 * #- Program the RN to initiate random Atomic Swap transaction from randomly selected RN_F.<br>
 * .
 */
class svt_chi_system_single_node_atomicswap_transaction_virtual_sequence extends svt_chi_system_single_node_rn_atomic_transaction_base_virtual_sequence;

  constraint atomic_operation_type_c { selected_atomic_xact_type == svt_chi_common_transaction::ATOMICSWAP;}

  `svt_xvm_object_utils(svt_chi_system_single_node_atomicswap_transaction_virtual_sequence)


  function new(string name = "svt_chi_system_single_node_atomicswap_transaction_virtual_sequence");
    super.new(name);
  endfunction 

  virtual task pre_start();
    bit status;
    super.pre_start();
`ifdef SVT_UVM_TECHNOLOGY
    snoop_me_status = uvm_config_db#(int unsigned)::get(null, get_full_name(), "snoopme",snoop_me_config_db);
    endian_status = uvm_config_db#(svt_chi_common_transaction::endian_enum)::get(m_sequencer, get_type_name(), "endian", endian_config_db);
`elsif SVT_OVM_TECHNOLOGY
    snoop_me_status = m_sequencer.get_config_int({get_type_name(), ".snoopme"}, snoop_me_config_db);
    endian_status = m_sequencer.get_config_int({get_type_name(), ".endian"}, endian_config_db);
`endif
    `svt_xvm_debug("pre_start", $sformatf("snoop_me_config_db is %0d as a result of %0s.", snoop_me_config_db, snoop_me_status ? "config DB" : "default value"));
    `svt_xvm_debug("pre_start", $sformatf("endian_config_db is %0s as a result of %0s.", endian_config_db.name(), endian_status ? "config DB" : "default value"));
  endtask

  /**
   * Initializes cachelines and sends WriteUniqueFull from node "node_index"
   */
  virtual task body();
    super.body();

    selected_atomic_xact_type = select_atomic_xact_type_config_db_status ? selected_atomic_xact_type_config_db : selected_atomic_xact_type;
  `svt_xvm_debug("body", $sformatf("selected_atomic_xact_type is %s as a result of %0s.", selected_atomic_xact_type.name(), select_atomic_xact_type_config_db_status ? "the config DB" : "randomization"));

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /**
     * If the selected node is RN-F/RN-I/RN-D node, do cache line initialization
     * In case of selected node is RN-I/RN-D, the cache initialization happens
     * from one of the peer RN-F nodes. 
     */
    send_coherent_transactions(selected_atomic_xact_type, 1);

    /** Wait for readshared transactions to finish */
    coherent_seq.wait_for_active_xacts_to_end();
    print_caches();
  endtask: body

  /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting Request Nodes = 1
   *  #- Valid Atomic operation type
   */
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    string str_is_supported_info_prefix = "";
    string str_is_supported_info_postfix = "";
    string str_is_supported_info = "";
    int num_supporting_rn_f_nodes;
    bit is_rn_idx_0_participating;
    string str_rn_f_node = "";
    int array_idx;
    string str_idx0_info = "";

    /** Supporting RN-F Nodes required */
    int required_num_supporting_rn_f_nodes = 1;
    bit supported_atomic_swap_xact = 0;
    `svt_xvm_debug("is_supported",$sformatf("Entering ..."));

    /** By default is_supported is 0 */
    is_supported = 0;

    /** Check for minimum required RN-F nodes.
     *  Also check whether the selected RN-F nodes are part of participating arrays or not.
     */ 
    num_supporting_rn_f_nodes = active_participating_rn_f_nodes.size();

    /** Check the requirements of RN-F nodes */  
    if (num_supporting_rn_f_nodes) begin
      /** Display the contents of Active Participating RN-F Nodes */
      foreach (active_participating_rn_f_nodes[j]) begin
        str_rn_f_node = {str_rn_f_node, $sformatf(" %0d", active_participating_rn_f_nodes[j])};
      end 
      `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_f_nodes are %0s", str_rn_f_node));
    end

    str_is_supported_info_prefix = $sformatf("Number of Supporting RN-F Node(s)  - Minimum Required : %0d Current : %0d", required_num_supporting_rn_f_nodes, num_supporting_rn_f_nodes);

    if ((initiating_rn_node_index_0_status==0)&&(valid_initiating_rn_f_node_index_0==0)) begin
        str_idx0_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN-Fs that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)";
    end
    else begin
      is_rn_idx_0_participating = is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_node_idx_0, array_idx);
      if (!is_rn_idx_0_participating) begin
        str_idx0_info = $sformatf("initiating_rn_node_idx_0 %0d is not valid for this sequence. The RN-F corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)", initiating_rn_node_idx_0, initiating_rn_node_idx_0);
      end
    end

    if (is_rn_idx_0_participating ) begin
      is_supported = 1;
    end

    str_is_supported_info_postfix = $sformatf("Atomic operation should be of type ATOMICSWAP");

    if(selected_atomic_xact_type == svt_chi_common_transaction::ATOMICSWAP) begin
      supported_atomic_swap_xact = 1;
    end
    else begin
      supported_atomic_swap_xact = 0;
    end 

    if (!is_supported) begin
      str_is_supported_info = $sformatf("%0s",str_idx0_info);
      issue_is_supported_failure($sformatf("This sequence cannot be run based on the current system configuration.\n\
                                            %0s \n\
                                            %0s \n\
                                            Modify configurations through \n\
                                            svt_chi_system_configuration::num_rn,\n\
                                            svt_chi_node_configuration::is_active,\n\
                                            svt_chi_system_configuration::participating_request_nodes\n\
                                            ", str_is_supported_info_prefix, str_is_supported_info));
    end  

    if (!supported_atomic_swap_xact) begin
      issue_is_supported_failure($sformatf("Invalid Atomic transaction type attempted.\n%0s \n",str_is_supported_info_postfix));
    end  

  endfunction

endclass

//====================================================================================
/** 
 * @groupname CHI_SINGLE_RN_ATOMICCOMPARE_TYPE
 * #- This sequence requires one initiating active and participating RN-F.<br>
 * #- If one or more active and participating RN-F exists, perform cache<br>
 *    initialization to a randomly selected HN.<br>
 * #- Program the RN to initiate random Atomic Compare transaction from randomly selected RN_F.<br>
 * .
 */
class svt_chi_system_single_node_atomiccompare_transaction_virtual_sequence extends svt_chi_system_single_node_rn_atomic_transaction_base_virtual_sequence;

  constraint atomic_operation_type_c { selected_atomic_xact_type == svt_chi_common_transaction::ATOMICCOMPARE;}

  `svt_xvm_object_utils(svt_chi_system_single_node_atomiccompare_transaction_virtual_sequence)

  function new(string name = "svt_chi_system_single_node_atomiccompare_transaction_virtual_sequence");
    super.new(name);
  endfunction 

  virtual task pre_start();
    super.pre_start();
`ifdef SVT_UVM_TECHNOLOGY
    snoop_me_status = uvm_config_db#(int unsigned)::get(null, get_full_name(), "snoopme",snoop_me_config_db);
    endian_status = uvm_config_db#(svt_chi_common_transaction::endian_enum)::get(m_sequencer, get_type_name(), "endian", endian_config_db);
    atomic_compare_data_same_as_mem_data_status = uvm_config_db#(int unsigned)::get(null, get_full_name(), "atomic_compare_data_same_as_mem_data",atomic_compare_data_same_as_mem_data_config_db);
`elsif SVT_OVM_TECHNOLOGY
    snoop_me_status = m_sequencer.get_config_int({get_type_name(), ".snoopme"}, snoop_me_config_db);
    endian_status = m_sequencer.get_config_int({get_type_name(), ".endian"}, endian_config_db);
    atomic_compare_data_same_as_mem_data_status = m_sequencer.get_config_int({get_type_name(), ".atomic_compare_data_same_as_mem_data"}, atomic_compare_data_same_as_mem_data_config_db);
`endif

    `svt_xvm_debug("pre_start", $sformatf("snoop_me_config_db is %0d as a result of %0s.", snoop_me_config_db, snoop_me_status ? "config DB" : "default value"));
    `svt_xvm_debug("pre_start", $sformatf("atomic_compare_data_same_as_mem_data_config_db is %0d as a result of %0s.", atomic_compare_data_same_as_mem_data_config_db, atomic_compare_data_same_as_mem_data_status ?  "config DB" : "default value"));
    `svt_xvm_debug("pre_start", $sformatf("endian_config_db is %0s as a result of %0s.", endian_config_db.name(), endian_status ? "config DB" : "default value"));
  endtask

  /**
   * Initializes cachelines and sends WriteUniqueFull from node "node_index"
   */
  virtual task body();
    super.body();

    selected_atomic_xact_type = select_atomic_xact_type_config_db_status ? selected_atomic_xact_type_config_db : selected_atomic_xact_type;
  `svt_xvm_debug("body", $sformatf("selected_atomic_xact_type is %s as a result of %0s.", selected_atomic_xact_type.name(), select_atomic_xact_type_config_db_status ? "the config DB" : "randomization"));

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /**
     * If the selected node is RN-F/RN-I/RN-D node, do cache line initialization
     * In case of selected node is RN-I/RN-D, the cache initialization happens
     * from one of the peer RN-F nodes. 
     */
    send_coherent_transactions(selected_atomic_xact_type, 1);

    /** Wait for readshared transactions to finish */
    coherent_seq.wait_for_active_xacts_to_end();
    print_caches();
  endtask: body

  /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting Request Nodes = 1
   *  #- Valid Atomic operation type
   */
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    string str_is_supported_info_prefix = "";
    string str_is_supported_info_postfix = "";
    string str_is_supported_info = "";
    int num_supporting_rn_f_nodes;
    bit is_rn_idx_0_participating;
    string str_rn_f_node = "";
    int array_idx;
    string str_idx0_info = "";

    /** Supporting RN-F Nodes required */
    int required_num_supporting_rn_f_nodes = 1;
    bit supported_atomic_compare_xact = 0;
    `svt_xvm_debug("is_supported",$sformatf("Entering ..."));

    /** By default is_supported is 0 */
    is_supported = 0;

    /** Check for minimum required RN-F nodes.
     *  Also check whether the selected RN-F nodes are part of participating arrays or not.
     */ 
    num_supporting_rn_f_nodes = active_participating_rn_f_nodes.size();

    /** Check the requirements of RN-F nodes */  
    if (num_supporting_rn_f_nodes) begin
      /** Display the contents of Active Participating RN-F Nodes */
      foreach (active_participating_rn_f_nodes[j]) begin
        str_rn_f_node = {str_rn_f_node, $sformatf(" %0d", active_participating_rn_f_nodes[j])};
      end 
      `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_f_nodes are %0s", str_rn_f_node));
    end

    str_is_supported_info_prefix = $sformatf("Number of Supporting RN-F Node(s)  - Minimum Required : %0d Current : %0d", required_num_supporting_rn_f_nodes, num_supporting_rn_f_nodes);

    if ((initiating_rn_node_index_0_status==0)&&(valid_initiating_rn_f_node_index_0==0)) begin
        str_idx0_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN-Fs that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)";
    end
    else begin
      is_rn_idx_0_participating = is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_node_idx_0, array_idx);
      if (!is_rn_idx_0_participating) begin
        str_idx0_info = $sformatf("initiating_rn_node_idx_0 %0d is not valid for this sequence. The RN-F corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)", initiating_rn_node_idx_0, initiating_rn_node_idx_0);
      end
    end

    if (is_rn_idx_0_participating ) begin
      is_supported = 1;
    end

    str_is_supported_info_postfix = $sformatf("Atomic operation should be of type ATOMICCOMPARE");

    if(selected_atomic_xact_type == svt_chi_common_transaction::ATOMICCOMPARE) begin

      supported_atomic_compare_xact = 1;
    end
    else begin
      supported_atomic_compare_xact = 0;
    end 

    if (!is_supported) begin
      str_is_supported_info = $sformatf("%0s",str_idx0_info);
      issue_is_supported_failure($sformatf("This sequence cannot be run based on the current system configuration.\n\
                                            %0s \n\
                                            %0s \n\
                                            Modify configurations through \n\
                                            svt_chi_system_configuration::num_rn,\n\
                                            svt_chi_node_configuration::is_active,\n\
                                            svt_chi_system_configuration::participating_request_nodes\n\
                                            ", str_is_supported_info_prefix, str_is_supported_info));
    end  

    if (!supported_atomic_compare_xact) begin
      issue_is_supported_failure($sformatf("Invalid Atomic transaction type attempted.\n%0s \n",str_is_supported_info_postfix));
    end  

  endfunction

endclass

//====================================================================================
/** 
 * @groupname CHI_SINGLE_RN_ATOMICSTORE_TYPE  
 * #- This sequence requires one initiating active and participating RN-F.<br>
 * #- If one or more active and participating RN-F exists, perform cache<br>
 *    initialization to a randomly selected HN.<br>
 * #- Program the RN to initiate random Atomic transaction from randomly selected RN_F<br>
 *    with order_type set to REQ_ORDERING_REQUIRED.<br>
 * .
 */
class svt_chi_system_single_node_rn_atomic_transaction_ordering_virtual_sequence extends svt_chi_system_single_node_rn_coherent_transaction_base_virtual_sequence;

  rand svt_chi_common_transaction::xact_type_enum selected_atomic_xact_type;

  constraint atomic_operation_type_c {
     selected_atomic_xact_type inside {
            svt_chi_common_transaction::ATOMICSTORE_ADD,
            svt_chi_common_transaction::ATOMICSTORE_CLR,
            svt_chi_common_transaction::ATOMICSTORE_EOR,
            svt_chi_common_transaction::ATOMICSTORE_SET,
            svt_chi_common_transaction::ATOMICSTORE_SMAX,
            svt_chi_common_transaction::ATOMICSTORE_SMIN,
            svt_chi_common_transaction::ATOMICSTORE_UMAX,
            svt_chi_common_transaction::ATOMICSTORE_UMIN,
            svt_chi_common_transaction::ATOMICLOAD_ADD,
            svt_chi_common_transaction::ATOMICLOAD_CLR,
            svt_chi_common_transaction::ATOMICLOAD_EOR,
            svt_chi_common_transaction::ATOMICLOAD_SET,
            svt_chi_common_transaction::ATOMICLOAD_SMAX,
            svt_chi_common_transaction::ATOMICLOAD_SMIN,
            svt_chi_common_transaction::ATOMICLOAD_UMAX,
            svt_chi_common_transaction::ATOMICLOAD_UMIN,
            svt_chi_common_transaction::ATOMICSWAP,
            svt_chi_common_transaction::ATOMICCOMPARE
      };
  }

  `svt_xvm_object_utils(svt_chi_system_single_node_rn_atomic_transaction_ordering_virtual_sequence)

  function new(string name = "svt_chi_system_single_node_rn_atomic_transaction_ordering_virtual_sequence");
    super.new(name);
  endfunction  

  virtual task pre_start();
    bit status;
    super.pre_start();
    raise_phase_objection();
    `ifdef SVT_UVM_TECHNOLOGY
      snoop_me_status = uvm_config_db#(int unsigned)::get(null, get_full_name(), "snoopme",snoop_me_config_db);
      endian_status = uvm_config_db#(svt_chi_common_transaction::endian_enum)::get(m_sequencer, get_type_name(), "endian", endian_config_db);
    `elsif SVT_OVM_TECHNOLOGY
      snoop_me_status = m_sequencer.get_config_int({get_type_name(), ".snoopme"}, snoop_me_config_db);
      endian_status = m_sequencer.get_config_int({get_type_name(), ".endian"}, endian_config_db);
    `endif
    request_ordering = 1;
  endtask // pre_start

  /** Drop objection */
  virtual task post_start();
    super.post_start();
    drop_phase_objection();
  endtask: post_start

  virtual task body();
    super.body();

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /**
     * If the selected node is RN-F/RN-I/RN-D node, do cache line initialization
     * In case of selected node is RN-I/RN-D, the cache initialization happens
     * from one of the peer RN-F nodes. 
     */
    send_coherent_transactions(selected_atomic_xact_type, 1);

    /** Wait for readshared transactions to finish */
    coherent_seq.wait_for_active_xacts_to_end();
    print_caches();
  endtask

endclass

/**
 * @groupname CHI_SYS_HAZARD
 * Abstract:
 * svt_chi_system_protocol_flow_ctrl_hn_atomic_read_hazard_directed_virtual_sequence
 * provides a sequence to test how components handle various hazard conditions
 * applicable for atomic and read transactions
 * 1. Send MAKEUNIQUE transaction to random address from random RN
 * 2. Send atomic type of transaction to the same address from different RN
 * 3. Send read type of transaction to the same address from different RN
 * 4. Check the order in which the two requests are processed by HN.
 * .
 */
class svt_chi_system_protocol_flow_ctrl_hn_atomic_read_hazard_directed_virtual_sequence extends svt_chi_system_protocol_flow_ctrl_xact_hazard_virtual_sequence;

  /** Parameter that controls the number of transactions that will be generated */
  rand int unsigned sequence_length = 10;

  rand bit enable_outstanding = 0;

  bit enable_outstanding_status = 0;

  /** Constrain the sequence length to a reasonable value */
  constraint reasonable_sequence_length {
    sequence_length <= 100;
  }

  `svt_xvm_object_utils(svt_chi_system_protocol_flow_ctrl_hn_atomic_read_hazard_directed_virtual_sequence)

  function new(string name = "svt_chi_system_protocol_flow_ctrl_hn_atomic_read_hazard_directed_virtual_sequence");
    super.new(name);
  endfunction  

  virtual task pre_body();
    raise_phase_objection();
  endtask

  /** Drop objection */
  virtual task post_start();
    super.post_start();
    drop_phase_objection();
  endtask: post_start

  virtual task body();
    bit                           status;
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0] txn_address;
    bit [`SVT_CHI_MAX_DATA_WIDTH -1:0] txn_data;
    bit txn_mem_attr_allocate_hint, txn_snp_attr_snp_domain_type, txn_is_non_secure_access;

    /** Sub sequences initiated from this sequence */
    svt_chi_rn_atomic_type_transaction_directed_sequence atomic_type_seq_0[int];

    /** Sub sequences initiated from this sequence */
    svt_chi_rn_read_type_transaction_directed_sequence read_seq_0[int];
    /** Sub sequences initiated from this sequence */
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq;
    svt_chi_rn_copyback_type_transaction_directed_sequence copyback_seq;

    `uvm_info("body", "Entered ...", UVM_HIGH)
    super.body();
    // Default
    enable_outstanding = 0;
    status = uvm_config_db #(int unsigned)::get(null, get_full_name(), "sequence_length", sequence_length);
    `uvm_info("body", $sformatf("sequence_length is %0d as a result of %0s.", sequence_length, status ? "config DB" : "randomization"), UVM_HIGH);

    enable_outstanding_status = uvm_config_db#(bit)::get(m_sequencer, get_type_name(), "enable_outstanding", enable_outstanding);
    `uvm_info("body", $sformatf("enable_outstanding is %0b as a result of %0s", enable_outstanding, (enable_outstanding_status?"config DB":"default setting")), UVM_HIGH);

    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :initiating_rn_f_node_index_0;
    initiating_rn_node_idx_1 = initiating_rn_node_index_1_status ? initiating_rn_node_index_1_from_config_db :initiating_rn_f_node_index_1;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_f_node_index_0;

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /** 
     * If the number of active_participating_rn_f_nodes are greater than 2, then
     * we can initialize the cache/memory from the RN having node index 
     * initiating_rn_f_node_index_2.
     * If the number of active_participating_rn_f_nodes are equal to 2, then
     * we can initialize the cache/memory from the RN having node index 
     * initiating_rn_node_idx_0.
     *  
     */
    if((active_participating_rn_f_nodes.size()>2) && (valid_initiating_rn_f_node_index_2))begin
      cache_initializing_rn_node_index = initiating_rn_f_node_index_2;
      /**
       * If the cache_initializing_rn_node_index is same as any of the RN node indices 
       * which are passed through config i.e initiating_rn_node_idx_0,initiating_rn_node_idx_1,
       * then assert perform_initialization_from_rn_used_for_hazard to 1, so that RN will be
       * in valid state to initilize the respective transaction.
       */
      if(initiating_rn_node_index_0_status || initiating_rn_node_index_1_status)begin
         if((cache_initializing_rn_node_index == initiating_rn_node_idx_0)||(cache_initializing_rn_node_index == initiating_rn_node_idx_1))begin
           perform_initialization_from_rn_used_for_hazard =  1;
         end
         else begin
           perform_initialization_from_rn_used_for_hazard =  0;
         end  
      end  
    end else begin
      cache_initializing_rn_node_index = initiating_rn_node_idx_0;
      perform_initialization_from_rn_used_for_hazard =  1;
    end

    str_initiating_rn_node_indices = "";
    /** Display the contents of Active Participating RN-F Nodes */
    foreach (active_participating_rn_f_nodes[j]) begin
      str_initiating_rn_node_indices = {str_initiating_rn_node_indices, $sformatf(" %0d", active_participating_rn_f_nodes[j])};
    end 
    str_initiating_rn_node_indices = {str_initiating_rn_node_indices, $sformatf("\n RN nodes used to initiate the transactions are initiating_rn_node_idx_0 : %0d, initiating_rn_node_idx_1 : %0d,cache_initializing_rn_node_index : %0d ", initiating_rn_node_idx_0, initiating_rn_node_idx_1, cache_initializing_rn_node_index)};
    `svt_xvm_debug("body", $sformatf("contents of active_participating_rn_f_nodes and RN nodes used to initiate the transactions are %0s", str_initiating_rn_node_indices));

    for(int i = 0; i < sequence_length; i++) begin
      bit rn0_is_unique, rn0_is_clean, rn1_is_unique, rn1_is_clean, rn0_read_status, rn1_read_status;
      bit rn_cache_dirty_state,rn_cache_unique_state;

      /** Write data into Cache of Randomly selected first RN with address of randomly selected HN Node */
      `svt_xvm_do_on_with(makeunique_seq, p_sequencer.rn_virt_seqr[cache_initializing_rn_node_index].rn_xact_seqr,
      {
        sequence_length == 1;
        hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
        seq_hn_node_idx == target_hn_node_idx_0;
        use_seq_is_non_secure_access == 0;               
      })

      /** Wait for MakeUnique transactions to finish */ 
      makeunique_seq.write_tran.wait_end();
      txn_address = makeunique_seq.output_xacts[0].addr;
      txn_data = makeunique_seq.data_in_cache;
      txn_mem_attr_allocate_hint = makeunique_seq.output_xacts[0].mem_attr_allocate_hint;
      txn_snp_attr_snp_domain_type = makeunique_seq.output_xacts[0].snp_attr_snp_domain_type;
      txn_is_non_secure_access = makeunique_seq.output_xacts[0].is_non_secure_access;

      /** Writeback the data to the main memory at the respective address. */ 
      if(perform_initialization_from_rn_used_for_hazard) begin
        `svt_xvm_do_on_with(copyback_seq, p_sequencer.rn_virt_seqr[cache_initializing_rn_node_index].rn_xact_seqr,
        {
          sequence_length == 1;
          data_in_cache == txn_data;
          seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
          hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
          min_addr == txn_address;
          max_addr == txn_address;
          seq_xact_type == svt_chi_transaction::WRITEBACKFULL;
          seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
          seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
          seq_is_non_secure_access == txn_is_non_secure_access;
          use_seq_is_non_secure_access == 1;               
        }
        )
        /** Waiting for copyback transaction to complete */ 
        copyback_seq.copyback_tran.wait_end();
      end 

      /* ATOMIC-READ hazard at HN **/
      fork 
        begin      
`ifndef SVT_CHI_ENABLE_MULTI_CLOCK
          @ (posedge sys_cfg.chi_if.clk);
`else
          @ (posedge sys_cfg.chi_if.rn_clk[initiating_rn_node_idx_0]);
`endif          
          xact_hazard_sema_0.get();
          /** Randomly selected first RN-F fires a Atomic transaction with MAKEUNIQUE 
           *  transaction address of randomly selected HN Node.
           */
          `svt_xvm_do_on_with(atomic_type_seq_0[i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
          {
            sequence_length == 1;
            data_in_cache == txn_data;
            seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
            hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
            min_addr == txn_address;
            max_addr == txn_address;
            seq_is_non_secure_access == txn_is_non_secure_access;
            use_seq_is_non_secure_access == 1;          
          }
          )
          /** Waiting for Atomic type transaction to complete */ 
          atomic_type_seq_0[i].atomic_tran.wait_end();
          xact_hazard_sema_0.put();
        end
        begin
`ifndef SVT_CHI_ENABLE_MULTI_CLOCK
          @ (posedge sys_cfg.chi_if.clk);
`else
          @ (posedge sys_cfg.chi_if.rn_clk[initiating_rn_node_idx_1]);
`endif          
          xact_hazard_sema_1.get();
          /** Randomly selected second RN-F fires a read transaction with MAKEUNIQUE 
           *  transaction address of randomly selected HN Node.
           */
          `svt_xvm_do_on_with(read_seq_0[i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,
          {
            sequence_length == 1;
            data_in_cache == txn_data;
            seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
            hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
            min_addr == txn_address;
            max_addr == txn_address;
            by_pass_read_data_check == 1;
            seq_xact_type != svt_chi_transaction::READNOSNP;
            seq_xact_type != svt_chi_transaction::CLEANUNIQUE;
            seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
            seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
            seq_is_non_secure_access == txn_is_non_secure_access;
            use_seq_is_non_secure_access == 1;               
            `ifdef SVT_CHI_ISSUE_B_ENABLE
              if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type != svt_chi_transaction::READNOTSHAREDDIRTY;
              if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision == svt_chi_node_configuration::ISSUE_A || sys_cfg.readspec_enable == 0) seq_xact_type != svt_chi_transaction::READSPEC;
              if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type != svt_chi_transaction::READONCECLEANINVALID;
              if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type != svt_chi_transaction::READONCEMAKEINVALID;
            `endif
            `ifdef SVT_CHI_ISSUE_E_ENABLE
              if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision <= svt_chi_node_configuration::ISSUE_D) seq_xact_type != svt_chi_transaction::READPREFERUNIQUE;
            `endif
          }
          )
          xact_hazard_sema_1.put();
          /** Waiting for Read type transaction to complete */ 
          read_seq_0[i].read_tran.wait_end(); 
        end
      join

    end
  endtask

endclass

/**
 * @groupname CHI_SYS_HAZARD
 * Abstract:
 * svt_chi_system_protocol_flow_ctrl_hn_atomic_copyback_hazard_directed_virtual_sequence
 * provides a sequence to test how components handle various hazard conditions
 * applicable for atomic and copyback transactions
 * 1. Initialize the cacheline using MAKEUNIQUE transaction from RN
 * 2. Send atomic type of transaction to the same address from different RN.
 * 3. Send Copyback type of transaction to the same address from same RN
 * from which the MAKEUNIQUE transaction initiated.
 * 4. Check the order in which the two requests are processed by HN.
 * .
 */

class svt_chi_system_protocol_flow_ctrl_hn_atomic_copyback_hazard_directed_virtual_sequence extends svt_chi_system_protocol_flow_ctrl_xact_hazard_virtual_sequence;

  /** Parameter that controls the number of transactions that will be generated */
  rand int unsigned sequence_length = 10;

  rand bit enable_outstanding = 0;

  bit enable_outstanding_status = 0;

  /** Constrain the sequence length to a reasonable value */
  constraint reasonable_sequence_length {
    sequence_length <= 100;
  }

  /** UVM Object Utility macro */
  `svt_xvm_object_utils(svt_chi_system_protocol_flow_ctrl_hn_atomic_copyback_hazard_directed_virtual_sequence)

  extern function new(string name="svt_chi_system_protocol_flow_ctrl_hn_atomic_copyback_hazard_directed_virtual_sequence"); 

  virtual task pre_body();
    raise_phase_objection();
  endtask
  
  virtual task body();
    bit                           status;
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0] txn_address;
    bit [`SVT_CHI_MAX_DATA_WIDTH -1:0] txn_data;
    bit txn_mem_attr_allocate_hint, txn_snp_attr_snp_domain_type, txn_is_non_secure_access;

    event copyback_txn_initiated;
    /** Sub sequences initiated from this sequence */
    svt_chi_rn_atomic_type_transaction_directed_sequence atomic_type_seq_0[int];
    svt_chi_rn_copyback_type_transaction_directed_sequence copyback_seq[int];
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq;

    `uvm_info("body", "Entered ...", UVM_HIGH)

    super.body(); 
    // Default
    enable_outstanding = 0;
    status = uvm_config_db #(int unsigned)::get(null, get_full_name(), "sequence_length", sequence_length);
    `uvm_info("body", $sformatf("sequence_length is %0d as a result of %0s.", sequence_length, status ? "config DB" : "randomization"), UVM_HIGH);

    enable_outstanding_status = uvm_config_db#(bit)::get(m_sequencer, get_type_name(), "enable_outstanding", enable_outstanding);
    `uvm_info("body", $sformatf("enable_outstanding is %0b as a result of %0s", enable_outstanding, (enable_outstanding_status?"config DB":"default setting")), UVM_HIGH);

    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :initiating_rn_f_node_index_0;
    initiating_rn_node_idx_1 = initiating_rn_node_index_1_status ? initiating_rn_node_index_1_from_config_db :initiating_rn_f_node_index_1;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_f_node_index_0;

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    str_initiating_rn_node_indices = "";
    /** Display the contents of Active Participating RN-F Nodes */
    foreach (active_participating_rn_f_nodes[j]) begin
      str_initiating_rn_node_indices = {str_initiating_rn_node_indices, $sformatf(" %0d", active_participating_rn_f_nodes[j])};
    end 
    str_initiating_rn_node_indices = {str_initiating_rn_node_indices, $sformatf("\n RN nodes used to initiate the transactions are initiating_rn_node_idx_0 : %0d, initiating_rn_node_idx_1 : %0d", initiating_rn_node_idx_0, initiating_rn_node_idx_1)};
    `svt_xvm_debug("body", $sformatf("contents of active_participating_rn_f_nodes and RN nodes used to initiate the transactions are %0s", str_initiating_rn_node_indices));

    for(int i = 0; i < sequence_length; i++) begin
      bit rn0_is_unique, rn0_is_clean, rn1_is_unique, rn1_is_clean, rn0_read_status, rn1_read_status;
      bit rn_cache_dirty_state,rn_cache_unique_state;

      /** Write data into Cache of Randomly selected first RN with address of randomly selected HN Node */
      `svt_xvm_do_on_with(makeunique_seq, p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,
      {
        sequence_length == 1;
        hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
        seq_hn_node_idx == target_hn_node_idx_0;
        use_seq_is_non_secure_access == 0;
      })

      /** Wait for MakeUnique transactions to finish */ 
      makeunique_seq.write_tran.wait_end();
      txn_address = makeunique_seq.output_xacts[0].addr;
      txn_data = makeunique_seq.data_in_cache;
      txn_mem_attr_allocate_hint = makeunique_seq.output_xacts[0].mem_attr_allocate_hint;
      txn_snp_attr_snp_domain_type = makeunique_seq.output_xacts[0].snp_attr_snp_domain_type;
      txn_is_non_secure_access = makeunique_seq.output_xacts[0].is_non_secure_access;

      /* ATOMIC-COPYBACK hazard at HN **/
      fork 
        begin      
`ifndef SVT_CHI_ENABLE_MULTI_CLOCK
          @ (posedge sys_cfg.chi_if.clk);
`else
          @ (posedge sys_cfg.chi_if.rn_clk[initiating_rn_node_idx_0]);
`endif          
          xact_hazard_sema_0.get();

          /** Randomly selected first RN-F fires a Atomic transaction with MAKEUNIQUE 
           *  transaction address of randomly selected HN Node.
           */
          `svt_xvm_do_on_with(atomic_type_seq_0[i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
          {
            sequence_length == 1;
            data_in_cache == txn_data;
            seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
            hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
            min_addr == txn_address;
            max_addr == txn_address;
            seq_is_non_secure_access == txn_is_non_secure_access;
            use_seq_is_non_secure_access == 1;               
       
          }
          )
          /** Waiting for Atomic type transaction to complete */ 
          atomic_type_seq_0[i].atomic_tran.wait_end();
          xact_hazard_sema_0.put();
        end
        begin
`ifndef SVT_CHI_ENABLE_MULTI_CLOCK
          @ (posedge sys_cfg.chi_if.clk);
`else
          @ (posedge sys_cfg.chi_if.rn_clk[initiating_rn_node_idx_1]);
`endif          
          xact_hazard_sema_1.get();
          /** Initiate a Copyback type transaction from initiating_rn_node_idx_1 to txn_address. */
          `svt_xvm_do_on_with(copyback_seq[i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,
          {
            sequence_length == 1;
            seq_xact_type == svt_chi_transaction::WRITEBACKFULL;
            seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
            seq_copyback_req_order_enable == 0;                        
            hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
            min_addr == txn_address;
            max_addr == txn_address;
            seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
            seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
            seq_is_non_secure_access == txn_is_non_secure_access;
            use_seq_is_non_secure_access == 1;                      
          }
          )
          xact_hazard_sema_1.put();
          /** Waiting for copyback transaction to complete */ 
          copyback_seq[i].copyback_tran.wait_end(); 
        end
      join
    end

    `uvm_info("body", "Exiting...", UVM_HIGH)
  endtask: body

  virtual task post_body();
    drop_phase_objection();
  endtask

endclass: svt_chi_system_protocol_flow_ctrl_hn_atomic_copyback_hazard_directed_virtual_sequence

function svt_chi_system_protocol_flow_ctrl_hn_atomic_copyback_hazard_directed_virtual_sequence::new(string name="svt_chi_system_protocol_flow_ctrl_hn_atomic_copyback_hazard_directed_virtual_sequence");
  super.new(name);
endfunction

/**
 * @groupname CHI_SYS_HAZARD
 * Abstract:
 * svt_chi_system_protocol_flow_ctrl_hn_atomic_write_hazard_directed_virtual_sequence
 * provides a sequence to test how components handle various hazard conditions
 * applicable for atomic and write transactions
 * 1. Send MAKEUNIQUE transaction to random address from random RN
 * 2. Send atomic type of transaction to the same address from different RN
 * 3. Send write type of transaction to the same address from different RN
 * 4. Check the order in which the two requests are processed by HN.
 * .
 */

class svt_chi_system_protocol_flow_ctrl_hn_atomic_write_hazard_directed_virtual_sequence extends svt_chi_system_protocol_flow_ctrl_xact_hazard_virtual_sequence;

  /** Parameter that controls the number of transactions that will be generated */
  rand int unsigned sequence_length = 10;

  rand bit enable_outstanding = 0;

  bit enable_outstanding_status = 0;

  /** Constrain the sequence length to a reasonable value */
  constraint reasonable_sequence_length {
    sequence_length <= 100;
  }

  `svt_xvm_object_utils(svt_chi_system_protocol_flow_ctrl_hn_atomic_write_hazard_directed_virtual_sequence)

  function new(string name = "svt_chi_system_protocol_flow_ctrl_hn_atomic_write_hazard_directed_virtual_sequence");
    super.new(name);
  endfunction  

  virtual task pre_body();
    raise_phase_objection();
  endtask
  
  virtual task body();
    bit                           status;
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0] txn_address;
    bit [`SVT_CHI_MAX_DATA_WIDTH -1:0] txn_data;
    bit txn_mem_attr_allocate_hint, txn_snp_attr_snp_domain_type, txn_is_non_secure_access;

    /** Sub sequences initiated from this sequence */
    svt_chi_rn_atomic_type_transaction_directed_sequence atomic_type_seq_0[int];
    svt_chi_rn_write_type_transaction_directed_sequence write_seq_0[int];
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq;
    svt_chi_rn_copyback_type_transaction_directed_sequence copyback_seq;

    `uvm_info("body", "Entered ...", UVM_HIGH)

    super.body();
    // Default
    enable_outstanding = 0;
    status = uvm_config_db #(int unsigned)::get(null, get_full_name(), "sequence_length", sequence_length);
    `uvm_info("body", $sformatf("sequence_length is %0d as a result of %0s.", sequence_length, status ? "config DB" : "randomization"), UVM_HIGH);

    enable_outstanding_status = uvm_config_db#(bit)::get(m_sequencer, get_type_name(), "enable_outstanding", enable_outstanding);
    `uvm_info("body", $sformatf("enable_outstanding is %0b as a result of %0s", enable_outstanding, (enable_outstanding_status?"config DB":"default setting")), UVM_HIGH);

    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :initiating_rn_f_node_index_0;
    initiating_rn_node_idx_1 = initiating_rn_node_index_1_status ? initiating_rn_node_index_1_from_config_db :initiating_rn_f_node_index_1;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_f_node_index_0;

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /** 
     * If the number of active_participating_rn_f_nodes are greater than 2, then
     * we can initialize the cache/memory from the RN having node index 
     * initiating_rn_f_node_index_2.
     * If the number of active_participating_rn_f_nodes are equal to 2, then
     * we can initialize the cache/memory from the RN having node index 
     * initiating_rn_node_idx_0.
     *  
     */
    if((active_participating_rn_f_nodes.size()>2) && (valid_initiating_rn_f_node_index_2))begin
      cache_initializing_rn_node_index = initiating_rn_f_node_index_2;
      /**
       * If the cache_initializing_rn_node_index is same as any of the RN node indices 
       * which are passed through config i.e initiating_rn_node_idx_0,initiating_rn_node_idx_1,
       * then assert perform_initialization_from_rn_used_for_hazard to 1, so that RN will be
       * in valid state to initilize the respective transaction.
       */
      if(initiating_rn_node_index_0_status || initiating_rn_node_index_1_status)begin
         if((cache_initializing_rn_node_index == initiating_rn_node_idx_0)||(cache_initializing_rn_node_index == initiating_rn_node_idx_1))begin
           perform_initialization_from_rn_used_for_hazard =  1;
         end
         else begin
           perform_initialization_from_rn_used_for_hazard =  0;
         end  
      end  
    end else begin
      cache_initializing_rn_node_index = initiating_rn_node_idx_0;
      perform_initialization_from_rn_used_for_hazard =  1;
    end

    str_initiating_rn_node_indices = "";
    /** Display the contents of Active Participating RN-F Nodes */
    foreach (active_participating_rn_f_nodes[j]) begin
      str_initiating_rn_node_indices = {str_initiating_rn_node_indices, $sformatf(" %0d", active_participating_rn_f_nodes[j])};
    end 
    str_initiating_rn_node_indices = {str_initiating_rn_node_indices, $sformatf("\n RN nodes used to initiate the transactions are initiating_rn_node_idx_0 : %0d, initiating_rn_node_idx_1 : %0d,cache_initializing_rn_node_index : %0d ", initiating_rn_node_idx_0, initiating_rn_node_idx_1, cache_initializing_rn_node_index)};
    `svt_xvm_debug("body", $sformatf("contents of active_participating_rn_f_nodes and RN nodes used to initiate the transactions are %0s", str_initiating_rn_node_indices));

    for(int i = 0; i < sequence_length; i++) begin
      bit rn0_is_unique, rn0_is_clean, rn1_is_unique, rn1_is_clean, rn0_read_status, rn1_read_status;
      bit rn_cache_dirty_state,rn_cache_unique_state;

      /** Write data into Cache of Randomly selected first RN with address of randomly selected HN Node */
      `svt_xvm_do_on_with(makeunique_seq, p_sequencer.rn_virt_seqr[cache_initializing_rn_node_index].rn_xact_seqr,
      {
        sequence_length == 1;
        hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
        seq_hn_node_idx == target_hn_node_idx_0;
        use_seq_is_non_secure_access == 0;
      })

      /** Wait for MakeUnique transactions to finish */ 
      makeunique_seq.write_tran.wait_end();
      txn_address = makeunique_seq.output_xacts[0].addr;
      txn_data = makeunique_seq.data_in_cache;
      txn_mem_attr_allocate_hint = makeunique_seq.output_xacts[0].mem_attr_allocate_hint;
      txn_snp_attr_snp_domain_type = makeunique_seq.output_xacts[0].snp_attr_snp_domain_type;
      txn_is_non_secure_access = makeunique_seq.output_xacts[0].is_non_secure_access;

      /** Writeback the data to the main memory at the respective address. */ 
      if(perform_initialization_from_rn_used_for_hazard) begin
        `svt_xvm_do_on_with(copyback_seq, p_sequencer.rn_virt_seqr[cache_initializing_rn_node_index].rn_xact_seqr,
        {
          sequence_length == 1;
          data_in_cache == txn_data;
          seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
          hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
          min_addr == txn_address;
          max_addr == txn_address;
          seq_xact_type == svt_chi_transaction::WRITEBACKFULL;
          seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
          seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
          seq_is_non_secure_access == txn_is_non_secure_access;
          use_seq_is_non_secure_access == 1;                      
        }
        )
        /** Waiting for copyback transaction to complete */ 
        copyback_seq.copyback_tran.wait_end();
      end 

      /* ATOMIC-WRITE hazard at HN **/
      fork 
        begin      
`ifndef SVT_CHI_ENABLE_MULTI_CLOCK
          @ (posedge sys_cfg.chi_if.clk);
`else
          @ (posedge sys_cfg.chi_if.rn_clk[initiating_rn_node_idx_0]);
`endif          
          xact_hazard_sema_0.get();
          /** Randomly selected first RN-F fires a Atomic transaction with MAKEUNIQUE 
           *  transaction address of randomly selected HN Node.
           */
          `svt_xvm_do_on_with(atomic_type_seq_0[i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
          {
            sequence_length == 1;
            data_in_cache == txn_data;
            seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
            hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
            min_addr == txn_address;
            max_addr == txn_address;
            seq_is_non_secure_access == txn_is_non_secure_access;
            use_seq_is_non_secure_access == 1;                      
       
          }
          )
          xact_hazard_sema_0.put();
          /** Waiting for Atomic type transaction to complete */ 
          atomic_type_seq_0[i].atomic_tran.wait_end();
        end
        begin
`ifndef SVT_CHI_ENABLE_MULTI_CLOCK
          @ (posedge sys_cfg.chi_if.clk);
`else
          @ (posedge sys_cfg.chi_if.rn_clk[initiating_rn_node_idx_1]);
`endif          
          xact_hazard_sema_1.get();
          /** Initiate a write type transaction from initiating_rn_node_idx_1 to txn_address. */ 
          `svt_xvm_do_on_with(write_seq_0[i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,
            {
            `ifdef SVT_CHI_ISSUE_B_ENABLE
             if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision == svt_chi_node_configuration::ISSUE_A || sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 0) {
               seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL};
             }
             else{
               seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL, svt_chi_transaction::WRITEUNIQUEFULLSTASH, svt_chi_transaction::WRITEUNIQUEPTLSTASH};
             }
            `else
               seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL};
            `endif
             sequence_length               == 1;
             seq_order_type   != svt_chi_transaction::NO_ORDERING_REQUIRED;
             hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
             min_addr          == txn_address;
             max_addr          == txn_address;
             seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
             seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
             seq_is_non_secure_access == txn_is_non_secure_access;
             use_seq_is_non_secure_access == 1;                      
            }
          )
          xact_hazard_sema_1.put();
          /** Wait for write type transactions to finish */ 
          write_seq_0[i].write_tran.wait_end();
        end
      join
    end

    `uvm_info("body", "Exiting...", UVM_HIGH)
  endtask: body

  virtual task post_body();
    drop_phase_objection();
  endtask

endclass: svt_chi_system_protocol_flow_ctrl_hn_atomic_write_hazard_directed_virtual_sequence

/**
 * @groupname CHI_SYS_HAZARD
 * Abstract:
 * svt_chi_system_protocol_flow_ctrl_hn_atomic_atomic_hazard_directed_virtual_sequence
 * provides a sequence to test how components handle various hazard conditions
 * applicable for atomic transactions
 * 1. Send MAKEUNIQUE transaction to random address from random RN
 * 2. Send atomic type of transactions to the above same address from two different RN's.
 * 3. Check the order in which the two requests are processed by HN.
 * .
 */
class svt_chi_system_protocol_flow_ctrl_hn_atomic_atomic_hazard_directed_virtual_sequence extends svt_chi_system_protocol_flow_ctrl_xact_hazard_virtual_sequence;

  /** Parameter that controls the number of transactions that will be generated */
  rand int unsigned sequence_length = 10;
  rand bit enable_outstanding = 0;
  bit enable_outstanding_status = 0;

  /** Constrain the sequence length to a reasonable value */
  constraint reasonable_sequence_length {
    sequence_length <= 100;
  }

  /** UVM Object Utility macro */
  `uvm_object_utils(svt_chi_system_protocol_flow_ctrl_hn_atomic_atomic_hazard_directed_virtual_sequence)

  extern function new(string name="svt_chi_system_protocol_flow_ctrl_hn_atomic_atomic_hazard_directed_virtual_sequence"); 

  virtual task pre_body();
    raise_phase_objection();
  endtask

  virtual task body();
    bit status;
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0] txn_address;
    bit [`SVT_CHI_MAX_DATA_WIDTH -1:0] txn_data;
    bit txn_mem_attr_allocate_hint, txn_snp_attr_is_snoopable, txn_snp_attr_snp_domain_type, txn_is_non_secure_access;

    /** Sub sequences initiated from this sequence */
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq;
    svt_chi_rn_copyback_type_transaction_directed_sequence copyback_seq;

    /** Sub CMO type transaction directed sequences initiated from this sequence */
    svt_chi_rn_atomic_type_transaction_directed_sequence atomic_type_seq_0[int],atomic_type_seq_1[int];

    `uvm_info("body", "Entered ...", UVM_HIGH)

    super.body();
    // Default
    enable_outstanding = 0;
    status = uvm_config_db #(int unsigned)::get(null, get_full_name(), "sequence_length", sequence_length);
    `uvm_info("body", $sformatf("sequence_length is %0d as a result of %0s.", sequence_length, status ? "config DB" : "randomization"), UVM_HIGH);

    enable_outstanding_status = uvm_config_db#(bit)::get(m_sequencer, get_type_name(), "enable_outstanding", enable_outstanding);
    `uvm_info("body", $sformatf("enable_outstanding is %0b as a result of %0s", enable_outstanding, (enable_outstanding_status?"config DB":"default setting")), UVM_HIGH);

    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :initiating_rn_f_node_index_0;
    initiating_rn_node_idx_1 = initiating_rn_node_index_1_status ? initiating_rn_node_index_1_from_config_db :initiating_rn_f_node_index_1;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_f_node_index_0;

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /** 
     * If the number of active_participating_rn_f_nodes are greater than 2, then
     * we can initialize the cache/memory from the RN having node index 
     * initiating_rn_f_node_index_2.
     * If the number of active_participating_rn_f_nodes are equal to 2, then
     * we can initialize the cache/memory from the RN having node index 
     * initiating_rn_node_idx_0.
     *  
     */
    if((active_participating_rn_f_nodes.size()>2) && (valid_initiating_rn_f_node_index_2))begin
      cache_initializing_rn_node_index = initiating_rn_f_node_index_2;
      /**
       * If the cache_initializing_rn_node_index is same as any of the RN node indices 
       * which are passed through config i.e initiating_rn_node_idx_0,initiating_rn_node_idx_1,
       * then assert perform_initialization_from_rn_used_for_hazard to 1, so that RN will be
       * in valid state to initilize the respective transaction.
       */
      if(initiating_rn_node_index_0_status || initiating_rn_node_index_1_status)begin
         if((cache_initializing_rn_node_index == initiating_rn_node_idx_0)||(cache_initializing_rn_node_index == initiating_rn_node_idx_1))begin
           perform_initialization_from_rn_used_for_hazard =  1;
         end
         else begin
           perform_initialization_from_rn_used_for_hazard =  0;
         end  
      end  
    end else begin
      cache_initializing_rn_node_index = initiating_rn_node_idx_0;
      perform_initialization_from_rn_used_for_hazard =  1;
    end

    str_initiating_rn_node_indices = "";
    /** Display the contents of Active Participating RN-F Nodes */
    foreach (active_participating_rn_f_nodes[j]) begin
      str_initiating_rn_node_indices = {str_initiating_rn_node_indices, $sformatf(" %0d", active_participating_rn_f_nodes[j])};
    end 
    str_initiating_rn_node_indices = {str_initiating_rn_node_indices, $sformatf("\n RN nodes used to initiate the transactions are initiating_rn_node_idx_0 : %0d, initiating_rn_node_idx_1 : %0d,cache_initializing_rn_node_index : %0d ", initiating_rn_node_idx_0, initiating_rn_node_idx_1, cache_initializing_rn_node_index)};
    `svt_xvm_debug("body", $sformatf("contents of active_participating_rn_f_nodes and RN nodes used to initiate the transactions are %0s", str_initiating_rn_node_indices));

    for(int i = 0; i < sequence_length; i++) begin

      /** Initiate MAKEUNIQUE transaction from cache_initializing_rn_node_index to randomly selected HN Node. */ 
      `svt_xvm_do_on_with(makeunique_seq, p_sequencer.rn_virt_seqr[cache_initializing_rn_node_index].rn_xact_seqr,
      {
        sequence_length == 1;
        hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
        seq_hn_node_idx == target_hn_node_idx_0;
        use_seq_is_non_secure_access == 0;
      })

      /** Wait for MakeUnique transactions to finish */ 
      makeunique_seq.write_tran.wait_end();
      txn_address = makeunique_seq.output_xacts[0].addr;
      txn_data = makeunique_seq.data_in_cache;
      txn_mem_attr_allocate_hint = makeunique_seq.output_xacts[0].mem_attr_allocate_hint;
      txn_snp_attr_is_snoopable = makeunique_seq.output_xacts[0].snp_attr_is_snoopable;
      txn_snp_attr_snp_domain_type = makeunique_seq.output_xacts[0].snp_attr_snp_domain_type;
      txn_is_non_secure_access = makeunique_seq.output_xacts[0].is_non_secure_access;

      /** Writeback the data to the main memory at the respective address. */ 
      if(perform_initialization_from_rn_used_for_hazard) begin
        `svt_xvm_do_on_with(copyback_seq, p_sequencer.rn_virt_seqr[cache_initializing_rn_node_index].rn_xact_seqr,
        {
          sequence_length == 1;
          data_in_cache == txn_data;
          seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
          hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
          min_addr == txn_address;
          max_addr == txn_address;
          seq_xact_type == svt_chi_transaction::WRITEBACKFULL;
          seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
          seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
          seq_is_non_secure_access == txn_is_non_secure_access;
          use_seq_is_non_secure_access == 1;                      
        }
        )
        /** Waiting for copyback transaction to complete */ 
        copyback_seq.copyback_tran.wait_end();
      end 

      /* ATOMIC-ATOMIC hazard at HN **/
      fork 
        begin      
`ifndef SVT_CHI_ENABLE_MULTI_CLOCK
          @ (posedge sys_cfg.chi_if.clk);
`else
          @ (posedge sys_cfg.chi_if.rn_clk[initiating_rn_node_idx_0]);
`endif          
          xact_hazard_sema_0.get();
          /** Randomly selected first RN-F fires a Atomic transaction with MAKEUNIQUE 
           *  transaction address of randomly selected HN Node.
           */
          `svt_xvm_do_on_with(atomic_type_seq_0[i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
          {
            sequence_length == 1;
            data_in_cache == txn_data;
            seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
            hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
            min_addr == txn_address;
            max_addr == txn_address;
            seq_is_non_secure_access == txn_is_non_secure_access;
            use_seq_is_non_secure_access == 1;               
       
          }
          )
          xact_hazard_sema_0.put();
          /** Waiting for Atomic type transaction to complete */ 
          atomic_type_seq_0[i].atomic_tran.wait_end();
        end
        begin
`ifndef SVT_CHI_ENABLE_MULTI_CLOCK
          @ (posedge sys_cfg.chi_if.clk);
`else
          @ (posedge sys_cfg.chi_if.rn_clk[initiating_rn_node_idx_1]);
`endif        
          xact_hazard_sema_1.get();
          /** Initiate Atomic type of transaction from initiating_rn_node_idx_1 to txn_address. */ 
          `svt_xvm_do_on_with(atomic_type_seq_1[i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,
          {
            sequence_length == 1;
            data_in_cache == txn_data;
            seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
            hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
            min_addr == txn_address;
            max_addr == txn_address;
            seq_is_non_secure_access == txn_is_non_secure_access;
            use_seq_is_non_secure_access == 1;               

          }
          )

          xact_hazard_sema_1.put();
          /** Waiting for Atomic type transaction to complete */ 
          atomic_type_seq_1[i].atomic_tran.wait_end(); 
        end
      join
    end

    `uvm_info("body", "Exiting...", UVM_HIGH)
  endtask: body

  virtual task post_body();
    drop_phase_objection();
  endtask

endclass: svt_chi_system_protocol_flow_ctrl_hn_atomic_atomic_hazard_directed_virtual_sequence

function svt_chi_system_protocol_flow_ctrl_hn_atomic_atomic_hazard_directed_virtual_sequence::new(string name="svt_chi_system_protocol_flow_ctrl_hn_atomic_atomic_hazard_directed_virtual_sequence");
  super.new(name);
endfunction

/**
 * @groupname CHI_SYS_HAZARD
 * Abstract:
 * svt_chi_system_protocol_flow_ctrl_hn_atomic_cmo_hazard_directed_virtual_sequence
 * provides a sequence to test how components handle various hazard conditions
 * applicable for atomic and cmo transactions
 * 1. Send MAKEUNIQUE transaction to random address from random RN
 * 2. Send atomic type of transaction to the same address from different RN
 * 3. Send cmo type of transaction to the same address from different RN
 * 4. Check the order in which the two requests are processed by HN.
 * .
 */
class svt_chi_system_protocol_flow_ctrl_hn_atomic_cmo_hazard_directed_virtual_sequence extends svt_chi_system_protocol_flow_ctrl_xact_hazard_virtual_sequence;

  /** Parameter that controls the number of transactions that will be generated */
  rand int unsigned sequence_length = 10;
  rand bit enable_outstanding = 0;
  bit enable_outstanding_status = 0;

  /** Constrain the sequence length to a reasonable value */
  constraint reasonable_sequence_length {
    sequence_length <= 100;
  }

  /** UVM Object Utility macro */
  `uvm_object_utils(svt_chi_system_protocol_flow_ctrl_hn_atomic_cmo_hazard_directed_virtual_sequence)

  extern function new(string name="svt_chi_system_protocol_flow_ctrl_hn_atomic_cmo_hazard_directed_virtual_sequence"); 

  virtual task pre_body();
    raise_phase_objection();
  endtask

  virtual task body();
    bit status;
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0] txn_address;
    bit [`SVT_CHI_MAX_DATA_WIDTH -1:0] txn_data;
    bit txn_mem_attr_allocate_hint, txn_snp_attr_is_snoopable, txn_snp_attr_snp_domain_type, txn_is_non_secure_access;

    /** Sub sequences initiated from this sequence */
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq;
    svt_chi_rn_copyback_type_transaction_directed_sequence copyback_seq;

    /** Sub CMO type transaction directed sequences initiated from this sequence */
    svt_chi_rn_cmo_type_transaction_directed_sequence cmo_seq_0[int];
    svt_chi_rn_atomic_type_transaction_directed_sequence atomic_type_seq_0[int];

    `uvm_info("body", "Entered ...", UVM_HIGH)

    super.body();
    // Default
    enable_outstanding = 0;
    status = uvm_config_db #(int unsigned)::get(null, get_full_name(), "sequence_length", sequence_length);
    `uvm_info("body", $sformatf("sequence_length is %0d as a result of %0s.", sequence_length, status ? "config DB" : "randomization"), UVM_HIGH);

    enable_outstanding_status = uvm_config_db#(bit)::get(m_sequencer, get_type_name(), "enable_outstanding", enable_outstanding);
    `uvm_info("body", $sformatf("enable_outstanding is %0b as a result of %0s", enable_outstanding, (enable_outstanding_status?"config DB":"default setting")), UVM_HIGH);

    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :initiating_rn_f_node_index_0;
    initiating_rn_node_idx_1 = initiating_rn_node_index_1_status ? initiating_rn_node_index_1_from_config_db :initiating_rn_f_node_index_1;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_f_node_index_0;

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /** 
     * If the number of active_participating_rn_f_nodes are greater than 2, then
     * we can initialize the cache/memory from the RN having node index 
     * initiating_rn_f_node_index_2.
     * If the number of active_participating_rn_f_nodes are equal to 2, then
     * we can initialize the cache/memory from the RN having node index 
     * initiating_rn_node_idx_0.
     *  
     */
    if((active_participating_rn_f_nodes.size()>2) && (valid_initiating_rn_f_node_index_2))begin
      cache_initializing_rn_node_index = initiating_rn_f_node_index_2;
      /**
       * If the cache_initializing_rn_node_index is same as any of the RN node indices 
       * which are passed through config i.e initiating_rn_node_idx_0,initiating_rn_node_idx_1,
       * then assert perform_initialization_from_rn_used_for_hazard to 1, so that RN will be
       * in valid state to initilize the respective transaction.
       */
      if(initiating_rn_node_index_0_status || initiating_rn_node_index_1_status)begin
         if((cache_initializing_rn_node_index == initiating_rn_node_idx_0)||(cache_initializing_rn_node_index == initiating_rn_node_idx_1))begin
           perform_initialization_from_rn_used_for_hazard =  1;
         end
         else begin
           perform_initialization_from_rn_used_for_hazard =  0;
         end  
      end  
    end else begin
      cache_initializing_rn_node_index = initiating_rn_node_idx_0;
      perform_initialization_from_rn_used_for_hazard =  1;
    end

    str_initiating_rn_node_indices = "";
    /** Display the contents of Active Participating RN-F Nodes */
    foreach (active_participating_rn_f_nodes[j]) begin
      str_initiating_rn_node_indices = {str_initiating_rn_node_indices, $sformatf(" %0d", active_participating_rn_f_nodes[j])};
    end 
    str_initiating_rn_node_indices = {str_initiating_rn_node_indices, $sformatf("\n RN nodes used to initiate the transactions are initiating_rn_node_idx_0 : %0d, initiating_rn_node_idx_1 : %0d,cache_initializing_rn_node_index : %0d ", initiating_rn_node_idx_0, initiating_rn_node_idx_1, cache_initializing_rn_node_index)};
    `svt_xvm_debug("body", $sformatf("contents of active_participating_rn_f_nodes and RN nodes used to initiate the transactions are %0s", str_initiating_rn_node_indices));

    for(int i = 0; i < sequence_length; i++) begin

      /** Initiate MAKEUNIQUE transaction from cache_initializing_rn_node_index to randomly selected HN Node. */ 
      `svt_xvm_do_on_with(makeunique_seq, p_sequencer.rn_virt_seqr[cache_initializing_rn_node_index].rn_xact_seqr,
      {
        sequence_length == 1;
        hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
        seq_hn_node_idx == target_hn_node_idx_0;
        use_seq_is_non_secure_access == 0;
      })

      /** Wait for MakeUnique transactions to finish */ 
      makeunique_seq.write_tran.wait_end();
      txn_address = makeunique_seq.output_xacts[0].addr;
      txn_data = makeunique_seq.data_in_cache;
      txn_mem_attr_allocate_hint = makeunique_seq.output_xacts[0].mem_attr_allocate_hint;
      txn_snp_attr_is_snoopable = makeunique_seq.output_xacts[0].snp_attr_is_snoopable;
      txn_snp_attr_snp_domain_type = makeunique_seq.output_xacts[0].snp_attr_snp_domain_type;
      txn_is_non_secure_access = makeunique_seq.output_xacts[0].is_non_secure_access;

      /** Writeback the data to the main memory at the respective address. */ 
      if(perform_initialization_from_rn_used_for_hazard) begin
        `svt_xvm_do_on_with(copyback_seq, p_sequencer.rn_virt_seqr[cache_initializing_rn_node_index].rn_xact_seqr,
        {
          sequence_length == 1;
          data_in_cache == txn_data;
          seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
          hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
          min_addr == txn_address;
          max_addr == txn_address;
          seq_xact_type == svt_chi_transaction::WRITEBACKFULL;
          seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
          seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
          seq_is_non_secure_access == txn_is_non_secure_access;
          use_seq_is_non_secure_access == 1;                      
        }
        )
        /** Waiting for copyback transaction to complete */ 
        copyback_seq.copyback_tran.wait_end();
      end 

      /* ATOMIC-CMO hazard at HN **/
      fork 
        begin      
`ifndef SVT_CHI_ENABLE_MULTI_CLOCK
          @ (posedge sys_cfg.chi_if.clk);
`else
          @ (posedge sys_cfg.chi_if.rn_clk[initiating_rn_node_idx_0]);
`endif          
          xact_hazard_sema_0.get();
          /** Randomly selected first RN-F fires a Atomic transaction with MAKEUNIQUE 
           *  transaction address of randomly selected HN Node.
           */
          `svt_xvm_do_on_with(atomic_type_seq_0[i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
          {
            sequence_length == 1;
            data_in_cache == txn_data;
            seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
            hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
            min_addr == txn_address;
            max_addr == txn_address;
            seq_is_non_secure_access == txn_is_non_secure_access;
            use_seq_is_non_secure_access == 1;                      
       
          }
          )
          xact_hazard_sema_0.put();
          /** Waiting for Atomic type transaction to complete */ 
          atomic_type_seq_0[i].atomic_tran.wait_end();
        end
        begin
`ifndef SVT_CHI_ENABLE_MULTI_CLOCK
          @ (posedge sys_cfg.chi_if.clk);
`else
          @ (posedge sys_cfg.chi_if.rn_clk[initiating_rn_node_idx_1]);
`endif        
          xact_hazard_sema_1.get();
          /** Initiate CMO type of transaction from initiating_rn_node_idx_1 to txn_address. */ 
          `svt_xvm_do_on_with(cmo_seq_0[i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,
          {
            sequence_length == 1;
            hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
            min_addr == txn_address;
            max_addr == txn_address;
            seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
            seq_snp_attr_is_snoopable == txn_snp_attr_is_snoopable;
            seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
            seq_is_non_secure_access == txn_is_non_secure_access;
            use_seq_is_non_secure_access == 1;                      
            `ifdef SVT_CHI_ISSUE_B_ENABLE
              if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision == svt_chi_node_configuration::ISSUE_A)
                {
                  !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSIST, svt_chi_transaction::STASHONCEUNIQUE,svt_chi_transaction::STASHONCESHARED});
                }
              `ifdef SVT_CHI_ISSUE_E_ENABLE
              else if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision < svt_chi_node_configuration::ISSUE_E){
                !(seq_xact_type inside {svt_chi_transaction::STASHONCESEPUNIQUE, svt_chi_transaction::STASHONCESEPSHARED});
                if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision < svt_chi_node_configuration::ISSUE_D){
                  !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                  if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 0)
                    !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                }
                else if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision >= svt_chi_node_configuration::ISSUE_D){
                  if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].cleansharedpersistsep_xact_enable ==0)
                    !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                  if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 0)
                    !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                }
              }
              else if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision >= svt_chi_node_configuration::ISSUE_E){
                if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].cleansharedpersistsep_xact_enable == 0)
                  !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 0)
                  !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED,svt_chi_transaction::STASHONCESEPUNIQUE, svt_chi_transaction::STASHONCESEPSHARED});
              }
              `elsif SVT_CHI_ISSUE_D_ENABLE
              else if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision < svt_chi_node_configuration::ISSUE_D){
                !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 0)
                  !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
              }
              else if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision >= svt_chi_node_configuration::ISSUE_D){
                if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].cleansharedpersistsep_xact_enable ==0)
                  !(seq_xact_type inside {svt_chi_transaction::CLEANSHAREDPERSISTSEP});
                if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 0){
                  !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                }
              }
              `endif //issue_d_enable
              else if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 0){
                  !(seq_xact_type inside {svt_chi_transaction::STASHONCEUNIQUE, svt_chi_transaction::STASHONCESHARED});
                }
            `endif
          }
          )
          xact_hazard_sema_1.put();
          /** Waiting for CMO type transaction to complete */ 
          cmo_seq_0[i].cmo_tran.wait_end(); 
        end
      join
    end

    `uvm_info("body", "Exiting...", UVM_HIGH)
  endtask: body

  virtual task post_body();
    drop_phase_objection();
  endtask

endclass: svt_chi_system_protocol_flow_ctrl_hn_atomic_cmo_hazard_directed_virtual_sequence

function svt_chi_system_protocol_flow_ctrl_hn_atomic_cmo_hazard_directed_virtual_sequence::new(string name="svt_chi_system_protocol_flow_ctrl_hn_atomic_cmo_hazard_directed_virtual_sequence");
  super.new(name);
endfunction

/** 
 * @groupname CHI_OUTSTANDING_ATOMIC_TYPE 
 * #- This sequence requires at least one HN node to be present in the Interconnect.
 * #- This sequence requires one initiating active and participating RN.
 * #- If another active and participating RN-F exists, perform cache
 *    initialization to a randomly selected HN.
 * #- Initiate maximum number of Atomic type transactions with 
 *    svt_chi_rn_transaction::suspend_wr_data set  to 1 from initiating RN to randomly 
 *    selected HN in non blocking mode. <br>
 *    - Maximum number of outstanding transactions at the HN is as per either #max_num_outstanding_atomic_xacts_at_hn or
 *      #max_num_outstanding_xacts_at_hn, which can be controlled through config DB.   
 *    - This ensures that the maximum outstanding transaction limit is reached at the HN. 
 *    - Also, the RN will not transmit NonCopyBackWrData corresponding to these transactions
 *      until svt_chi_rn_transaction::suspend_wr_data is set to 0 from the seqeunce.
 *    .
 * #- The addresses of these atomic transactions are such that:
 *    - Same as initialized cache line addresses if cache initialization is performed
 *    - Otherwise, random addresses targeting the same HN
 *    .
 * #- Once the RN receives the responses for all the outstanding transactions from
 *    HN, svt_chi_rn_transaction::suspend_wr_data is set to 0 for all the outstanding
 *    transactions. <br>
 *    This ensures that the NonCopyBackWrData for these transactions can be resumed 
 *    from RN.
 * #- Check that the HN responds properly for all outstanding atomic type transactions
 *    and these are completed successfully.
 * .
 */ 
class svt_chi_system_protocol_flow_ctrl_atomic_outstanding_same_rn_same_hn_virtual_sequence extends svt_chi_system_base_virtual_sequence;

  //-----------------------------------------------------------------------------  
  // Member attributes
  //-----------------------------------------------------------------------------  

  /** To display contents of Active Participating RN's node info. */
  string str_rn_node;

  /** To display contents of Active Participating RN-F's node info. */
  string str_rn_f_node;

  `svt_xvm_object_utils(svt_chi_system_protocol_flow_ctrl_atomic_outstanding_same_rn_same_hn_virtual_sequence)

  function new(string name = "svt_chi_system_protocol_flow_ctrl_atomic_outstanding_same_rn_same_hn_virtual_sequence");
    super.new(name);
  endfunction  

  //-----------------------------------------------------------------------------
  /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting any type of Request Nodes = 1
   *  #- Minimum required number of HN Nodes = 1   
   *  .
   */
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    
    /** local variables */
    int num_supporting_request_nodes;
    int num_hn_f_nodes;   
    int array_idx;
    bit is_rn_idx_0_participating;
    string str_is_supported_info_prefix = "";
    string str_is_supported_info = "";
    string str_idx0_info = "";
    /** Supporting any type of Request Nodes required */
    int required_num_supporting_request_nodes = 1;
    int required_num_hn_nodes = 1;
    
    `svt_xvm_debug("is_supported",$sformatf("Entering ..."));

    /** By default is_supported is 0 */
    is_supported = 0;

    /** Check for minimum required HN nodes */
    num_hn_f_nodes = hn_f_nodes.size();
    
    /** Check requirment of number of HN nodes needed */
    if (num_hn_f_nodes < required_num_hn_nodes) begin
      issue_is_supported_failure($sformatf("This sequence requires minimum %0d HN-F nodes to be present in the system. Number of HN-F nodes are %0d. Program number of HN nodes using svt_chi_system_configuration::num_hn. Program the HN interface type using svt_chi_system_configuration::chi_addr_cfg.hn_interface_type[].", required_num_hn_nodes, num_hn_f_nodes));
      return 0;      
    end
    
    /** Check for minimum required RN nodes.
     *  Also check whether the selected RN nodes are part of participating arrays or not.
     */    
    num_supporting_request_nodes = active_participating_rn_nodes.size();

    /** Check the requirements of RN nodes */
    if (num_supporting_request_nodes) begin
      /** Display the contents of Active Participating RN Nodes */
      foreach (active_participating_rn_nodes[j]) begin
        str_rn_node = {str_rn_node, $sformatf(" %0d", active_participating_rn_nodes[j])};
      end 
      `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_nodes are %0s", str_rn_node));
    end

    str_is_supported_info_prefix = $sformatf("Number of Supporting RN Node(s)  - Minimum Required : %0d Current : %0d", required_num_supporting_request_nodes, num_supporting_request_nodes);
    
    if ((initiating_rn_node_index_0_status==0)&&(valid_initiating_rn_node_index_0==0)) begin
        str_idx0_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN's that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F or RN_I)";
    end
    else begin
      is_rn_idx_0_participating = is_value_found_in_int_assoc_array(active_participating_rn_nodes, initiating_rn_node_idx_0, array_idx);
      if (!is_rn_idx_0_participating) begin
        str_idx0_info = $sformatf("initiating_rn_node_idx_0 %0d is not valid for this sequence. The RN corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuration::participating_rn_nodes[])", initiating_rn_node_idx_0, initiating_rn_node_idx_0);
      end
    end

    if (is_rn_idx_0_participating) begin
      is_supported = 1;
      if(max_num_outstanding_atomic_xacts_at_hn > 0) begin
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].num_outstanding_atomic_xact < max_num_outstanding_atomic_xacts_at_hn) begin
          str_idx0_info = $sformatf("Programmed value of max_num_outstanding_atomic_xacts_at_hn_status is %0d. But num_outstanding_atomic_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_atomic_xact of the initiating RN node must be equal to or greater than max_num_outstanding_atomic_xacts_at_hn_status of the target HN", max_num_outstanding_atomic_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_0_participating].num_outstanding_atomic_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
      end else begin
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].num_outstanding_xact < max_num_outstanding_xacts_at_hn) begin
          str_idx0_info = $sformatf("Programmed value of max_num_outstanding_xacts_at_hn_status is %0d. But num_outstanding_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_xact of the initiating RN node must be equal to or greater than max_num_outstanding_xacts_at_hn of the target HN", max_num_outstanding_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_0_participating].num_outstanding_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
      end
    end
    
    if (!is_supported) begin
      str_is_supported_info = $sformatf("%0s",str_idx0_info);
      if (is_rn_idx_0_participating) begin
        issue_is_supported_failure($sformatf("This sequence cannot be run based on the current system configuration.\n\
                                              %0s\n\
                                              %0s \n\
                                              Modify configurations through \n\
                                              svt_chi_system_configuration::num_rn,\n\
                                              svt_chi_node_configuration::is_active,\n\
                                              svt_chi_system_configuration::participating_rn_nodes[]\n\
                                              ", str_is_supported_info_prefix, str_is_supported_info));
      end
      else begin
        issue_is_supported_failure($sformatf("This sequence cannot be run based on the current node configurations of RN%0d\n\
                                              %0s \n\
                                              Modify configuration through \n\
                                              svt_chi_node_configuration::num_outstanding_xact,\n\
                                              svt_chi_node_configuration::num_outstanding_atomic_xact,\n\
                                              ",str_is_supported_info, initiating_rn_node_idx_0));
      end
    end      
    `svt_xvm_debug("is_supported",$sformatf("Exiting ..."));
    if (!is_target_hn_idx_valid_for_curr_cfg()) begin
      is_supported = 0;
      `svt_xvm_note("is_supported", "not a valid hn_idx based on random_tgt_id_enable for current cfg");
    end
  endfunction : is_supported

  virtual task pre_start();
    bit status;
    /** Status field for capturing config DB get status for request_ordering */  
    bit request_ordering_status;
    /** Variable used to decide if request ordering in the transaction must be set or not.
     *  This can be programmed using config DB.
     *  If not programmed, the request ordering field in the generated transaction will be randomized
     */
    int request_ordering = -1;

    super.pre_start();
    raise_phase_objection();
  endtask // pre_start

  /** Drop objection */
  virtual task post_start();
    super.post_start();
    drop_phase_objection();
  endtask: post_start

  virtual task body();
    bit                           status;
    /** Queue of addresses, used by the transactions generated */
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0] addr_q[$];
    /** Flag to track whether cache initialization needs to be performed or not*/
    bit                                perform_cache_initialization;
    int                                array_idx;
    int                                num_outstanding_xacts_to_generate;
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0] txn_address;
    bit [`SVT_CHI_MAX_DATA_WIDTH -1:0] txn_data;
    bit txn_mem_attr_allocate_hint, txn_snp_attr_snp_domain_type, txn_is_non_secure_access;

    /** Metric variables */
    int received_responses = 0;

    /** Sub sequences initiated from this sequence */
    svt_chi_rn_atomic_type_transaction_directed_sequence atomic_type_seq_0[int];

    /** Sub sequences initiated from this sequence */
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq[int];
    svt_chi_rn_copyback_type_transaction_directed_sequence copyback_seq[int];

    `uvm_info("body", "Entered ...", UVM_HIGH)
    super.body();
    // Default
    max_num_outstanding_xacts_at_hn_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(), "max_num_outstanding_xacts_at_hn", max_num_outstanding_xacts_at_hn);
    max_num_outstanding_atomic_xacts_at_hn_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(), "max_num_outstanding_atomic_xacts_at_hn", max_num_outstanding_atomic_xacts_at_hn);

    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :initiating_rn_node_idx_0;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_node_index_0;

    `svt_xvm_debug("body", $sformatf("max_num_outstanding_xacts_at_hn is %0d as a result of %0s.", max_num_outstanding_xacts_at_hn, max_num_outstanding_xacts_at_hn_status ? "config DB" : "default"));
    `svt_xvm_debug("body", $sformatf("max_num_outstanding_atomic_xacts_at_hn is %0d as a result of %0s.", max_num_outstanding_atomic_xacts_at_hn, max_num_outstanding_atomic_xacts_at_hn_status ? "config DB" : "default"));
    `svt_xvm_debug("body", $sformatf("initiating_rn_node_idx_0 is %0d as a result of %0s.", initiating_rn_node_idx_0, initiating_rn_node_index_0_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("target_hn_node_idx_0 is %0d as a result of %0s.", target_hn_node_idx_0, target_hn_node_index_0_status ? "config DB" : "Randomization"));

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /** 
     * If the number of active_participating_rn_f_nodes are greater than 1, then
     * we can initialize the cache/memory from the RN having node index 
     * initiating_rn_f_node_index_1.
     * If the number of active_participating_rn_f_nodes are equal to 1, then
     * we can initialize the cache/memory from the RN having node index 
     * initiating_rn_node_idx_0.
     *  
     */
    if((active_participating_rn_f_nodes.size()>1) && (valid_initiating_rn_f_node_index_1))begin
      cache_line_init_rn_f_node_index = initiating_rn_f_node_index_1;
    end else begin
      cache_line_init_rn_f_node_index = initiating_rn_node_idx_0;
    end

    // If the cache_line_init_rn_f_node_index is part of active_participating_rn_f_nodes array, and
    // then we can perform cache initialization from the 
    // RN[cache_line_init_rn_f_node_index].
    if ((is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, cache_line_init_rn_f_node_index, array_idx))) begin
      perform_cache_initialization = 1;
    end

    `svt_xvm_debug("body", $sformatf("perform_cache_initialization is %0b, cache_line_init_rn_f_node_index is %0d, initiating_rn_node_idx_0 is %0d", perform_cache_initialization, cache_line_init_rn_f_node_index, initiating_rn_node_idx_0));    

    //If max outstanding count for Atomic transactions has been programmed, use that to generate the outstanding atomics
    if(max_num_outstanding_atomic_xacts_at_hn > 0) begin
      num_outstanding_xacts_to_generate = max_num_outstanding_atomic_xacts_at_hn;
      `svt_xvm_debug("body",$sformatf("max_num_outstanding_atomic_xacts_at_hn is set to a non-zero value (%0d). Hence, the value programmed in max_num_outstanding_xacts_at_hn will be ignored. The number of outstanding transactions issued by the sequence will be equal to max_num_outstanding_atomic_xacts_at_hn", max_num_outstanding_atomic_xacts_at_hn));
    end
    //If not, use the max outstanding transaction count
    else begin
      num_outstanding_xacts_to_generate = max_num_outstanding_xacts_at_hn;
    end

    for(int k = 0; k < sequence_length; k++) begin
      if(perform_cache_initialization) begin
        `svt_xvm_debug("body",$sformatf("Starting cache initialization for %0d addresses from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d",num_outstanding_xacts_to_generate, cache_line_init_rn_f_node_index, target_hn_node_idx_0));

        for(int i = 0; i < num_outstanding_xacts_to_generate; i++) begin     
          `svt_xvm_debug("body", $sformatf("cache_line_init_rn_f_node_index is %0d,initiating_rn_node_idx_0 is %0d" ,cache_line_init_rn_f_node_index, initiating_rn_node_idx_0));
          /** Write data into Cache of Randomly selected first RN-F with address of randomly selected HN Node */
          `svt_xvm_do_on_with(makeunique_seq[i],p_sequencer.rn_virt_seqr[cache_line_init_rn_f_node_index].rn_xact_seqr,
          {
            sequence_length   == 1;
            hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
            seq_hn_node_idx   == target_hn_node_idx_0;
            use_seq_is_non_secure_access == 0;                      
          })
          
          `svt_xvm_debug("body", $sformatf("%0s Waiting for MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) to end",`SVT_CHI_PRINT_PREFIX(makeunique_seq[i].write_tran),i, makeunique_seq[i].write_tran.hn_node_idx, makeunique_seq[i].write_tran.tgt_id));
          makeunique_seq[i].write_tran.wait_end();
          `svt_xvm_debug("body", $sformatf("%0s MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) ended",`SVT_CHI_PRINT_PREFIX(makeunique_seq[i].write_tran),i, makeunique_seq[i].write_tran.hn_node_idx, makeunique_seq[i].write_tran.tgt_id));
          /** Queue for collecting the address of makeunique transactions */
          addr_q.push_back(makeunique_seq[i].output_xacts[0].addr);
          `svt_xvm_verbose("body", $sformatf("MakeUnique transaction [%0d] is %0s", i,makeunique_seq[i].write_tran.sprint()));

          /** Wait for MakeUnique transactions to finish */ 
          txn_address = makeunique_seq[i].output_xacts[0].addr;
          txn_data = makeunique_seq[i].data_in_cache;
          txn_mem_attr_allocate_hint = makeunique_seq[i].output_xacts[0].mem_attr_allocate_hint;
          txn_snp_attr_snp_domain_type = makeunique_seq[i].output_xacts[0].snp_attr_snp_domain_type;
          txn_is_non_secure_access = makeunique_seq[i].output_xacts[0].is_non_secure_access;

          /** Writeback the data to the main memory at the respective address. */ 
          `svt_xvm_do_on_with(copyback_seq[i], p_sequencer.rn_virt_seqr[cache_line_init_rn_f_node_index].rn_xact_seqr,
          {
            sequence_length == 1;
            data_in_cache == txn_data;
            seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
            hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
            min_addr == txn_address;
            max_addr == txn_address;
            seq_xact_type == svt_chi_transaction::WRITEBACKFULL;
            seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
            seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
            seq_is_non_secure_access == txn_is_non_secure_access;
            use_seq_is_non_secure_access == 1;                      
          }
          )
          /** Waiting for copyback transaction to complete */ 
          copyback_seq[i].copyback_tran.wait_end();
        end//for(int i = 0; i < num_outstanding_xacts_to_generate; i++)
      end// if (perform_cache_initialization)

      `svt_xvm_debug("body",$sformatf("Starting transmission of Atomic type transactions for %0d addresses from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d with suspend_wr_data set to 1",num_outstanding_xacts_to_generate, initiating_rn_node_idx_0, target_hn_node_idx_0));

      for(int i = 0; i < num_outstanding_xacts_to_generate; i++) begin 
        `svt_xvm_debug("body", $sformatf("initiating_rn_node_idx_0 is %0d",initiating_rn_node_idx_0));
        /** Randomly selected first RN-F fires a Atomic transaction with MAKEUNIQUE 
         *  transaction address of randomly selected HN Node.
         */
        `svt_xvm_do_on_with(atomic_type_seq_0[i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
        {
          sequence_length == 1;
          `ifdef SVT_CHI_ISSUE_E_ENABLE
           if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision >= svt_chi_node_configuration::ISSUE_E) {
            seq_txn_id         == (i*3);
           }
           else{
            seq_txn_id         == (i % num_outstanding_xacts_to_generate);
           }
          `else
            seq_txn_id         == (i % num_outstanding_xacts_to_generate);
          `endif
          data_in_cache == txn_data;
          seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
          if(perform_cache_initialization) {
            hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
            min_addr         == addr_q[i];
            max_addr         == addr_q[i];
            seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
            seq_is_non_secure_access == txn_is_non_secure_access;
            use_seq_is_non_secure_access == 1;       
          }
          else {
            hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
            seq_hn_node_idx    == target_hn_node_idx_0;
            use_seq_is_non_secure_access == 0;
          }
        })
        `svt_xvm_debug("body", $sformatf("%0s Transmitting Atomic Transaction [%0d] targeted to HN (idx %0d, id %0d) ",`SVT_CHI_PRINT_PREFIX(atomic_type_seq_0[i].atomic_tran),i, atomic_type_seq_0[i].atomic_tran.hn_node_idx, atomic_type_seq_0[i].atomic_tran.tgt_id));
        `svt_xvm_verbose("body", $sformatf("Atomic Transaction [%0d] is %0s", i,atomic_type_seq_0[i].atomic_tran.sprint()));        
        
      end//for(int i = 0; i < num_outstanding_xacts_to_generate; i++)

      /** Waiting for the DBIDResp responses from HN for atomic trasactions */
      foreach(atomic_type_seq_0[wr]) begin
        fork
          automatic int _wr = wr;
          begin
            `svt_xvm_debug("body", $sformatf("%0s Atomic transaction [%0d] targeted to HN (idx %0d, id %0d), suspend_wr_data %0b: waiting for response from interconnect",`SVT_CHI_PRINT_PREFIX(atomic_type_seq_0[_wr].atomic_tran),_wr, atomic_type_seq_0[_wr].atomic_tran.hn_node_idx, atomic_type_seq_0[_wr].atomic_tran.tgt_id,atomic_type_seq_0[_wr].atomic_tran.suspend_wr_data));
            fork
            begin
              fork
                begin
                  atomic_type_seq_0[_wr].atomic_tran.wait_for_tx_data_prereqs();
                end
                begin
                  wait(atomic_type_seq_0[_wr].atomic_tran.req_status == svt_chi_transaction::RETRY);// begin
                end
              join_any
              disable fork;
            end
            join
            received_responses++;
            `svt_xvm_debug("body", $sformatf("%0s Atomic transaction [%0d] targeted to HN (idx %0d, id %0d), suspend_wr_data %0b: received response from interconnect. Total responses received %0d",`SVT_CHI_PRINT_PREFIX(atomic_type_seq_0[_wr].atomic_tran),_wr, atomic_type_seq_0[_wr].atomic_tran.hn_node_idx, atomic_type_seq_0[_wr].atomic_tran.tgt_id,atomic_type_seq_0[_wr].atomic_tran.suspend_wr_data,received_responses));
          end
        join_none
      end

      /** Wait until All DBIDResp responses are received for Atomic transaction */ 
      `svt_xvm_debug("body",$sformatf("Completed initiation of Atomic type transactions for %0d addresses from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d with suspend_wr_data set to 1, and waiting to receive responses from interconnect.",
                                num_outstanding_xacts_to_generate, initiating_rn_node_idx_0,target_hn_node_idx_0));
      wait(received_responses == num_outstanding_xacts_to_generate);
      `svt_xvm_debug("body",$sformatf("Received responses from interconnect to Atomic type transactions for %0d addresses from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d with suspend_wr_data set to 1.",
                                num_outstanding_xacts_to_generate, initiating_rn_node_idx_0,target_hn_node_idx_0));
     
      /** Self Check1: To check suspend_wr_data should not be modified to zero by the VIP
       * before reseting from test bench
       */
      foreach (atomic_type_seq_0[self_check_idx1]) begin
        if (!atomic_type_seq_0[self_check_idx1].atomic_tran.is_terminated()) begin
          if (atomic_type_seq_0[self_check_idx1].atomic_tran.suspend_wr_data == 0) begin
            `svt_xvm_error("body", $sformatf("%0s suspend_wr_data should be 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(atomic_type_seq_0[self_check_idx1].atomic_tran)));
          end
          else begin
            `svt_xvm_debug("body", $sformatf("%0s suspend_wr_data is 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(atomic_type_seq_0[self_check_idx1].atomic_tran)));
          end
        end
      end

      /** Self Check2: To check transaction is not ended by the VIP before resuming the 
       *  suspend_wr_data to zero from the test bench
       */
      foreach(atomic_type_seq_0[self_check_idx2]) begin
        if (!atomic_type_seq_0[self_check_idx2].atomic_tran.is_terminated()) begin
          if (atomic_type_seq_0[self_check_idx2].atomic_tran.end_event.is_on() == 1) begin
            `svt_xvm_error("body", $sformatf("Unexpected: %0s Transaction's end_event triggered when suspend_wr_data is still 1.", `SVT_CHI_PRINT_PREFIX(atomic_type_seq_0[self_check_idx2].atomic_tran)));
          end
          else begin
            `svt_xvm_debug("body", $sformatf("Expected: %0s Transaction's end_event is not triggered when suspend_wr_data is still 1.", `SVT_CHI_PRINT_PREFIX(atomic_type_seq_0[self_check_idx2].atomic_tran)));
          end
        end
      end
 
      /** Self Check 3: To check that the current_outstanding_*_xact_count in the RNs
       * are as per the transactions inititated by the sequence
       */
      /** Check if the total outstanding xact counter is set correctly in the shared status of the RN agent */
      if(atomic_type_seq_0[0].shared_status.prot_status.current_outstanding_xact_count != num_outstanding_xacts_to_generate)
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding transactions from the sequence but the outstanding transaction count in the shared status of RN%0d is %0d", num_outstanding_xacts_to_generate, initiating_rn_node_idx_0, atomic_type_seq_0[0].shared_status.prot_status.current_outstanding_xact_count));

      /** Check if the outstanding Atomic xact counter is set correctly in the shared status of the RN agent */
      if(atomic_type_seq_0[0].shared_status.prot_status.current_outstanding_atomic_xact_count != num_outstanding_xacts_to_generate) begin
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding Atomic transactions from the sequence but the outstanding Atomic transaction count in the shared status of RN%0d is %0d", num_outstanding_xacts_to_generate, initiating_rn_node_idx_0, atomic_type_seq_0[0].shared_status.prot_status.current_outstanding_atomic_xact_count));
      end

      `svt_xvm_debug("body", $sformatf("RN%0d: Number of outstanding transactions : %0d, Number of outstanding Atomic xacts : %0d", initiating_rn_node_idx_0, atomic_type_seq_0[0].shared_status.prot_status.current_outstanding_xact_count, atomic_type_seq_0[0].shared_status.prot_status.current_outstanding_atomic_xact_count));

      /** Resuming all NonCopyBackWrData for above Atomic transactions */
      `svt_xvm_debug("body",$sformatf("Resuming the Atomic transactions by setting svt_chi_rn_transaction::suspend_wr_data set to 0"))
      foreach(atomic_type_seq_0[index4]) begin
        atomic_type_seq_0[index4].atomic_tran.suspend_wr_data = 0;
        `svt_xvm_debug("body", $sformatf("After Resume received_responses is %0d for iteration %0d and suspend_wr_data is %0b",received_responses, index4, atomic_type_seq_0[index4].atomic_tran.suspend_wr_data));
      end
     
      /** Waiting for Atomic transactions to complete*/
      `svt_xvm_debug("body",$sformatf("Waiting for completion of all the outstanding Atomic type transactions"));
      foreach(atomic_type_seq_0[self_check_idx3]) begin
        `svt_xvm_debug("body", $sformatf("Waiting for above atomic_type_seq_0[%0d] transaction %0s to end", self_check_idx3, `SVT_CHI_PRINT_PREFIX(atomic_type_seq_0[self_check_idx3].atomic_tran)));
        atomic_type_seq_0[self_check_idx3].atomic_tran.wait_end();

        /** Self Check4: To check suspend_wr_data should not be asserted after the transaction
         *  completes as it is reseted from test bench
         */
        if (!atomic_type_seq_0[self_check_idx3].atomic_tran.is_terminated()) begin
          if (atomic_type_seq_0[self_check_idx3].atomic_tran.suspend_wr_data == 1) begin
            `svt_xvm_error("body", $sformatf("%0s suspend_wr_data should be 0 as it has been reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(atomic_type_seq_0[self_check_idx3].atomic_tran)));
          end
          else begin
            `svt_xvm_debug("body", $sformatf("%0s suspend_wr_data is 0 as it is reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(atomic_type_seq_0[self_check_idx3].atomic_tran)));
          end
        end
      end
      `svt_xvm_debug("body",$sformatf("Received completions for all Atomic type outstanding transactions"));

      /** Targetted HN ID from the RN should be same throughout*/
      foreach(atomic_type_seq_0[wr]) begin
        int hn_idx_0;
        hn_idx_0 = sys_cfg.get_hn_idx(atomic_type_seq_0[wr].output_xacts[0].addr);
        if (hn_idx_0 == target_hn_node_idx_0) begin
          `svt_xvm_debug("body", $sformatf("Targeted HN Index from the RN is same as expected.  rn[%0d] to hn_idx[%0d] and it matches target_hn_node_idx_0 %0d", initiating_rn_node_idx_0, hn_idx_0,target_hn_node_idx_0));
        end
        else begin
          `svt_xvm_error("body", $sformatf("Targeted HN Index from the RN is different, which is unexpected.  rn[%0d] %0s transaction to hn_idx[%0d] and it doesn't match target_hn_node_idx_0 %0d", 
                                           initiating_rn_node_idx_0, `SVT_CHI_PRINT_PREFIX( atomic_type_seq_0[wr].output_xacts[0]), hn_idx_0,target_hn_node_idx_0));
        end
      end
            
      /** Reset received_responses to Zero */
      received_responses = 0;

      /** Delete the contents of address collection queue */
      addr_q.delete();

    end//for(int k = 0; k < sequence_length; k++) begin 
  `svt_xvm_debug("body", "Exiting...")
  endtask
endclass

/** 
 * @groupname CHI_OUTSTANDING_ATOMIC_TYPE  
 * #- This sequence requires at least one HN node to be present in the Interconnect.
 * #- This sequence requires two initiating active and participating RN.
 * #- If another active and participating RN-F exists, perform cache
 *    initialization to a randomly selected HN.
 * #- Initiate 128 Atomic type transactions with 
 *    svt_chi_rn_transaction::suspend_wr_data set to 1 from each of the two initiating RNs to the randomly 
 *    selected HN in non blocking mode. <br>
 *    - Maximum number of outstanding transactions at the HN is as per either #max_num_outstanding_atomic_xacts_at_hn or
 *      #max_num_outstanding_xacts_at_hn, which can be controlled through config DB.   
 *    - This ensures that the maximum outstanding transaction limit is reached at the HN.
 *    - Also, both the RNs will not transmit NonCopyBackWrData corresponding to these transactions
 *      until svt_chi_rn_transaction::suspend_wr_data is set to 0 from the seqeunce.
 *    .
 * #- The addresses of these atomic transactions are such that:
 *    - Same as initialized cache line addresses if cache initialization is performed
 *    - Otherwise, random addresses targeting the same HN
 *    .
 * #- Once the RNs receive the responses for all the outstanding transactions from
 *    HN, svt_chi_rn_transaction::suspend_wr_data is set to 0 for all the outstanding
 *    transactions. <br>
 *    This ensures that the NonCopyBackWrData for these transactions can be resumed 
 *    from both the RNs.
 * #- Check that the HN responds properly for all outstanding atomic type transactions
 *    and these are completed successfully.
 * .
 */
class svt_chi_system_protocol_flow_ctrl_atomic_outstanding_diff_rn_same_hn_virtual_sequence extends svt_chi_system_base_virtual_sequence;
  //-----------------------------------------------------------------------------  
  // Member attributes
  //-----------------------------------------------------------------------------  

  /** To display contents of Active Participating RN's node info. */
  string str_rn_node;

  /** To display contents of Active Participating RN-F's node info. */
  string str_rn_f_node;

  /** UVM/OVM Object Utility macro */
  `svt_xvm_object_utils(svt_chi_system_protocol_flow_ctrl_atomic_outstanding_diff_rn_same_hn_virtual_sequence)

  //-----------------------------------------------------------------------------  
  // Methods
  //-----------------------------------------------------------------------------
  /** Constructor */
  extern function new(string name="svt_chi_system_protocol_flow_ctrl_atomic_outstanding_diff_rn_same_hn_virtual_sequence");

  //-----------------------------------------------------------------------------
  /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting any type of Request Nodes = 2
   *  #- Minimum required number of HN Nodes = 1   
   *  .
   */
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    
    /** local variables */
    int num_supporting_request_nodes;
    int num_hn_f_nodes;   
    int array_idx;
    bit is_rn_idx_0_participating, is_rn_idx_1_participating;
    string str_is_supported_info_prefix = "";
    string str_is_supported_info = "";
    string str_idx0_info = "";
    string str_idx1_info = "";    
    /** Supporting any type of Request Nodes required */
    int required_num_supporting_request_nodes = 2;
    int required_num_hn_nodes = 1;
    
    `svt_xvm_debug("is_supported",$sformatf("Entering ..."));

    /** By default is_supported is 0 */
    is_supported = 0;

    /** Check for minimum required HN nodes */
    num_hn_f_nodes = hn_f_nodes.size();
    
    /** Check requirment of number of HN nodes needed */
    if (num_hn_f_nodes < required_num_hn_nodes) begin
      issue_is_supported_failure($sformatf("This sequence requires minimum %0d HN-F nodes to be present in the system. Number of HN-F nodes are %0d. Program number of HN nodes using svt_chi_system_configuration::num_hn. Program the HN interface type using svt_chi_system_configuration::chi_addr_cfg.hn_interface_type[].", required_num_hn_nodes, num_hn_f_nodes));
      return 0;      
    end
    
    /** Check for minimum required RN nodes.
     *  Also check whether the selected RN nodes are part of participating arrays or not.
     */    
    num_supporting_request_nodes = active_participating_rn_nodes.size();

    /** Check the requirements of RN nodes */
    if (num_supporting_request_nodes) begin
      /** Display the contents of Active Participating RN Nodes */
      foreach (active_participating_rn_nodes[j]) begin
        str_rn_node = {str_rn_node, $sformatf(" %0d", active_participating_rn_nodes[j])};
      end 
      `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_nodes are %0s", str_rn_node));
    end

    str_is_supported_info_prefix = $sformatf("Number of Supporting RN Node(s)  - Minimum Required : %0d Current : %0d", required_num_supporting_request_nodes, num_supporting_request_nodes);
    
    if ((initiating_rn_node_index_0_status==0)&&(valid_initiating_rn_node_index_0==0)) begin
        str_idx0_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN's that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F or RN_I)";
    end
    else begin
      is_rn_idx_0_participating = is_value_found_in_int_assoc_array(active_participating_rn_nodes, initiating_rn_node_idx_0, array_idx);
      if (!is_rn_idx_0_participating) begin
        str_idx0_info = $sformatf("initiating_rn_node_idx_0 %0d is not valid for this sequence. The RN corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuration::participating_rn_nodes[])", initiating_rn_node_idx_0, initiating_rn_node_idx_0);
      end
    end
    if ((initiating_rn_node_index_1_status==0)&&(valid_initiating_rn_node_index_1==0)) begin
        str_idx1_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN's that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F or RN_I)";
    end
    else begin
      is_rn_idx_1_participating = is_value_found_in_int_assoc_array(active_participating_rn_nodes, initiating_rn_node_idx_1, array_idx);
      if (!is_rn_idx_1_participating) begin
        str_idx1_info = $sformatf("initiating_rn_node_idx_1 %0d is not valid for this sequence. The RN corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuration::participating_rn_nodes[])", initiating_rn_node_idx_1, initiating_rn_node_idx_1);
      end
    end

    if (is_rn_idx_0_participating && is_rn_idx_1_participating) begin
      is_supported = 1;
      if(max_num_outstanding_atomic_xacts_at_hn > 0) begin
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].num_outstanding_atomic_xact < (max_num_outstanding_atomic_xacts_at_hn/2)) begin
          str_idx0_info = $sformatf("Programmed value of max_num_outstanding_atomic_xacts_at_hn_status is %0d. But num_outstanding_atomic_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_atomic_xact of the initiating RN node must be equal to or greater than half of max_num_outstanding_atomic_xacts_at_hn_status of the target HN", max_num_outstanding_atomic_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_0_participating].num_outstanding_atomic_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].num_outstanding_atomic_xact < (max_num_outstanding_atomic_xacts_at_hn/2)) begin
          str_idx1_info = $sformatf("Programmed value of max_num_outstanding_atomic_xacts_at_hn_status is %0d. But num_outstanding_atomic_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_atomic_xact of the initiating RN node must be equal to or greater than half of max_num_outstanding_atomic_xacts_at_hn_status of the target HN", max_num_outstanding_atomic_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_1_participating].num_outstanding_atomic_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
      end else begin
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].num_outstanding_xact < (max_num_outstanding_xacts_at_hn/2)) begin
          str_idx0_info = $sformatf("Programmed value of max_num_outstanding_xacts_at_hn_status is %0d. But num_outstanding_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_xact of the initiating RN node must be equal to or greater than half of max_num_outstanding_xacts_at_hn of the target HN", max_num_outstanding_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_0_participating].num_outstanding_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].num_outstanding_xact < (max_num_outstanding_xacts_at_hn/2)) begin
          str_idx1_info = $sformatf("Programmed value of max_num_outstanding_xacts_at_hn_status is %0d. But num_outstanding_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_xact of the initiating RN node must be equal to or greater than half of max_num_outstanding_xacts_at_hn of the target HN", max_num_outstanding_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_1_participating].num_outstanding_xact, initiating_rn_node_idx_1);
          is_supported = 0;
        end
      end
    end
    
    if (!is_supported) begin
      str_is_supported_info = $sformatf("%0s%0s",str_idx0_info, str_idx1_info);
      if (is_rn_idx_0_participating && is_rn_idx_1_participating) begin
        issue_is_supported_failure($sformatf("This sequence cannot be run based on the current system configuration.\n\
                                              %0s\n\
                                              %0s \n\
                                              Modify configurations through \n\
                                              svt_chi_system_configuration::num_rn,\n\
                                              svt_chi_node_configuration::is_active,\n\
                                              svt_chi_system_configuration::participating_rn_nodes[]\n\
                                              ", str_is_supported_info_prefix, str_is_supported_info));
      end
      else begin
        issue_is_supported_failure($sformatf("This sequence cannot be run based on the current node configurations of RN%0d and/or RN%0d.\n\
                                              %0s \n\
                                              Modify configuration through \n\
                                              svt_chi_node_configuration::num_outstanding_xact,\n\
                                              svt_chi_node_configuration::num_outstanding_atomic_xact,\n\
                                              ",str_is_supported_info, initiating_rn_node_idx_0, initiating_rn_node_idx_1));
      end
    end      
    `svt_xvm_debug("is_supported",$sformatf("Exiting ..."));
    if (!is_target_hn_idx_valid_for_curr_cfg()) begin
      is_supported = 0;
      `svt_xvm_note("is_supported", "not a valid hn_idx based on random_tgt_id_enable for current cfg");
    end
  endfunction : is_supported

  virtual task pre_start();
    bit status;
    /** Status field for capturing config DB get status for request_ordering */  
    bit request_ordering_status;
    /** Variable used to decide if request ordering in the transaction must be set or not.
     *  This can be programmed using config DB.
     *  If not programmed, the request ordering field in the generated transaction will be randomized
     */
    int request_ordering = -1;
    `svt_xvm_debug("pre_start",$sformatf("Entering ..."));
    super.pre_start();
    raise_phase_objection();
  endtask // pre_start

  /** Drop objection */
  virtual task post_start();
    super.post_start();
    drop_phase_objection();
  endtask: post_start

  virtual task body();
    bit                           status;
    /** Queue of addresses, used by the transactions generated */
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0] addr_q[$];
    bit txn_is_non_secure_access_q[$];
    /** Flag to track whether cache initialization needs to be performed or not*/
    bit                                perform_cache_initialization;
    int                                array_idx;
    int                                num_outstanding_xacts_to_generate;
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0] txn_address;
    bit [`SVT_CHI_MAX_DATA_WIDTH -1:0] txn_data;
    bit txn_mem_attr_allocate_hint, txn_snp_attr_snp_domain_type, txn_is_non_secure_access;

    /** Metric variables */
    int received_responses = 0;

    /** Sub Atomic type transaction directed sequences initiated from this sequence */
    svt_chi_rn_atomic_type_transaction_directed_sequence atomic_seq[int];
    
    /** Sub Read type transaction cache initialization directed sequences initiated from this sequence */
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq[int];
    svt_chi_rn_copyback_type_transaction_directed_sequence copyback_seq[int];

    `svt_xvm_debug("body", "Entering ...")
    super.body();

    max_num_outstanding_xacts_at_hn_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(), "max_num_outstanding_xacts_at_hn", max_num_outstanding_xacts_at_hn);
    max_num_outstanding_atomic_xacts_at_hn_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(), "max_num_outstanding_atomic_xacts_at_hn", max_num_outstanding_atomic_xacts_at_hn);
    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :initiating_rn_node_index_0;
    initiating_rn_node_idx_1 = initiating_rn_node_index_1_status ? initiating_rn_node_index_1_from_config_db :initiating_rn_node_index_1;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_node_index_0;

    `svt_xvm_debug("body", $sformatf("max_num_outstanding_xacts_at_hn is %0d as a result of %0s.", max_num_outstanding_xacts_at_hn, max_num_outstanding_xacts_at_hn_status ? "config DB" : "default"));
    `svt_xvm_debug("body", $sformatf("max_num_outstanding_atomic_xacts_at_hn is %0d as a result of %0s.", max_num_outstanding_atomic_xacts_at_hn, max_num_outstanding_atomic_xacts_at_hn_status ? "config DB" : "default"));
    `svt_xvm_debug("body", $sformatf("initiating_rn_node_idx_0 is %0d as a result of %0s.", initiating_rn_node_idx_0, initiating_rn_node_index_0_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("initiating_rn_node_idx_1 is %0d as a result of %0s.", initiating_rn_node_idx_1, initiating_rn_node_index_1_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("target_hn_node_idx_0 is %0d as a result of %0s.", target_hn_node_idx_0, target_hn_node_index_0_status ? "config DB" : "Randomization")); 

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    //If there are participating RN-F nodes in the system, set the cache_line_init_rn_f_node_index to any one of them
    if(active_participating_rn_f_nodes.size()) begin
      cache_line_init_rn_f_node_index = active_participating_rn_f_nodes[0];
      perform_cache_initialization=1;
    end
    /**
     * If the cache_line_init_rn_f_node_index is same as any of the initiating RN node indices 
     * initiating_rn_node_idx_0,initiating_rn_node_idx_1,
     * then re-assign the cache_line_init_rn_f_node_index with RN node index ,which is active,
     * participating and not equal to initiating_rn_node_idx_0, initiating_rn_node_idx_1.
     */
      if((cache_line_init_rn_f_node_index == initiating_rn_node_idx_0)||(cache_line_init_rn_f_node_index == initiating_rn_node_idx_1))begin  
        int active_participating_q [$];
        `svt_chi_xxm_debug("body",$sformatf("cache_line_init_rn_f_node_index= %0d is same as initiating_rn_node_idx_0=%0d or initiating_rn_node_idx_1=%0d and active_participating_rn_f_nodes.size()= %0d",cache_line_init_rn_f_node_index,initiating_rn_node_idx_0,initiating_rn_node_idx_1,active_participating_rn_f_nodes.size()));
        active_participating_q = active_participating_rn_f_nodes.find with ((item != initiating_rn_node_idx_0) && (item != initiating_rn_node_idx_1));
        //If there are RN-Fs that do not coincide with initiating_rn_node_idx_0 and initiating_rn_node_idx_1, set one of them as cache_line_init_rn_f_node_index
        if(active_participating_q.size()>0)begin
          cache_line_init_rn_f_node_index = active_participating_q.pop_back();
          perform_cache_initialization=1;
          `svt_chi_xxm_debug("body", $sformatf("active_participating_q.size() is %0d and Selected different cache_line_init_rn_f_node_index=%0d", active_participating_q.size(),cache_line_init_rn_f_node_index));
          active_participating_q.delete();
        //If there are no other RN-Fs in the system, check if both initiating RN node index 0 and 1 are RN-Fs. If yes, then set cache_line_init_rn_f_node_index to one of the initiating RN nodes (we will initiate cache init transactions fromm both RN-Fs, so it does not matter which index we set cache_line_init_rn_f_node_index to). If no, then cache initialization cannot be performed.
        end else begin
          if((is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_node_idx_0, array_idx)) && (is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_node_idx_1, array_idx))) begin
            perform_cache_initialization=1;
            `svt_chi_xxm_debug("body",$sformatf("Selected cache_line_init_rn_f_node_index= %0d is same as initiating_rn_node_index_0=%0d or initiating_rn_node_index_1=%0d and active_participating_rn_f_nodes.size()= %0d. Cache initialization will be performed from initiating_rn_node_index_0 and initiating_rn_node_index_1",cache_line_init_rn_f_node_index,initiating_rn_node_index_0_from_config_db,initiating_rn_node_index_1_from_config_db,active_participating_rn_f_nodes.size()));
          end else begin
            perform_cache_initialization=0;
          end
        end
      end

    /**
     * If the cache_line_init_rn_f_node_index is not part of active_participating_rn_f_nodes array, then we cannot
     * perform cache initialization.
     */
    if (!(is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, cache_line_init_rn_f_node_index, array_idx))) begin
      perform_cache_initialization = 0;
    end

    `svt_xvm_debug("body", $sformatf("perform_cache_initialization is %0b, cache_line_init_rn_f_node_index is %0d, initiating_rn_node_idx_0 is %0d, initiating_rn_node_idx_1 is %0d", perform_cache_initialization, cache_line_init_rn_f_node_index, initiating_rn_node_idx_0, initiating_rn_node_idx_1));    

    //If max outstanding count for Write transactions has been programmed, use that to generate the outstanding Writes
    if(max_num_outstanding_atomic_xacts_at_hn > 0) begin
      num_outstanding_xacts_to_generate = max_num_outstanding_atomic_xacts_at_hn;
      `svt_xvm_debug("body",$sformatf("max_num_outstanding_atomic_xacts_at_hn is set to a non-zero value (%0d). Hence, the value programmed in max_num_outstanding_xacts_at_hn will be ignored. The number of outstanding transactions issued by the sequence will be equal to max_num_outstanding_atomic_xacts_at_hn", max_num_outstanding_atomic_xacts_at_hn));
    end
    //If not, use the max outstanding transaction count
    else
      num_outstanding_xacts_to_generate = max_num_outstanding_xacts_at_hn;

    for(int k = 0; k < sequence_length; k++) begin
      
      if(perform_cache_initialization) begin  
        
        `svt_xvm_debug("body",$sformatf("Starting cache initialization for %0d addresses from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d",
                                        num_outstanding_xacts_to_generate, cache_line_init_rn_f_node_index, target_hn_node_idx_0));
        
        for(int i = 0; i < num_outstanding_xacts_to_generate; i++) begin
          //cache_line_init_rn_f_node_index will be set to initiating_rn_node_idx_1 or initiating_rn_node_idx_0 only when there are only 2 RN-Fs in the system. In such a case,
          //the cache init transactions must be issued alternately from initiating_rn_node_idx_1 and
          //initiating_rn_node_idx_0 respectively
          if(cache_line_init_rn_f_node_index == initiating_rn_node_idx_1 || cache_line_init_rn_f_node_index == initiating_rn_node_idx_0) begin
            if(i % 2 == 0) 
              cache_line_init_rn_f_node_index = initiating_rn_node_idx_1;
            else
              cache_line_init_rn_f_node_index = initiating_rn_node_idx_0; 
          end
        
          /** Write data into Cache of Randomly selected first RN-F with address of randomly selected HN Node */
          `svt_xvm_do_on_with(makeunique_seq[i],p_sequencer.rn_virt_seqr[cache_line_init_rn_f_node_index].rn_xact_seqr,
          {
           sequence_length   == 1;
           hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
           seq_hn_node_idx   == target_hn_node_idx_0;
           use_seq_is_non_secure_access == 0;
          })
          
          `svt_xvm_debug("body", $sformatf("%0s Waiting for MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) to end",`SVT_CHI_PRINT_PREFIX(makeunique_seq[i].write_tran),i, makeunique_seq[i].write_tran.hn_node_idx, makeunique_seq[i].write_tran.tgt_id));
          makeunique_seq[i].write_tran.wait_end();
          `svt_xvm_debug("body", $sformatf("%0s MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) ended",`SVT_CHI_PRINT_PREFIX(makeunique_seq[i].write_tran),i, makeunique_seq[i].write_tran.hn_node_idx, makeunique_seq[i].write_tran.tgt_id));
          /** Queue for collecting the address of makeunique transactions */
          addr_q.push_back(makeunique_seq[i].output_xacts[0].addr);
          txn_is_non_secure_access_q.push_back(makeunique_seq[i].output_xacts[0].is_non_secure_access);
          `svt_xvm_verbose("body", $sformatf("MakeUnique transaction [%0d] is %0s", i,makeunique_seq[i].write_tran.sprint()));

          /** Wait for MakeUnique transactions to finish */ 
          txn_address = makeunique_seq[i].output_xacts[0].addr;
          txn_data = makeunique_seq[i].data_in_cache;
          txn_mem_attr_allocate_hint = makeunique_seq[i].output_xacts[0].mem_attr_allocate_hint;
          txn_snp_attr_snp_domain_type = makeunique_seq[i].output_xacts[0].snp_attr_snp_domain_type;
          txn_is_non_secure_access = makeunique_seq[i].output_xacts[0].is_non_secure_access;

          /** Writeback the data to the main memory at the respective address. */ 
          `svt_xvm_do_on_with(copyback_seq[i], p_sequencer.rn_virt_seqr[cache_line_init_rn_f_node_index].rn_xact_seqr,
          {
            sequence_length == 1;
            data_in_cache == txn_data;
            seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
            hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
            min_addr == txn_address;
            max_addr == txn_address;
            seq_xact_type == svt_chi_transaction::WRITEBACKFULL;
            seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
            seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
            seq_is_non_secure_access == txn_is_non_secure_access;
            use_seq_is_non_secure_access == 1;                      
          }
          )
          /** Waiting for copyback transaction to complete */ 
          copyback_seq[i].copyback_tran.wait_end();
        end
        
        `svt_xvm_debug("body",$sformatf("Ended cache initialization for %0d addresses from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d",
                                        num_outstanding_xacts_to_generate, cache_line_init_rn_f_node_index, target_hn_node_idx_0));
      end // if (perform_cache_initialization)
      
      `svt_xvm_debug("body",$sformatf("Starting transmission of Atomic type transactions for %0d addresses with suspend_wr_data set to 1",num_outstanding_xacts_to_generate));
      //for(int i = 0; i < num_outstanding_xacts_to_generate/2; i++) begin
      fork
        /** 
           * Do 128 transactions from each of the two different RNs each to all MAKEUNIQUE 
           * transaction address of same HN node with suspend response*/ 
        begin
          for(int i = 0; i < (num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2); i++) begin
            `svt_xvm_debug("body",$sformatf("Sending Atomic type transactions from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d with suspend_wr_data set to 1",initiating_rn_node_idx_0, target_hn_node_idx_0));
            `svt_xvm_do_on_with(atomic_seq[2*i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
            {
             sequence_length               == 1;
             seq_txn_id                    == (i % num_outstanding_xacts_to_generate);
             /** Transactions are set to ordered at requestor for stream WriteUniques transactions. */
             seq_order_type   == svt_chi_transaction::NO_ORDERING_REQUIRED;
             if (perform_cache_initialization) { 
               hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
               min_addr          == addr_q[2*i];
               max_addr          == addr_q[2*i];
               seq_is_non_secure_access == txn_is_non_secure_access_q[2*i];
               use_seq_is_non_secure_access == 1;              
             }
             else {
               hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
               seq_hn_node_idx == target_hn_node_idx_0;
               use_seq_is_non_secure_access == 0;
             }
            })
           
            `svt_xvm_debug("body", $sformatf("%0s Transmitting Atomic Transaction [%0d] targeted to HN (idx %0d, id %0d) ",`SVT_CHI_PRINT_PREFIX(atomic_seq[2*i].atomic_tran),2*i, atomic_seq[2*i].atomic_tran.hn_node_idx, atomic_seq[2*i].atomic_tran.tgt_id));
            `svt_xvm_verbose("body", $sformatf("Atomic Transaction [%0d] is %0s", 2*i,atomic_seq[2*i].atomic_tran.sprint()));

          end
        end
        begin
          for(int i = 0; i < num_outstanding_xacts_to_generate/2; i++) begin
            `svt_xvm_debug("body",$sformatf("Sending Atomic type transactions from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d with suspend_wr_data set to 1",initiating_rn_node_idx_0, target_hn_node_idx_0));
            `svt_xvm_do_on_with(atomic_seq[2*i + 1], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,
            {
             sequence_length               == 1;
             `ifdef SVT_CHI_ISSUE_E_ENABLE
              if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision >= svt_chi_node_configuration::ISSUE_E) {
               seq_txn_id         == (i*3);
              }
              else{
               seq_txn_id         == (i % num_outstanding_xacts_to_generate);
              }
             `else
               seq_txn_id         == (i % num_outstanding_xacts_to_generate);
             `endif
             /** Transactions are set to ordered at requestor for stream WriteUniques transactions. */
             seq_order_type   == svt_chi_transaction::NO_ORDERING_REQUIRED;
             if (perform_cache_initialization) {
               hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
               min_addr           == addr_q[2*i + 1];
               max_addr           == addr_q[2*i + 1];
               seq_is_non_secure_access == txn_is_non_secure_access_q[2*i+ 1];
               use_seq_is_non_secure_access == 1;              
       
             }
             else {
               hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
               seq_hn_node_idx == target_hn_node_idx_0;
               use_seq_is_non_secure_access == 0;       
             }
            })
          
            `svt_xvm_debug("body", $sformatf("%0s Transmitting Atomic Transaction [%0d] targeted to HN (idx %0d, id %0d) ",`SVT_CHI_PRINT_PREFIX(atomic_seq[2*i + 1].atomic_tran),2*i + 1, atomic_seq[2*i + 1].atomic_tran.hn_node_idx, atomic_seq[2*i + 1].atomic_tran.tgt_id));
            `svt_xvm_verbose("body", $sformatf("Atomic Transaction [%0d] is %0s", 2*i + 1,atomic_seq[2*i + 1].atomic_tran.sprint()));
          end
        end
      join
     // end //for(int i = 0; i < num_outstanding_xacts_to_generate/2; i++)  
      
      /** Waiting for the DBIDResp responses from HN for atomic trasactions */
      foreach(atomic_seq[wr]) begin
        fork
          automatic int _wr = wr;
          begin
            `svt_xvm_debug("body", $sformatf("%0s Atomic transaction [%0d] targeted to HN (idx %0d, id %0d), suspend_wr_data %0b: waiting for response from interconnect",`SVT_CHI_PRINT_PREFIX(atomic_seq[_wr].atomic_tran),_wr, atomic_seq[_wr].atomic_tran.hn_node_idx, atomic_seq[_wr].atomic_tran.tgt_id,atomic_seq[_wr].atomic_tran.suspend_wr_data));
            fork
            begin
              fork
                begin
                  atomic_seq[_wr].atomic_tran.wait_for_tx_data_prereqs();
                end
                begin
                  wait(atomic_seq[_wr].atomic_tran.req_status == svt_chi_transaction::RETRY);// begin
                end
              join_any
              disable fork;
            end
            join
            received_responses++;
            `svt_xvm_debug("body", $sformatf("%0s Atomic transaction [%0d] targeted to HN (idx %0d, id %0d), suspend_wr_data %0b: received response from interconnect. Total responses received %0d",`SVT_CHI_PRINT_PREFIX(atomic_seq[_wr].atomic_tran),_wr, atomic_seq[_wr].atomic_tran.hn_node_idx, atomic_seq[_wr].atomic_tran.tgt_id,atomic_seq[_wr].atomic_tran.suspend_wr_data,received_responses));
          end
        join_none
      end

      /** Wait until All DBIDResp responses are received for atomic transaction */ 
      `svt_xvm_debug("body",$sformatf("Completed initiation of Atomic type transactions for %0d addresses from p_sequencer.rn_virt_seqr[%0d] and p_sequencer.rn_virt_seqr[%0d] to HN idx %0d with suspend_wr_data set to 1, and waiting to receive responses from interconnect.",
                                num_outstanding_xacts_to_generate, initiating_rn_node_idx_0,initiating_rn_node_idx_1,target_hn_node_idx_0));
      wait(received_responses == num_outstanding_xacts_to_generate);
      `svt_xvm_debug("body",$sformatf("Received responses from interconnect to Write type transactions for %0d addresses from p_sequencer.rn_virt_seqr[%0d] and p_sequencer.rn_virt_seqr[%0d] to HN idx %0d with suspend_wr_data set to 1.",
                                num_outstanding_xacts_to_generate, initiating_rn_node_idx_0,initiating_rn_node_idx_1,target_hn_node_idx_0));
     
      /** Self Check1: To check suspend_wr_data should not be modified to zero by the VIP
       *  before reseting from test bench.
       */
      foreach (atomic_seq[self_check_idx1]) begin
        if (!atomic_seq[self_check_idx1].atomic_tran.is_terminated()) begin
          if (atomic_seq[self_check_idx1].atomic_tran.suspend_wr_data == 0) begin
            `svt_xvm_error("body", $sformatf("%0s suspend_wr_data should be 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(atomic_seq[self_check_idx1].atomic_tran)));
          end
          else begin
            `svt_xvm_debug("body", $sformatf("%0s suspend_wr_data is 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(atomic_seq[self_check_idx1].atomic_tran)));
          end
        end
      end

      /** Self Check2: To check transaction is not ended by the VIP before resuming the 
       *  suspend_wr_data to zero from the test bench
       */
      foreach(atomic_seq[self_check_idx2]) begin
        if (!atomic_seq[self_check_idx2].atomic_tran.is_terminated()) begin
          if (atomic_seq[self_check_idx2].atomic_tran.end_event.is_on() == 1) begin
            `svt_xvm_error("body", $sformatf("Unexpected: %0s Transaction's end_event triggered when suspend_wr_data is still 1.", `SVT_CHI_PRINT_PREFIX(atomic_seq[self_check_idx2].atomic_tran)));
          end
          else begin
            `svt_xvm_debug("body", $sformatf("Expected: %0s Transaction's end_event is not triggered when suspend_wr_data is still 1.", `SVT_CHI_PRINT_PREFIX(atomic_seq[self_check_idx2].atomic_tran)));
          end
        end
      end
 
      /** Self Check 3: To check that the current_outstanding_*_xact_count in the RNs
       * are as per the transactions inititated by the sequence
       */
      /** Check if the total outstanding xact counter is set correctly in the shared status of the RN agent */
      if(atomic_seq[0].shared_status.prot_status.current_outstanding_xact_count != (num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2))
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding transactions from the sequence but the outstanding transaction count in the shared status of RN%0d is %0d", (num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2), initiating_rn_node_idx_0, atomic_seq[0].shared_status.prot_status.current_outstanding_xact_count));
      /** Check if the outstanding Atomic xact counter is set correctly in the shared status of the RN agent */
      if(atomic_seq[0].shared_status.prot_status.current_outstanding_atomic_xact_count != (num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2)) begin
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding Write transactions from the sequence but the outstanding Write transaction count in the shared status of RN%0d is %0d", (num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2), initiating_rn_node_idx_0, atomic_seq[0].shared_status.prot_status.current_outstanding_atomic_xact_count));
      end
      /** Check if the total outstanding xact counter is set correctly in the shared status of the second RN agent */
      if(atomic_seq[1].shared_status.prot_status.current_outstanding_xact_count != num_outstanding_xacts_to_generate/2)
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding transactions from the sequence but the oustanding transaction count in the shared status of RN%0d is %0d", num_outstanding_xacts_to_generate/2, initiating_rn_node_idx_1, atomic_seq[1].shared_status.prot_status.current_outstanding_xact_count));
      /** Check if the outstanding Atomic xact counter is set correctly in the shared status of the RN agent */
      if(atomic_seq[1].shared_status.prot_status.current_outstanding_atomic_xact_count !=  num_outstanding_xacts_to_generate/2) begin
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding Atomic transactions from the sequence but the outstanding Atomic transaction count in the shared status of RN%0d is %0d", num_outstanding_xacts_to_generate/2, initiating_rn_node_idx_1, atomic_seq[1].shared_status.prot_status.current_outstanding_atomic_xact_count));
      end

      `svt_xvm_debug("body", $sformatf("RN%0d: Number of outstanding transactions : %0d, Number of outstanding atomic xacts : %0d", initiating_rn_node_idx_0, atomic_seq[0].shared_status.prot_status.current_outstanding_xact_count, atomic_seq[0].shared_status.prot_status.current_outstanding_atomic_xact_count));
      `svt_xvm_debug("body", $sformatf("RN%0d: Number of outstanding transactions : %0d, Number of outstanding atomic xacts : %0d", initiating_rn_node_idx_1, atomic_seq[0].shared_status.prot_status.current_outstanding_xact_count, atomic_seq[1].shared_status.prot_status.current_outstanding_atomic_xact_count));

      /** Resuming all NonCopyBackWrData for above atomic transactions */
      `svt_xvm_debug("body",$sformatf("Resuming the atomic transactions by setting svt_chi_rn_transaction::suspsend_wr_data set to 0"))
      foreach(atomic_seq[index4]) begin
        atomic_seq[index4].atomic_tran.suspend_wr_data = 0;
        `svt_xvm_debug("body", $sformatf("After Resume received_responses is %0d for iteration %0d and suspend_wr_data is %0b",received_responses, index4, atomic_seq[index4].atomic_tran.suspend_wr_data));
      end

      /** Waiting for Atomic transactions to complete*/
      `svt_xvm_debug("body",$sformatf("Waiting for completion of all the outstanding atomic type transactions"));
      foreach(atomic_seq[self_check_idx3]) begin
        `svt_xvm_debug("body", $sformatf("Waiting for above atomic_seq[%0d] transaction %0s to end", self_check_idx3, `SVT_CHI_PRINT_PREFIX(atomic_seq[self_check_idx3].atomic_tran)));
        atomic_seq[self_check_idx3].atomic_tran.wait_end();

        /** Self Check4: To check suspend_wr_data should not be asserted after the transaction
         *  completes as it is reseted from test bench
         */
        if (!atomic_seq[self_check_idx3].atomic_tran.is_terminated()) begin
          if (atomic_seq[self_check_idx3].atomic_tran.suspend_wr_data == 1) begin
            `svt_xvm_error("body", $sformatf("%0s suspend_wr_data should be 0 as it has been reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(atomic_seq[self_check_idx3].atomic_tran)));
          end
          else begin
            `svt_xvm_debug("body", $sformatf("%0s suspend_wr_data is 0 as it is reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(atomic_seq[self_check_idx3].atomic_tran)));
          end
        end
      end
      `svt_xvm_debug("body",$sformatf("Received completions for all atomic type outstanding transactions"));
      
      /** Targeted HN IDs from both RNs should be same */
      for(int index_5 = 0; index_5 < num_outstanding_xacts_to_generate/2; index_5++) begin
        int hn_idx_0, hn_idx_1;
        hn_idx_0 = sys_cfg.get_hn_idx(atomic_seq[2*index_5].output_xacts[0].addr);
        hn_idx_1 = sys_cfg.get_hn_idx(atomic_seq[2*index_5 + 1].output_xacts[0].addr);
        if ((hn_idx_0 == target_hn_node_idx_0) && (hn_idx_0 == hn_idx_1)) begin
          /** pass */
          `svt_xvm_debug("body", $sformatf("Targeted HN Index from both RNs are same as expected.  rn[%0d] to hn_idx[%0d], rn[%0d] to hn_idx[%0d] and they match with the target_hn_node_idx_0 %0d", initiating_rn_node_idx_0, hn_idx_0, initiating_rn_node_idx_1, hn_idx_1,target_hn_node_idx_0));
        end
        else begin
          /** fail */
          `svt_xvm_error("body", $sformatf("Targeted HN Index from both RNs are different, which is unexpected.  rn[%0d] %0s transaction to hn_idx[%0d], rn[%0d] %0s transaction to hn_idx[%0d] and one or both of hn_idx don't match with the target_hn_node_idx_0 %0d ",initiating_rn_node_idx_0, `SVT_CHI_PRINT_PREFIX( atomic_seq[2*index_5].output_xacts[0]), hn_idx_0, initiating_rn_node_idx_1, `SVT_CHI_PRINT_PREFIX( atomic_seq[2*index_5 + 1].output_xacts[0]), hn_idx_1,target_hn_node_idx_0));
        end
      end
     
      /** Reset received_responses to zero */
      received_responses = 0;
      
      /** Delete the contents of address collection queue */
      addr_q.delete();

    end //for(int k = 0; k < sequence_length; k++)
    
    `svt_xvm_debug("body", "Exiting...")
  endtask: body

  virtual task post_body();
    drop_phase_objection();
  endtask

endclass: svt_chi_system_protocol_flow_ctrl_atomic_outstanding_diff_rn_same_hn_virtual_sequence

function svt_chi_system_protocol_flow_ctrl_atomic_outstanding_diff_rn_same_hn_virtual_sequence::new(string name="svt_chi_system_protocol_flow_ctrl_atomic_outstanding_diff_rn_same_hn_virtual_sequence");
  super.new(name);
endfunction

/**
 * @groupname CHI_OUTSTANDING_ATOMIC_TYPE  
 * #- This sequence requires at least two HN nodes to be present in the Interconnect.
 * #- This sequence requires two initiating active and participating RNs.
 * #- If another active and participating RN-F exists, perform cache
 *    initialization to two randomly selected HNs.
 * #- Initiate Atomic type transactions with 
 *    svt_chi_rn_transaction::suspend_wr_data set  to 1 each from both the initiating RNs, 128 each to randomly 
 *    selected two HNs from each of the RN in non blocking mode. <br>
 *    - Maximum number of outstanding transactions at the HN is as per either #max_num_outstanding_atomic_xacts_at_hn or
 *      #max_num_outstanding_xacts_at_hn, which can be controlled through config DB.   
 *    - This ensures that the maximum outstanding transaction limit is reached at both the HNs.
 *    - Also, the RNs will not transmit NonCopyBackWrData corresponding to these transactions
 *      until svt_chi_rn_transaction::suspend_wr_data is set to 0 from the sequence.
 *    .
 * #- The addresses of these atomic transactions are such that:
 *    - Same as initialized cache line addresses if cache initialization is performed
 *    - Otherwise, random addresses targeting both the HNs
 *    .
 * #- Once the RNs receive the responses for all the outstanding transactions from
 *    both of the HNs, svt_chi_rn_transaction::suspend_wr_data is set to 0 for all the outstanding
 *    transactions. <br>
 *    This ensures that the NonCopyBackWrData for these transactions can be resumed 
 *    from the RNs.
 * #- Check that both of the HNs respond properly for all outstanding atomic type transactions
 *    and these are completed successfully.
 * .
 */
class svt_chi_system_protocol_flow_ctrl_atomic_outstanding_diff_rn_diff_hn_virtual_sequence extends svt_chi_system_base_virtual_sequence;
  
  //-----------------------------------------------------------------------------  
  // Member attributes
  //-----------------------------------------------------------------------------  

  /** To display contents of Active Participating RN's node info. */
  string str_rn_node;

  /** To display contents of Active Participating RN-F's node info. */
  string str_rn_f_node;

  /** UVM/OVM Object Utility macro */
  `svt_xvm_object_utils(svt_chi_system_protocol_flow_ctrl_atomic_outstanding_diff_rn_diff_hn_virtual_sequence)

  //-----------------------------------------------------------------------------  
  // Methods
  //-----------------------------------------------------------------------------
  /** Constructor */
  extern function new(string name="svt_chi_system_protocol_flow_ctrl_atomic_outstanding_diff_rn_diff_hn_virtual_sequence");

  //-----------------------------------------------------------------------------
  /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting any type of Request Nodes = 2
   *  #- Minimum required number of HN Nodes = 2   
   *  .
   */
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    
    /** local variables */
    int num_supporting_request_nodes;
    int num_hn_f_nodes;   
    int array_idx;
    bit is_rn_idx_0_participating, is_rn_idx_1_participating;
    string str_is_supported_info_prefix = "";
    string str_is_supported_info = "";
    string str_idx0_info = "";
    string str_idx1_info = "";    
    /** Supporting any type of Request Nodes required */
    int required_num_supporting_request_nodes = 2;
    int required_num_hn_nodes = 2;
    
    `svt_xvm_debug("is_supported",$sformatf("Entering ..."));

    /** By default is_supported is 0 */
    is_supported = 0;
    
    /** Check for minimum required HN nodes */
    num_hn_f_nodes = hn_f_nodes.size();
    
    /** Check requirment of number of HN nodes needed */
    if (num_hn_f_nodes < required_num_hn_nodes) begin
      issue_is_supported_failure($sformatf("This sequence requires minimum %0d HN-F nodes to be present in the system. Number of HN-F nodes are %0d. Program number of HN nodes using svt_chi_system_configuration::num_hn. Program the HN interface type using svt_chi_system_configuration::chi_addr_cfg.hn_interface_type[].", required_num_hn_nodes, num_hn_f_nodes));
      return 0;      
    end
    
    /** Check for minimum required RN nodes.
     *  Also check whether the selected RN nodes are part of participating arrays or not.
     */    
    num_supporting_request_nodes = active_participating_rn_nodes.size();

    /** Check the requirements of RN nodes */
    if (num_supporting_request_nodes) begin
      /** Display the contents of Active Participating RN Nodes */
      foreach (active_participating_rn_nodes[j]) begin
        str_rn_node = {str_rn_node, $sformatf(" %0d", active_participating_rn_nodes[j])};
      end 
      `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_nodes are %0s", str_rn_node));
    end

    str_is_supported_info_prefix = $sformatf("Number of Supporting RN Node(s)  - Minimum Required : %0d Current : %0d", required_num_supporting_request_nodes, num_supporting_request_nodes);
    
    if ((initiating_rn_node_index_0_status==0)&&(valid_initiating_rn_node_index_0==0)) begin
        str_idx0_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN's that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F or RN_I)";
    end
    else begin
      is_rn_idx_0_participating = is_value_found_in_int_assoc_array(active_participating_rn_nodes, initiating_rn_node_idx_0, array_idx);
      if (!is_rn_idx_0_participating) begin
        str_idx0_info = $sformatf("initiating_rn_node_idx_0 %0d is not valid for this sequence. The RN corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuration::participating_rn_nodes[])", initiating_rn_node_idx_0, initiating_rn_node_idx_0);
      end
    end
    if ((initiating_rn_node_index_1_status==0)&&(valid_initiating_rn_node_index_1==0)) begin
        str_idx1_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN's that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F or RN_I)";
    end
    else begin
      is_rn_idx_1_participating = is_value_found_in_int_assoc_array(active_participating_rn_nodes, initiating_rn_node_idx_1, array_idx);
      if (!is_rn_idx_1_participating) begin
        str_idx1_info = $sformatf("initiating_rn_node_idx_1 %0d is not valid for this sequence. The RN corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuration::participating_rn_nodes[])", initiating_rn_node_idx_1, initiating_rn_node_idx_1);
      end
    end

    if (is_rn_idx_0_participating && is_rn_idx_1_participating) begin
      is_supported = 1;
      if(max_num_outstanding_atomic_xacts_at_hn > 0) begin
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].num_outstanding_atomic_xact < max_num_outstanding_atomic_xacts_at_hn) begin
          str_idx0_info = $sformatf("Programmed value of max_num_outstanding_atomic_xacts_at_hn_status is %0d. But num_outstanding_atomic_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_atomic_xact of the initiating RN node must be equal to or greater than max_num_outstanding_atomic_xacts_at_hn_status of the target HN", max_num_outstanding_atomic_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_0_participating].num_outstanding_atomic_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].num_outstanding_atomic_xact < max_num_outstanding_atomic_xacts_at_hn) begin
          str_idx1_info = $sformatf("Programmed value of max_num_outstanding_atomic_xacts_at_hn_status is %0d. But num_outstanding_atomic_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_atomic_xact of the initiating RN node must be equal to or greater than max_num_outstanding_atomic_xacts_at_hn_status of the target HN", max_num_outstanding_atomic_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_1_participating].num_outstanding_atomic_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
      end else begin
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].num_outstanding_xact < max_num_outstanding_xacts_at_hn) begin
          str_idx0_info = $sformatf("Programmed value of max_num_outstanding_xacts_at_hn_status is %0d. But num_outstanding_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_xact of the initiating RN node must be equal to or greater than max_num_outstanding_xacts_at_hn of the target HN", max_num_outstanding_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_0_participating].num_outstanding_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].num_outstanding_xact < max_num_outstanding_xacts_at_hn) begin
          str_idx1_info = $sformatf("Programmed value of max_num_outstanding_xacts_at_hn_status is %0d. But num_outstanding_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_xact of the initiating RN node must be equal to or greater than max_num_outstanding_xacts_at_hn of the target HN", max_num_outstanding_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_1_participating].num_outstanding_xact, initiating_rn_node_idx_1);
          is_supported = 0;
        end
      end
    end
    
    if (!is_supported) begin
      str_is_supported_info = $sformatf("%0s%0s",str_idx0_info, str_idx1_info);
      if (is_rn_idx_0_participating && is_rn_idx_1_participating) begin
        issue_is_supported_failure($sformatf("This sequence cannot be run based on the current system configuration.\n\
                                              %0s\n\
                                              %0s \n\
                                              Modify configurations through \n\
                                              svt_chi_system_configuration::num_rn,\n\
                                              svt_chi_node_configuration::is_active,\n\
                                              svt_chi_system_configuration::participating_rn_nodes[]\n\
                                              ", str_is_supported_info_prefix, str_is_supported_info));
      end
      else begin
        issue_is_supported_failure($sformatf("This sequence cannot be run based on the current node configurations of RN%0d and/or RN%0d.\n\
                                              %0s \n\
                                              Modify configuration through \n\
                                              svt_chi_node_configuration::num_outstanding_xact,\n\
                                              svt_chi_node_configuration::num_outstanding_atomic_xact,\n\
                                              ",str_is_supported_info, initiating_rn_node_idx_0, initiating_rn_node_idx_1));
      end
    end      
    `svt_xvm_debug("is_supported",$sformatf("Exiting ..."));
    if (!is_target_hn_idx_valid_for_curr_cfg()) begin
      is_supported = 0;
      `svt_xvm_note("is_supported", "not a valid hn_idx based on random_tgt_id_enable for current cfg");
    end
  endfunction : is_supported

  virtual task pre_start();
    bit status;
    /** Status field for capturing config DB get status for request_ordering */  
    bit request_ordering_status;
    /** Variable used to decide if request ordering in the transaction must be set or not.
     *  This can be programmed using config DB.
     *  If not programmed, the request ordering field in the generated transaction will be randomized
     */
    int request_ordering = -1;
    `svt_xvm_debug("pre_start",$sformatf("Entering ..."));
    super.pre_start();
    raise_phase_objection();
  endtask // pre_start

  /** Drop objection */
  virtual task post_start();
    super.post_start();
    drop_phase_objection();
  endtask: post_start

  virtual task body();
    /** Queue of addresses, used by the transactions generated */
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0] addr_q[$];
    bit txn_is_non_secure_access_q[$];

    /** Flag to track whether cache initialization needs to be performed or not*/
    bit                                perform_cache_initialization;
    int                                array_idx;
    int                                num_outstanding_xacts_to_generate;
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0] txn_address;
    bit [`SVT_CHI_MAX_DATA_WIDTH -1:0] txn_data;
    bit txn_mem_attr_allocate_hint, txn_snp_attr_snp_domain_type, txn_is_non_secure_access;
    /** Metric variables */
    int received_responses = 0;
    int total_num_tran = 0;

    /** Sub Atomic type transaction directed sequences initiated from this sequence */
    svt_chi_rn_atomic_type_transaction_directed_sequence atomic_seq[int];
    
    /** Sub Read type transaction cache initialization directed sequences initiated from this sequence */
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq[int];
    svt_chi_rn_copyback_type_transaction_directed_sequence copyback_seq[int];

    super.body();

    `svt_xvm_debug("body", "Entering ...")

    max_num_outstanding_xacts_at_hn_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(), "max_num_outstanding_xacts_at_hn", max_num_outstanding_xacts_at_hn);
    max_num_outstanding_atomic_xacts_at_hn_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(), "max_num_outstanding_atomic_xacts_at_hn", max_num_outstanding_atomic_xacts_at_hn);
    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :initiating_rn_node_index_0;
    initiating_rn_node_idx_1 = initiating_rn_node_index_1_status ? initiating_rn_node_index_1_from_config_db :initiating_rn_node_index_1;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_node_index_0;
    target_hn_node_idx_1 = target_hn_node_index_1_status ? target_hn_node_index_1_from_config_db :target_hn_node_index_1;

    `svt_xvm_debug("body", $sformatf("max_num_outstanding_xacts_at_hn is %0d as a result of %0s.", max_num_outstanding_xacts_at_hn, max_num_outstanding_xacts_at_hn_status ? "config DB" : "default"));
    `svt_xvm_debug("body", $sformatf("max_num_outstanding_atomic_xacts_at_hn is %0d as a result of %0s.", max_num_outstanding_atomic_xacts_at_hn, max_num_outstanding_atomic_xacts_at_hn_status ? "config DB" : "default"));
    `svt_xvm_debug("body", $sformatf("initiating_rn_node_idx_0 is %0d as a result of %0s.", initiating_rn_node_idx_0, initiating_rn_node_index_0_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("initiating_rn_node_idx_1 is %0d as a result of %0s.", initiating_rn_node_idx_1, initiating_rn_node_index_1_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("target_hn_node_idx_0 is %0d as a result of %0s.", target_hn_node_idx_0, target_hn_node_index_0_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("target_hn_node_idx_1 is %0d as a result of %0s.", target_hn_node_idx_1, target_hn_node_index_1_status ? "config DB" : "Randomization")); 

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    //If there are participating RN-F nodes in the system, set the cache_line_init_rn_f_node_index to any one of them
    if(active_participating_rn_f_nodes.size()) begin
      cache_line_init_rn_f_node_index = active_participating_rn_f_nodes[0];
      perform_cache_initialization=1;
    end
    /**
     * If the cache_line_init_rn_f_node_index is same as any of the initiating RN node indices 
     * initiating_rn_node_idx_0,initiating_rn_node_idx_1,
     * then re-assign the cache_line_init_rn_f_node_index with RN node index ,which is active,
     * participating and not equal to initiating_rn_node_idx_0, initiating_rn_node_idx_1.
     */
      if((cache_line_init_rn_f_node_index == initiating_rn_node_idx_0)||(cache_line_init_rn_f_node_index == initiating_rn_node_idx_1))begin  
        int active_participating_q [$];
        `svt_chi_xxm_debug("body",$sformatf("cache_line_init_rn_f_node_index= %0d is same as initiating_rn_node_idx_0=%0d or initiating_rn_node_idx_1=%0d and active_participating_rn_f_nodes.size()= %0d",cache_line_init_rn_f_node_index,initiating_rn_node_idx_0,initiating_rn_node_idx_1,active_participating_rn_f_nodes.size()));
        active_participating_q = active_participating_rn_f_nodes.find with ((item != initiating_rn_node_idx_0) && (item != initiating_rn_node_idx_1));
        //If there are RN-Fs that do not coincide with initiating_rn_node_idx_0 and initiating_rn_node_idx_1, set one of them as cache_line_init_rn_f_node_index
        if(active_participating_q.size()>0)begin
          cache_line_init_rn_f_node_index = active_participating_q.pop_back();
          perform_cache_initialization=1;
          `svt_chi_xxm_debug("body", $sformatf("active_participating_q.size() is %0d and Selected different cache_line_init_rn_f_node_index=%0d", active_participating_q.size(),cache_line_init_rn_f_node_index));
          active_participating_q.delete();
        //If there are no other RN-Fs in the system, check if both initiating RN node index 0 and 1 are RN-Fs. If yes, then set cache_line_init_rn_f_node_index to one of the initiating RN nodes (we will initiate cache init transactions fromm both RN-Fs, so it does not matter which index we set cache_line_init_rn_f_node_index to). If no, then cache initialization cannot be performed.
        end else begin
          if((is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_node_idx_0, array_idx)) && (is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_node_idx_1, array_idx))) begin
            perform_cache_initialization=1;
            `svt_chi_xxm_debug("body",$sformatf("Selected cache_line_init_rn_f_node_index= %0d is same as initiating_rn_node_index_0=%0d or initiating_rn_node_index_1=%0d and active_participating_rn_f_nodes.size()= %0d. Cache initialization will be performed from initiating_rn_node_index_0 and initiating_rn_node_index_1",cache_line_init_rn_f_node_index,initiating_rn_node_index_0_from_config_db,initiating_rn_node_index_1_from_config_db,active_participating_rn_f_nodes.size()));
          end else begin
            perform_cache_initialization=0;
          end
        end
      end

    /**
     * If the cache_line_init_rn_f_node_index is not part of active_participating_rn_f_nodes array, then we cannot
     * perform cache initialization.
     */
    if (!(is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, cache_line_init_rn_f_node_index, array_idx))) begin
      perform_cache_initialization = 0;
    end
    
    `svt_xvm_debug("body", $sformatf("perform_cache_initialization is %0b, cache_line_init_rn_f_node_index is %0d, initiating_rn_node_idx_0 is %0d, initiating_rn_node_idx_1 is %0d", perform_cache_initialization, cache_line_init_rn_f_node_index, initiating_rn_node_idx_0, initiating_rn_node_idx_1));    

    for(int k = 0; k < sequence_length; k++) begin
      //If max outstanding count for Atomic transactions has been programmed, use that to generate the outstanding Atomics
      if(max_num_outstanding_atomic_xacts_at_hn > 0) begin
        total_num_tran = (max_num_outstanding_atomic_xacts_at_hn * 2);
        `svt_xvm_debug("body",$sformatf("max_num_outstanding_atomic_xacts_at_hn is set to a non-zero value (%0d). Hence, the value programmed in max_num_outstanding_xacts_at_hn will be ignored. The number of outstanding transactions issued by the sequence will be equal to max_num_outstanding_atomic_xacts_at_hn", max_num_outstanding_atomic_xacts_at_hn));
      end
      else
        total_num_tran = (max_num_outstanding_xacts_at_hn * 2);
      `svt_xvm_debug("body", $sformatf("total_num_tran is %0d",total_num_tran));
      
      if(perform_cache_initialization) begin  
        
        `svt_xvm_debug("body",$sformatf("Starting cache initialization for %0d addresses from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d and HN idx %0d",
                                        total_num_tran, cache_line_init_rn_f_node_index, target_hn_node_idx_0,target_hn_node_idx_1));
      
        for(int i = 0; i < total_num_tran; i++) begin
          //cache_line_init_rn_f_node_index will be set to initiating_rn_node_idx_1 or initiating_rn_node_idx_0 only when there are only 2 RN-Fs in the system. In such a case,
          //the cache init transactions must be issued alternately from initiating_rn_node_idx_1 and
          //initiating_rn_node_idx_0 respectively
          if(cache_line_init_rn_f_node_index == initiating_rn_node_idx_1 || cache_line_init_rn_f_node_index == initiating_rn_node_idx_0) begin
            if(i % 2 == 0) 
              cache_line_init_rn_f_node_index = initiating_rn_node_idx_1;
            else
              cache_line_init_rn_f_node_index = initiating_rn_node_idx_0; 
          end
        
          /** Atomic data into Cache of Randomly selected first RN-F with address of randomly selected HN Node */
          `svt_xvm_do_on_with(makeunique_seq[i],p_sequencer.rn_virt_seqr[cache_line_init_rn_f_node_index].rn_xact_seqr,
          {
           sequence_length   == 1;
           hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
           seq_txn_id        == (i % (total_num_tran/2));
           if (i < total_num_tran/2) {
             seq_hn_node_idx == target_hn_node_idx_0;
           }
           else if(i < total_num_tran) {
              seq_hn_node_idx == target_hn_node_idx_1;
           }
          })

          `svt_xvm_debug("body", $sformatf("%0s Waiting for MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) to end",`SVT_CHI_PRINT_PREFIX(makeunique_seq[i].write_tran),i, makeunique_seq[i].write_tran.hn_node_idx, makeunique_seq[i].write_tran.tgt_id));
          makeunique_seq[i].write_tran.wait_end();
          `svt_xvm_debug("body", $sformatf("%0s MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) ended",`SVT_CHI_PRINT_PREFIX(makeunique_seq[i].write_tran),i, makeunique_seq[i].write_tran.hn_node_idx, makeunique_seq[i].write_tran.tgt_id));
          
          /** Collecting address into address queue*/
          addr_q.push_back(makeunique_seq[i].output_xacts[0].addr);
          txn_is_non_secure_access_q.push_back(makeunique_seq[i].output_xacts[0].is_non_secure_access);
          
          `svt_xvm_verbose("body", $sformatf("MakeUnique transaction [%0d] is %0s", i,makeunique_seq[i].write_tran.sprint()));
        end
        
        `svt_xvm_debug("body",$sformatf("Ended cache initialization for %0d addresses from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d and HN idx %0d",
                                        total_num_tran, cache_line_init_rn_f_node_index, target_hn_node_idx_0,target_hn_node_idx_1));
      end // if (perform_cache_initialization)

      `svt_xvm_debug("body",$sformatf("Starting transmission of Atomic type transactions for %0d addresses with suspend_wr_data set to 1",total_num_tran));
      for(int i = 0; i < total_num_tran/2; i++) begin
        fork
          /** 
           * Do transactions from each of the two different RNs each to all MAKEUNIQUE 
           * transaction address of the two different HN nodes, 128 each from one RN to one HN. 
           */ 
          begin
            if (i < total_num_tran/4) begin
              `svt_xvm_debug("body",$sformatf("Sending Atomic type transactions from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d ", initiating_rn_node_idx_0, target_hn_node_idx_0));
            end
            else begin
              `svt_xvm_debug("body",$sformatf("Sending Atomic type transactions from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d ", initiating_rn_node_idx_0, target_hn_node_idx_1));
            end
            
            `svt_xvm_do_on_with(atomic_seq[2*i],p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
            {
             sequence_length               == 1;
             seq_txn_id                    == (i % (total_num_tran/2));
             /** Transactions are set to ordered at requestor for Atomic transactions. */
             seq_order_type   == svt_chi_transaction::NO_ORDERING_REQUIRED;
             if (perform_cache_initialization) {  
               hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
               min_addr          == addr_q[2*i];
               max_addr          == addr_q[2*i];
               seq_is_non_secure_access == txn_is_non_secure_access_q[2*i+ 1];
               use_seq_is_non_secure_access == 1;              
       
             }
             else {
               hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
               use_seq_is_non_secure_access == 0;                  
               if (i < total_num_tran/4) {
                 seq_hn_node_idx == target_hn_node_idx_0;
               }
               else if(i < total_num_tran/2) {
                 seq_hn_node_idx == target_hn_node_idx_1;
               }
             }
            })
           
            `svt_xvm_debug("body", $sformatf("%0s Transmitting Atomic Transaction [%0d] targeted to HN (idx %0d, id %0d) ",`SVT_CHI_PRINT_PREFIX(atomic_seq[2*i].atomic_tran),2*i, atomic_seq[2*i].atomic_tran.hn_node_idx, atomic_seq[2*i].atomic_tran.tgt_id));
            `svt_xvm_verbose("body", $sformatf("Atomic Transaction [%0d] is %0s", 2*i,atomic_seq[2*i].atomic_tran.sprint()));

          end
          begin
            if (i < total_num_tran/4) begin
              `svt_xvm_debug("body",$sformatf("Sending Atomic type transactions from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d ", initiating_rn_node_idx_1, target_hn_node_idx_0));
            end
            else begin
              `svt_xvm_debug("body",$sformatf("Sending Atomic type transactions from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d ", initiating_rn_node_idx_1, target_hn_node_idx_1));
            end
            
            `svt_xvm_do_on_with(atomic_seq[2*i + 1],p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,
            {
             sequence_length               == 1;
             seq_txn_id                    == (i % (total_num_tran/2));
             /** Transactions are set to ordered at requestor for Atomic transactions. */
             seq_order_type   == svt_chi_transaction::NO_ORDERING_REQUIRED;
             if (perform_cache_initialization) {  
               hn_addr_rand_type             == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
               min_addr         == addr_q[2*i + 1];
               max_addr         == addr_q[2*i + 1];
               seq_is_non_secure_access == txn_is_non_secure_access_q[2*i+ 1];
               use_seq_is_non_secure_access == 1;              
       
             }
             else {
               hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
               use_seq_is_non_secure_access == 0;       
               if (i < total_num_tran/4) {
                 seq_hn_node_idx == target_hn_node_idx_0;
               }
               else if(i < total_num_tran/2) {
                 seq_hn_node_idx == target_hn_node_idx_1;
               }
             } 
            })
           
           `svt_xvm_debug("body", $sformatf("%0s Transmitting Atomic Transaction [%0d] targeted to HN (idx %0d, id %0d) ",`SVT_CHI_PRINT_PREFIX(atomic_seq[2*i + 1].atomic_tran),2*i + 1, atomic_seq[2*i + 1].atomic_tran.hn_node_idx, atomic_seq[2*i + 1].atomic_tran.tgt_id));
           `svt_xvm_verbose("body", $sformatf("Atomic Transaction [%0d] is %0s", 2*i + 1,atomic_seq[2*i + 1].atomic_tran.sprint()));
          end
        join
      end // for (int i = 0; i < total_num_tran/2; i++)

      /** Waiting for the DBIDResp responses from HN for atomic trasactions */
      foreach(atomic_seq[wr]) begin
        fork
          automatic int _wr = wr;
          begin
            `svt_xvm_debug("body", $sformatf("%0s Atomic transaction [%0d] targeted to HN (idx %0d, id %0d), suspend_wr_data %0b: waiting for response from interconnect",`SVT_CHI_PRINT_PREFIX(atomic_seq[_wr].atomic_tran),_wr, atomic_seq[_wr].atomic_tran.hn_node_idx, atomic_seq[_wr].atomic_tran.tgt_id,atomic_seq[_wr].atomic_tran.suspend_wr_data));
            fork
            begin
              fork
                begin
                  atomic_seq[_wr].atomic_tran.wait_for_tx_data_prereqs();
                end
                begin
                  wait(atomic_seq[_wr].atomic_tran.req_status == svt_chi_transaction::RETRY);// begin
                end
              join_any
              disable fork;
            end
            join
            received_responses++;
            `svt_xvm_debug("body", $sformatf("%0s Atomic transaction [%0d] targeted to HN (idx %0d, id %0d), suspend_wr_data %0b: received response from interconnect. Total responses received %0d",`SVT_CHI_PRINT_PREFIX(atomic_seq[_wr].atomic_tran),_wr, atomic_seq[_wr].atomic_tran.hn_node_idx, atomic_seq[_wr].atomic_tran.tgt_id,atomic_seq[_wr].atomic_tran.suspend_wr_data,received_responses));
          end
        join_none
      end

      /** Wait until All 512 DBIDResp responses are received for atomic transaction */ 
      `svt_xvm_debug("body",$sformatf("Completed initiation of Atomic type transactions for %0d addresses from p_sequencer.rn_virt_seqr[%0d] and p_sequencer.rn_virt_seqr[%0d] to HN idx %0d and HN idx %0d with suspend_wr_data set to 1, and waiting to receive responses from interconnect.",
                                total_num_tran, initiating_rn_node_idx_0,initiating_rn_node_idx_1,target_hn_node_idx_0,target_hn_node_idx_1));
      wait(received_responses == total_num_tran);
      `svt_xvm_debug("body",$sformatf("Received responses from interconnect to Atomic type transactions for %0d addresses from p_sequencer.rn_virt_seqr[%0d] and p_sequencer.rn_virt_seqr[%0d] to HN idx %0d and HN idx %0d with suspend_wr_data set to 1.",
                                total_num_tran, initiating_rn_node_idx_0,initiating_rn_node_idx_1,target_hn_node_idx_0,target_hn_node_idx_1));
     
      /** Self Check1: To check suspend_wr_data should not be modified to zero by the VIP
       *  before reseting from test bench.
       */
      foreach (atomic_seq[self_check_idx1]) begin
        if (!atomic_seq[self_check_idx1].atomic_tran.is_terminated()) begin
          if (atomic_seq[self_check_idx1].atomic_tran.suspend_wr_data == 0) begin
            `svt_xvm_error("body", $sformatf("%0s suspend_wr_data should be 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(atomic_seq[self_check_idx1].atomic_tran)));
          end
          else begin
            `svt_xvm_debug("body", $sformatf("%0s suspend_wr_data is 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(atomic_seq[self_check_idx1].atomic_tran)));
          end
        end
      end
     
      /** Self Check2: To check transaction is not ended by the VIP before resuming the 
       *  suspend_wr_data to zero from the test bench
       */
      foreach(atomic_seq[self_check_idx2]) begin
        if (!atomic_seq[self_check_idx2].atomic_tran.is_terminated()) begin
          if (atomic_seq[self_check_idx2].atomic_tran.end_event.is_on() == 1) begin
            `svt_xvm_error("body", $sformatf("Unexpected: %0s Transaction's end_event triggered when suspend_wr_data is still 1.", `SVT_CHI_PRINT_PREFIX(atomic_seq[self_check_idx2].atomic_tran)));
          end
          else begin
            `svt_xvm_debug("body", $sformatf("Expected: %0s Transaction's end_event is not triggered when suspend_wr_data is still 1.", `SVT_CHI_PRINT_PREFIX(atomic_seq[self_check_idx2].atomic_tran)));
          end
        end
      end
 
      /** Self Check 3: To check that the current_outstanding_*_xact_count in the RNs
       * are as per the transactions inititated by the sequence
       */
      /** Check if the total outstanding xact counter is set correctly in the shared status of the RN agent */
      if(atomic_seq[0].shared_status.prot_status.current_outstanding_xact_count != total_num_tran/2)
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding transactions from the sequence but the outstanding transaction count in the shared status of RN%0d is %0d", total_num_tran/2, initiating_rn_node_idx_0, atomic_seq[0].shared_status.prot_status.current_outstanding_xact_count));
      /** Check if the outstanding Atomic xact counter is set correctly in the shared status of the RN agent */
      if(atomic_seq[0].shared_status.prot_status.current_outstanding_atomic_xact_count != total_num_tran/2) begin
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding Atomic transactions from the sequence but the outstanding Atomic transaction count in the shared status of RN%0d is %0d", total_num_tran/2, initiating_rn_node_idx_0, atomic_seq[0].shared_status.prot_status.current_outstanding_atomic_xact_count));
      end
      /** Check if the total outstanding xact counter is set correctly in the shared status of the second RN agent */
      if(atomic_seq[1].shared_status.prot_status.current_outstanding_xact_count != total_num_tran/2)
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding transactions from the sequence but the oustanding transaction count in the shared status of RN%0d is %0d", total_num_tran/2, initiating_rn_node_idx_1, atomic_seq[1].shared_status.prot_status.current_outstanding_xact_count));
      /** Check if the outstanding Atomic xact counter is set correctly in the shared status of the RN agent */
      if(atomic_seq[1].shared_status.prot_status.current_outstanding_atomic_xact_count != total_num_tran/2) begin
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding Atomic transactions from the sequence but the outstanding Atomic transaction count in the shared status of RN%0d is %0d", total_num_tran/2, initiating_rn_node_idx_1, atomic_seq[1].shared_status.prot_status.current_outstanding_atomic_xact_count));
      end

      `svt_xvm_debug("body", $sformatf("RN%0d: Number of outstanding transactions : %0d, Number of outstanding atomic xacts : %0d", initiating_rn_node_idx_0, atomic_seq[0].shared_status.prot_status.current_outstanding_xact_count, atomic_seq[0].shared_status.prot_status.current_outstanding_atomic_xact_count));
      `svt_xvm_debug("body", $sformatf("RN%0d: Number of outstanding transactions : %0d, Number of outstanding atomic xacts : %0d", initiating_rn_node_idx_1, atomic_seq[0].shared_status.prot_status.current_outstanding_xact_count, atomic_seq[1].shared_status.prot_status.current_outstanding_atomic_xact_count));

      /** Resuming all NonCopyBackWrData for above atomic transactions */
      `svt_xvm_debug("body",$sformatf("Resuming the atomic transactions by setting svt_chi_rn_transaction::suspsend_wr_data set to 0"))
      foreach(atomic_seq[index4]) begin
        atomic_seq[index4].atomic_tran.suspend_wr_data = 0;
          `svt_xvm_debug("body", $sformatf("After Resume received_responses is %0d for iteration %0d and suspend_wr_data is %0b",received_responses, index4, atomic_seq[index4].atomic_tran.suspend_wr_data));
      end
      
      /** Waiting for Atomic transactions to complete */
      `svt_xvm_debug("body",$sformatf("Waiting for completion of all the outstanding atomic type transactions"));
      foreach(atomic_seq[self_check_idx3]) begin
        `svt_xvm_debug("body", $sformatf("Waiting for above atomic_seq[%0d] transaction %0s to end", self_check_idx3, `SVT_CHI_PRINT_PREFIX(atomic_seq[self_check_idx3].atomic_tran)));
        atomic_seq[self_check_idx3].atomic_tran.wait_end();
      
        /** Self Check4: To check suspend_wr_data should not be asserted after the transaction 
         *  completes as it is reseted from test bench
         */
        if (!atomic_seq[self_check_idx3].atomic_tran.is_terminated()) begin
          if (atomic_seq[self_check_idx3].atomic_tran.suspend_wr_data == 1) begin
            `svt_xvm_error("body", $sformatf("%0s suspend_wr_data should be 0 as it has been reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(atomic_seq[self_check_idx3].atomic_tran)));
          end
          else begin
            `svt_xvm_debug("body", $sformatf("%0s suspend_wr_data is 0 as it is reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(atomic_seq[self_check_idx3].atomic_tran)));
          end
        end
      end
      `svt_xvm_debug("body",$sformatf("Received completions for all atomic type outstanding transactions"));
     
      // Targetted HN IDs from both RNs should be different. Currently, this self-check is only performed
      // the number of outstanding transactions to be issued to an HN is a multiple of 2,ie, total_num_tran is a multiple of 4
      if((total_num_tran % 4) == 0) begin
        for(int i = 0; i<total_num_tran/2; i++)begin
          int hn_idx_0, hn_idx_1;
          hn_idx_0 = sys_cfg.get_hn_idx(atomic_seq[2*i].output_xacts[0].addr);
          hn_idx_1 = sys_cfg.get_hn_idx(atomic_seq[2*i + 1].output_xacts[0].addr);
          if(i < total_num_tran/4) begin
            if ((hn_idx_0 == hn_idx_1) && (hn_idx_0 == target_hn_node_idx_0)) begin
            // pass
              `svt_xvm_debug("body", $sformatf("Targeted HN Index from both RNs are same as expected.  rn[%0d] to hn_idx[%0d], rn[%0d] to hn_idx[%0d] and they match with the target_hn_node_idx_0 %0d", initiating_rn_node_idx_0, hn_idx_0, initiating_rn_node_idx_1, hn_idx_1,target_hn_node_idx_0));
            end
            else begin
            // fail
              `svt_xvm_error("body", $sformatf("Targeted HN Index from one or both of the RNs are different from first target node index, which is unexpected.  rn[%0d] %0s transaction to hn_idx[%0d], rn[%0d] %0s transaction to hn_idx[%0d] and the target_hn_node_idx_0 is %0d", initiating_rn_node_idx_0, `SVT_CHI_PRINT_PREFIX( atomic_seq[2*i].output_xacts[0]), hn_idx_0, initiating_rn_node_idx_1, `SVT_CHI_PRINT_PREFIX( atomic_seq[2*i + 1].output_xacts[0]), hn_idx_1,target_hn_node_idx_0));
            end
          end
          else if(i < total_num_tran/2) begin
            if ((hn_idx_0 == hn_idx_1) && (hn_idx_0 == target_hn_node_idx_1)) begin
            // pass
              `svt_xvm_debug("body", $sformatf("Targeted HN Index from both RNs are same as expected.  rn[%0d] to hn_idx[%0d], rn[%0d] to hn_idx[%0d] and they match with the target_hn_node_idx_1 %0d", initiating_rn_node_idx_0, hn_idx_0, initiating_rn_node_idx_1, hn_idx_1,target_hn_node_idx_1));
            end
            else begin
              // fail
              `svt_xvm_error("body", $sformatf("Targeted HN Index from one or both of the RNs is different from second target node index, which is unexpected.  rn[%0d] %0s transaction to hn_idx[%0d], rn[%0d] %0s transaction to hn_idx[%0d] and the target_hn_node_idx_1 is %0d", initiating_rn_node_idx_0, `SVT_CHI_PRINT_PREFIX( atomic_seq[2*i].output_xacts[0]), hn_idx_0, initiating_rn_node_idx_1, `SVT_CHI_PRINT_PREFIX( atomic_seq[2*i + 1].output_xacts[0]), hn_idx_1,target_hn_node_idx_1));
            end
          end
        end
      end
      
      /** Reset received_responses to zero */
      received_responses = 0;
      
      /** Delete the contents of address collection queue */
      addr_q.delete();
    
    end //for(int k = 0; k < sequence_length; k++)
    
    `svt_xvm_debug("body", "Exiting...")
  endtask: body

  virtual task post_body();
    drop_phase_objection();
  endtask
endclass:svt_chi_system_protocol_flow_ctrl_atomic_outstanding_diff_rn_diff_hn_virtual_sequence  

function svt_chi_system_protocol_flow_ctrl_atomic_outstanding_diff_rn_diff_hn_virtual_sequence::new(string name="svt_chi_system_protocol_flow_ctrl_atomic_outstanding_diff_rn_diff_hn_virtual_sequence");
  super.new(name);
endfunction

//====================================================================================
/**
 * @groupname CHI_FLOW_CTRL_WR_TYPE   
 *    #- This sequence requires at least one HN node to be present in the Interconnect.<br>
 *    #- This sequence requires one initiating active and participating RN.<br>
 *    #- Initiate WRITEUNIQUEFULL/WRITEUNIQUEPTL type transactions with<br> 
 *       svt_chi_rn_transaction::suspend_comp_ack set to 1 from initiating RN. <br> 
 *    #- Wait for the Initiating RN to transmit the DATA flits without waiting for Compack<br> 
 *    #- Resume the suspended Compack after the DATA flits are transmitted.<brr> 
 *       - This ensures that the expcompack s sent after all the DATA flits are transmitted on to interface.<br>
 *       .
 *    .
 */
class svt_chi_system_protocol_flow_ctrl_writeunique_suspend_compack_virtual_sequence extends svt_chi_system_base_virtual_sequence;
  
  //-----------------------------------------------------------------------------  
  // Member attributes
  //-----------------------------------------------------------------------------  

  /** To display contents of Active Participating RN's node info. */
  string str_rn_node;

  /** To display contents of Active Participating RN-F's node info. */
  string str_rn_f_node;

  int unsigned select_rn_f_node = 0;
  int unsigned select_rn_i_node = 0;
  int unsigned select_rn_d_node = 0;

  bit set_exp_comp_ack = 0;
  bit set_suspend_compack = 0;
  int unsigned sel_initiating_rn_node_index_0 =0;

  /** Status flags. */
  bit select_rn_f_node_status = 0;
  bit select_rn_i_node_status = 0;
  bit select_rn_d_node_status = 0;
  bit set_exp_comp_ack_status = 0;
  bit set_suspend_compack_status = 0;
  bit sel_data_flit_status = 0;

  /** UVM/OVM Object Utility macro */
  `svt_xvm_object_utils(svt_chi_system_protocol_flow_ctrl_writeunique_suspend_compack_virtual_sequence)
  
  svt_chi_rn_write_type_transaction_directed_sequence::seq_sel_data_flit_sent_enum sel_data_flit = svt_chi_rn_write_type_transaction_directed_sequence::LAST_DAT_FLIT_SENT;

  //-----------------------------------------------------------------------------  
  // Methods
  //-----------------------------------------------------------------------------
  /** Constructor */
  extern function new(string name="svt_chi_system_protocol_flow_ctrl_writeunique_suspend_compack_virtual_sequence");
 
  virtual task pre_start();

    `svt_xvm_debug("pre_start",$sformatf("Entering ..."));
    super.pre_start();
    raise_phase_objection();
    select_rn_f_node_status = uvm_config_db#(int unsigned)::get(null, get_full_name(), "select_rn_f_node", select_rn_f_node);
    `svt_xvm_debug("body", $sformatf("select_rn_f_node is %0d as a result of %0s", select_rn_f_node, (select_rn_f_node_status ?"config DB":"Default setting")));
    select_rn_i_node_status = uvm_config_db#(int unsigned)::get(null, get_full_name(), "select_rn_i_node", select_rn_i_node);
    `svt_xvm_debug("body", $sformatf("select_rn_i_node is %0d as a result of %0s", select_rn_i_node, (select_rn_i_node_status ?"config DB":"Default setting")));
    select_rn_d_node_status = uvm_config_db#(int unsigned)::get(null, get_full_name(), "select_rn_d_node", select_rn_d_node);
    `svt_xvm_debug("body", $sformatf("select_rn_d_node is %0d as a result of %0s", select_rn_d_node, (select_rn_d_node_status ?"config DB":"Default setting")));


    set_exp_comp_ack_status = uvm_config_db#(bit)::get(null, get_full_name(), "set_exp_comp_ack", set_exp_comp_ack);
    `svt_xvm_debug("body", $sformatf("set_exp_comp_ack is %0d as a result of %0s", set_exp_comp_ack, (set_exp_comp_ack_status ?"config DB":"Default setting")));

    set_suspend_compack_status = uvm_config_db#(bit)::get(null, get_full_name(), "set_suspend_compack", set_suspend_compack);
    `svt_xvm_debug("body", $sformatf("set_suspend_compack is %0d as a result of %0s", set_suspend_compack, (set_suspend_compack_status ?"config DB":"Default setting")));

    sel_data_flit_status = uvm_config_db#(svt_chi_rn_write_type_transaction_directed_sequence::seq_sel_data_flit_sent_enum)::get(null, get_full_name(), "sel_data_flit",sel_data_flit);

  endtask // pre_start

  virtual task body();
    string str_node_types = "";
    /** Sub Write type transaction directed sequences initiated from this sequence */
    svt_chi_rn_write_type_transaction_directed_sequence write_seq[int];

    if (select_rn_f_node) begin
      str_node_types = "Initiating nodes are of RN-F type.";
      sel_initiating_rn_node_index_0 = initiating_rn_f_node_index_0;
    end
    else if (select_rn_i_node) begin
      str_node_types = "Iniating nodes are of RN-I type.";
      sel_initiating_rn_node_index_0 = initiating_rn_i_node_index_0;
    end
    else if (select_rn_d_node) begin
      str_node_types = "Initiating nodes are of RN-D type.";
      sel_initiating_rn_node_index_0 = initiating_rn_d_node_index_0;
    end

    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :sel_initiating_rn_node_index_0;

    `svt_xvm_debug("body", $sformatf("initiating_rn_node_idx_0 is %0d as a result of %0s.", initiating_rn_node_idx_0, initiating_rn_node_index_0_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("target_hn_node_idx_0 is %0d as a result of %0s.", target_hn_node_idx_0, target_hn_node_index_0_status ? "config DB" : "Randomization"));

    //  check if current environment is supported or not 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    for(int i=0; i<sequence_length; i++)begin
      `svt_xvm_create_on(write_seq[i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr)
      void'(write_seq[i].randomize() with
             {
               sequence_length == 1;
               seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL,svt_chi_transaction::WRITEUNIQUEPTL};
               seq_order_type != svt_chi_transaction::NO_ORDERING_REQUIRED;    
               hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
               seq_hn_node_idx    == target_hn_node_idx_0; 
             });

      write_seq[i].suspend_compack = set_suspend_compack;
      write_seq[i].seq_exp_comp_ack = set_exp_comp_ack;
      write_seq[i].seq_select_data_flit_sent = sel_data_flit;
      write_seq[i].start(p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr);

    end//sequence_length
    
  `svt_xvm_debug("body", "Exiting...")
  endtask: body

  virtual task post_body();
    drop_phase_objection();
  endtask

  /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting RN-F Nodes = 1 when select_rn_f_node is programmed to 1
   *  #- minimum supporting RN-I Nodes = 1 when select_rn_i_node is programmed to 1
   *  #- minimum supporting RN-D Nodes = 1 when select_rn_d_node is programmed to 1
   */
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    
    /** local variables */
    int num_supporting_rn_f_nodes;
    int num_supporting_rn_i_nodes;
    int num_supporting_rn_d_nodes;
    string str_is_supported_info_prefix = "";
    string str_is_supported_info = "";

    /** Supporting Request Nodes required */
    int required_num_supporting_rn_f_nodes = 0;
    int required_num_supporting_rn_i_nodes = 0;
    int required_num_supporting_rn_d_nodes = 0;
    int required_num_hn_nodes = 1;
    int num_hn_f_nodes;
    int array_idx;
    string str_idx0_info = "";
    bit    is_rn_idx_0_participating, is_rn_idx_1_participating;   
    `svt_xvm_debug("is_supported",$sformatf("calling is_supported"));

    /** By default is_supported is 0 */
    is_supported = 0;

    /** Check for minimum required HN-F nodes */
    num_hn_f_nodes = hn_f_nodes.size();

    /** Check requirment of number of HN nodes needed */ 
    if (num_hn_f_nodes < required_num_hn_nodes) begin
      issue_is_supported_failure($sformatf("This sequence requires minimum %0d HN-F nodes to be present in the system. Number of HN-F nodes are %0d. Program number of HN nodes using svt_chi_system_configuration::num_hn. Program the HN interface type using svt_chi_system_configuration::chi_addr_cfg.hn_interface_type[].", required_num_hn_nodes, num_hn_f_nodes));
      return 0;      
    end
    
    /** Either of select_rn_d_node, select_rn_i_node, select_rn_f_node needs to be programmed to 1.
     *  More than one flag cannot be 1 or 0 together.
     */
    if (((select_rn_f_node == 0) && (select_rn_i_node == 0) && (select_rn_d_node == 0)) ||
        ((select_rn_f_node == 1) && (select_rn_i_node == 1) && (select_rn_d_node == 1))) begin
      issue_is_supported_failure($sformatf("select_rn_f_node = %0d. select_rn_i_node = %0d. select_rn_d_node = %0d. Programming one of these two variables to 1 through config DB is required for this sequence to be run.", select_rn_f_node, select_rn_i_node, select_rn_d_node));
      return 0;
    end

    /** Set minimum required supporting RN-F, RN-D and RN-I nodes depending on  
     *  select_rn_f_node or select_rn_d_node or select_rn_i_node flags respectively.
     */   
    if(select_rn_f_node)
      required_num_supporting_rn_f_nodes = 1;
    else if(select_rn_i_node) begin
      required_num_supporting_rn_i_nodes = 1;
    end else if (select_rn_d_node)begin
      required_num_supporting_rn_d_nodes = 1;
    end

    /** Check for minimum required RN-F, RN-D and RN-I nodes.
     *  Also check whether the selected RN-F, RN-D and RN-I nodes are part of participating arrays or not.
     */ 
    num_supporting_rn_f_nodes = active_participating_rn_f_nodes.size();
    num_supporting_rn_d_nodes = active_participating_rn_d_nodes.size();
    num_supporting_rn_i_nodes = active_participating_rn_i_nodes.size();

    /** Check the requirements of RN nodes */
    if (num_supporting_rn_f_nodes) begin
      /** Display the contents of Active Participating RN-F Nodes */
      foreach (active_participating_rn_f_nodes[j]) begin
        str_node_info = {str_node_info, $sformatf(" %0d", active_participating_rn_f_nodes[j])};
      end      
      `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_f_nodes are %0s", str_node_info));
    end
    
    /** Display the contents of Active Participating RN-D Nodes */
    str_node_info = "";

    /** Check the requirement of RN-D nodes */ 
    if (num_supporting_rn_d_nodes) begin
      foreach (active_participating_rn_d_nodes[j]) begin
        str_node_info = {str_node_info, $sformatf(" %0d", active_participating_rn_d_nodes[j])};
      end 
      `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_d_nodes are %0s", str_node_info));
    end    

    /** Display the contents of Active Participating RN-I Nodes */
    str_node_info = "";

    /** Check the requirement of RN-I nodes */ 
    if (num_supporting_rn_i_nodes) begin
      foreach (active_participating_rn_i_nodes[j]) begin
        str_node_info = {str_node_info, $sformatf(" %0d", active_participating_rn_i_nodes[j])};
      end 
      `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_i_nodes are %0s", str_node_info));
    end

    /** Check the required supporting Request Nodes */
    if (select_rn_f_node == 1) begin
      
      str_is_supported_info_prefix = $sformatf("select_rn_f_node is set to 1. Number of Supporting RN-F Node(s)  - Minimum Required : %0d Current : %0d", required_num_supporting_rn_f_nodes,num_supporting_rn_f_nodes);

      if ((initiating_rn_node_index_0_status==0)&&(valid_initiating_rn_f_node_index_0==0)) begin
          str_idx0_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN-Fs that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)";
      end
      else begin
        is_rn_idx_0_participating = is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_node_idx_0, array_idx);
        if (!is_rn_idx_0_participating) begin
          str_idx0_info = $sformatf("initiating_rn_node_idx_0 %0d is not valid for this sequence. The RN-F corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)", initiating_rn_node_idx_0, initiating_rn_node_idx_0);
        end
      end
    end
    else if (select_rn_i_node == 1) begin
      
      str_is_supported_info_prefix = $sformatf("select_rn_i_node is set to 1. Number of Supporting RN-I Node(s)  - Minimum Required : %0d Current : %0d", required_num_supporting_rn_i_nodes,num_supporting_rn_i_nodes);

      if ((initiating_rn_node_index_0_status==0)&&(valid_initiating_rn_i_node_index_0==0)) begin
        str_idx0_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN-Is that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_I)";
      end
      else begin
        is_rn_idx_0_participating = is_value_found_in_int_assoc_array(active_participating_rn_i_nodes, initiating_rn_node_idx_0, array_idx);
        if (!is_rn_idx_0_participating) begin
         
          str_idx0_info = $sformatf("initiating_rn_node_idx_0 %0d is not valid for this sequence. The RN-I corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_I)", initiating_rn_node_idx_0, initiating_rn_node_idx_0);
        end  
      end
    end
    else if (select_rn_d_node == 1) begin
      str_is_supported_info_prefix = $sformatf("select_rn_d_node is set to 1. Number of Supporting RN-D Node(s)  - Minimum Required : %0d Current : %0d", required_num_supporting_rn_d_nodes,num_supporting_rn_d_nodes);

      if ((initiating_rn_node_index_0_status==0)&&(valid_initiating_rn_d_node_index_0==0)) begin
        str_idx0_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN-Ds that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_D)";
      end
      else begin
        is_rn_idx_0_participating = is_value_found_in_int_assoc_array(active_participating_rn_d_nodes, initiating_rn_node_idx_0, array_idx);
        if (!is_rn_idx_0_participating) begin
         
          str_idx0_info = $sformatf("initiating_rn_node_idx_0 %0d is not valid for this sequence. The RN-D corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_D)", initiating_rn_node_idx_0, initiating_rn_node_idx_0);
        end  
      end
    end

    if (is_rn_idx_0_participating ) begin
      is_supported = 1;
    end
    
    if (!is_supported) begin
      str_is_supported_info = $sformatf("%0s",str_idx0_info);
      issue_is_supported_failure($sformatf("This sequence cannot be run based on the current system configuration.\n\
                                            %0s\n\
                                            %0s \n\
                                            Modify configurations through \n\
                                            svt_chi_system_configuration::num_rn,\n\
                                            svt_chi_node_configuration::is_active,\n\
                                            svt_chi_system_configuration::participating_rn_nodes[]\n\
                                            ", str_is_supported_info_prefix, str_is_supported_info));
    end

  endfunction : is_supported

endclass: svt_chi_system_protocol_flow_ctrl_writeunique_suspend_compack_virtual_sequence

function svt_chi_system_protocol_flow_ctrl_writeunique_suspend_compack_virtual_sequence::new(string name="svt_chi_system_protocol_flow_ctrl_writeunique_suspend_compack_virtual_sequence");
  super.new(name);
endfunction

/** 
 * @groupname CHI_FLOW_CTRL_PREFETCHTGT_TYPE 
 * #- This sequence requires at least one HN node to be present in the Interconnect.
 * #- This sequence requires one initiating active and participating RN.
 * #- If another active and participating RN-F exists, perform cache
 *    initialization to a randomly selected HN.
 * #- Initiate a Write type transactions with 
 *    svt_chi_rn_transaction::suspend_wr_data set  to 1 from initiating RN to randomly 
 *    selected HN in non blocking mode. <br>
 *    - Also, the RN will not transmit NonCopyBackWrData corresponding to write transaction
 *      until svt_chi_rn_transaction::suspend_wr_data is set to 0 from the seqeunce.
 *    .
 * #- Initiate a PREFETCHTGT type transaction to the same address of write transaction address.
 *    - Txn_id of a PREFETCHTGT transaction is set to below values based on #sel_txnid_type_enum,
 *      which can be controlled through config DB or random value by default
 *      - when sel_txnid_type_enum == TXNID_SAME_AS_PREFETCHTGT i.e txn_id is same as Write transaction txn_id 
 *      - when sel_txnid_type_enum == TXNID_NOT_SAME_AS_PREFETCHTGT i.e txn_id is not same as Write transaction txn_id
 *      .
 *    .  
 * #- Wait for the PREFETCHTGT transaction to end, Once it ends 
 *    svt_chi_rn_transaction::suspend_wr_data is set to 0 for the outstanding write transaction. <br>
 *    This ensures that the NonCopyBackWrData for the above write transaction can be resumed from RN.
 *
 * #- Check that the HN responds properly for PREFETCHTGT and Write transactions
 *    and these are completed successfully.
 * .
 */ 
class svt_chi_system_protocol_flow_ctrl_prefetchtgt_write_outstanding_virtual_sequence extends svt_chi_system_base_virtual_sequence;
  
  //-----------------------------------------------------------------------------  
  // Member attributes
  //-----------------------------------------------------------------------------  

  /** @cond PRIVATE */
  /** To display contents of Active Participating RN's node info. */
  string str_rn_node;

  /** To display contents of Active Participating RN-F's node info. */
  string str_rn_f_node;

  /** @endcond */

  /**
   * Control on Txn_id of Write transaction to be same/different from PREFETCHTGT transaction which are targeted to same addr.
   */
  typedef enum {
    TXNID_SAME_AS_PREFETCHTGT = 0,
    TXNID_NOT_SAME_AS_PREFETCHTGT = 1
  } sel_txnid_type_enum;

  rand sel_txnid_type_enum sel_txnid_type = TXNID_SAME_AS_PREFETCHTGT;

  /** Status field for capturing config DB get status for sel_txnid_type_enum */
  bit sel_txnid_type_satus;

  /** UVM/OVM Object Utility macro */
  `svt_xvm_object_utils(svt_chi_system_protocol_flow_ctrl_prefetchtgt_write_outstanding_virtual_sequence)
  
  //-----------------------------------------------------------------------------  
  // Methods
  //-----------------------------------------------------------------------------
  /** Constructor */
  extern function new(string name="svt_chi_system_protocol_flow_ctrl_prefetchtgt_write_outstanding_virtual_sequence");

  virtual task pre_start();
    super.pre_start();
    `svt_xvm_debug("pre_start",$sformatf("Entering ..."));
    raise_phase_objection();
    sel_txnid_type_satus = svt_config_int_db#(sel_txnid_type_enum)::get(null, get_full_name(),"sel_txnid_type", sel_txnid_type);
    `svt_xvm_debug("body", $sformatf("sel_txnid_type is %0s as a result of %0s", sel_txnid_type, (sel_txnid_type_satus ?"config DB":"Random Value")));
  endtask // pre_start

   /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting RN-F Nodes = 1
   *  #- svt_chi_node_configuration::chi_spec_revision = svt_chi_node_configuration::ISSUE_B
   */
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    string str_is_supported_info_prefix = "This sequence cannot be run based on the current configuration.\n";
    string str_is_supported_info = "";
    string str_is_supported_info_suffix = "Modify configurations through svt_chi_node_configuration::chi_spec_revision\n";
    is_supported = super.is_supported(cfg, silent);
    if(is_supported) begin
      `ifdef SVT_CHI_ISSUE_B_ENABLE
      if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) begin
        is_supported = 0;
        str_is_supported_info = $sformatf("svt_chi_node_configuration::chi_spec_revision set to svt_chi_node_configuration::ISSUE_A for initiating requester node %0d. PrefetchTgt can only be issued from RN when svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_B or later. ", initiating_rn_node_idx_0);
      end else
        is_supported = 1;
      `else
        is_supported = 0;
        str_is_supported_info = $sformatf("Macro SVT_CHI_ISSUE_B_ENABLE or SVT_CHI_ISSUE_C_ENABLE is not defined. PrefetchTgt can only be issued when SVT_CHI_ISSUE_B_ENABLE or SVT_CHI_ISSUE_C_ENABLE is defined and svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_B or later for the Requester Nodes. ");
      `endif
      if (!is_supported) begin
        string str_complete_is_supported_info = {str_is_supported_info_prefix, str_is_supported_info, str_is_supported_info_suffix};
        issue_is_supported_failure(str_complete_is_supported_info);
      end
    end
  endfunction : is_supported

  virtual task body();
    /** Queue of addresses, used by the transactions generated */
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0] addr_q[$];
    bit seq_is_non_secure_access_q[$];
    /** Flag to track whether cache initialization needs to be performed or not*/
    bit                                perform_cache_initialization;
    int                                array_idx;
    int                                num_outstanding_xacts_to_generate;
    /** Metric variables */
    int received_responses = 0;
    
    /** Sub Write type transaction directed sequences initiated from this sequence */
    svt_chi_rn_write_type_transaction_directed_sequence write_seq;
    /** Sub Prefetchtgt type transaction directed sequences initiated from this sequence */
    svt_chi_rn_prefetchtgt_type_transaction_directed_sequence prefetchtgt_seq;
    /** Sub Read type transaction cache initialization directed sequences initiated from this sequence */
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq;

    `svt_xvm_debug("body", "Entering ...")
    super.body();

    initiating_rn_node_idx_0 =  initiating_rn_f_node_index_0;

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /**
     * If the cache_line_init_rn_f_node_index is same as the RN node index 
     * which are passed through config i.e initiating_rn_node_idx_0,
     * then re-assign the cache_line_init_rn_f_node_index with RN node index ,which is active,
     * participating and not equal to initiating_rn_node_idx_0.
     */
    if(initiating_rn_node_index_0_status)begin  
      if((cache_line_init_rn_f_node_index == initiating_rn_node_idx_0))begin  
        int active_participating_q [$];
        `svt_chi_xxm_debug("body",$sformatf("cache_line_init_rn_f_node_index= %0d is same as initiating_rn_node_idx_0=%0d and active_participating_rn_f_nodes.size()= %0d",cache_line_init_rn_f_node_index,initiating_rn_node_idx_0,active_participating_rn_f_nodes.size()));
        if(active_participating_rn_f_nodes.size()>1)begin
          active_participating_q = active_participating_rn_f_nodes.find with (item != initiating_rn_node_idx_0);
          cache_line_init_rn_f_node_index = active_participating_q.pop_back();
          `svt_chi_xxm_debug("body", $sformatf("active_participating_q.size() is %0d and Selected different cache_line_init_rn_f_node_index=%0d", active_participating_q.size(),cache_line_init_rn_f_node_index));
          active_participating_q.delete();
        end else begin
          perform_cache_initialization=0;
          `svt_chi_xxm_debug("body",$sformatf("BYPASSING Cache Initialization as selected cache_line_init_rn_f_node_index= %0d is same as initiating_rn_node_index_0_from_config_db=%0d and active_participating_rn_f_nodes.size()= %0d",cache_line_init_rn_f_node_index,initiating_rn_node_index_0_from_config_db,active_participating_rn_f_nodes.size()));
        end
      end  
    end 

    // If the cache_line_init_rn_f_node_index is part of active_participating_rn_f_nodes array, and
    // it is not equal to initiating_rn_node_idx_0; then we can
    // perform cache initialization from the RN[cache_line_init_rn_f_node_index].
    if ((is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, cache_line_init_rn_f_node_index, array_idx)) &&
        (cache_line_init_rn_f_node_index != initiating_rn_node_idx_0)) begin
      perform_cache_initialization = 1;
    end
    
    `svt_xvm_debug("body", $sformatf("perform_cache_initialization is %0b, cache_line_init_rn_f_node_index is %0d, initiating_rn_node_idx_0 is %0d", perform_cache_initialization, cache_line_init_rn_f_node_index, initiating_rn_node_idx_0));    

    for(int k = 0; k < sequence_length; k++) begin
      if(perform_cache_initialization) begin
        
        `svt_xvm_debug("body",$sformatf("Starting cache initialization for %0d addresses from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d",num_outstanding_xacts_to_generate, cache_line_init_rn_f_node_index, target_hn_node_idx_0));
      
        /** Write data into Cache of Randomly selected first RN-F with address of randomly selected HN Node */
        `svt_xvm_do_on_with(makeunique_seq,p_sequencer.rn_virt_seqr[cache_line_init_rn_f_node_index].rn_xact_seqr,
        {
          sequence_length   == 1;
          set_unique_addr_value    == 1;
          hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
          seq_hn_node_idx   == target_hn_node_idx_0;
          use_seq_is_non_secure_access == 0;
        })
        
        `svt_xvm_debug("body", $sformatf("%0s Waiting for MakeUnique transaction targeted to HN (idx %0d, id %0d) to end",`SVT_CHI_PRINT_PREFIX(makeunique_seq.write_tran), makeunique_seq.write_tran.hn_node_idx, makeunique_seq.write_tran.tgt_id));
        makeunique_seq.write_tran.wait_end();
        /** Queue for collecting the address of makeunique transactions */
        addr_q.push_back(makeunique_seq.output_xacts[0].addr);
        seq_is_non_secure_access_q.push_back(makeunique_seq.output_xacts[0].is_non_secure_access);
        `svt_xvm_verbose("body", $sformatf("MakeUnique transaction is %0s", makeunique_seq.write_tran.sprint()));
      end        

      /** 
        * Do a WRITE transaction from same RN to the MAKEUNIQUE 
        * transaction addresses of same HN-F node in case of 
        * initialization or select the randomly selected HN-F 
        * if initialization is not necessary.  
        */ 
      `svt_xvm_do_on_with(write_seq,p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
        {
       if (perform_cache_initialization)
         seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL};
       else
         seq_xact_type inside {svt_chi_transaction::WRITENOSNPFULL, svt_chi_transaction::WRITENOSNPPTL};

         sequence_length    == 1;
         if(perform_cache_initialization) {
             hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
             min_addr         == addr_q[0];
             max_addr         == addr_q[0];
             seq_is_non_secure_access == seq_is_non_secure_access_q[0]; 
             use_seq_is_non_secure_access == 1;
         }
         else {
             hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
             seq_hn_node_idx    == target_hn_node_idx_0;
             use_seq_is_non_secure_access == 0;
         }         
         seq_order_type     == svt_chi_transaction::NO_ORDERING_REQUIRED;
        })
      write_seq.write_tran.suspend_wr_data = 1;
      write_seq.write_tran.wait_begin();

      /** 
        * Do a PREFETCHTGT transaction from same RN to the WRITE 
        * transaction address. 
        */ 
      `svt_xvm_do_on_with(prefetchtgt_seq,p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
        {
         sequence_length    == 1;
         hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
         min_addr           ==  write_seq.write_tran.addr;
         max_addr           ==  write_seq.write_tran.addr;
         if (sel_txnid_type == TXNID_SAME_AS_PREFETCHTGT) {
           seq_txn_id       == write_seq.write_tran.txn_id;
         }        
         else {
           seq_txn_id       != write_seq.write_tran.txn_id;
         }
        })

      /** Waiting for write transactions to end */
      prefetchtgt_seq.prefetchtgt_tran.wait_end();

      /** Self Check1: To check suspend_wr_data should not be modified to zero by the VIP
       * before reseting from test bench
       */
      if (!write_seq.write_tran.is_terminated()) begin
        if (write_seq.write_tran.suspend_wr_data == 0) begin
          `svt_xvm_error("body", $sformatf("%0s suspend_wr_data should be 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(write_seq.write_tran)));
        end
        else begin
          `svt_xvm_debug("body", $sformatf("%0s suspend_wr_data is 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(write_seq.write_tran)));
        end
      end

      /** Self Check2: To check transaction is not ended by the VIP before resuming the 
       *  suspend_wr_data to zero from the test bench
       */
      if (!write_seq.write_tran.is_terminated()) begin
        if (write_seq.write_tran.end_event.is_on() == 1) begin
          `svt_xvm_error("body", $sformatf("Unexpected: %0s Transaction's end_event triggered when suspend_wr_data is still 1.", `SVT_CHI_PRINT_PREFIX(write_seq.write_tran)));
        end
        else begin
          `svt_xvm_debug("body", $sformatf("Expected: %0s Transaction's end_event is not triggered when suspend_wr_data is still 1.", `SVT_CHI_PRINT_PREFIX(write_seq.write_tran)));
        end
      end

      /** Resuming the NonCopyBackWrData for above write transaction */
      `svt_xvm_debug("body",$sformatf("Resuming the write transaction by setting svt_chi_rn_transaction::suspend_wr_data set to 0"))
      write_seq.write_tran.suspend_wr_data = 0;
      `svt_xvm_debug("body", $sformatf("After Resume received_response suspend_wr_data is %0b",write_seq.write_tran.suspend_wr_data));

      write_seq.write_tran.wait_end();
      /** Waiting for Write transactions to complete*/
      `svt_xvm_debug("body",$sformatf("Waiting for completion of the outstanding write type transaction"));
      `svt_xvm_debug("body",$sformatf("Received completion for write type outstanding transaction"));

      /** Delete the contents of address collection queue */
      addr_q.delete();

    end //sequence_length
    
  `svt_xvm_debug("body", "Exiting...")
  endtask: body

  virtual task post_body();
    drop_phase_objection();
  endtask

endclass: svt_chi_system_protocol_flow_ctrl_prefetchtgt_write_outstanding_virtual_sequence

function svt_chi_system_protocol_flow_ctrl_prefetchtgt_write_outstanding_virtual_sequence::new(string name="svt_chi_system_protocol_flow_ctrl_prefetchtgt_write_outstanding_virtual_sequence");
  super.new(name);
endfunction

/** 
 * @groupname CHI_FLOW_CTRL_PREFETCHTGT_TYPE 
 * #- This sequence requires at least one HN node to be present in the Interconnect.
 * #- This sequence requires one initiating active and participating RN.
 * #- If another active and participating RN-F exists, perform cache
 *    initialization to a randomly selected HN.
 * #- Initiate a Read type transactions with  <br>
 *    svt_chi_rn_transaction::suspend_comp_ack set  to 1 from initiating RN to randomly 
 *    selected HN in non blocking mode. <br>
 *    - Also, the RN will not transmit CompAck corresponding to these transactions<br>
 *      until svt_chi_rn_transaction::suspend_comp_ack is set to 0 from the seqeunce.<br>
 *    .
 * #- Initiate a PREFETCHTGT type transaction to the same address of read transaction address.
 *    - Txn_id of a PREFETCHTGT transaction is set to below values based on #sel_txnid_type_enum,
 *      which can be controlled through config DB or random value by default
 *      - when sel_txnid_type_enum == TXNID_SAME_AS_PREFETCHTGT i.e txn_id is same as read transaction txn_id 
 *      - when sel_txnid_type_enum == TXNID_NOT_SAME_AS_PREFETCHTGT i.e txn_id is not same as read transaction txn_id
 *      .
 *    . 
 * #- Wait for the PREFETCHTGT transaction to end, Once it ends 
 *    svt_chi_rn_transaction::suspend_comp_ack is set to 0 for the outstanding read transaction. <br>
 *    This ensures that the CompAck for the above Read transaction can be resumed<br> 
 *    from RN.<br>
 *
 * #- Check that the HN responds properly for PREFETCHTGT and Read transactions
 *    and these are completed successfully.
 * .
 */ 
class svt_chi_system_protocol_flow_ctrl_prefetchtgt_read_outstanding_virtual_sequence extends svt_chi_system_base_virtual_sequence;
  
  //-----------------------------------------------------------------------------  
  // Member attributes
  //-----------------------------------------------------------------------------  
  /** @cond PRIVATE */
  /** To display contents of Active Participating RN's node info. */
  string str_rn_node;

  /** To display contents of Active Participating RN-F's node info. */
  string str_rn_f_node;
  /** Parameter that controls the enabling of transactions in non-blocking mode from the sequence */
  bit enable_outstanding = 0;

  /** Represents the RN-F node for which the sequence will be initiated. Setting this is not yet supproted. */ 
  int select_rn_f_node = 0;  
  
  /** Represents the RN-I node for which the sequence will be initiated. Setting this is not yet supproted. */ 
  int select_rn_i_node = 0;
  
  /** Represents the RN-D node for which the sequence will be initiated. Setting this is not yet supproted. */ 
  int select_rn_d_node = 0; 

  /** Status filed for capturing config DB get status for select_rn_f_node */
  bit select_rn_f_node_status = 0;
  
  /** Status filed for capturing config DB get status for select_rn_i_node */
  bit select_rn_i_node_status = 0;

  /** Status filed for capturing config DB get status for select_rn_d_node */
  bit select_rn_d_node_status = 0;

  /** Represents the received read responses */
  int received_read_responses = 0;

  /** To display contents of Active Participating RN's nodes info. */
  string str_node_info;
  /** @endcond */
                 
  /**
   * Control on Txn_id of Read transaction to be same/different from PREFETCHTGT transaction which are targeted to same addr.
   */
  typedef enum {
    TXNID_SAME_AS_PREFETCHTGT = 0,
    TXNID_NOT_SAME_AS_PREFETCHTGT = 1
  } sel_txnid_type_enum;

  rand sel_txnid_type_enum sel_txnid_type = TXNID_SAME_AS_PREFETCHTGT;

  /** Status field for capturing config DB get status for sel_txnid_type_enum */
  bit sel_txnid_type_satus;

  /** UVM/OVM Object Utility macro */
  `svt_xvm_object_utils(svt_chi_system_protocol_flow_ctrl_prefetchtgt_read_outstanding_virtual_sequence)
  
  //-----------------------------------------------------------------------------  
  // Methods
  //-----------------------------------------------------------------------------
  /** Constructor */
  extern function new(string name="svt_chi_system_protocol_flow_ctrl_prefetchtgt_read_outstanding_virtual_sequence");

   /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting RN-F Nodes = 1
   *  #- svt_chi_node_configuration::chi_spec_revision = svt_chi_node_configuration::ISSUE_B
   */
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    string str_is_supported_info_prefix = "This sequence cannot be run based on the current configuration.\n";
    string str_is_supported_info = "";
    string str_is_supported_info_suffix = "Modify configurations through svt_chi_node_configuration::chi_spec_revision\n";
    is_supported = super.is_supported(cfg, silent);
    if(is_supported) begin
      `ifdef SVT_CHI_ISSUE_B_ENABLE
      if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) begin
        is_supported = 0;
        str_is_supported_info = $sformatf("svt_chi_node_configuration::chi_spec_revision set to svt_chi_node_configuration::ISSUE_A for initiating requester node %0d. PrefetchTgt can only be issued from RN when svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_B or later. ", initiating_rn_node_idx_0);
      end else
        is_supported = 1;
      `else
        is_supported = 0;
        str_is_supported_info = $sformatf("Macro SVT_CHI_ISSUE_B_ENABLE or SVT_CHI_ISSUE_C_ENABLE is not defined. PrefetchTgt can only be issued when SVT_CHI_ISSUE_B_ENABLE or SVT_CHI_ISSUE_C_ENABLE is defined and svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_B or later for the Requester Nodes. ");
      `endif
      if (!is_supported) begin
        string str_complete_is_supported_info = {str_is_supported_info_prefix, str_is_supported_info, str_is_supported_info_suffix};
        issue_is_supported_failure(str_complete_is_supported_info);
      end
    end
  endfunction : is_supported

  virtual task pre_start();
    bit enable_outstanding_status;
    super.pre_start();
    `svt_xvm_debug("pre_start",$sformatf("Entering ..."));
    raise_phase_objection();
    sel_txnid_type_satus = svt_config_int_db#(sel_txnid_type_enum)::get(null, get_full_name(),"sel_txnid_type", sel_txnid_type);
    `svt_xvm_debug("body", $sformatf("sel_txnid_type is %0s as a result of %0s", sel_txnid_type, (sel_txnid_type_satus ?"config DB":"Random value")));
    enable_outstanding_status = uvm_config_db#(bit)::get(m_sequencer, get_type_name(), "enable_outstanding", enable_outstanding);
    `svt_xvm_debug("body", $sformatf("enable_outstanding is %0b as a result of %0s", enable_outstanding, (enable_outstanding_status?"config DB":"default setting")));
    `svt_xvm_debug("pre_start",$sformatf("Exiting ..."));    
  endtask // pre_start

  virtual task body();
    /** Queue of addresses, used by the transactions generated */
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0] addr_q[$];
    bit seq_is_non_secure_access_q[$];
    /** Flag to track whether cache initialization needs to be performed or not*/
    bit                                perform_cache_initialization;
    int                                array_idx;
    int                                num_outstanding_xacts_to_generate;
    /** Metric variables */
    int received_responses = 0;
    string str_node_types = "";
    int unsigned sel_initiating_rn_node_idx_0;    
    /** Sub read type transaction directed sequences initiated from this sequence */
    svt_chi_rn_read_type_transaction_directed_sequence read_seq;
    /** Sub Prefetchtgt type transaction directed sequences initiated from this sequence */
    svt_chi_rn_prefetchtgt_type_transaction_directed_sequence prefetchtgt_seq;
    /** Sub Read type transaction cache initialization directed sequences initiated from this sequence */
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq;

    `svt_xvm_debug("body", "Entering ...")
    super.body();

    initiating_rn_node_idx_0 =  initiating_rn_f_node_index_0;

    `svt_xvm_debug("body", "Entering ...");

    /**
     * If the cache_line_init_rn_f_node_index is part of active_participating_rn_f_nodes array, and
     * it is not equal to initiating_rn_node_idx_0 then we can
     * perform cache initialization from the RN[cache_line_init_rn_f_node_index].
     */
    if ((is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, cache_line_init_rn_f_node_index, array_idx)) &&
        (cache_line_init_rn_f_node_index != initiating_rn_node_idx_0)) begin
      perform_cache_initialization = 1;
    end

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    `svt_xvm_debug("body", $sformatf("perform_cache_initialization is %0b, cache_line_init_rn_f_node_index is %0d, initiating_rn_node_idx_0 is %0d", perform_cache_initialization, cache_line_init_rn_f_node_index, initiating_rn_node_idx_0));    

    for(int k = 0; k < sequence_length; k++) begin
      if(perform_cache_initialization) begin
        
        `svt_xvm_debug("body",$sformatf("Starting cache initialization for %0d addresses from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d",num_outstanding_xacts_to_generate, cache_line_init_rn_f_node_index, target_hn_node_idx_0));
      
        /** Write data into Cache of Randomly selected first RN-F with address of randomly selected HN Node */
        `svt_xvm_do_on_with(makeunique_seq,p_sequencer.rn_virt_seqr[cache_line_init_rn_f_node_index].rn_xact_seqr,
        {
          sequence_length   == 1;
          set_unique_addr_value    == 1;
          hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
          seq_hn_node_idx   == target_hn_node_idx_0;
          use_seq_is_non_secure_access == 0;
        })
        
        `svt_xvm_debug("body", $sformatf("%0s Waiting for MakeUnique transaction targeted to HN (idx %0d, id %0d) to end",`SVT_CHI_PRINT_PREFIX(makeunique_seq.write_tran), makeunique_seq.write_tran.hn_node_idx, makeunique_seq.write_tran.tgt_id));
        makeunique_seq.write_tran.wait_end();
        /** Queue for collecting the address of makeunique transactions */
        addr_q.push_back(makeunique_seq.output_xacts[0].addr);
        seq_is_non_secure_access_q.push_back(makeunique_seq.output_xacts[0].is_non_secure_access);
        `svt_xvm_verbose("body", $sformatf("MakeUnique transaction is %0s", makeunique_seq.write_tran.sprint()));
      end        

      /** 
        * Do a read transaction from same RN to the MAKEUNIQUE 
        * transaction addresses of same HN-F node in case of 
        * initialization or select the randomly selected HN-F 
        * if initialization is not necessary.  
        */ 
      `svt_xvm_do_on_with(read_seq,p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
        {
          sequence_length == 1;
          seq_order_type  == svt_chi_transaction::NO_ORDERING_REQUIRED;
          if (perform_cache_initialization) {
            hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
            min_addr == addr_q[0];
            max_addr == addr_q[0];
            seq_is_non_secure_access == seq_is_non_secure_access_q[0]; 
            use_seq_is_non_secure_access == 1;
            data_in_cache == makeunique_seq.data_in_cache;
            by_pass_read_data_check == 0;
          }
          else {
            hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
            seq_hn_node_idx    == target_hn_node_idx_0; 
            by_pass_read_data_check == 1;
            use_seq_is_non_secure_access == 0;
          }
       
           if (perform_cache_initialization) {
       
             seq_xact_type != svt_chi_transaction::READNOSNP;
             if (select_rn_i_node || select_rn_d_node) seq_xact_type == svt_chi_transaction::READONCE;
             `ifdef SVT_CHI_ISSUE_B_ENABLE
             if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type != svt_chi_transaction::READNOTSHAREDDIRTY;
             if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A || sys_cfg.readspec_enable == 0) seq_xact_type != svt_chi_transaction::READSPEC;
             if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type != svt_chi_transaction::READONCECLEANINVALID;
             if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type != svt_chi_transaction::READONCEMAKEINVALID;
             `endif
            `ifdef SVT_CHI_ISSUE_E_ENABLE
              if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision <= svt_chi_node_configuration::ISSUE_D) seq_xact_type != svt_chi_transaction::READPREFERUNIQUE;
            `endif

           }
           else 
             seq_xact_type == svt_chi_transaction::READNOSNP;

        })

        `svt_xvm_debug("body", $sformatf("%0s Transmitting Read Transaction targeted to HN (idx %0d, id %0d) ",`SVT_CHI_PRINT_PREFIX(read_seq.read_tran),read_seq.read_tran.hn_node_idx, read_seq.read_tran.tgt_id));
        `svt_xvm_verbose("body", $sformatf("Read Transaction is %0s",read_seq.read_tran.sprint()));
      read_seq.read_tran.suspend_comp_ack = 1;
      read_seq.read_tran.wait_begin();

      /** 
        * Do a PREFETCHTGT transaction from same RN to the READ 
        * transaction address. 
        */ 
      `svt_xvm_do_on_with(prefetchtgt_seq,p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
        {
         sequence_length    == 1;
         hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
         min_addr           ==  read_seq.read_tran.addr;
         max_addr           ==  read_seq.read_tran.addr;
         if (sel_txnid_type == TXNID_SAME_AS_PREFETCHTGT) {
           seq_txn_id       == read_seq.read_tran.txn_id;
         }        
         else {
           seq_txn_id       != read_seq.read_tran.txn_id;
         }
        })

      /** Waiting for read transactions to end */
      prefetchtgt_seq.prefetchtgt_tran.wait_end();

      /** Self Check1: To check suspend_comp_ack should not be modified to zero by the VIP
       *  before reseting from test bench
       */
      if (!read_seq.read_tran.is_terminated()) begin
        if (read_seq.read_tran.suspend_comp_ack == 0) begin
          `svt_xvm_error("body", $sformatf("%0s suspend_comp_ack should be 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(read_seq.read_tran)));
        end
        else begin
          `svt_xvm_debug("body", $sformatf("%0s suspend_comp_ack is 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(read_seq.read_tran)));
        end
      end

      /** Self Check2: To check end_event should not be 1 before resuming the
       *  transaction from test bench
       */
      if (!read_seq.read_tran.is_terminated()) begin
        if (read_seq.read_tran.end_event.is_on() == 1) begin
          `svt_xvm_error("body", $sformatf("Unexpected: %0s Transaction's end_event triggered when suspend_comp_ack is still 1.", `SVT_CHI_PRINT_PREFIX(read_seq.read_tran)));
        end
        else begin
          `svt_xvm_debug("body", $sformatf("Expected: %0s Transaction's end_event is not triggered when suspend_comp_ack is still 1.", `SVT_CHI_PRINT_PREFIX(read_seq.read_tran)));
        end
      end
      
      /** Resuming CompAck responses for above Read transaction */
      `svt_xvm_debug("body",$sformatf("Resuming the read transaction by setting svt_chi_rn_transaction::suspend_comp_ack set to 0"))
      read_seq.read_tran.suspend_comp_ack = 0;
      `svt_xvm_debug("body", $sformatf("After Resume received_response suspend_comp_ack is %0b",read_seq.read_tran.suspend_comp_ack));

      read_seq.read_tran.wait_end();
      /** Waiting for read transactions to complete*/
      `svt_xvm_debug("body",$sformatf("Waiting for completion of the outstanding read type transaction"));
      `svt_xvm_debug("body",$sformatf("Received completion for read type outstanding transaction"));

      /** Delete the contents of address collection queue */
      addr_q.delete();

    end //sequence_length
    
  `svt_xvm_debug("body", "Exiting...")
  endtask: body

  virtual task post_body();
    drop_phase_objection();
  endtask

endclass: svt_chi_system_protocol_flow_ctrl_prefetchtgt_read_outstanding_virtual_sequence

function svt_chi_system_protocol_flow_ctrl_prefetchtgt_read_outstanding_virtual_sequence::new(string name="svt_chi_system_protocol_flow_ctrl_prefetchtgt_read_outstanding_virtual_sequence");
  super.new(name);
endfunction

`endif

`ifdef SVT_CHI_ISSUE_E_ENABLE
//------------------------------------------------------------------------------
/** 
 * @groupname CHI_SINGLE_RN_RD_TYPE 
 *  This sequence initiates MakeReadUnique transaction from the RN-F node specified with 
 *  node_index, which can be a random node or a specific node configured by the user. 
 *  Before sending each MakeReadUnique transaction, cachelines of peer node are initialized
 *  to random, valid states.
 *  This sequence requires SVT_CHI_ISSUE_E_ENABLE macro to be defined and
 *  svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_E or later.
 */
class svt_chi_system_single_node_makereadunique_virtual_sequence extends svt_chi_system_single_node_rn_coherent_transaction_base_virtual_sequence;

  `svt_xvm_object_utils(svt_chi_system_single_node_makereadunique_virtual_sequence)
  
  function new(string name = "svt_chi_system_single_node_makereadunique_virtual_sequence");
    super.new(name);
  endfunction

  /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting RN-F Nodes = 1
   *  #- svt_chi_node_configuration::chi_spec_revision >= svt_chi_node_configuration::ISSUE_E
   */
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    string str_is_supported_info_prefix = "This sequence cannot be run based on the current configuration.\n";
    string str_is_supported_info = "";
    string str_is_supported_info_suffix = "Modify configurations through svt_chi_node_configuration::chi_spec_revision\n";
    is_supported = super.is_supported(cfg, silent);
    if(is_supported) begin
      if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision < svt_chi_node_configuration::ISSUE_E) begin
        is_supported = 0;
        str_is_supported_info = $sformatf("svt_chi_node_configuration::chi_spec_revision is not set to svt_chi_node_configuration::ISSUE_E or later for initiating requester node %0d. MakeReadUnique can only be issued from RN when svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_E or later ", initiating_rn_node_idx_0);
      end else begin
        is_supported = 1;
      end  

      if (!is_supported) begin
        string str_complete_is_supported_info = {str_is_supported_info_prefix, str_is_supported_info, str_is_supported_info_suffix};
        issue_is_supported_failure(str_complete_is_supported_info);
      end
    end
  endfunction

  /**
   * Initializes cachelines and sends makereadunique from node "node_index"
   */
  virtual task body();
    super.body();

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    send_coherent_transactions(svt_chi_common_transaction::MAKEREADUNIQUE ,1);
    /** Wait for readshared transactions to finish */
    coherent_seq.wait_for_active_xacts_to_end();
    print_caches();

  endtask: body
endclass: svt_chi_system_single_node_makereadunique_virtual_sequence

//------------------------------------------------------------------------------
/** 
 * @groupname CHI_SINGLE_RN_RD_TYPE 
 *  This sequence initiates ReadPreferUnique transaction from the RN-F node specified with 
 *  node_index, which can be a random node or a specific node configured by the user. 
 *  Before sending each ReadPreferUnique transaction, cachelines of peer node are initialized
 *  to random, valid states.
 *  This sequence requires SVT_CHI_ISSUE_E_ENABLE macro to be defined and
 *  svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_E or later.
 */
class svt_chi_system_single_node_readpreferunique_virtual_sequence extends svt_chi_system_single_node_rn_coherent_transaction_base_virtual_sequence;

  `svt_xvm_object_utils(svt_chi_system_single_node_readpreferunique_virtual_sequence)
  
  function new(string name = "svt_chi_system_single_node_readpreferunique_virtual_sequence");
    super.new(name);
  endfunction

  /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting RN-F Nodes = 2
   *  #- svt_chi_node_configuration::chi_spec_revision >= svt_chi_node_configuration::ISSUE_E
   */
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    string str_is_supported_info_prefix = "This sequence cannot be run based on the current configuration.\n";
    string str_is_supported_info = "";
    string str_is_supported_info_suffix = "Modify configurations through svt_chi_node_configuration::chi_spec_revision\n";
    is_supported = super.is_supported(cfg, silent);
    if(is_supported) begin
      if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision < svt_chi_node_configuration::ISSUE_E) begin
        is_supported = 0;
        str_is_supported_info = $sformatf("svt_chi_node_configuration::chi_spec_revision is not set to svt_chi_node_configuration::ISSUE_E or later for initiating requester node %0d. Writeevictorevict can only be issued from RN when svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_E or later ", initiating_rn_node_idx_0);
      end else begin
        is_supported = 1;
      end  
      if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision < svt_chi_node_configuration::ISSUE_E) begin
        is_supported = 0;
        str_is_supported_info = $sformatf("svt_chi_node_configuration::chi_spec_revision is not set to svt_chi_node_configuration::ISSUE_E or later for initiating requester node %0d. Writeevictorevict can only be issued from RN when svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_E or later ", initiating_rn_node_idx_1);
      end else begin
        is_supported = 1;
      end  

      if (!is_supported) begin
        string str_complete_is_supported_info = {str_is_supported_info_prefix, str_is_supported_info, str_is_supported_info_suffix};
        issue_is_supported_failure(str_complete_is_supported_info);
      end
    end
  endfunction

  /**
   * Initializes cachelines and sends ReadPreferUnique from node "node_index"
   */
  virtual task body();
    super.body();

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    send_coherent_transactions(svt_chi_common_transaction::READPREFERUNIQUE ,1);
    /** Wait for readshared transactions to finish */
    coherent_seq.wait_for_active_xacts_to_end();
    print_caches();

  endtask: body
endclass: svt_chi_system_single_node_readpreferunique_virtual_sequence

//------------------------------------------------------------------------------
/** 
 * @groupname CHI_SINGLE_RN_CPBK_TYPE 
 *  This sequence initiates WriteEvictorEvict transaction from the RN-F node specified with 
 *  node_index, which can be a random node or a specific node configured by the user. 
 *  Before sending each WriteEvictorEvict transaction, cachelines of peer node are initialized
 *  to random, valid states.
 *  This sequence requires SVT_CHI_ISSUE_E_ENABLE macro to be defined and
 *  svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_E or later.
 */
class svt_chi_system_single_node_writeevictorevict_virtual_sequence extends svt_chi_system_single_node_rn_coherent_transaction_base_virtual_sequence;

  `svt_xvm_object_utils(svt_chi_system_single_node_writeevictorevict_virtual_sequence)
  
  function new(string name = "svt_chi_system_single_node_writeevictorevict_virtual_sequence");
    super.new(name);
  endfunction

  /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting RN-F Nodes = 1
   *  #- svt_chi_node_configuration::chi_spec_revision >= svt_chi_node_configuration::ISSUE_E
   */
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    string str_is_supported_info_prefix = "This sequence cannot be run based on the current configuration.\n";
    string str_is_supported_info = "";
    string str_is_supported_info_suffix = "Modify configurations through svt_chi_node_configuration::chi_spec_revision\n";
    is_supported = super.is_supported(cfg, silent);
    if(is_supported) begin
      if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision < svt_chi_node_configuration::ISSUE_E) begin
        is_supported = 0;
        str_is_supported_info = $sformatf("svt_chi_node_configuration::chi_spec_revision is not set to svt_chi_node_configuration::ISSUE_E or later for initiating requester node %0d. Writeevictorevict can only be issued from RN when svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_E or later ", initiating_rn_node_idx_0);
      end else begin
        is_supported = 1;
      end  

      if (!is_supported) begin
        string str_complete_is_supported_info = {str_is_supported_info_prefix, str_is_supported_info, str_is_supported_info_suffix};
        issue_is_supported_failure(str_complete_is_supported_info);
      end
    end
  endfunction

  /**
   * Initializes cachelines and sends WriteEvictorEvict from node "node_index"
   */
  virtual task body();
    super.body();

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end
    
    send_coherent_transactions(svt_chi_common_transaction::WRITEEVICTOREVICT, 1);
    /** Wait for WriteEvictorEvict transactions to finish */
    coherent_seq.wait_for_active_xacts_to_end();
    
    print_caches();

  endtask: body
endclass: svt_chi_system_single_node_writeevictorevict_virtual_sequence

//------------------------------------------------------------------------------
/**
 * @groupname CHI_SYS_HAZARD
 * Abstract:
 * svt_chi_e_system_protocol_flow_ctrl_hn_writesoptionaldata_noninvalidating_snoop_hazard_directed_virtual_sequence
 * provides a sequence to test how components handle various hazard conditions
 * applicable for WRITEEVICTOREVICT and snoop transactions
 * 1. Send MAKEUNIQUE transaction to random address from random RN
 * 2. Send WRITEBACKFULL transaction to the same address from same RN
 * 3. Send READCLEAN transaction to the same address from different RN so that initial Cache state will move to either UC/SC
 * 4. Below 2 transactions are initiated parallelly from different RN-F nodes.
 *    #- Send READCLEAN transaction to the same address from different RN
 *    #- Send WRITEEVICTOREVICT type of transaction to the same address from the same
 *       RN from which READCLEAN transaction is initiated.
 *    .
 * 5. Check the order in which the two requests are processed by HN.
 * .
 *
 *  This sequence requires SVT_CHI_ISSUE_E_ENABLE macro to be defined and
 *  svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_E or later.
 *
 */
class svt_chi_e_system_protocol_flow_ctrl_hn_writesoptionaldata_noninvalidating_snoop_hazard_directed_virtual_sequence extends svt_chi_system_protocol_flow_ctrl_xact_hazard_virtual_sequence;

  /** Parameter that controls the number of transactions that will be generated */
  rand int unsigned sequence_length = 10;

  rand bit enable_outstanding = 0;

  bit enable_outstanding_status = 0;

  /** Constrain the sequence length to a reasonable value */
  constraint reasonable_sequence_length {
    sequence_length <= 100;
  }

  /** UVM Object Utility macro */
  `uvm_object_utils(svt_chi_e_system_protocol_flow_ctrl_hn_writesoptionaldata_noninvalidating_snoop_hazard_directed_virtual_sequence)

  extern function new(string name="svt_chi_e_system_protocol_flow_ctrl_hn_writesoptionaldata_noninvalidating_snoop_hazard_directed_virtual_sequence"); 

  virtual task pre_body();
    raise_phase_objection();
  endtask
 
  /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting RN-F Nodes = 2
   *  #- svt_chi_node_configuration::chi_spec_revision >= svt_chi_node_configuration::ISSUE_E
   */
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    string str_is_supported_info_prefix = "This sequence cannot be run based on the current configuration.\n";
    string str_is_supported_info = "";
    string str_is_supported_info_suffix = "Modify configurations through svt_chi_node_configuration::chi_spec_revision\n";
    is_supported = super.is_supported(cfg, silent);
    if(is_supported) begin
      if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision < svt_chi_node_configuration::ISSUE_E) begin
        is_supported = 0;
        str_is_supported_info = $sformatf("svt_chi_node_configuration::chi_spec_revision is not set to svt_chi_node_configuration::ISSUE_E or later for initiating requester node %0d. Writeevictorevict can only be issued from RN when svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_E or later ", initiating_rn_node_idx_0);
      end else begin
        is_supported = 1;
      end  
      if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision < svt_chi_node_configuration::ISSUE_E) begin
        is_supported = 0;
        str_is_supported_info = $sformatf("svt_chi_node_configuration::chi_spec_revision is not set to svt_chi_node_configuration::ISSUE_E or later for initiating requester node %0d. Writeevictorevict can only be issued from RN when svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_E or later ", initiating_rn_node_idx_1);
      end else begin
        is_supported = 1;
      end  

      if (!is_supported) begin
        string str_complete_is_supported_info = {str_is_supported_info_prefix, str_is_supported_info, str_is_supported_info_suffix};
        issue_is_supported_failure(str_complete_is_supported_info);
      end
    end
  endfunction

  virtual task body();
    bit                           status;
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0] txn_address;
    bit [`SVT_CHI_MAX_DATA_WIDTH -1:0] txn_data;
    bit txn_mem_attr_allocate_hint, txn_snp_attr_snp_domain_type, txn_is_non_secure_access;
    event read_type_txn_ended;

    /** Sub sequences initiated from this sequence */
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq;
    svt_chi_rn_copyback_type_transaction_directed_sequence copyback_seq;
    svt_chi_rn_read_type_transaction_directed_sequence read_seq;

    /** Sub sequences initiated from this sequence */
    svt_chi_rn_read_type_transaction_directed_sequence read_seq_0;
    svt_chi_e_rn_writesoptionaldata_type_transaction_directed_sequence writesoptionaldata_seq;

    `uvm_info("body", "Entered ...", UVM_HIGH)

    // Default
    enable_outstanding = 0;
    status = uvm_config_db #(int unsigned)::get(null, get_full_name(), "sequence_length", sequence_length);
    `uvm_info("body", $sformatf("sequence_length is %0d as a result of %0s.", sequence_length, status ? "config DB" : "randomization"), UVM_HIGH);

    enable_outstanding_status = uvm_config_db#(bit)::get(m_sequencer, get_type_name(), "enable_outstanding", enable_outstanding);
    `uvm_info("body", $sformatf("enable_outstanding is %0b as a result of %0s", enable_outstanding, (enable_outstanding_status?"config DB":"default setting")), UVM_HIGH);

    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :initiating_rn_f_node_index_0;
    initiating_rn_node_idx_1 = initiating_rn_node_index_1_status ? initiating_rn_node_index_1_from_config_db :initiating_rn_f_node_index_1;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_f_node_index_0;

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    str_initiating_rn_node_indices = "";
    /** Display the contents of Active Participating RN-F Nodes */
    foreach (active_participating_rn_f_nodes[j]) begin
      str_initiating_rn_node_indices = {str_initiating_rn_node_indices, $sformatf(" %0d", active_participating_rn_f_nodes[j])};
    end 
    str_initiating_rn_node_indices = {str_initiating_rn_node_indices, $sformatf("\n RN nodes used to initiate the transactions are initiating_rn_node_idx_0 : %0d, initiating_rn_node_idx_1 : %0d", initiating_rn_node_idx_0, initiating_rn_node_idx_1)};
    `svt_xvm_debug("body", $sformatf("contents of active_participating_rn_f_nodes and RN nodes used to initiate the transactions are %0s", str_initiating_rn_node_indices));
    for(int i = 0; i < sequence_length; i++) begin
      bit rn0_is_unique, rn0_is_clean, rn1_is_unique, rn1_is_clean, rn0_read_status, rn1_read_status;
      bit rn_cache_dirty_state,rn_cache_unique_state;

      /** Write data into Cache of Randomly selected first RN with address of randomly selected HN Node */
      `svt_xvm_do_on_with(makeunique_seq, p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,
      {
        sequence_length == 1;
        hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
        seq_hn_node_idx == target_hn_node_idx_0;
        use_seq_is_non_secure_access == 0;        
      })

      /** Wait for MakeUnique transactions to finish */ 
      makeunique_seq.write_tran.wait_end();
      txn_address = makeunique_seq.output_xacts[0].addr;
      txn_data = makeunique_seq.data_in_cache;
      txn_mem_attr_allocate_hint = makeunique_seq.output_xacts[0].mem_attr_allocate_hint;
      txn_snp_attr_snp_domain_type = makeunique_seq.output_xacts[0].snp_attr_snp_domain_type;
      txn_is_non_secure_access = makeunique_seq.output_xacts[0].is_non_secure_access;

      /** Initiate a WRITEBACKFULL transaction from initiating_rn_node_idx_1 to txn_address. */ 
      `svt_xvm_do_on_with(copyback_seq, p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,
      {
        sequence_length == 1;
        data_in_cache == txn_data;
        seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
        hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
        min_addr == txn_address;
        max_addr == txn_address;
        seq_xact_type == svt_chi_transaction::WRITEBACKFULL;
        seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
        seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
        seq_is_non_secure_access == txn_is_non_secure_access;
        use_seq_is_non_secure_access == 1;               
      }
      )
      /** Waiting for copyback transaction to complete */ 
      copyback_seq.copyback_tran.wait_end(); 
      
      // Do a READCLEAN transaction from initiating_rn_node_idx_0, followed by WRITEEVICTOREVICT
      // transaction from initiating_rn_node_idx_1 after a delay of 1 clock cycle.
      `svt_xvm_do_on_with(read_seq, p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
      {
        sequence_length == 1;
        data_in_cache == txn_data;
        seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
        hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
        min_addr == txn_address;
        max_addr == txn_address;
        seq_xact_type == svt_chi_transaction::READCLEAN;
        seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
        seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
        seq_is_non_secure_access == txn_is_non_secure_access;
        use_seq_is_non_secure_access == 1;        
      }
      )
      /** Waiting for Read type transaction to complete */ 
      read_seq.read_tran.wait_end(); 

      /* WRITEEVICTOREVICT-SNOOP hazard at RN **/
      fork 
        begin      
          // Do a READCLEAN transaction from initiating_rn_node_idx_0, followed by WRITEBACK
          // transaction from initiating_rn_node_idx_1 after a delay of 1 clock cycle.
          `svt_xvm_do_on_with(read_seq_0, p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,
          {
            sequence_length == 1;
            data_in_cache == txn_data;
            seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
            hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
            min_addr == txn_address;
            max_addr == txn_address;
            seq_xact_type != svt_chi_transaction::READNOSNP;
            `ifdef SVT_CHI_ISSUE_B_ENABLE
            seq_xact_type != svt_chi_transaction::READSPEC;
            `endif
            seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
            seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
            seq_is_non_secure_access == txn_is_non_secure_access;
            use_seq_is_non_secure_access == 1;        
          }
          )
          /** Waiting for Read type transaction to complete */ 
          read_seq_0.read_tran.wait_end(); 
          ->read_type_txn_ended;
        end
        begin
          repeat (2)begin
`ifndef SVT_CHI_ENABLE_MULTI_CLOCK
            @ (posedge sys_cfg.chi_if.clk);
`else
            @ (posedge sys_cfg.chi_if.rn_clk[initiating_rn_node_idx_0]);
`endif
          end  
          wait (read_seq_0 != null);
          read_seq_0.read_tran.wait_begin(); 
          /** Initiate a WRITEEVICTOREVICT transaction from initiating_rn_node_idx_0 to txn_address. */ 
          `svt_xvm_do_on_with(writesoptionaldata_seq, p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
          {
            sequence_length == 1;
            data_in_cache == txn_data;
            seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
            hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
            min_addr == txn_address;
            max_addr == txn_address;
          }
          )
          /** Waiting for WRITEEVICTOREVICT transaction to complete */ 
          writesoptionaldata_seq.copyback_tran.wait_end(); 
        end
        begin
          @read_type_txn_ended;
          `svt_xvm_debug("body", $psprintf("Read transaction %0s ended succesfully. Transaction req_status :: %0s , data_status :: %0s",`SVT_CHI_PRINT_PREFIX(read_seq_0.read_tran),read_seq_0.read_tran.req_status, read_seq_0.read_tran.data_status));
          `svt_xvm_debug("body", $psprintf("Checking the req_status :: %0s and data_status :: %0s of a Copyback transaction :: %0s",writesoptionaldata_seq.copyback_tran.req_status, writesoptionaldata_seq.copyback_tran.data_status,`SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq.copyback_tran)));
          if((writesoptionaldata_seq.copyback_tran.req_status == svt_chi_transaction::ACCEPT)||
             (writesoptionaldata_seq.copyback_tran.req_status == svt_chi_transaction::ABORTED)||
             (writesoptionaldata_seq.copyback_tran.resp_status == svt_chi_transaction::ACCEPT)||
             (writesoptionaldata_seq.copyback_tran.data_status == svt_chi_transaction::ACCEPT))begin
            `svt_xvm_error("body", $psprintf("Copyback transaction :: %0s is not expected to complete before read type transaction - %0s",`SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq.copyback_tran),`SVT_CHI_PRINT_PREFIX(read_seq_0.read_tran)));
          end
          else begin
            `svt_xvm_debug("body", $psprintf("read transaction :: %0s completed first and it is followed by copyback type transaction - %0s",`SVT_CHI_PRINT_PREFIX(read_seq_0.read_tran),`SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq.copyback_tran)));
          end
        end
      join
    end

    `uvm_info("body", "Exiting...", UVM_HIGH)
  endtask: body

  virtual task post_body();
    drop_phase_objection();
  endtask

endclass: svt_chi_e_system_protocol_flow_ctrl_hn_writesoptionaldata_noninvalidating_snoop_hazard_directed_virtual_sequence

function svt_chi_e_system_protocol_flow_ctrl_hn_writesoptionaldata_noninvalidating_snoop_hazard_directed_virtual_sequence::new(string name="svt_chi_e_system_protocol_flow_ctrl_hn_writesoptionaldata_noninvalidating_snoop_hazard_directed_virtual_sequence");
  super.new(name);
endfunction

//------------------------------------------------------------------------------
/**
 * @groupname CHI_SYS_HAZARD
 * Abstract:
 * svt_chi_e_system_protocol_flow_ctrl_hn_writesoptionaldata_invalidating_snoop_hazard_directed_virtual_sequence
 * provides a sequence to test how components handle various hazard conditions
 * applicable for WRITEEVICTOREVICT and snoop transactions
 * 1. Send MAKEUNIQUE transaction to random address from random RN
 * 2. Send WRITEBACKFULL transaction to the same address from same RN
 * 3. Send READCLEAN transaction to the same address from different RN so that initial Cache state will move to either UC/SC
 * 4. Below 2 transactions are initiated parallelly from different RN-F nodes.
 *    #- Send CLEANINVALID/MAKEINVALID type of transaction to the same address from different RN
 *    #- Send WRITEEVICTOREVICT type of transaction to the same address from the same
 *       RN from which READCLEAN transaction is initiated.
 *    .
 * 5. Check the order in which the two requests are processed by HN. 
 * .
 *
 *  This sequence requires SVT_CHI_ISSUE_E_ENABLE macro to be defined and
 *  svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_E or later.
 *
 */
class svt_chi_e_system_protocol_flow_ctrl_hn_writesoptionaldata_invalidating_snoop_hazard_directed_virtual_sequence extends svt_chi_system_protocol_flow_ctrl_xact_hazard_virtual_sequence;

  /** Parameter that controls the number of transactions that will be generated */
  rand int unsigned sequence_length = 10;

  rand bit enable_outstanding = 0;

  bit enable_outstanding_status = 0;

  /** Constrain the sequence length to a reasonable value */
  constraint reasonable_sequence_length {
    sequence_length <= 100;
  }

  /** UVM Object Utility macro */
  `uvm_object_utils(svt_chi_e_system_protocol_flow_ctrl_hn_writesoptionaldata_invalidating_snoop_hazard_directed_virtual_sequence)

  extern function new(string name="svt_chi_e_system_protocol_flow_ctrl_hn_writesoptionaldata_invalidating_snoop_hazard_directed_virtual_sequence"); 

  virtual task pre_body();
    raise_phase_objection();
  endtask
 
  /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting RN-F Nodes = 2
   *  #- svt_chi_node_configuration::chi_spec_revision >= svt_chi_node_configuration::ISSUE_E
   */
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    string str_is_supported_info_prefix = "This sequence cannot be run based on the current configuration.\n";
    string str_is_supported_info = "";
    string str_is_supported_info_suffix = "Modify configurations through svt_chi_node_configuration::chi_spec_revision\n";
    is_supported = super.is_supported(cfg, silent);
    if(is_supported) begin
      if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision < svt_chi_node_configuration::ISSUE_E) begin
        is_supported = 0;
        str_is_supported_info = $sformatf("svt_chi_node_configuration::chi_spec_revision is not set to svt_chi_node_configuration::ISSUE_E or later for initiating requester node %0d. Writeevictorevict can only be issued from RN when svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_E or later ", initiating_rn_node_idx_0);
      end else begin
        is_supported = 1;
      end  
      if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision < svt_chi_node_configuration::ISSUE_E) begin
        is_supported = 0;
        str_is_supported_info = $sformatf("svt_chi_node_configuration::chi_spec_revision is not set to svt_chi_node_configuration::ISSUE_E or later for initiating requester node %0d. Writeevictorevict can only be issued from RN when svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_E or later ", initiating_rn_node_idx_1);
      end else begin
        is_supported = 1;
      end  

      if (!is_supported) begin
        string str_complete_is_supported_info = {str_is_supported_info_prefix, str_is_supported_info, str_is_supported_info_suffix};
        issue_is_supported_failure(str_complete_is_supported_info);
      end
    end
  endfunction

  virtual task body();
    bit                           status;
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0] txn_address;
    bit [`SVT_CHI_MAX_DATA_WIDTH -1:0] txn_data;
    bit txn_mem_attr_allocate_hint, txn_snp_attr_is_snoopable, txn_snp_attr_snp_domain_type, txn_is_non_secure_access;
    event cmo_type_txn_ended;

    /** Sub sequences initiated from this sequence */
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq;
    svt_chi_rn_copyback_type_transaction_directed_sequence copyback_seq;
    svt_chi_rn_read_type_transaction_directed_sequence read_seq;

    /** Sub sequences initiated from this sequence */
    svt_chi_rn_read_type_transaction_directed_sequence read_seq_0;
    /** Sub CMO type transaction directed sequences initiated from this sequence */
    svt_chi_rn_cmo_type_transaction_directed_sequence cmo_seq_0;

    svt_chi_e_rn_writesoptionaldata_type_transaction_directed_sequence writesoptionaldata_seq;

    `uvm_info("body", "Entered ...", UVM_HIGH)

    // Default
    enable_outstanding = 0;
    status = uvm_config_db #(int unsigned)::get(null, get_full_name(), "sequence_length", sequence_length);
    `uvm_info("body", $sformatf("sequence_length is %0d as a result of %0s.", sequence_length, status ? "config DB" : "randomization"), UVM_HIGH);

    enable_outstanding_status = uvm_config_db#(bit)::get(m_sequencer, get_type_name(), "enable_outstanding", enable_outstanding);
    `uvm_info("body", $sformatf("enable_outstanding is %0b as a result of %0s", enable_outstanding, (enable_outstanding_status?"config DB":"default setting")), UVM_HIGH);

    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :initiating_rn_f_node_index_0;
    initiating_rn_node_idx_1 = initiating_rn_node_index_1_status ? initiating_rn_node_index_1_from_config_db :initiating_rn_f_node_index_1;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_f_node_index_0;

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    str_initiating_rn_node_indices = "";
    /** Display the contents of Active Participating RN-F Nodes */
    foreach (active_participating_rn_f_nodes[j]) begin
      str_initiating_rn_node_indices = {str_initiating_rn_node_indices, $sformatf(" %0d", active_participating_rn_f_nodes[j])};
    end 
    str_initiating_rn_node_indices = {str_initiating_rn_node_indices, $sformatf("\n RN nodes used to initiate the transactions are initiating_rn_node_idx_0 : %0d, initiating_rn_node_idx_1 : %0d", initiating_rn_node_idx_0, initiating_rn_node_idx_1)};
    `svt_xvm_debug("body", $sformatf("contents of active_participating_rn_f_nodes and RN nodes used to initiate the transactions are %0s", str_initiating_rn_node_indices));

    for(int i = 0; i < sequence_length; i++) begin
      bit rn0_is_unique, rn0_is_clean, rn1_is_unique, rn1_is_clean, rn0_read_status, rn1_read_status;
      bit rn_cache_dirty_state,rn_cache_unique_state;

      /** Write data into Cache of Randomly selected first RN with address of randomly selected HN Node */
      `svt_xvm_do_on_with(makeunique_seq, p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,
      {
        sequence_length == 1;
        hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
        seq_hn_node_idx == target_hn_node_idx_0;
        use_seq_is_non_secure_access == 0;        
      })

      /** Wait for MakeUnique transactions to finish */ 
      makeunique_seq.write_tran.wait_end();
      txn_address = makeunique_seq.output_xacts[0].addr;
      txn_data = makeunique_seq.data_in_cache;
      txn_mem_attr_allocate_hint = makeunique_seq.output_xacts[0].mem_attr_allocate_hint;
      txn_snp_attr_is_snoopable = makeunique_seq.output_xacts[0].snp_attr_is_snoopable;
      txn_snp_attr_snp_domain_type = makeunique_seq.output_xacts[0].snp_attr_snp_domain_type;
      txn_is_non_secure_access = makeunique_seq.output_xacts[0].is_non_secure_access;

      /** Initiate a WRITEBACKFULL transaction from initiating_rn_node_idx_1 to txn_address. */ 
      `svt_xvm_do_on_with(copyback_seq, p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,
      {
        sequence_length == 1;
        data_in_cache == txn_data;
        seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
        hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
        min_addr == txn_address;
        max_addr == txn_address;
        seq_xact_type == svt_chi_transaction::WRITEBACKFULL;
        seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
        seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
        seq_is_non_secure_access == txn_is_non_secure_access;
        use_seq_is_non_secure_access == 1;               
      }
      )
      /** Waiting for copyback transaction to complete */ 
      copyback_seq.copyback_tran.wait_end(); 
      
      // Do a READCLEAN transaction from initiating_rn_node_idx_0, followed by WRITEEVICTOREVICT
      // transaction from initiating_rn_node_idx_1 after a delay of 1 clock cycle.
      `svt_xvm_do_on_with(read_seq, p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
      {
        sequence_length == 1;
        data_in_cache == txn_data;
        seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
        hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
        min_addr == txn_address;
        max_addr == txn_address;
        seq_xact_type == svt_chi_transaction::READCLEAN;
        seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
        seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
        seq_is_non_secure_access == txn_is_non_secure_access;
        use_seq_is_non_secure_access == 1;        
      }
      )
      /** Waiting for Read type transaction to complete */ 
      read_seq.read_tran.wait_end(); 

      /* WRITEEVICTOREVICT-SNOOP hazard at RN **/
      fork 
        begin      
          xact_hazard_sema_0.get();
          /** Initiate CMO type of transaction from initiating_rn_node_idx_0 to txn_address. */ 
          `svt_xvm_do_on_with(cmo_seq_0, p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,
          {
            sequence_length == 1;
            hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
            min_addr == txn_address;
            max_addr == txn_address;
            seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
            seq_snp_attr_is_snoopable == txn_snp_attr_is_snoopable;
            seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
            seq_is_non_secure_access == txn_is_non_secure_access;
            use_seq_is_non_secure_access == 1;               
            seq_xact_type inside {svt_chi_transaction::CLEANINVALID, svt_chi_transaction::MAKEINVALID};
          }
          )
          xact_hazard_sema_0.put();
          /** Waiting for CMO type transaction to complete */ 
          cmo_seq_0.cmo_tran.wait_end(); 
          ->cmo_type_txn_ended;
        end
        begin
          repeat (2)begin
`ifndef SVT_CHI_ENABLE_MULTI_CLOCK
            @ (posedge sys_cfg.chi_if.clk);
`else
            @ (posedge sys_cfg.chi_if.rn_clk[initiating_rn_node_idx_0]);
`endif
          end  
          wait (cmo_seq_0 != null);
          cmo_seq_0.cmo_tran.wait_begin(); 
          /** Initiate a WRITEEVICTOREVICT transaction from initiating_rn_node_idx_0 to txn_address. */ 
          `svt_xvm_do_on_with(writesoptionaldata_seq, p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
          {
            sequence_length == 1;
            data_in_cache == txn_data;
            seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
            hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
            min_addr == txn_address;
            max_addr == txn_address;
          }
          )
          /** Waiting for copyback transaction to complete */ 
          writesoptionaldata_seq.copyback_tran.wait_end(); 
        end
        begin
          @cmo_type_txn_ended;
          `svt_xvm_debug("body", $psprintf("CMO transaction %0s ended succesfully. Transaction req_status :: %0s , data_status :: %0s",`SVT_CHI_PRINT_PREFIX(cmo_seq_0.cmo_tran),cmo_seq_0.cmo_tran.req_status, cmo_seq_0.cmo_tran.data_status));
          `svt_xvm_debug("body", $psprintf("Checking the req_status :: %0s and data_status :: %0s of a Copyback transaction :: %0s",writesoptionaldata_seq.copyback_tran.req_status, writesoptionaldata_seq.copyback_tran.data_status,`SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq.copyback_tran)));
          if((writesoptionaldata_seq.copyback_tran.req_status == svt_chi_transaction::ACCEPT)||
             (writesoptionaldata_seq.copyback_tran.req_status == svt_chi_transaction::ABORTED)||
             (writesoptionaldata_seq.copyback_tran.resp_status == svt_chi_transaction::ACCEPT)||
             (writesoptionaldata_seq.copyback_tran.data_status == svt_chi_transaction::ACCEPT))begin
            `svt_xvm_error("body", $psprintf("Copyback transaction :: %0s is not expected to complete before cmo type transaction - %0s",`SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq.copyback_tran),`SVT_CHI_PRINT_PREFIX(cmo_seq_0.cmo_tran)));
          end
          else begin
            `svt_xvm_debug("body", $psprintf("cmo transaction :: %0s completed first and it is followed by copyback type transaction - %0s",`SVT_CHI_PRINT_PREFIX(cmo_seq_0.cmo_tran),`SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq.copyback_tran)));
          end
        end
      join
    end

    `uvm_info("body", "Exiting...", UVM_HIGH)
  endtask: body

  virtual task post_body();
    drop_phase_objection();
  endtask

endclass: svt_chi_e_system_protocol_flow_ctrl_hn_writesoptionaldata_invalidating_snoop_hazard_directed_virtual_sequence

function svt_chi_e_system_protocol_flow_ctrl_hn_writesoptionaldata_invalidating_snoop_hazard_directed_virtual_sequence::new(string name="svt_chi_e_system_protocol_flow_ctrl_hn_writesoptionaldata_invalidating_snoop_hazard_directed_virtual_sequence");
  super.new(name);
endfunction

 //====================================================================================
 /** 
  * @groupname CHI_OUTSTANDING_CPBK_TYPE  
  * #- This sequence requires atleast one HN node to be present in the Interconnect.
  * #- This sequence requires atleast one initiating active and participating RN-F.
  * #- Inititate maximum number of MAKEUNIQUE followed by WRITEBACKFULL followed by
  *    READCLEAN transactions from existing active and 
  *    participating RN-F, to perform cache initialization to a
  *    randomly selected HN.
  * #- Initiate maximum number of Writesoptionaldata COPYBACK type transactions with 
  *    svt_chi_rn_transaction::suspend_wr_data set to 1 and
  *    svt_chi_rn_transaction::suspend_comp_ack set to 1 from the initiating
  *    RN-F to the randomly selected HN in non blocking mode. <br>
  *    - Maximum number of outstanding transactions at the HN is as per either #max_num_outstanding_write_xacts_at_hn or
  *      #max_num_outstanding_xacts_at_hn, which can be controlled through config DB.   
  *    - This ensures that the maximum outstanding transaction limit is reached at HN.
  *    - Also, the RN-F will not transmit CopyBackWrData or Compack corresponding to these
  *      transactions until svt_chi_rn_transaction::suspend_wr_data is or svt_chi_rn_transaction::suspend_comp_ack
  *      whichever is applicable is set to 0 from the sequence.
  *
  *    .
  * #- The addresses of these Writesoptionaldata COPYBACK transactions are such that:
  *    - Same as initialized cache line addresses if cache initialization is performed
  *    .
  * #- The RN-F of these Writesoptionaldata COPYBACK transactions are such that:
  *    - Same as RN-F from which cache initialization is performed
  *    .
  * #- Once the RN-F receives the responses for all the outstanding transactions from
  *    HN, attribute svt_chi_rn_transaction::suspend_wr_data or svt_chi_rn_transaction::suspend_comp_ack
  *    whichever is applicable is set to 0 for all the outstanding transactions. <br>
  *    This ensures that the CopyBackWrData or Compack for these transactions can be resumed 
  *    from RN-F.
  * #- Check that the HN responds properly for all outstanding Writesoptionaldata COPYBACK type
  *    transactions and these are completed successfully.
  * .
  * #- This sequence generates Writesoptionaldata COPYBACK type WRITEEVICTOREVICT transactions.
  * .
  *
  *  This sequence requires SVT_CHI_ISSUE_E_ENABLE macro to be defined and
  *  svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_E or later.
  *
  */ 
 
 class svt_chi_system_protocol_flow_ctrl_writesoptionaldata_outstanding_same_rn_same_hn_virtual_sequence extends svt_chi_system_protocol_flow_ctrl_copyback_outstanding_same_rn_same_hn_virtual_sequence;
 
   /** UVM/OVM Object Utility macro */
   `svt_xvm_object_utils(svt_chi_system_protocol_flow_ctrl_writesoptionaldata_outstanding_same_rn_same_hn_virtual_sequence)
 
   //-----------------------------------------------------------------------------  
   // Methods
   //-----------------------------------------------------------------------------
   /** Constructor */
   extern function new(string name="svt_chi_system_protocol_flow_ctrl_writesoptionaldata_outstanding_same_rn_same_hn_virtual_sequence"); 
 
   /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting RN-F Nodes = 1
   *  #- svt_chi_node_configuration::chi_spec_revision >= svt_chi_node_configuration::ISSUE_E
   *  .
   */
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    string str_is_supported_info_prefix = "This sequence cannot be run based on the current configuration.\n";
    string str_is_supported_info = "";
    string str_is_supported_info_suffix = "Modify configurations through svt_chi_node_configuration::chi_spec_revision\n";
    is_supported = super.is_supported(cfg, silent);
    if(is_supported) begin
      if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision < svt_chi_node_configuration::ISSUE_E) begin
        is_supported = 0;
        str_is_supported_info = $sformatf("svt_chi_node_configuration::chi_spec_revision is not set to svt_chi_node_configuration::ISSUE_E or later for initiating requester node %0d. Writeevictorevict can only be issued from RN when svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_E or later ", initiating_rn_node_idx_0);
      end else begin
        is_supported = 1;
      end  

      if (!is_supported) begin
        string str_complete_is_supported_info = {str_is_supported_info_prefix, str_is_supported_info, str_is_supported_info_suffix};
        issue_is_supported_failure(str_complete_is_supported_info);
      end
    end
  endfunction

 //-----------------------------------------------------------------------------
   virtual task body();
 
     /** Setting transaction id width */
     int txn_id_width=`SVT_CHI_TXN_ID_WIDTH;
 
     /** Queue of addresses, used by the transactions generated */
     bit[`SVT_CHI_MAX_ADDR_WIDTH -1:0] copyback_addr_queue[$];                      
     bit copyback_is_non_secure_access_queue[$];                      
     /** Queue of Unique transaction id's, used by the transactions generated */
     int txn_id_arr[$];
 
     int num_outstanding_xacts_to_generate;
 
     /** Sub Read type transaction cache initialization directed sequences initiated from this sequence */
     svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq[int];
     /** Sub CopyBack type transaction directed sequences initiated from this sequence */
     svt_chi_rn_copyback_type_transaction_directed_sequence copyback_seq[int];
     svt_chi_rn_read_type_transaction_directed_sequence read_seq[int];
 
     svt_chi_e_rn_writesoptionaldata_type_transaction_directed_sequence writesoptionaldata_seq[int];
 
     `svt_xvm_debug("body", "Entering ...")
 
     max_num_outstanding_xacts_at_hn_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(), "max_num_outstanding_xacts_at_hn", max_num_outstanding_xacts_at_hn);
     max_num_outstanding_write_xacts_at_hn_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(), "max_num_outstanding_write_xacts_at_hn", max_num_outstanding_write_xacts_at_hn);
     initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :initiating_rn_f_node_index_0;
     target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_f_node_index_0;
 
     /** check if current environment is supported or not */ 
     if(!is_supported(sys_cfg, silent))  begin
       `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
       return;
     end
 
     //If max outstanding count for Write transactions has been programmed, use that to generate the outstanding Copyback
     if(max_num_outstanding_write_xacts_at_hn > 0) begin
       num_outstanding_xacts_to_generate = max_num_outstanding_write_xacts_at_hn;
       `svt_xvm_debug("body",$sformatf("max_num_outstanding_write_xacts_at_hn is set to a non-zero value (%0d). Hence, the value programmed in max_num_outstanding_xacts_at_hn will be ignored. The number of outstanding transactions issued by the sequence will be equal to max_num_outstanding_write_xacts_at_hn", max_num_outstanding_write_xacts_at_hn));
     end
     //If not, use the max outstanding transaction count
     else
       num_outstanding_xacts_to_generate = max_num_outstanding_xacts_at_hn;
 
     for(int i = 0; i < sequence_length; i++) begin
 
       /** Collecting txn_id */
       if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision >= svt_chi_node_configuration::ISSUE_E) begin
         for(int id=0; id <= `SVT_CHI_SPEC_PERMITTED_MAX_TXNID_VALUE_FOR_ISSUE_E; id++) begin
           txn_id_arr.push_back(id);
         end
       end
       else if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision >= svt_chi_node_configuration::ISSUE_D) begin
         for(int id=0; id <= `SVT_CHI_SPEC_PERMITTED_MAX_TXNID_VALUE_FOR_ISSUE_D; id++) begin
           txn_id_arr.push_back(id);
         end
       end else begin
         for(int id=0; id <= `SVT_CHI_SPEC_PERMITTED_MAX_TXNID_VALUE_UPTO_ISSUE_C; id++) begin
           txn_id_arr.push_back(id);
         end
       end
 
       /** Shuffling all collected txn_id */
       txn_id_arr.shuffle;
 
       /** Initiating outstanding MakeUnique transactions from random RN-F
        *  to initialise the cache line state to UD state which is followed by  
        *  WRITEBACKFULL and READCLEAN. 
        */
       for(int l=0; l< num_outstanding_xacts_to_generate; l++) begin
         `svt_xvm_do_on_with(makeunique_seq[l], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,{
           sequence_length    == 1;
           set_unique_addr_value    == 1;
           hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
           seq_hn_node_idx  == target_hn_node_idx_0;        
           use_seq_is_non_secure_access == 0;                    
         })  
 
         `svt_xvm_verbose("body", $sformatf(" MakeUnique Transaction %0s",makeunique_seq[l].write_tran.sprint()));
 
       /** Waiting for above MakeUnique transactions to complete */ 
         `svt_xvm_debug("body", $sformatf("%0s Waiting for MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) to end",`SVT_CHI_PRINT_PREFIX(makeunique_seq[l].write_tran),l, makeunique_seq[l].write_tran.hn_node_idx, makeunique_seq[l].write_tran.tgt_id));
       
         makeunique_seq[l].write_tran.wait_end(); 
 
         `svt_xvm_debug("body", $sformatf("%0s MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) ended",`SVT_CHI_PRINT_PREFIX(makeunique_seq[l].write_tran),l, makeunique_seq[l].write_tran.hn_node_idx, makeunique_seq[l].write_tran.tgt_id));
 
         /** Retrieving address from output transactions generated by the sequence  */
         copyback_addr_queue.push_back(makeunique_seq[l].write_tran.addr);
         copyback_is_non_secure_access_queue.push_back(makeunique_seq[l].write_tran.is_non_secure_access);
 
         /** Initiate a WRITEBACKFULL transaction from initiating_rn_node_idx_1 to txn_address. */ 
         `svt_xvm_do_on_with(copyback_seq[l], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,{
           sequence_length == 1;
           seq_txn_id == makeunique_seq[l].write_tran.txn_id;
           seq_xact_type == svt_chi_transaction::WRITEBACKFULL;
           seq_order_type  == svt_chi_transaction::NO_ORDERING_REQUIRED;
           seq_copyback_req_order_enable == 0;  
           hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
           min_addr           == makeunique_seq[l].write_tran.addr;
           max_addr           == makeunique_seq[l].write_tran.addr;     
           seq_is_non_secure_access == makeunique_seq[l].write_tran.is_non_secure_access;
           use_seq_is_non_secure_access == 1;              
           })
         copyback_seq[l].copyback_tran.wait_end(); 
 
         // Do a READCLEAN transaction from initiating_rn_node_idx_0, followed by WRITEEVICTOREVICT
         // transaction from initiating_rn_node_idx_1 after a delay of 1 clock cycle.
         `svt_xvm_do_on_with(read_seq[l], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
         {
           sequence_length == 1;
           data_in_cache == makeunique_seq[l].write_tran.data;
           seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
           hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
           min_addr           == makeunique_seq[l].write_tran.addr;
           max_addr           == makeunique_seq[l].write_tran.addr;     
           seq_xact_type      == svt_chi_transaction::READCLEAN;
           seq_mem_attr_allocate_hint == makeunique_seq[l].write_tran.mem_attr_allocate_hint;
           seq_snp_attr_snp_domain_type == makeunique_seq[l].write_tran.snp_attr_snp_domain_type;
           seq_is_non_secure_access == makeunique_seq[l].write_tran.is_non_secure_access;
           use_seq_is_non_secure_access == 1;        
         }
         )
         /** Waiting for Read type transaction to complete */ 
         read_seq[l].read_tran.wait_end(); 
       end //forloop of Cache initialization sequences
 
       /** Initiating outstanding Write optinal data transactions from a Random RN-F.  
        *  Initial cache line state is:
        *   SC, UC : svt_chi_transaction::WRITEEVICTOREVICT  
        */
       for(int j = 0; j < num_outstanding_xacts_to_generate; j++) begin
         bit[`SVT_CHI_MAX_ADDR_WIDTH -1:0]txn_addr = copyback_addr_queue.pop_front();
         bit txn_is_non_secure = copyback_is_non_secure_access_queue.pop_front();
         automatic int txn_id   = txn_id_arr.pop_front();
         `svt_xvm_do_on_with(writesoptionaldata_seq[j], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,{
           sequence_length == 1;
           seq_txn_id == txn_id;
           seq_order_type  == svt_chi_transaction::NO_ORDERING_REQUIRED;
           seq_copyback_req_order_enable == 0;  
           hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
           min_addr           == txn_addr;
           max_addr           == txn_addr;     
           seq_is_non_secure_access == txn_is_non_secure;
           use_seq_is_non_secure_access == 1;              
           })
         
         `svt_xvm_debug("body", $sformatf("%0s Transmitting Writeevictorevict CopyBack Transaction [%0d] targeted to HN (idx %0d, id %0d) ",`SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq[j].copyback_tran),j, writesoptionaldata_seq[j].copyback_tran.hn_node_idx, writesoptionaldata_seq[j].copyback_tran.tgt_id));
         `svt_xvm_verbose("body", $sformatf("CopyBack Transaction [%0d] is %0s", j,writesoptionaldata_seq[j].copyback_tran.sprint()));
       end //forloop of CopyBack
 
       /** Checking for the reception of all the Comp/CompDBIDResp from the Interconnect */
       foreach(writesoptionaldata_seq[index_1]) begin
         fork
           automatic int _index_1 = index_1;
           begin
             `svt_xvm_debug("body", $sformatf("%0s CopyBack transaction [%0d] targeted to HN (idx %0d, id %0d), suspend_wr_data %0b, suspend_comp_ack %0b: waiting for response from interconnect",`SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq[_index_1].copyback_tran),_index_1, writesoptionaldata_seq[_index_1].copyback_tran.hn_node_idx, writesoptionaldata_seq[_index_1].copyback_tran.tgt_id,writesoptionaldata_seq[_index_1].copyback_tran.suspend_wr_data, writesoptionaldata_seq[_index_1].copyback_tran.suspend_comp_ack));
            /** Waiting for either Comp response/Compdbidresp/Retry reponse from the ICN */ 
             fork
             begin
               fork
                 begin
                   /** Waiting for either Comp response from the ICN or req_status to be ACCEPT */ 
                   writesoptionaldata_seq[_index_1].copyback_tran.wait_for_tx_compack_prereqs();
                 end
                 begin
                   /** Waiting for either Compdbidresp response from the ICN or req_status to be ACCEPT */ 
                   writesoptionaldata_seq[_index_1].copyback_tran.wait_for_tx_data_prereqs();
                 end
                 begin
                   /** Waiting for Retry response from the ICN or req_status to be RETRY */ 
                   wait(writesoptionaldata_seq[_index_1].copyback_tran.req_status == svt_chi_transaction::RETRY);// begin
                 end
               join_any
               disable fork;
             end
             join
             received_copyback_responses++;
             
             `svt_xvm_debug("body", $sformatf("%0s CopyBack transaction [%0d] targeted to HN (idx %0d, id %0d), suspend_wr_data %0b, suspend_comp_ack %0b: waiting for response from interconnect. Total responses received %0d",`SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq[_index_1].copyback_tran),_index_1, writesoptionaldata_seq[_index_1].copyback_tran.hn_node_idx, writesoptionaldata_seq[_index_1].copyback_tran.tgt_id,writesoptionaldata_seq[_index_1].copyback_tran.suspend_wr_data, writesoptionaldata_seq[_index_1].copyback_tran.suspend_comp_ack,received_copyback_responses));
           end
         join_none  
       end
      
       /** Waiting for the Comp/CompDBIDResp from HN to Resume the Suspended Response of all above Copyback transactions */ 
       `svt_xvm_debug("body",$sformatf("Completed initiation of CopyBack type transactions for %0d addresses from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d with suspend_wr_data or suspend_comp_ack set to 1, and waiting to receive responses from interconnect.",num_outstanding_xacts_to_generate, initiating_rn_node_idx_0, target_hn_node_idx_0));
       
       wait(received_copyback_responses == num_outstanding_xacts_to_generate);
       outstanding_xact_count_reached = 1;
       `svt_xvm_debug("body",$sformatf("Received responses from interconnect to CopyBack type transactions for %0d addresses from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d with suspend_wr_data set to 1",num_outstanding_xacts_to_generate, initiating_rn_node_idx_0, target_hn_node_idx_0));
 
       /** Self Check1: To check suspend_wr_data/suspend_comp_ack should not be modified to zero by the VIP
        *  before reseting from test bench.
        */
       foreach (writesoptionaldata_seq[self_check_idx1]) begin
         if(!writesoptionaldata_seq[self_check_idx1].copyback_tran.is_terminated()) begin 
           // Checking compack is expected for Writeoptional data transactions.      
           if(writesoptionaldata_seq[self_check_idx1].copyback_tran.has_compack_transfer_for_copyback_xact()) begin 
             if (writesoptionaldata_seq[self_check_idx1].copyback_tran.suspend_comp_ack == 0) begin
               `svt_xvm_error("body", $sformatf("%0s suspend_comp_ack should be 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq[self_check_idx1].copyback_tran)));
             end
             else begin
               `svt_xvm_debug("body", $sformatf("%0s suspend_comp_ack is 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq[self_check_idx1].copyback_tran)));
             end
           end
           else begin
             if (writesoptionaldata_seq[self_check_idx1].copyback_tran.suspend_wr_data == 0) begin
               `svt_xvm_error("body", $sformatf("%0s suspend_wr_data should be 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq[self_check_idx1].copyback_tran)));
             end
             else begin
               `svt_xvm_debug("body", $sformatf("%0s suspend_wr_data is 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq[self_check_idx1].copyback_tran)));
             end
           end        
         end
       end
 
       /** Self Check2: To check transaction is not ended by the VIP before resuming the 
        *  suspend_wr_data to zero from the test bench<br>
        */
       foreach (writesoptionaldata_seq[self_check_idx2]) begin
         if(!writesoptionaldata_seq[self_check_idx2].copyback_tran.is_terminated()) begin 
           if (writesoptionaldata_seq[self_check_idx2].copyback_tran.end_event.is_on() == 1) begin
             if (writesoptionaldata_seq[self_check_idx2].copyback_tran.has_compack_transfer_for_copyback_xact()) begin 
               // Fail  event has triggered
               `svt_xvm_error("body", $sformatf("Unexpected: %0s Transaction's end_event triggered when suspend_compack is still 1.", `SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq[self_check_idx2].copyback_tran)));
             end 
             else begin
               // Fail  event has triggered
               `svt_xvm_error("body", $sformatf("Unexpected: %0s Transaction's end_event triggered when suspend_wr_data is still 1.", `SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq[self_check_idx2].copyback_tran)));
             end        
           end
           else begin
             if (writesoptionaldata_seq[self_check_idx2].copyback_tran.has_compack_transfer_for_copyback_xact()) begin 
               // Pass  event is not triggered
               `svt_xvm_debug("body", $sformatf("Expected: %0s Transaction's end_event is not triggered when suspend_compack is still 1.", `SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq[self_check_idx2].copyback_tran)));
             end
             else begin
               // Pass  event is not triggered
               `svt_xvm_debug("body", $sformatf("Expected: %0s Transaction's end_event is not triggered when suspend_wr_data is still 1.", `SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq[self_check_idx2].copyback_tran)));
             end        
           end
         end
       end
  
       /** Self Check 3: To check that the current_outstanding_*_xact_count in the RN
        * is as per the transactions inititated by the sequence
        */
       /** Check if the total outstanding xact counter is set correctly in the shared status of the RN agent */
       if(writesoptionaldata_seq[0].shared_status.prot_status.current_outstanding_xact_count != num_outstanding_xacts_to_generate)
         `svt_xvm_error("body", $sformatf("Issued %0d outstanding transactions from the sequence but the outstanding transaction count in the shared status of RN%0d is %0d", num_outstanding_xacts_to_generate, initiating_rn_node_idx_0, writesoptionaldata_seq[0].shared_status.prot_status.current_outstanding_xact_count));
       /** Check if the outstanding Write xact counter is set correctly in the shared status of the RN agent */
       if(writesoptionaldata_seq[0].shared_status.prot_status.current_outstanding_write_xact_count != num_outstanding_xacts_to_generate) begin
         `svt_xvm_error("body", $sformatf("Issued %0d outstanding Copyback transactions from the sequence but the outstanding Write transaction count in the shared status of RN%0d is %0d", num_outstanding_xacts_to_generate, initiating_rn_node_idx_0, writesoptionaldata_seq[0].shared_status.prot_status.current_outstanding_write_xact_count));
       end
 
       `svt_xvm_debug("body", $sformatf("RN%0d: Number of outstanding transactions : %0d, Number of outstanding write xacts : %0d", initiating_rn_node_idx_0, writesoptionaldata_seq[0].shared_status.prot_status.current_outstanding_xact_count, writesoptionaldata_seq[0].shared_status.prot_status.current_outstanding_write_xact_count));
 
       /** Targeted HN ID from the RN should be same throughout */
       foreach(writesoptionaldata_seq[wr]) begin
         int hn_idx_0;
         hn_idx_0 = sys_cfg.get_hn_idx(writesoptionaldata_seq[wr].output_xacts[0].addr);
         if (hn_idx_0 == target_hn_node_idx_0) begin
           `svt_xvm_debug("body", $sformatf("Targeted HN Index from the RN is same as expected.  rn[%0d] to hn_idx[%0d]", initiating_rn_node_idx_0, hn_idx_0));
         end
         else begin
           `svt_xvm_error("body", $sformatf("Targeted HN Index from the RN is different, which is unexpected.  rn[%0d] %0s transaction to hn_idx[%0d]",initiating_rn_node_idx_0, `SVT_CHI_PRINT_PREFIX( writesoptionaldata_seq[wr].output_xacts[0]), hn_idx_0));
         end
       end
       
       /** Resuming all Suspended Response of all above Copyback transactions  */
       foreach(writesoptionaldata_seq[wr]) begin
         if (writesoptionaldata_seq[wr].copyback_tran.has_compack_transfer_for_copyback_xact()) begin 
           `svt_xvm_debug("body",$sformatf("Received responses for all CopyBack type transactions from interconnect, resuming the transactions by setting svt_chi_rn_transaction::suspend_comp_ack set to 0 %0s",`SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq[wr].copyback_tran)));
           writesoptionaldata_seq[wr].copyback_tran.suspend_comp_ack=0; 
           `svt_xvm_debug("body", $sformatf("For iteration %0d : After Resume, received_copyback_responses is %0d,suspend_comp_ack is %0b",wr,received_copyback_responses,writesoptionaldata_seq[wr].copyback_tran.suspend_comp_ack));
         end
         else begin
           `svt_xvm_debug("body",$sformatf("Received responses for all CopyBack type transactions from interconnect, resuming the transactions by setting svt_chi_rn_transaction::suspend_wr_data set to 0 %0s",`SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq[wr].copyback_tran)));
           writesoptionaldata_seq[wr].copyback_tran.suspend_wr_data=0; 
           `svt_xvm_debug("body", $sformatf("For iteration %0d : After Resume, received_copyback_responses is %0d,suspend_wr_data is %0b",wr,received_copyback_responses,writesoptionaldata_seq[wr].copyback_tran.suspend_wr_data));
         end  
       end
 
       `svt_xvm_debug("body",$sformatf("Waiting for completion of all the outstanding CopyBack type transactions"));
       /** Waiting for above Copyback outstanding transactions to complete */
       foreach(writesoptionaldata_seq[index_2]) begin
         `svt_xvm_debug("body", $sformatf("Waiting for above writesoptionaldata_seq[%0d] transaction %0s to end", index_2,`SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq[index_2].copyback_tran)));
         writesoptionaldata_seq[index_2].copyback_tran.wait_end(); 
         /** Self Check4: To check suspend_comp_ack/suspend_wr_data should not be asserted after the transaction 
          *  completes as it is reseted from test bench
          */
         if(!writesoptionaldata_seq[index_2].copyback_tran.is_terminated()) begin 
           if (writesoptionaldata_seq[index_2].copyback_tran.has_compack_transfer_for_copyback_xact()) begin 
             if (writesoptionaldata_seq[index_2].copyback_tran.suspend_comp_ack == 1) begin
               `svt_xvm_error("body", $sformatf("%0s suspend_comp_ack should be 0 as it has been reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq[index_2].copyback_tran)));
             end
             else begin
               `svt_xvm_debug("body", $sformatf("%0s suspend_comp_ack is 0 as it is reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq[index_2].copyback_tran)));
             end
           end
           else begin
             if (writesoptionaldata_seq[index_2].copyback_tran.suspend_wr_data == 1) begin
               `svt_xvm_error("body", $sformatf("%0s suspend_wr_data should be 0 as it has been reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq[index_2].copyback_tran)));
             end
             else begin
               `svt_xvm_debug("body", $sformatf("%0s suspend_wr_data is 0 as it is reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq[index_2].copyback_tran)));
             end
           end        
         end
       end
       `svt_xvm_debug("body",$sformatf("Received completions for all CopyBack type outstanding transactions"));
       
   
       /** Reset received_copyback_responses to Zero */
       received_copyback_responses = 0;
 
       /** Empty the address and txn_id queues */
       copyback_addr_queue.delete();
       copyback_is_non_secure_access_queue.delete();
       txn_id_arr.delete();
        
     end//for loop of sequence_length

     /** 
     * To check the Interconnect HN Node shall responds to 
     * outstanding tranactions to RN.<br>
     * Check done by System monitor(List of checkers)<br>
     *  #- copyback_data_integrity_check
     *  .  
     */
     `svt_xvm_debug("body", "Exiting...")
   endtask: body
 
 endclass
 
 function svt_chi_system_protocol_flow_ctrl_writesoptionaldata_outstanding_same_rn_same_hn_virtual_sequence::new(string name="svt_chi_system_protocol_flow_ctrl_writesoptionaldata_outstanding_same_rn_same_hn_virtual_sequence");
   super.new(name);
 endfunction

//====================================================================================
/** 
 * @groupname CHI_OUTSTANDING_CPBK_TYPE 
 * #- This sequence requires atleast one HN node to be present in the Interconnect.
 * #- This sequence requires atleast two initiating active and participating RN-Fs.
 * #- Inititate maximum number of MAKEUNIQUE followed by WRITEBACKFULL followed by
 *    READCLEAN transactions from existing active and 
 *    participating RN-F, to perform cache initialization to a
 *    randomly selected HN.
 * #- Initiate maximum number of Writesoptionaldata COPYBACK type transactions with 
 *    svt_chi_rn_transaction::suspend_wr_data set to 1 and
 *    svt_chi_rn_transaction::suspend_comp_ack set to 1 from the initiating
 *    RN-Fs to randomly selected HN in non blocking mode. <br>
 *    - Maximum number of outstanding transactions at the HN is as per either #max_num_outstanding_write_xacts_at_hn or
 *      #max_num_outstanding_xacts_at_hn, which can be controlled through config DB.  
 *    - This ensures that the maximum outstanding transaction limit is reached at
 *      the HN. 
 *    - Also,the RN-Fs will not transmit CopyBackWrData or Compack corresponding to these
 *      transactions until svt_chi_rn_transaction::suspend_wr_data or svt_chi_rn_transaction::suspend_comp_ack
 *      whichever is applicable is set to 0 from the sequence.
 *    .
 * #- The addresses of these COPYBACK transactions are such that:
 *    - Same as initialized cache line addresses if cache initialization is performed
 *    .
 * #- The RN-Fs of these COPYBACK transactions are such that:
 *    - Same as RN-Fs from which cache initialization is performed
 *    .
 * #- Once the RN-Fs receives the responses for all the outstanding transactions from
 *    the HN, attribute svt_chi_rn_transaction::suspend_wr_data or svt_chi_rn_transaction::suspend_comp_ack 
 *    whichever is applicable is set to 0 for all the outstanding transactions. <br>
 *    This ensures that the CopyBackWrData or Compack for these transactions can be resumed 
 *    from RN-Fs.
 * #- Check that the HN responds properly for all outstanding Writesoptionaldata COPYBACK type
 *    transactions and these are completed successfully.
 * .
 * #- This sequence gemerates Writesoptionaldata COPYBACK type WRITEEVICTOREVICT transactions.
 * .
 *
 *  This sequence requires SVT_CHI_ISSUE_E_ENABLE macro to be defined and
 *  svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_E or later.
 *
 */ 

class svt_chi_system_protocol_flow_ctrl_writesoptionaldata_outstanding_diff_rn_same_hn_virtual_sequence extends svt_chi_system_protocol_flow_ctrl_copyback_outstanding_diff_rn_same_hn_virtual_sequence;

  /** UVM Object Utility macro */
  `svt_xvm_object_utils(svt_chi_system_protocol_flow_ctrl_writesoptionaldata_outstanding_diff_rn_same_hn_virtual_sequence)

  //-----------------------------------------------------------------------------  
  // Methods
  //-----------------------------------------------------------------------------
  /** Constructor */
  extern function new(string name="svt_chi_system_protocol_flow_ctrl_writesoptionaldata_outstanding_diff_rn_same_hn_virtual_sequence"); 
 
  /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting RN-F Nodes = 2
   *  #- svt_chi_node_configuration::chi_spec_revision >= svt_chi_node_configuration::ISSUE_E
   */
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    string str_is_supported_info_prefix = "This sequence cannot be run based on the current configuration.\n";
    string str_is_supported_info = "";
    string str_is_supported_info_suffix = "Modify configurations through svt_chi_node_configuration::chi_spec_revision\n";
    is_supported = super.is_supported(cfg, silent);
    if(is_supported) begin
      if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision < svt_chi_node_configuration::ISSUE_E) begin
        is_supported = 0;
        str_is_supported_info = $sformatf("svt_chi_node_configuration::chi_spec_revision is not set to svt_chi_node_configuration::ISSUE_E or later for initiating requester node %0d. Writeevictorevict can only be issued from RN when svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_E or later ", initiating_rn_node_idx_0);
      end else begin
        is_supported = 1;
      end  
      if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision < svt_chi_node_configuration::ISSUE_E) begin
        is_supported = 0;
        str_is_supported_info = $sformatf("svt_chi_node_configuration::chi_spec_revision is not set to svt_chi_node_configuration::ISSUE_E or later for initiating requester node %0d. Writeevictorevict can only be issued from RN when svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_E or later ", initiating_rn_node_idx_1);
      end else begin
        is_supported = 1;
      end  

      if (!is_supported) begin
        string str_complete_is_supported_info = {str_is_supported_info_prefix, str_is_supported_info, str_is_supported_info_suffix};
        issue_is_supported_failure(str_complete_is_supported_info);
      end
    end
  endfunction

  //----------------------------------------------------------------------------- 
  virtual task body();
    /** Queue for collecting the Address to send Copyback transactions */
    bit[`SVT_CHI_MAX_ADDR_WIDTH -1:0] rn_f_node_idx_0_copyback_addr_queue[$];                      
    bit[`SVT_CHI_MAX_ADDR_WIDTH -1:0] rn_f_node_idx_1_copyback_addr_queue[$];     
    bit rn_f_node_idx_0_copyback_non_secure_queue[$];                      
    bit rn_f_node_idx_1_copyback_non_secure_queue[$];                      
    /** Queue to collect Unique transaction id's */    
    int txn_id_arr[$];
    /** Setting transaction id width */
    int txn_id_width=`SVT_CHI_TXN_ID_WIDTH;
    int num_outstanding_xacts_to_generate;

    /** Sub sequences initiated from this sequence */
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq[int];
    svt_chi_rn_copyback_type_transaction_directed_sequence copyback_seq[int];
    svt_chi_rn_read_type_transaction_directed_sequence read_seq[int];

    svt_chi_e_rn_writesoptionaldata_type_transaction_directed_sequence writesoptionaldata_seq[int];

    `svt_xvm_debug("body", "Entering ...")

    max_num_outstanding_xacts_at_hn_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(), "max_num_outstanding_xacts_at_hn", max_num_outstanding_xacts_at_hn);
    max_num_outstanding_write_xacts_at_hn_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(), "max_num_outstanding_write_xacts_at_hn", max_num_outstanding_write_xacts_at_hn);
    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :initiating_rn_f_node_index_0;
    initiating_rn_node_idx_1 = initiating_rn_node_index_1_status ? initiating_rn_node_index_1_from_config_db :initiating_rn_f_node_index_1;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_f_node_index_0;

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    //If max outstanding count for Write transactions has been programmed, use that to generate the outstanding Copyback
    if(max_num_outstanding_write_xacts_at_hn > 0) begin
      num_outstanding_xacts_to_generate = max_num_outstanding_write_xacts_at_hn;
      `svt_xvm_debug("body",$sformatf("max_num_outstanding_write_xacts_at_hn is set to a non-zero value (%0d). Hence, the value programmed in max_num_outstanding_xacts_at_hn will be ignored. The number of outstanding transactions issued by the sequence will be equal to max_num_outstanding_write_xacts_at_hn", max_num_outstanding_write_xacts_at_hn));
    end
    //If not, use the max outstanding transaction count
    else
      num_outstanding_xacts_to_generate = max_num_outstanding_xacts_at_hn;

    for(int i = 0; i < sequence_length; i++) begin
      `svt_xvm_debug("body",$sformatf("Starting cache initialization for %0d addresses from p_sequencer.rn_virt_seqr[%0d] and p_sequencer.rn_virt_seqr[%0d] to HN idx %0d",
                                        num_outstanding_xacts_to_generate, initiating_rn_node_idx_0, initiating_rn_node_idx_1, target_hn_node_idx_0));

      /** Collecting txn_id */
      if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision >= svt_chi_node_configuration::ISSUE_E) begin
        for(int id=0; id <= `SVT_CHI_SPEC_PERMITTED_MAX_TXNID_VALUE_FOR_ISSUE_E; id++) begin
          txn_id_arr.push_back(id);
        end
      end
      else if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision >= svt_chi_node_configuration::ISSUE_D) begin
        for(int id=0; id <= `SVT_CHI_SPEC_PERMITTED_MAX_TXNID_VALUE_FOR_ISSUE_D; id++) begin
          txn_id_arr.push_back(id);
        end
      end else begin
        for(int id=0; id <= `SVT_CHI_SPEC_PERMITTED_MAX_TXNID_VALUE_UPTO_ISSUE_C; id++) begin
          txn_id_arr.push_back(id);
        end
      end

      /** Shuffling all collected txn_id */
      txn_id_arr.shuffle;

      /** Initiating outstanding MakeUnique transactions from different RN-Fs
       *  to initialise the cache line state to UD state.  
       */

      for(int k=0; k< num_outstanding_xacts_to_generate; k++) begin
        automatic int initiating_rn_index;
        if (k%2)begin
          initiating_rn_index = initiating_rn_node_idx_1;
        end 
        else begin
          initiating_rn_index = initiating_rn_node_idx_0;
        end 

        `svt_xvm_do_on_with(makeunique_seq[k], p_sequencer.rn_virt_seqr[initiating_rn_index].rn_xact_seqr,{
          sequence_length    == 1;
          hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
          seq_hn_node_idx  == target_hn_node_idx_0;
          use_seq_is_non_secure_access == 0;        
        })
        
        `svt_xvm_debug("body", $sformatf("%0s Waiting for MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) to end %d",`SVT_CHI_PRINT_PREFIX(makeunique_seq[k].write_tran),k, makeunique_seq[k].write_tran.hn_node_idx, makeunique_seq[k].write_tran.tgt_id,num_outstanding_xacts_to_generate));
        // Waiting for current MakeUnique transaction to complete 
        makeunique_seq[k].write_tran.wait_end();
        
        //Checking if transaction is dropped
        if (makeunique_seq[k].output_xacts[0].is_xact_dropped) begin
          `svt_xvm_debug("body", $sformatf("%0s First set of MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) is Droppped. Re-randomizing the transaction.",`SVT_CHI_PRINT_PREFIX(makeunique_seq[k].write_tran),k, makeunique_seq[k].write_tran.hn_node_idx, makeunique_seq[k].write_tran.tgt_id));
          k--;
        end
        else begin
          if (k%2)begin
            rn_f_node_idx_1_copyback_addr_queue.push_back(makeunique_seq[k].write_tran.addr);
            rn_f_node_idx_1_copyback_non_secure_queue.push_back(makeunique_seq[k].write_tran.is_non_secure_access);
          end 
          else begin
            rn_f_node_idx_0_copyback_addr_queue.push_back(makeunique_seq[k].write_tran.addr);
            rn_f_node_idx_0_copyback_non_secure_queue.push_back(makeunique_seq[k].write_tran.is_non_secure_access);
          end 

          `svt_xvm_debug("body", $sformatf("%0s MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) ended",`SVT_CHI_PRINT_PREFIX(makeunique_seq[k].write_tran),k, makeunique_seq[k].write_tran.hn_node_idx, makeunique_seq[k].write_tran.tgt_id));
          
          `svt_xvm_verbose("body", $sformatf("MakeUnique transaction [%0d]  is %0s", k,makeunique_seq[k].write_tran.sprint()));
          
        end //end of else condition of cache state check

        // Initiating the Copyback transaction write the dirty data to main memory
        `svt_xvm_do_on_with(copyback_seq[k], p_sequencer.rn_virt_seqr[initiating_rn_index].rn_xact_seqr,{
          sequence_length    == 1;
          seq_txn_id == makeunique_seq[k].write_tran.txn_id;
          seq_xact_type == svt_chi_transaction::WRITEBACKFULL;
          seq_order_type  == svt_chi_transaction::NO_ORDERING_REQUIRED;
          seq_copyback_req_order_enable == 0;                        
          hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
          min_addr           == makeunique_seq[k].write_tran.addr;
          max_addr           == makeunique_seq[k].write_tran.addr;     
          seq_is_non_secure_access == makeunique_seq[k].write_tran.is_non_secure_access;
          use_seq_is_non_secure_access == 1;        
        })
        
        `svt_xvm_debug("body", $sformatf("%0s Transmitting Copyback Transaction [%0d] targeted to HN (idx %0d, id %0d) ",`SVT_CHI_PRINT_PREFIX(copyback_seq[k].copyback_tran),k, copyback_seq[k].copyback_tran.hn_node_idx, copyback_seq[k].copyback_tran.tgt_id));
        // Waiting for current Copyback transaction to complete 
        copyback_seq[k].copyback_tran.wait_end();

        // Do a READCLEAN transaction from initiating_rn_index
        `svt_xvm_do_on_with(read_seq[k], p_sequencer.rn_virt_seqr[initiating_rn_index].rn_xact_seqr,
        {
          sequence_length == 1;
          data_in_cache == makeunique_seq[k].write_tran.data;
          seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
          hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
          min_addr           == makeunique_seq[k].write_tran.addr;
          max_addr           == makeunique_seq[k].write_tran.addr;     
          seq_xact_type      == svt_chi_transaction::READCLEAN;
          seq_mem_attr_allocate_hint == makeunique_seq[k].write_tran.mem_attr_allocate_hint;
          seq_snp_attr_snp_domain_type == makeunique_seq[k].write_tran.snp_attr_snp_domain_type;
          seq_is_non_secure_access == makeunique_seq[k].write_tran.is_non_secure_access;
          use_seq_is_non_secure_access == 1;        
        }
        )
        /** Waiting for Read type transaction to complete */ 
        read_seq[k].read_tran.wait_end(); 
      end  
      //end of cache initiatlization.

      /** Initiating outstanding WRITEEVICTOREVICT transactions from two Random RN-Fs.  
       *  Initial cache line state is:
       *   UC, SC:  svt_chi_transaction::WRITEEVICTOREVICT  
       */
        fork
          begin
            for(int j = 0; j < (num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2); j++) begin
              automatic bit[`SVT_CHI_MAX_ADDR_WIDTH -1:0] txn_addr;                                      
              automatic bit txn_is_non_secure_access;                                      
              automatic bit[(`SVT_CHI_TXN_ID_WIDTH-1):0]txn_id   = txn_id_arr.pop_front();
              txn_addr = rn_f_node_idx_0_copyback_addr_queue.pop_front();
              txn_is_non_secure_access = rn_f_node_idx_0_copyback_non_secure_queue.pop_front();
              `svt_xvm_do_on_with(writesoptionaldata_seq[j], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,{
                sequence_length == 1;
                seq_txn_id == txn_id;
                seq_order_type  == svt_chi_transaction::NO_ORDERING_REQUIRED;
                seq_copyback_req_order_enable == 0;                        
                hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                min_addr           == txn_addr;
                max_addr           == txn_addr;     
                seq_is_non_secure_access == txn_is_non_secure_access;
                use_seq_is_non_secure_access == 1;
                })

              `svt_xvm_debug("body", $sformatf("%0s Transmitting Writeevictorevict Transaction [%0d] targeted to HN (idx %0d, id %0d) ",`SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq[j].copyback_tran),j, writesoptionaldata_seq[j].copyback_tran.hn_node_idx, writesoptionaldata_seq[j].copyback_tran.tgt_id));
              `svt_xvm_verbose("body", $sformatf("Writeevictorevict Copyback Transaction [%0d] is %0s", j,writesoptionaldata_seq[j].copyback_tran.sprint()));
            end  
          end  
          begin
            for(int j = 0; j < num_outstanding_xacts_to_generate/2; j++) begin
              automatic bit[`SVT_CHI_MAX_ADDR_WIDTH -1:0] txn_addr;                                      
              automatic bit txn_is_non_secure_access;                                      
              automatic bit[(`SVT_CHI_TXN_ID_WIDTH-1):0]txn_id   = txn_id_arr.pop_front();
              txn_addr = rn_f_node_idx_1_copyback_addr_queue.pop_front();
              txn_is_non_secure_access = rn_f_node_idx_1_copyback_non_secure_queue.pop_front();
              `svt_xvm_do_on_with(writesoptionaldata_seq[((num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2)+j)], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,{
                sequence_length == 1;
                seq_txn_id == txn_id;
                seq_order_type  == svt_chi_transaction::NO_ORDERING_REQUIRED;
                seq_copyback_req_order_enable == 0;     
                hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                min_addr           == txn_addr;
                max_addr           == txn_addr;     
                seq_is_non_secure_access == txn_is_non_secure_access;
                use_seq_is_non_secure_access == 1;       
                })
              `svt_xvm_debug("body", $sformatf("%0s Transmitting Writeevictorevict Copyback Transaction [%0d] targeted to HN (idx %0d, id %0d) ",`SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq[((num_outstanding_xacts_to_generate/2)+j)].copyback_tran),((num_outstanding_xacts_to_generate/2)+j), writesoptionaldata_seq[((num_outstanding_xacts_to_generate/2)+j)].copyback_tran.hn_node_idx, writesoptionaldata_seq[((num_outstanding_xacts_to_generate/2)+j)].copyback_tran.tgt_id));
              `svt_xvm_verbose("body", $sformatf("Writeevictorevict Copyback Transaction [%0d] is %0s", ((num_outstanding_xacts_to_generate/2)+j),writesoptionaldata_seq[((num_outstanding_xacts_to_generate/2)+j)].copyback_tran.sprint()));
            end  
          end  
        join  

      /** Checking for the reception of all the Comp/CompDBIDResp from the Interconnect */
      foreach(writesoptionaldata_seq[index_1]) begin
        fork
          automatic int _index_1 = index_1;
          begin
            `svt_xvm_debug("body", $sformatf("%0s Copyback transaction [%0d] targeted to HN (idx %0d, id %0d), suspend_wr_data %0b, suspend_comp_ack %0b: waiting for response from interconnect",`SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq[_index_1].copyback_tran),_index_1, writesoptionaldata_seq[_index_1].copyback_tran.hn_node_idx, writesoptionaldata_seq[_index_1].copyback_tran.tgt_id,writesoptionaldata_seq[_index_1].copyback_tran.suspend_wr_data, writesoptionaldata_seq[_index_1].copyback_tran.suspend_comp_ack));
            /** Waiting for either Comp response/Compdbidresp/Retry reponse from the ICN */ 
            fork
            begin
              fork
                begin
                  /** Waiting for either Comp response from the ICN or req_status to be ACCEPT */ 
                  writesoptionaldata_seq[_index_1].copyback_tran.wait_for_tx_compack_prereqs();
                end
                begin
                  /** Waiting for either Compdbidresp response from the ICN or req_status to be ACCEPT */ 
                  writesoptionaldata_seq[_index_1].copyback_tran.wait_for_tx_data_prereqs();
                end
                begin
                  /** Waiting for Retry response from the ICN or req_status to be RETRY */ 
                  wait(writesoptionaldata_seq[_index_1].copyback_tran.req_status == svt_chi_transaction::RETRY);// begin
                end
              join_any
              disable fork;
            end
            join
            received_copyback_responses++;
            `svt_xvm_debug("body", $sformatf("%0s Copyback transaction [%0d] targeted to HN (idx %0d, id %0d), suspend_wr_data %0b suspend_comp_ack %0b: received response from interconnect. Total responses received %0d",`SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq[_index_1].copyback_tran),_index_1, writesoptionaldata_seq[_index_1].copyback_tran.hn_node_idx, writesoptionaldata_seq[_index_1].copyback_tran.tgt_id,writesoptionaldata_seq[_index_1].copyback_tran.suspend_wr_data, writesoptionaldata_seq[_index_1].copyback_tran.suspend_comp_ack, received_copyback_responses));
          end
        join_none  
      end

      /** Wait until All Comp/Compdbidresp responses are received at RN-Fs */
      `svt_xvm_debug("body",$sformatf("Completed initiation of Copyback type transactions for %0d addresses from p_sequencer.rn_virt_seqr[%0d] and p_sequencer.rn_virt_seqr[%0d] to HN idx %0d with suspend_wr_data set to 1 or suspend_comp_ack set to 1, and waiting to receive responses from interconnect.",
                                num_outstanding_xacts_to_generate, initiating_rn_node_idx_0, initiating_rn_node_idx_1, target_hn_node_idx_0)); 
      wait(received_copyback_responses == num_outstanding_xacts_to_generate);
      `svt_xvm_debug("body",$sformatf("Received responses from interconnect to Copyback type transactions for %0d addresses from p_sequencer.rn_virt_seqr[%0d] and p_sequencer.rn_virt_seqr[%0d] to HN idx %0d with suspend_wr_data set to 1 or suspend_comp_ack set to 1",
                                      num_outstanding_xacts_to_generate, initiating_rn_node_idx_0, initiating_rn_node_idx_1, target_hn_node_idx_0)); 

      /** Self Check1: To check suspend_wr_data/suspend_comp_ack should not be modified to zero by the VIP
       *  before reseting from test bench.
       */
      foreach (writesoptionaldata_seq[self_check_idx1]) begin
        if(!writesoptionaldata_seq[self_check_idx1].copyback_tran.is_terminated()) begin 
          // Checking compack is expected for Writeoptional data transactions.      
          if(writesoptionaldata_seq[self_check_idx1].copyback_tran.has_compack_transfer_for_copyback_xact()) begin 
            if (writesoptionaldata_seq[self_check_idx1].copyback_tran.suspend_comp_ack == 0) begin
              `svt_xvm_error("body", $sformatf("%0s suspend_comp_ack should be 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq[self_check_idx1].copyback_tran)));
            end
            else begin
              `svt_xvm_debug("body", $sformatf("%0s suspend_comp_ack is 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq[self_check_idx1].copyback_tran)));
            end
          end
          else begin // if(writesoptionaldata_seq[self_check_idx1].copyback_tran.has_compack_transfer_for_copyback_xact())
            if (writesoptionaldata_seq[self_check_idx1].copyback_tran.suspend_wr_data == 0) begin
              `svt_xvm_error("body", $sformatf("%0s suspend_wr_data should be 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq[self_check_idx1].copyback_tran)));
            end
            else begin
              `svt_xvm_debug("body", $sformatf("%0s suspend_wr_data is 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq[self_check_idx1].copyback_tran)));
            end
          end        
        end
      end

      /** Self Check2: To check suspend_wr_data/suspend_comp_ack should not be modified to zero by the VIP 
       *  before reseting from test bench.
       */ 
      foreach (writesoptionaldata_seq[self_check_idx2]) begin
        if(!writesoptionaldata_seq[self_check_idx2].copyback_tran.is_terminated()) begin 
         // Checking compack is expected for Writeoptional data transactions.      
         if (writesoptionaldata_seq[self_check_idx2].copyback_tran.has_compack_transfer_for_copyback_xact()) begin 
            /** Pass event is not triggered */
            if (writesoptionaldata_seq[self_check_idx2].copyback_tran.end_event.is_on() == 1) begin
              `svt_xvm_error("body", $sformatf("Unexpected: %0s Transaction's end_event triggered when suspend_comp_ack is still 1.", `SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq[self_check_idx2].copyback_tran)));
            end
            /** Fail event has triggered */
            else begin
              `svt_xvm_debug("body", $sformatf("Expected: %0s Transaction's end_event is not triggered when suspend_comp_ack is still 1.", `SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq[self_check_idx2].copyback_tran)));
            end
          end  
          else begin      
            /** Pass event is not triggered */
            if (writesoptionaldata_seq[self_check_idx2].copyback_tran.end_event.is_on() == 1) begin
              `svt_xvm_error("body", $sformatf("Unexpected: %0s Transaction's end_event triggered when suspend_wr_data is still 1.", `SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq[self_check_idx2].copyback_tran)));
            end
            /** Fail event has triggered */
            else begin
              `svt_xvm_debug("body", $sformatf("Expected: %0s Transaction's end_event is not triggered when suspend_wr_data is still 1.", `SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq[self_check_idx2].copyback_tran)));
            end
          end  
        end
      end
 
      /** Self Check 3: To check that the current_outstanding_*_xact_count in the RNs
       * are as per the transactions inititated by the sequence
       */
      /** Check if the total outstanding xact counter is set correctly in the shared status of the RN agent */
      if(writesoptionaldata_seq[0].shared_status.prot_status.current_outstanding_xact_count != (num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2))
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding transactions from the sequence but the outstanding transaction count in the shared status of RN%0d is %0d", (num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2), initiating_rn_node_idx_0, writesoptionaldata_seq[0].shared_status.prot_status.current_outstanding_xact_count));
      /** Check if the outstanding Write xact counter is set correctly in the shared status of the RN agent */
      if(writesoptionaldata_seq[0].shared_status.prot_status.current_outstanding_write_xact_count != (num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2)) begin
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding Copyback transactions from the sequence but the outstanding Write transaction count in the shared status of RN%0d is %0d", (num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2), initiating_rn_node_idx_0, writesoptionaldata_seq[0].shared_status.prot_status.current_outstanding_write_xact_count));
      end
      /** Check if the total outstanding xact counter is set correctly in the shared status of the RN agent */
      if(writesoptionaldata_seq[(num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2)].shared_status.prot_status.current_outstanding_xact_count != num_outstanding_xacts_to_generate/2)
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding transactions from the sequence but the outstanding transaction count in the shared status of RN%0d is %0d", num_outstanding_xacts_to_generate/2, initiating_rn_node_idx_1, writesoptionaldata_seq[(num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2)].shared_status.prot_status.current_outstanding_xact_count));
      /** Check if the outstanding Write xact counter is set correctly in the shared status of the RN agent */
      if(writesoptionaldata_seq[(num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2)].shared_status.prot_status.current_outstanding_write_xact_count != num_outstanding_xacts_to_generate/2) begin
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding Copyback transactions from the sequence but the outstanding Write transaction count in the shared status of RN%0d is %0d", num_outstanding_xacts_to_generate/2, initiating_rn_node_idx_1, writesoptionaldata_seq[(num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2)].shared_status.prot_status.current_outstanding_write_xact_count));
      end

      `svt_xvm_debug("body", $sformatf("RN%0d: Number of outstanding transactions : %0d, Number of outstanding write xacts : %0d", initiating_rn_node_idx_0, writesoptionaldata_seq[0].shared_status.prot_status.current_outstanding_xact_count, writesoptionaldata_seq[0].shared_status.prot_status.current_outstanding_write_xact_count));
      `svt_xvm_debug("body", $sformatf("RN%0d: Number of outstanding transactions : %0d, Number of outstanding write xacts : %0d", initiating_rn_node_idx_1, writesoptionaldata_seq[1].shared_status.prot_status.current_outstanding_xact_count, writesoptionaldata_seq[1].shared_status.prot_status.current_outstanding_write_xact_count));

      /** Targeted HN IDs from both RN-Fs should be same */
      for(int index_3 = 0; index_3 < num_outstanding_xacts_to_generate/2; index_3++) begin
        int hn_idx_0, hn_idx_1;
        hn_idx_0 = sys_cfg.get_hn_idx(writesoptionaldata_seq[index_3].output_xacts[0].addr);
        hn_idx_1 = sys_cfg.get_hn_idx(writesoptionaldata_seq[((num_outstanding_xacts_to_generate/2) + index_3)].output_xacts[0].addr);
        if ((hn_idx_0 == target_hn_node_idx_0) && (hn_idx_0 == hn_idx_1)) begin
          /** pass */
          `svt_xvm_debug("body", $sformatf("Targeted HN Index from both RNs is same as expected.  rn[%0d] to hn_idx[%0d], rn[%0d] to hn_idx[%0d]", initiating_rn_node_idx_0, hn_idx_0, initiating_rn_node_idx_1, hn_idx_1));
        end
        else begin
          /** fail */
          `svt_xvm_error("body", $sformatf("Targeted HN Index from both RNs is different, which is unexpected.  rn[%0d] %0s transaction to hn_idx[%0d], rn[%0d] %0s transaction to hn_idx[%0d]",initiating_rn_node_idx_0, `SVT_CHI_PRINT_PREFIX( writesoptionaldata_seq[index_3].output_xacts[0]), hn_idx_0, initiating_rn_node_idx_1, `SVT_CHI_PRINT_PREFIX( writesoptionaldata_seq[((num_outstanding_xacts_to_generate/2)+index_3)].output_xacts[0]), hn_idx_1));
        end
      end  

      /** Resuming all Suspended Response of all above Copyback transactions  */
      foreach(writesoptionaldata_seq[wr]) begin
        if(writesoptionaldata_seq[wr].copyback_tran.has_compack_transfer_for_copyback_xact()) begin 
          `svt_xvm_debug("body",$sformatf("Received responses for all Copyback type transactions from interconnect, resuming the transactions by setting svt_chi_rn_transaction::suspend_comp_ack set to 0 %0s",`SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq[wr].copyback_tran)));
          writesoptionaldata_seq[wr].copyback_tran.suspend_comp_ack=0;
          `svt_xvm_debug("body", $sformatf("For iteration %0d : After Resume, received_copyback_responses is %0d,suspend_comp_ack is %0b ", wr,received_copyback_responses,writesoptionaldata_seq[wr].copyback_tran.suspend_comp_ack));
        end
        else begin
          `svt_xvm_debug("body",$sformatf("Received responses for all Copyback type transactions from interconnect, resuming the transactions by setting svt_chi_rn_transaction::suspend_wr_data set to 0 %0s",`SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq[wr].copyback_tran)));
          writesoptionaldata_seq[wr].copyback_tran.suspend_wr_data=0;
          `svt_xvm_debug("body", $sformatf("For iteration %0d : After Resume, received_copyback_responses is %0d,suspend_wr_data is %0b ", wr,received_copyback_responses,writesoptionaldata_seq[wr].copyback_tran.suspend_wr_data));
        end        
      end

      /** Waiting for above copyback outstanding transactions to complete */
      foreach(writesoptionaldata_seq[index_2]) begin
        `svt_xvm_debug("body", $sformatf("Waiting for above writesoptionaldata_seq[%0d] transaction %0s to end", index_2, `SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq[index_2].copyback_tran)));
        writesoptionaldata_seq[index_2].copyback_tran.wait_end(); 
        
        /** Self Check4: To check suspend_wr_data/suspend_comp_ack should not be asserted after the transaction 
         *  completes as it is reseted from test bench
         */
        if(!writesoptionaldata_seq[index_2].copyback_tran.is_terminated()) begin 
          if(writesoptionaldata_seq[index_2].copyback_tran.has_compack_transfer_for_copyback_xact()) begin 
            if (writesoptionaldata_seq[index_2].copyback_tran.suspend_comp_ack == 1) begin
              `svt_xvm_error("body", $sformatf("%0s suspend_comp_ack should be 0 as it has been reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq[index_2].copyback_tran)));
            end
            else begin
              `svt_xvm_debug("body", $sformatf("%0s suspend_comp_ack is 0 as it is reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq[index_2].copyback_tran)));
            end
          end
          else begin
            if (writesoptionaldata_seq[index_2].copyback_tran.suspend_wr_data == 1) begin
              `svt_xvm_error("body", $sformatf("%0s suspend_wr_data should be 0 as it has been reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq[index_2].copyback_tran)));
            end
            else begin
              `svt_xvm_debug("body", $sformatf("%0s suspend_wr_data is 0 as it is reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq[index_2].copyback_tran)));
            end
          end        
        end
      end
     
      /** Empty the address and txn_id queues */
      rn_f_node_idx_0_copyback_addr_queue.delete();                      
      rn_f_node_idx_1_copyback_addr_queue.delete();                      
      rn_f_node_idx_0_copyback_non_secure_queue.delete();                      
      rn_f_node_idx_1_copyback_non_secure_queue.delete();                      
      txn_id_arr.delete();
      
      /** Reset received_read_responses to Zero */
      received_copyback_responses = 0;
      `svt_xvm_debug("body", "Exiting...")
    end//sequence_length
    /** 
     * To check the Interconnect HN Node shall responds to 
     * outstanding transactions from RN-Fs.<br>
     * Check done by System monitor(List of checkers)<br>
     *  #- copyback_data_integrity_check
     *  .  
     */
  endtask: body

  virtual task post_body();
    drop_phase_objection();
  endtask
endclass: svt_chi_system_protocol_flow_ctrl_writesoptionaldata_outstanding_diff_rn_same_hn_virtual_sequence

function svt_chi_system_protocol_flow_ctrl_writesoptionaldata_outstanding_diff_rn_same_hn_virtual_sequence::new(string name="svt_chi_system_protocol_flow_ctrl_writesoptionaldata_outstanding_diff_rn_same_hn_virtual_sequence");
  super.new(name);
endfunction

//====================================================================================
/** 
 * @groupname CHI_OUTSTANDING_CPBK_TYPE 
 * #- This sequence requires atleast two HN node to be present in the Interconnect.
 * #- This sequence requires atleast two initiating active and participating RN-Fs.
 * #- Inititate maximum number of MAKEUNIQUE followed by WRITEBACKFULL followed by
 *    READCLEAN transactions from existing active and 
 *    participating RN-F, to perform cache initialization to a
 *    randomly selected different HNs.
 * #- Initiate maximum number of Writesoptionaldata COPYBACK type transactions with 
 *    svt_chi_rn_transaction::suspend_wr_data set to 1 and
 *    svt_chi_rn_transaction::suspend_comp_ack set to 1 from the initiating
 *    RN-Fs to randomly selected HNs in non blocking mode. <br>
 *    - Maximum number of outstanding transactions at the HN is as per either #max_num_outstanding_write_xacts_at_hn or
 *      #max_num_outstanding_xacts_at_hn, which can be controlled through config DB.  
 *    - This ensures that the maximum outstanding transaction limit is reached at
 *      two different HNs. 
 *    - Also,the RN-Fs will not transmit CopyBackWrData or Compack corresponding to these
 *      transactions until svt_chi_rn_transaction::suspend_wr_data or svt_chi_rn_transaction::suspend_comp_ack
 *      whichever is applicable is set to 0 from the sequence.
 *    .
 * #- The addresses of these Writesoptionaldata COPYBACK transactions are such that:
 *    - Same as initialized cache line addresses if cache initialization is performed
 *    .
 * #- The RN-Fs of these Writesoptionaldata COPYBACK transactions are such that:
 *    - Same as RN-Fs from which cache initialization is performed
 *    .
 * #- Once the RN-Fs receives the responses for all the outstanding transactions from
 *    the HN, attribute svt_chi_rn_transaction::suspend_wr_data or svt_chi_rn_transaction::suspend_comp_ack 
 *    whichever is applicable is set to 0 for all the outstanding transactions. <br>
 *    This ensures that the CopyBackWrData or Compack for these transactions can be resumed 
 *    from RN-Fs.
 * #- Check that the HN responds properly for all outstanding Writesoptionaldata COPYBACK type
 *    transactions and these are completed successfully.
 * .
 * #- This sequence generates  Writesoptionaldata COPYBACK type WRITEEVICTOREVICT transactions.
 * .
 *
 *  This sequence requires SVT_CHI_ISSUE_E_ENABLE macro to be defined and
 *  svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_E or later.
 *
 */ 
class svt_chi_system_protocol_flow_ctrl_writesoptionaldata_outstanding_diff_rn_diff_hn_virtual_sequence extends svt_chi_system_protocol_flow_ctrl_copyback_outstanding_diff_rn_diff_hn_virtual_sequence;

  /** UVM Object Utility macro */
  `svt_xvm_object_utils(svt_chi_system_protocol_flow_ctrl_writesoptionaldata_outstanding_diff_rn_diff_hn_virtual_sequence)

  //-----------------------------------------------------------------------------  
  // Methods
  //-----------------------------------------------------------------------------
  /** Constructor */
  extern function new(string name="svt_chi_system_protocol_flow_ctrl_writesoptionaldata_outstanding_diff_rn_diff_hn_virtual_sequence"); 

  /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting RN-F Nodes = 2
   *  #- svt_chi_node_configuration::chi_spec_revision >= svt_chi_node_configuration::ISSUE_E
   */
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    string str_is_supported_info_prefix = "This sequence cannot be run based on the current configuration.\n";
    string str_is_supported_info = "";
    string str_is_supported_info_suffix = "Modify configurations through svt_chi_node_configuration::chi_spec_revision\n";
    is_supported = super.is_supported(cfg, silent);
    if(is_supported) begin
      if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision < svt_chi_node_configuration::ISSUE_E) begin
        is_supported = 0;
        str_is_supported_info = $sformatf("svt_chi_node_configuration::chi_spec_revision is not set to svt_chi_node_configuration::ISSUE_E or later for initiating requester node %0d. Writeevictorevict can only be issued from RN when svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_E or later ", initiating_rn_node_idx_0);
      end else begin
        is_supported = 1;
      end  
      if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision < svt_chi_node_configuration::ISSUE_E) begin
        is_supported = 0;
        str_is_supported_info = $sformatf("svt_chi_node_configuration::chi_spec_revision is not set to svt_chi_node_configuration::ISSUE_E or later for initiating requester node %0d. Writeevictorevict can only be issued from RN when svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_E or later ", initiating_rn_node_idx_1);
      end else begin
        is_supported = 1;
      end  

      if (!is_supported) begin
        string str_complete_is_supported_info = {str_is_supported_info_prefix, str_is_supported_info, str_is_supported_info_suffix};
        issue_is_supported_failure(str_complete_is_supported_info);
      end
    end
  endfunction

  //-----------------------------------------------------------------------------
  virtual task body();

    int received_copyback_responses=0;
    int NUM_OUTSTANDING_XACT;

    /** Setting transaction id width */
    int txn_id_width=`SVT_CHI_TXN_ID_WIDTH;

    /** Queue of RN-F's, intitiating Copyback transactions */
    int initiating_rn_f_node_idx_1_queue[$];
    int initiating_rn_f_node_idx_0_queue[$];

    /** Queue of addresses, used by the transactions generated */
    bit[`SVT_CHI_MAX_ADDR_WIDTH -1:0] rn_f_node_idx_0_copyback_addr_queue[$];                      
    bit[`SVT_CHI_MAX_ADDR_WIDTH -1:0] rn_f_node_idx_1_copyback_addr_queue[$];                      
    bit rn_f_node_idx_0_copyback_non_secure_queue[$];                      
    bit rn_f_node_idx_1_copyback_non_secure_queue[$];                      


    /** Queue of Unique transaction id's, used by the transactions generated */
    int rn_f_node_idx_0_txn_id_queue[$];
    int rn_f_node_idx_1_txn_id_queue[$];

    /** Sub Read type transaction cache initialization directed sequences initiated from this sequence */
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq_0[int];
    svt_chi_rn_copyback_type_transaction_directed_sequence copyback_seq[int];
    svt_chi_rn_read_type_transaction_directed_sequence read_seq[int];

    /** Sub Writeoptionaldata CopyBack type transaction directed sequences initiated from this sequence */
    svt_chi_e_rn_writesoptionaldata_type_transaction_directed_sequence writesoptionaldata_seq[int];
     
    `svt_xvm_debug("body", "Entering ...")
    
    max_num_outstanding_xacts_at_hn_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(), "max_num_outstanding_xacts_at_hn", max_num_outstanding_xacts_at_hn);
    max_num_outstanding_write_xacts_at_hn_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(), "max_num_outstanding_write_xacts_at_hn", max_num_outstanding_write_xacts_at_hn);
    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :initiating_rn_f_node_index_0;
    initiating_rn_node_idx_1 = initiating_rn_node_index_1_status ? initiating_rn_node_index_1_from_config_db :initiating_rn_f_node_index_1;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_f_node_index_0;
    target_hn_node_idx_1 = target_hn_node_index_1_status ? target_hn_node_index_1_from_config_db :target_hn_f_node_index_1;

    `svt_xvm_debug("body", $sformatf("max_num_outstanding_xacts_at_hn is %0d as a result of %0s.", max_num_outstanding_xacts_at_hn, max_num_outstanding_xacts_at_hn_status ? "config DB" : "default"));
    `svt_xvm_debug("body", $sformatf("max_num_outstanding_write_xacts_at_hn is %0d as a result of %0s.", max_num_outstanding_write_xacts_at_hn, max_num_outstanding_write_xacts_at_hn_status ? "config DB" : "default"));
    `svt_xvm_debug("body", $sformatf("initiating_rn_node_idx_0 is %0d as a result of %0s.", initiating_rn_node_idx_0, initiating_rn_node_index_0_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("initiating_rn_node_idx_1 is %0d as a result of %0s.", initiating_rn_node_idx_1, initiating_rn_node_index_1_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("target_hn_node_idx_0 is %0d as a result of %0s.", target_hn_node_idx_0, target_hn_node_index_0_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("target_hn_node_idx_1 is %0d as a result of %0s.", target_hn_node_idx_1, target_hn_node_index_1_status ? "config DB" : "Randomization"));  
   
    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    //If max outstanding count for Write transactions has been programmed, use that to generate the outstanding Copyback
    if(max_num_outstanding_write_xacts_at_hn > 0) begin
      NUM_OUTSTANDING_XACT = (max_num_outstanding_write_xacts_at_hn * 2);
      `svt_xvm_debug("body",$sformatf("max_num_outstanding_write_xacts_at_hn is set to a non-zero value (%0d). Hence, the value programmed in max_num_outstanding_xacts_at_hn will be ignored. The number of outstanding transactions issued by the sequence will be equal to max_num_outstanding_write_xacts_at_hn", max_num_outstanding_write_xacts_at_hn));
    end
    else
      NUM_OUTSTANDING_XACT = (max_num_outstanding_xacts_at_hn * 2);
    `svt_xvm_debug("body", $sformatf("Number of NUM_OUTSTANDING_XACT is %0d",NUM_OUTSTANDING_XACT));

    for(int i = 0; i < sequence_length; i++) begin

      /** Collecting txn_id */
      if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision >= svt_chi_node_configuration::ISSUE_E) begin
        for(int id=0; id <= `SVT_CHI_SPEC_PERMITTED_MAX_TXNID_VALUE_FOR_ISSUE_E; id++) begin
          rn_f_node_idx_0_txn_id_queue.push_back(id);
        end
      end
      else if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision >= svt_chi_node_configuration::ISSUE_D) begin
        for(int id=0; id <= `SVT_CHI_SPEC_PERMITTED_MAX_TXNID_VALUE_FOR_ISSUE_D; id++) begin
          rn_f_node_idx_0_txn_id_queue.push_back(id);
        end
      end else begin
        for(int id=0; id <= `SVT_CHI_SPEC_PERMITTED_MAX_TXNID_VALUE_UPTO_ISSUE_C; id++) begin
          rn_f_node_idx_0_txn_id_queue.push_back(id);
        end
      end
      if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision >= svt_chi_node_configuration::ISSUE_E) begin
        for(int id=0; id <= `SVT_CHI_SPEC_PERMITTED_MAX_TXNID_VALUE_FOR_ISSUE_E; id++) begin
          rn_f_node_idx_1_txn_id_queue.push_back(id);
        end
      end
      else if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision >= svt_chi_node_configuration::ISSUE_D) begin
        for(int id=0; id <= `SVT_CHI_SPEC_PERMITTED_MAX_TXNID_VALUE_FOR_ISSUE_D; id++) begin
          rn_f_node_idx_1_txn_id_queue.push_back(id);
        end
      end else begin
        for(int id=0; id <= `SVT_CHI_SPEC_PERMITTED_MAX_TXNID_VALUE_UPTO_ISSUE_C; id++) begin
          rn_f_node_idx_1_txn_id_queue.push_back(id);
        end
      end

      /** Shuffling all collected txn_id */
      rn_f_node_idx_0_txn_id_queue.shuffle;
      rn_f_node_idx_1_txn_id_queue.shuffle;

      /** Initiating outstanding MakeUnique transactions followed by Wribackfull followed by 
       *  Readshared or Readnotshareddirty from different RN-Fs
       *  to initialise the cache line state to UC or SC state and for below transactions.  
       *  WRITEEVICTOREVICT.
       */
      for(int l=0; l<NUM_OUTSTANDING_XACT ; l++) begin
        automatic int initiating_rn_index;
        
        if (l%2)begin
          initiating_rn_index = initiating_rn_node_idx_1;
          initiating_rn_f_node_idx_1_queue.push_back(initiating_rn_index);
        end 
        else begin
          initiating_rn_index = initiating_rn_node_idx_0;
          initiating_rn_f_node_idx_0_queue.push_back(initiating_rn_index);
        end 

        `svt_xvm_do_on_with(makeunique_seq_0[l], p_sequencer.rn_virt_seqr[initiating_rn_index].rn_xact_seqr,{
          sequence_length    == 1;
          hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
          use_seq_is_non_secure_access == 0;
          if(l == 0)
          {
            seq_hn_node_idx    == target_hn_node_idx_0;                                        
          }
          else if (l < NUM_OUTSTANDING_XACT/4)
          {
            seq_hn_node_idx == makeunique_seq_0[0].seq_hn_node_idx;                                   
          }
          else if (l == NUM_OUTSTANDING_XACT/4)
          {
            seq_hn_node_idx    == target_hn_node_idx_1;                                        
          }
          else if (l < NUM_OUTSTANDING_XACT/2)
          {
            seq_hn_node_idx == makeunique_seq_0[NUM_OUTSTANDING_XACT/4].seq_hn_node_idx;                                   
          }
          else if ((l >= NUM_OUTSTANDING_XACT/2) && (l < NUM_OUTSTANDING_XACT*3/4))
          {
            seq_hn_node_idx == makeunique_seq_0[0].seq_hn_node_idx;                                   
          }
          else
          {
            seq_hn_node_idx == makeunique_seq_0[NUM_OUTSTANDING_XACT/4].seq_hn_node_idx;                                   
          }
        })
        
        /** Retrieving 512 addresses from output transactions generated by the sequence  */
        if (l%2)begin
          rn_f_node_idx_1_copyback_addr_queue.push_back(makeunique_seq_0[l].write_tran.addr);
          rn_f_node_idx_1_copyback_non_secure_queue.push_back(makeunique_seq_0[l].write_tran.is_non_secure_access);
        end 
        else begin
          rn_f_node_idx_0_copyback_addr_queue.push_back(makeunique_seq_0[l].write_tran.addr);
          rn_f_node_idx_0_copyback_non_secure_queue.push_back(makeunique_seq_0[l].write_tran.is_non_secure_access);
        end 

        `svt_xvm_debug("body", $sformatf("%0s Waiting for MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) to end",`SVT_CHI_PRINT_PREFIX(makeunique_seq_0[l].write_tran),l, makeunique_seq_0[l].write_tran.hn_node_idx, makeunique_seq_0[l].write_tran.tgt_id));
        makeunique_seq_0[l].write_tran.wait_end(); 
        `svt_xvm_debug("body", $sformatf("%0s MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) ended",`SVT_CHI_PRINT_PREFIX(makeunique_seq_0[l].write_tran),l, makeunique_seq_0[l].write_tran.hn_node_idx, makeunique_seq_0[l].write_tran.tgt_id));

        // Initiating the Copyback transaction write the dirty data to main memory
        `svt_xvm_do_on_with(copyback_seq[l], p_sequencer.rn_virt_seqr[initiating_rn_index].rn_xact_seqr,{
          sequence_length    == 1;
          seq_txn_id == makeunique_seq_0[l].write_tran.txn_id;
          seq_xact_type == svt_chi_transaction::WRITEBACKFULL;
          seq_order_type  == svt_chi_transaction::NO_ORDERING_REQUIRED;
          seq_copyback_req_order_enable == 0;                        
          hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
          min_addr           == makeunique_seq_0[l].write_tran.addr;
          max_addr           == makeunique_seq_0[l].write_tran.addr;     
          seq_is_non_secure_access == makeunique_seq_0[l].write_tran.is_non_secure_access;
          use_seq_is_non_secure_access == 1;        
        })
        
        `svt_xvm_debug("body", $sformatf("%0s Transmitting Copyback Transaction [%0d] targeted to HN (idx %0d, id %0d) ",`SVT_CHI_PRINT_PREFIX(copyback_seq[l].copyback_tran),l, copyback_seq[l].copyback_tran.hn_node_idx, copyback_seq[l].copyback_tran.tgt_id));

        // Waiting for current Copyback transaction to complete 
        copyback_seq[l].copyback_tran.wait_end();

        // Do a READCLEAN transaction from initiating_rn_index
        `svt_xvm_do_on_with(read_seq[l], p_sequencer.rn_virt_seqr[initiating_rn_index].rn_xact_seqr,
        {
          sequence_length == 1;
          data_in_cache == makeunique_seq_0[l].write_tran.data;
          seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
          hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
          min_addr           == makeunique_seq_0[l].write_tran.addr;
          max_addr           == makeunique_seq_0[l].write_tran.addr;     
          seq_xact_type      == svt_chi_transaction::READCLEAN;
          seq_mem_attr_allocate_hint == makeunique_seq_0[l].write_tran.mem_attr_allocate_hint;
          seq_snp_attr_snp_domain_type == makeunique_seq_0[l].write_tran.snp_attr_snp_domain_type;
          seq_is_non_secure_access == makeunique_seq_0[l].write_tran.is_non_secure_access;
          use_seq_is_non_secure_access == 1;        
        }
        )
        `svt_xvm_debug("body", $sformatf("%0s Transmitting Read Transaction [%0d] targeted to HN (idx %0d, id %0d) ",`SVT_CHI_PRINT_PREFIX(read_seq[l].read_tran),l, read_seq[l].read_tran.hn_node_idx, read_seq[l].read_tran.tgt_id));

        /** Waiting for Read type transaction to complete */ 
        read_seq[l].read_tran.wait_end(); 

      end //forloop of 512 MakeUnique follewed by Writebackfull followed by READSHARED/READSHAREDNOTDIRTY.

      /** Initiating outstanding Writeoptionaldata CopyBack transactions from different Random RN-F.  
       *  Initial cache line state is:
       *   UC, SC : svt_chi_transaction::WRITEEVICTOREVICT  
       */
      for(int j = 0; j < NUM_OUTSTANDING_XACT/2; j++) begin
        automatic int initiating_rn_index;

        fork
          begin
            automatic bit[`SVT_CHI_MAX_ADDR_WIDTH -1:0] txn_addr;                                      
            automatic bit txn_is_non_secure_access;
            automatic bit[(`SVT_CHI_TXN_ID_WIDTH-1):0]txn_id;
            txn_addr = rn_f_node_idx_1_copyback_addr_queue.pop_front();
            txn_is_non_secure_access = rn_f_node_idx_1_copyback_non_secure_queue.pop_front();
            txn_id = rn_f_node_idx_1_txn_id_queue.pop_front();
            
            `svt_xvm_do_on_with(writesoptionaldata_seq[j], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,{
              sequence_length == 1;
              seq_txn_id == txn_id;
              seq_order_type  == svt_chi_transaction::NO_ORDERING_REQUIRED;
              seq_copyback_req_order_enable == 0;                                          
              hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
              min_addr           == txn_addr;
              max_addr           == txn_addr;     
              seq_is_non_secure_access == txn_is_non_secure_access;
              use_seq_is_non_secure_access == 1;       
              })
            `svt_xvm_debug("body", $sformatf("%0s Transmitting Writesoptionaldata CopyBack Transaction [%0d] targeted to HN (idx %0d, id %0d)",`SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq[j].copyback_tran),j, writesoptionaldata_seq[j].copyback_tran.hn_node_idx, writesoptionaldata_seq[j].copyback_tran.tgt_id));
            `svt_xvm_verbose("body", $sformatf("Writesoptionaldata CopyBack Transaction [%0d] is %0s", j,writesoptionaldata_seq[j].copyback_tran.sprint()));
        end//begin
          begin
            automatic bit[`SVT_CHI_MAX_ADDR_WIDTH -1:0] txn_addr;                                      
            automatic bit txn_is_non_secure_access;
            automatic bit[(`SVT_CHI_TXN_ID_WIDTH-1):0]txn_id;
            txn_addr = rn_f_node_idx_0_copyback_addr_queue.pop_front();
            txn_is_non_secure_access = rn_f_node_idx_0_copyback_non_secure_queue.pop_front();
            txn_id = rn_f_node_idx_0_txn_id_queue.pop_front();
            `svt_xvm_do_on_with(writesoptionaldata_seq[((NUM_OUTSTANDING_XACT/2) + j)], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,{
              sequence_length == 1;
              seq_txn_id == txn_id;
              seq_order_type  == svt_chi_transaction::NO_ORDERING_REQUIRED;
              seq_copyback_req_order_enable == 0;                                          
              hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
              min_addr           == txn_addr;
              max_addr           == txn_addr;     
              seq_is_non_secure_access == txn_is_non_secure_access;
              use_seq_is_non_secure_access == 1;       
              })
            `svt_xvm_debug("body", $sformatf("%0s Transmitting CopyBack Transaction [%0d] targeted to HN (idx %0d, id %0d)",`SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq[((NUM_OUTSTANDING_XACT/2) + j)].copyback_tran),((NUM_OUTSTANDING_XACT/2) + j), writesoptionaldata_seq[((NUM_OUTSTANDING_XACT/2) + j)].copyback_tran.hn_node_idx, writesoptionaldata_seq[((NUM_OUTSTANDING_XACT/2) + j)].copyback_tran.tgt_id));
            `svt_xvm_verbose("body", $sformatf("CopyBack Transaction [%0d] is %0s", ((NUM_OUTSTANDING_XACT/2) + j),writesoptionaldata_seq[((NUM_OUTSTANDING_XACT/2) + j)].copyback_tran.sprint()));
          end//begin
        join       
      end//forloop of CopyBack

      /** Checking for the reception of all the CompDBIDResp/Comp from the Interconnect */
      foreach(writesoptionaldata_seq[index_1]) begin
        fork
            automatic int _index_1 = index_1;
          begin
          `svt_xvm_debug("body", $sformatf("%0s Writesoptionaldata CopyBack transaction [%0d] targeted to HN (idx %0d, id %0d), suspend_wr_data %0b suspend_comp_ack %0b: waiting for response from interconnect",`SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq[_index_1].copyback_tran),_index_1, writesoptionaldata_seq[_index_1].copyback_tran.hn_node_idx, writesoptionaldata_seq[_index_1].copyback_tran.tgt_id,writesoptionaldata_seq[_index_1].copyback_tran.suspend_wr_data,writesoptionaldata_seq[_index_1].copyback_tran.suspend_comp_ack));
            
            //Wait until a CompDBIDResp/Comp/RetryAck is received for the generated Copybacks
            fork
            begin
              fork
                begin
                  /** Waiting for either Comp response from the ICN or req_status to be ACCEPT */ 
                  writesoptionaldata_seq[_index_1].copyback_tran.wait_for_tx_compack_prereqs();
                end
                begin
                  /** Waiting for either Compdbidresp response from the ICN or req_status to be ACCEPT */ 
                  writesoptionaldata_seq[_index_1].copyback_tran.wait_for_tx_data_prereqs();
                end
                begin
                  /** Waiting for Retry response from the ICN or req_status to be RETRY */ 
                  wait(writesoptionaldata_seq[_index_1].copyback_tran.req_status == svt_chi_transaction::RETRY);// begin
                end
              join_any
              disable fork;
            end
            join
            received_copyback_responses++;
            
            `svt_xvm_debug("body", $sformatf("%0s Writesoptionaldata CopyBack transaction [%0d] targeted to HN (idx %0d, id %0d), suspend_wr_data %0b suspend_comp_ack %0b: waiting for response from interconnect. Total responses received %0d",`SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq[_index_1].copyback_tran),_index_1, writesoptionaldata_seq[_index_1].copyback_tran.hn_node_idx, writesoptionaldata_seq[_index_1].copyback_tran.tgt_id,writesoptionaldata_seq[_index_1].copyback_tran.suspend_wr_data, writesoptionaldata_seq[_index_1].copyback_tran.suspend_comp_ack, received_copyback_responses));
          end
        join_none  
      end
     
      `svt_xvm_debug("body", $sformatf(" Waiting for the CompDBIDResp/Comp from HN to Resume the Suspended Response of Copyback transactions "));
      /** Waiting for the CompDBIDResp/Comp from HN to Resume the Suspended Response of all above Copyback transactions */ 
      wait(received_copyback_responses == NUM_OUTSTANDING_XACT); 
      
      /** Self Check1: To check suspend_wr_data/suspend_comp_ack should not be modified to zero by the VIP
       *  before reseting from test bench.
       */
      foreach (writesoptionaldata_seq[self_check_idx1]) begin
        if(!writesoptionaldata_seq[self_check_idx1].copyback_tran.is_terminated()) begin 
          if (writesoptionaldata_seq[self_check_idx1].copyback_tran.has_compack_transfer_for_copyback_xact()) begin      
            if (writesoptionaldata_seq[self_check_idx1].copyback_tran.suspend_comp_ack == 0) begin
              `svt_xvm_error("body", $sformatf("%0s suspend_comp_ack should be 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq[self_check_idx1].copyback_tran)));
            end
            else begin
              `svt_xvm_debug("body", $sformatf("%0s suspend_comp_ack is 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq[self_check_idx1].copyback_tran)));
            end
          end
          else begin
            if (writesoptionaldata_seq[self_check_idx1].copyback_tran.suspend_wr_data == 0) begin
              `svt_xvm_error("body", $sformatf("%0s suspend_wr_data should be 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq[self_check_idx1].copyback_tran)));
            end
            else begin
              `svt_xvm_debug("body", $sformatf("%0s suspend_wr_data is 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq[self_check_idx1].copyback_tran)));
            end
          end
        end  
      end

      /** Self Check2: To check transaction is not ended by the VIP before resuming the 
       *  suspend_wr_data/suspend_comp_ack to zero from the test bench<br>
       */
      foreach (writesoptionaldata_seq[self_check_idx2]) begin
        if(!writesoptionaldata_seq[self_check_idx2].copyback_tran.is_terminated()) begin 
          if (writesoptionaldata_seq[self_check_idx2].copyback_tran.has_compack_transfer_for_copyback_xact()) begin      
            /** Fail  event has triggered */
            if (writesoptionaldata_seq[self_check_idx2].copyback_tran.end_event.is_on() == 1) begin
              `svt_xvm_error("body", $sformatf("Unexpected: %0s Transaction's end_event triggered when suspend_comp_ack is still 1.", `SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq[self_check_idx2].copyback_tran)));
            end
            /** Pass  event is not triggered */
            else begin
              `svt_xvm_debug("body", $sformatf("Expected: %0s Transaction's end_event is not triggered when suspend_comp_ack is still 1.", `SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq[self_check_idx2].copyback_tran)));
            end
          end
          else begin
            /** Fail  event has triggered */
            if (writesoptionaldata_seq[self_check_idx2].copyback_tran.end_event.is_on() == 1) begin
              `svt_xvm_error("body", $sformatf("Unexpected: %0s Transaction's end_event triggered when suspend_wr_data is still 1.", `SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq[self_check_idx2].copyback_tran)));
            end
            /** Pass  event is not triggered */
            else begin
              `svt_xvm_debug("body", $sformatf("Expected: %0s Transaction's end_event is not triggered when suspend_wr_data is still 1.", `SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq[self_check_idx2].copyback_tran)));
            end
          end        
        end
      end
 
      /** Self Check 3: To check that the current_outstanding_*_xact_count in the RNs
       * are as per the transactions inititated by the sequence
       */
      /** Check if the total outstanding xact counter is set correctly in the shared status of the RN agent */
      if(writesoptionaldata_seq[0].shared_status.prot_status.current_outstanding_xact_count != NUM_OUTSTANDING_XACT/2)
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding transactions from the sequence but the outstanding transaction count in the shared status of RN%0d is %0d", NUM_OUTSTANDING_XACT/2, initiating_rn_node_idx_0, writesoptionaldata_seq[0].shared_status.prot_status.current_outstanding_xact_count));
      /** Check if the outstanding Write xact counter is set correctly in the shared status of the RN agent */
      if(writesoptionaldata_seq[0].shared_status.prot_status.current_outstanding_write_xact_count != NUM_OUTSTANDING_XACT/2) begin
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding Copyback transactions from the sequence but the outstanding Write transaction count in the shared status of RN%0d is %0d", NUM_OUTSTANDING_XACT/2, initiating_rn_node_idx_0, writesoptionaldata_seq[0].shared_status.prot_status.current_outstanding_write_xact_count));
      end
      /** Check if the total outstanding xact counter is set correctly in the shared status of the RN agent */
      if(writesoptionaldata_seq[1].shared_status.prot_status.current_outstanding_xact_count != NUM_OUTSTANDING_XACT/2)
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding transactions from the sequence but the outstanding transaction count in the shared status of RN%0d is %0d", NUM_OUTSTANDING_XACT/2, initiating_rn_node_idx_1, writesoptionaldata_seq[1].shared_status.prot_status.current_outstanding_xact_count));
      /** Check if the outstanding Write xact counter is set correctly in the shared status of the RN agent */
      if(writesoptionaldata_seq[1].shared_status.prot_status.current_outstanding_write_xact_count != NUM_OUTSTANDING_XACT/2) begin
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding Copyback transactions from the sequence but the outstanding Write transaction count in the shared status of RN%0d is %0d", NUM_OUTSTANDING_XACT/2, initiating_rn_node_idx_1, writesoptionaldata_seq[1].shared_status.prot_status.current_outstanding_write_xact_count));
      end

      `svt_xvm_debug("body", $sformatf("RN%0d: Number of outstanding transactions : %0d, Number of outstanding write xacts : %0d", initiating_rn_node_idx_0, writesoptionaldata_seq[0].shared_status.prot_status.current_outstanding_xact_count, writesoptionaldata_seq[0].shared_status.prot_status.current_outstanding_write_xact_count));
      `svt_xvm_debug("body", $sformatf("RN%0d: Number of outstanding transactions : %0d, Number of outstanding write xacts : %0d", initiating_rn_node_idx_1, writesoptionaldata_seq[1].shared_status.prot_status.current_outstanding_xact_count, writesoptionaldata_seq[1].shared_status.prot_status.current_outstanding_write_xact_count));

      /** Resuming the Suspended Response of all above Writesoptionaldata Copyback transactions  */
      foreach(writesoptionaldata_seq[wr]) begin
        if (writesoptionaldata_seq[wr].copyback_tran.has_compack_transfer_for_copyback_xact()) begin
          `svt_xvm_debug("body",$sformatf("Received responses for all Writesoptionaldata Copyback type transactions from interconnect, resuming the transactions by setting svt_chi_rn_transaction::suspend_comp_ack set to 0 %0s",`SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq[wr].copyback_tran)));
          writesoptionaldata_seq[wr].copyback_tran.suspend_comp_ack=0; 
          `svt_xvm_debug("body", $sformatf("For iteration %0d : After Resume, received_copyback_responses is %0d,suspend_comp_ack is %0b", wr,received_copyback_responses,writesoptionaldata_seq[wr].copyback_tran.suspend_comp_ack));
        end        
        else begin
          `svt_xvm_debug("body",$sformatf("Received responses for all Writesoptionaldata Copyback type transactions from interconnect, resuming the transactions by setting svt_chi_rn_transaction::suspend_wr_data set to 0 %0s",`SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq[wr].copyback_tran)));
          writesoptionaldata_seq[wr].copyback_tran.suspend_wr_data=0; 
          `svt_xvm_debug("body", $sformatf("For iteration %0d : After Resume, received_copyback_responses is %0d,suspend_wr_data is %0b", wr,received_copyback_responses,writesoptionaldata_seq[wr].copyback_tran.suspend_wr_data));
        end  
      end

      `svt_xvm_debug("body",$sformatf("Waiting for completion of all the outstanding copyback type transactions"));
      /** Waiting for above Copyback outstanding transactions to complete */ 
      foreach(writesoptionaldata_seq[index_5]) begin
        `svt_xvm_debug("body", $sformatf("Waiting for above copyback[%0d] transaction %0s to end", index_5, `SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq[index_5].copyback_tran)));
        writesoptionaldata_seq[index_5].copyback_tran.wait_end(); 

        /** Self Check4: To check suspend_wr_data/suspend_comp_ack should not be asserted after
         * the transaction completes as it is reseted from test bench
         */
        if(!writesoptionaldata_seq[index_5].copyback_tran.is_terminated()) begin 
          if (writesoptionaldata_seq[index_5].copyback_tran.has_compack_transfer_for_copyback_xact()) begin      
            if (writesoptionaldata_seq[index_5].copyback_tran.suspend_comp_ack == 1) begin
              `svt_xvm_error("body", $sformatf("%0s suspend_comp_ack  should be 0 as it should be reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq[index_5].copyback_tran)));
            end
            else begin
              `svt_xvm_debug("body", $sformatf("%0s suspend_comp_ack is 0 as it is reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq[index_5].copyback_tran)));
            end
          end
          else begin
            if (writesoptionaldata_seq[index_5].copyback_tran.suspend_wr_data == 1) begin
              `svt_xvm_error("body", $sformatf("%0s suspend_wr_data  should be 0 as it should be reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq[index_5].copyback_tran)));
            end
            else begin
              `svt_xvm_debug("body", $sformatf("%0s suspend_wr_data is 0 as it is reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq[index_5].copyback_tran)));
            end
          end        
        end
      end

      // Targetted HN IDs from both RNs should be different. This check is currently enabled only when
      // the number of outstanding transactions to be issued to an HN is a multiple of 4,ie, NUM_OUTSTANDING_XACT is a multiple of 8
      if((NUM_OUTSTANDING_XACT % 8) == 0) begin
        for(int i = 0; i<NUM_OUTSTANDING_XACT/2; i++)begin
          int hn_idx_0, hn_idx_1;
          hn_idx_0 = sys_cfg.get_hn_idx(writesoptionaldata_seq[i].output_xacts[0].addr);
          hn_idx_1 = sys_cfg.get_hn_idx(writesoptionaldata_seq[(NUM_OUTSTANDING_XACT/2) + i].output_xacts[0].addr);
          if((i < NUM_OUTSTANDING_XACT/8) || ((i >= NUM_OUTSTANDING_XACT/4) && (i < 3*NUM_OUTSTANDING_XACT/8))) begin
            if ((hn_idx_0 == hn_idx_1) && (hn_idx_0 == target_hn_node_idx_0)) begin
              `svt_xvm_debug("body", $sformatf("Targeted HN Index from both RNs are same as expected.  rn[%0d] to hn_idx[%0d], rn[%0d] to hn_idx[%0d] and they match with the target_hn_node_idx_0 %0d", initiating_rn_node_idx_0, hn_idx_0, initiating_rn_node_idx_1, hn_idx_1,target_hn_node_idx_0));
            end
            else begin
              `svt_xvm_error("body", $sformatf("Targeted HN Index from one or both of the RNs are different from first target node index, which is unexpected.  rn[%0d] %0s transaction to hn_idx[%0d], rn[%0d] %0s transaction to hn_idx[%0d] and the target_hn_node_idx_0 is %0d", initiating_rn_node_idx_0, `SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq[2*i].output_xacts[0]), hn_idx_0, initiating_rn_node_idx_1, `SVT_CHI_PRINT_PREFIX( writesoptionaldata_seq[2*i + 1].output_xacts[0]), hn_idx_1,target_hn_node_idx_0));
            end
          end
          else if((i < NUM_OUTSTANDING_XACT/4) || ((i >= 3*NUM_OUTSTANDING_XACT/8) && (i < NUM_OUTSTANDING_XACT/2))) begin
            if ((hn_idx_0 == hn_idx_1) && (hn_idx_0 == target_hn_node_idx_1)) begin
              `svt_xvm_debug("body", $sformatf("Targeted HN Index from both RNs are same as expected.  rn[%0d] to hn_idx[%0d], rn[%0d] to hn_idx[%0d] and they match with the target_hn_node_idx_1 %0d", initiating_rn_node_idx_0, hn_idx_0, initiating_rn_node_idx_1, hn_idx_1,target_hn_node_idx_1));
            end
            else begin
              `svt_xvm_error("body", $sformatf("Targeted HN Index from one or both of the RNs are different from first target node index, which is unexpected.  rn[%0d] %0s transaction to hn_idx[%0d], rn[%0d] %0s transaction to hn_idx[%0d] and the target_hn_node_idx_1 is %0d", initiating_rn_node_idx_0,`SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq[2*i].output_xacts[0]),hn_idx_0, initiating_rn_node_idx_1, `SVT_CHI_PRINT_PREFIX(writesoptionaldata_seq[2*i + 1].output_xacts[0]),hn_idx_1,target_hn_node_idx_1));
            end
          end
        end
      end

      /** Empty the address ,RN-F's and txn_id queues */
      rn_f_node_idx_0_copyback_addr_queue.delete();
      rn_f_node_idx_1_copyback_addr_queue.delete();
      rn_f_node_idx_0_copyback_non_secure_queue.delete();
      rn_f_node_idx_1_copyback_non_secure_queue.delete();
      rn_f_node_idx_0_txn_id_queue.delete();
      rn_f_node_idx_1_txn_id_queue.delete();    
      initiating_rn_f_node_idx_1_queue.delete();  
      initiating_rn_f_node_idx_0_queue.delete();

      /** Reset received_copyback_responses to Zero */
      received_copyback_responses = 0;

    end//forloop of sequence_length

    /** 
     * To check the Interconnect HN's shall responds properly for all outstanding
     *CopyBack transactions to particular RN.<br>
     * Check done by System monitor(List of checkers)<br>
     *  #- copyback_data_integrity_check 
     *  .  
     */
    `svt_xvm_debug("body", "Exiting...")
  endtask: body

endclass: svt_chi_system_protocol_flow_ctrl_writesoptionaldata_outstanding_diff_rn_diff_hn_virtual_sequence

function svt_chi_system_protocol_flow_ctrl_writesoptionaldata_outstanding_diff_rn_diff_hn_virtual_sequence::new(string name="svt_chi_system_protocol_flow_ctrl_writesoptionaldata_outstanding_diff_rn_diff_hn_virtual_sequence");
  super.new(name);
endfunction

//====================================================================================
/**
 * @groupname CHI_OUTSTANDING_RD_TYPE   
 *    #- This sequence requires at least one HN node to be present in the Interconnect.<br>
 *    #- This sequence requires one initiating active and participating RN.<br>
 *    #- If another active and participating RN-F exists, perform cache<br>
 *       initialization to a randomly selected HN.<br>
 *    #- Initiate maximum number of MakeReadUnique type transactions with<br> 
 *       svt_chi_rn_transaction::suspend_comp_ack set  to 1 from initiating RN to randomly<br> 
 *       selected HN in non blocking mode. <br>
 *       - This ensures that the maximum outstanding transaction limit is reached at the HN.<br> 
 *       - Maximum number of outstanding transactions at the HN is as per either #max_num_outstanding_read_xacts_at_hn or
 *         #max_num_outstanding_xacts_at_hn, which can be controlled through config DB.
 *       - Also, the RN will not transmit CompAck corresponding to these transactions<br>
 *       until svt_chi_rn_transaction::suspend_comp_ack is set to 0 from the seqeunce.<br>
 *       .
 *    #- The addresses of these MakeReadUnique transactions are such that:<br>
 *       - Same as initialized cache line addresses if cache initialization is performed<br>
 *       - Otherwise, random addresses targeting the same HN<br>
 *       .
 *    #- Once the RN receives the responses for all the outstanding transactions from<br>
 *       HN, svt_chi_rn_transaction::suspend_comp_ack is set to 0 for all the outstanding<br>
 *       transactions. <br>
 *       This ensures that the CompAck for these transactions can be resumed<br> 
 *       from RN.<br>
 *    #- Check that the HN responds properly for all outstanding MakeReadUnique type transactions<br>
 *       and these are completed successfully.<br>
 *    #- This sequence requires SVT_CHI_ISSUE_E_ENABLE macro to be defined and
 *       svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_E or later.<br>
 *    .
 *
 */

class svt_chi_system_protocol_flow_ctrl_makereadunique_outstanding_same_rn_same_hn_virtual_sequence extends svt_chi_system_base_virtual_sequence;

  //-----------------------------------------------------------------------------  
  // Member attributes
  //-----------------------------------------------------------------------------  
  /** Parameter that controls the enabling of transactions in non-blocking mode from the sequence */
  bit enable_outstanding = 0;

  /** Represents the received read responses */
  int received_read_responses = 0;

  /** To display contents of Active Participating RN's nodes info. */
  string str_node_info;

  /** UVM/OVM Object Utility macro */
  `svt_xvm_object_utils(svt_chi_system_protocol_flow_ctrl_makereadunique_outstanding_same_rn_same_hn_virtual_sequence)
  
  //-----------------------------------------------------------------------------  
  // Methods
  //-----------------------------------------------------------------------------
  /** Constructor */
  extern function new(string name="svt_chi_system_protocol_flow_ctrl_makereadunique_outstanding_same_rn_same_hn_virtual_sequence"); 
  
  // -----------------------------------------------------------------------------
  virtual task pre_start();
    bit enable_outstanding_status;
    `svt_xvm_debug("pre_start",$sformatf("Entering ..."));
    super.pre_start();
    raise_phase_objection();
    enable_outstanding_status = uvm_config_db#(bit)::get(m_sequencer, get_type_name(), "enable_outstanding", enable_outstanding);
    `svt_xvm_debug("body", $sformatf("enable_outstanding is %0b as a result of %0s", enable_outstanding, (enable_outstanding_status?"config DB":"default setting")));
    `svt_xvm_debug("pre_start",$sformatf("Exiting ..."));
  endtask // pre_start

  // -----------------------------------------------------------------------------
  /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting RN-F Nodes = 1 
   *  #- svt_chi_node_configuration::chi_spec_revision >= svt_chi_node_configuration::ISSUE_E
   *  .
   */
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    
    /** local variables */
    int num_supporting_rn_f_nodes;
    string str_is_supported_info_prefix = "";
    string str_is_supported_info = "";
    string str_is_supported_info_suffix = "Modify configurations through svt_chi_node_configuration::chi_spec_revision\n";

    /** Supporting Request Nodes required */
    int required_num_supporting_rn_f_nodes = 0;
    int required_num_hn_nodes = 1;
    int num_hn_f_nodes;
    int array_idx;
    string str_idx0_info = "";
    bit    is_rn_idx_0_participating;   
    `svt_xvm_debug("is_supported",$sformatf("Entering..."));

    /** By default is_supported is 0 */
    is_supported = 0;

    /** Check for minimum required HN-F nodes */
    num_hn_f_nodes = hn_f_nodes.size();
    
    /** Check requirment of number of HN nodes needed */
    if (num_hn_f_nodes < required_num_hn_nodes) begin
      issue_is_supported_failure($sformatf("This sequence requires minimum %0d HN-F nodes to be present in the system. Number of HN-F nodes are %0d. Program number of HN nodes using svt_chi_system_configuration::num_hn. Program the HN interface type using svt_chi_system_configuration::chi_addr_cfg.hn_interface_type[].", required_num_hn_nodes, num_hn_f_nodes));
      return 0;      
    end
    
    /** Set minimum required supporting RN-F nodes */   
    required_num_supporting_rn_f_nodes = 1;

    /** Check for minimum required RN-F nodes. */
    num_supporting_rn_f_nodes = active_participating_rn_f_nodes.size();

    /** Check the requirement of RN-F nodes */
    if (num_supporting_rn_f_nodes) begin
      /** Display the contents of Active Participating RN-F Nodes */
      foreach (active_participating_rn_f_nodes[j]) begin
        str_node_info = {str_node_info, $sformatf(" %0d", active_participating_rn_f_nodes[j])};
      end      
      `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_f_nodes are %0s", str_node_info));
    end
    
    /** Check the required supporting Request Nodes */
    
    str_is_supported_info_prefix = $sformatf("Number of Supporting RN-F Node(s)  - Minimum Required : %0d Current : %0d", required_num_supporting_rn_f_nodes,num_supporting_rn_f_nodes);
    if ((initiating_rn_node_index_0_status==0)&&(valid_initiating_rn_f_node_index_0==0)) begin
        str_idx0_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN-Fs that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)";
    end
    else begin
      is_rn_idx_0_participating = is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_node_idx_0, array_idx);
      if (!is_rn_idx_0_participating) begin
        str_idx0_info = $sformatf("initiating_rn_node_idx_0 %0d is not valid for this sequence. The RN-F corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)", initiating_rn_node_idx_0, initiating_rn_node_idx_0);
      end
    end

    if (is_rn_idx_0_participating) begin
      is_supported = 1;
      //If max_num_outstanding_read_xacts_at_hn is set to a non-default value, it would mean that separate outstanding xact limit is set
      //for each transaction type category, and so we compare the configured num_outstanding_read_xact value of the initiating RN with max_num_outstanding_read_xacts_at_hn
      if(max_num_outstanding_read_xacts_at_hn > 0) begin
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].num_outstanding_read_xact < max_num_outstanding_read_xacts_at_hn) begin
          str_idx0_info = $sformatf("Programmed value of num_outstanding_read_xacts_at_hn_status is %0d. But max_num_outstanding_read_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_read_xact of the initiating RN node must be equal to or greater than max_num_outstanding_read_xacts_at_hn_status of the target HN", max_num_outstanding_read_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_0_participating].num_outstanding_read_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
      //If max_num_outstanding_read_xacts_at_hn is set to 0, it would mean that only one overall outstanding xact limit is set
      //so we compare the configured num_outstanding_xact value of the initiating RN with max_num_outstanding_xacts_at_hn
      end else begin
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].num_outstanding_xact < max_num_outstanding_xacts_at_hn) begin
          str_idx0_info = $sformatf("Programmed value of max_num_outstanding_xacts_at_hn_status is %0d. But num_outstanding_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_xact of the initiating RN node must be equal to or greater than max_num_outstanding_xacts_at_hn of the target HN", max_num_outstanding_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_0_participating].num_outstanding_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
      end
    end
    
    if (!is_supported) begin
      str_is_supported_info = $sformatf("%0s",str_idx0_info);
      
      if (silent) begin
        if (is_rn_idx_0_participating) begin
          `svt_xvm_debug("is_supported",$sformatf("This sequence cannot be run based on the current system configuration.\n\
                                                  %0s\n\
                                                  %0s \n\
                                                  Modify configurations through \n\
                                                  svt_chi_system_configuration::num_rn,\n\
                                                  svt_chi_node_configuration::is_active,\n\
                                                  svt_chi_system_configuration::participating_rn_nodes[]\n\
                                                  ", str_is_supported_info_prefix, str_is_supported_info));
        end
        else begin
          `svt_xvm_debug("is_supported",$sformatf("This sequence cannot be run based on the current node configuration of RN%0d.\n\
                                                  %0s \n\
                                                  Modify configurations through \n\
                                                  svt_chi_node_configuration::num_outstanding_xact,\n\
                                                  svt_chi_node_configuration::num_outstanding_read_xact,\n\
                                                  ", initiating_rn_node_idx_0, str_is_supported_info));
        end
      end
      else begin
        if (is_rn_idx_0_participating) begin
          `svt_xvm_note("is_supported",$sformatf("This sequence cannot be run based on the current system configuration.\n\
                                                 %0s\n\
                                                 %0s \n\
                                                 Modify configurations through \n\
                                                 svt_chi_system_configuration::num_rn,\n\
                                                 svt_chi_node_configuration::is_active,\n\
                                                 svt_chi_system_configuration::participating_rn_nodes[]\n\
                                                 ", str_is_supported_info_prefix, str_is_supported_info));
        end
        else begin
          `svt_xvm_note("is_supported",$sformatf("This sequence cannot be run based on the current node configuration of RN%0d.\n\
                                                  %0s \n\
                                                  Modify configurations through \n\
                                                  svt_chi_node_configuration::num_outstanding_xact,\n\
                                                  svt_chi_node_configuration::num_outstanding_read_xact,\n\
                                                  ", initiating_rn_node_idx_0, str_is_supported_info));
        end
      end // else: !if(silent)
    end
    if (!is_target_hn_idx_valid_for_curr_cfg()) begin
      is_supported = 0;
      `svt_xvm_note("is_supported", "not a valid hn_idx based on random_tgt_id_enable for current cfg");
    end

    /** Checking the Spec revision **/
    if(is_supported) begin
      str_is_supported_info_prefix = "This sequence cannot be run based on the current configuration.\n";
      str_is_supported_info = "";

      if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision < svt_chi_node_configuration::ISSUE_E) begin
        is_supported = 0;
        str_is_supported_info = $sformatf("svt_chi_node_configuration::chi_spec_revision is not set to svt_chi_node_configuration::ISSUE_E or later for initiating requester node %0d. Writeevictorevict can only be issued from RN when svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_E or later ", initiating_rn_node_idx_0);
      end else begin
        is_supported = 1;
      end  

      if (!is_supported) begin
        string str_complete_is_supported_info = {str_is_supported_info_prefix, str_is_supported_info, str_is_supported_info_suffix};
        issue_is_supported_failure(str_complete_is_supported_info);
      end
    end
  endfunction : is_supported  

  // -----------------------------------------------------------------------------
  virtual task body();
    /** Queue of addresses, used by the transactions generated */
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0]                    addr_collection_q[$];
    bit seq_is_non_secure_access_q[$];
    int                                                   array_idx;
    int                                                   num_outstanding_xacts_to_generate;

    /** Sub sequences initiated from this sequence */
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq[int];
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq_1[int];

    /** Sub CopyBack type transaction directed sequences initiated from this sequence */
    svt_chi_rn_copyback_type_transaction_directed_sequence copyback_seq[int];

    /** Sub Read type transaction directed sequences initiated from this sequence */
    svt_chi_rn_read_type_transaction_directed_sequence read_seq[int];

    /** Sub MakeReadUnique type transaction directed sequences initiated from this sequence */
    svt_chi_rn_makereadunique_type_transaction_directed_sequence makereadunique_seq[int];

    /** Flag to track whether cache initialization needs to be performed or not*/
    bit perform_cache_initialization;
    string str_node_types = "";
    int unsigned sel_initiating_rn_node_idx_0; 
    bit rn_is_valid, rn_is_unique,rn_is_clean;
    bit[`SVT_CHI_MAX_ADDR_WIDTH-1:0] txn_address;

    super.body();
    `svt_xvm_debug("body", "Entering ...");

    max_num_outstanding_xacts_at_hn_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(),"max_num_outstanding_xacts_at_hn",max_num_outstanding_xacts_at_hn);
    max_num_outstanding_read_xacts_at_hn_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(),"max_num_outstanding_read_xacts_at_hn",max_num_outstanding_read_xacts_at_hn);
    max_num_outstanding_write_xacts_at_hn_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(),"max_num_outstanding_write_xacts_at_hn",max_num_outstanding_write_xacts_at_hn);
    max_num_outstanding_cmo_xacts_at_hn_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(),"max_num_outstanding_cmo_xacts_at_hn",max_num_outstanding_cmo_xacts_at_hn);

    str_node_types = "Initiating nodes are of RN-F type.";
    cache_line_init_rn_f_node_index = initiating_rn_f_node_index_0;          
    sel_initiating_rn_node_idx_0 = initiating_rn_f_node_index_0;

    `svt_xvm_debug("body", $sformatf("%0s perform_cache_initialization = %0b. cache_line_init_rn_f_node_index = %0d. sel_initiating_rn_node_idx_0 = %0d.", str_node_types, perform_cache_initialization, cache_line_init_rn_f_node_index, sel_initiating_rn_node_idx_0));
    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :sel_initiating_rn_node_idx_0;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_f_node_index_0;
    `svt_xvm_debug("body", $sformatf("max_num_outstanding_xacts_at_hn is %0d as a result of %0s.", max_num_outstanding_xacts_at_hn, max_num_outstanding_xacts_at_hn_status ? "config DB" : "default"));
    `svt_xvm_debug("body", $sformatf("max_num_outstanding_read_xacts_at_hn is %0d as a result of %0s.", max_num_outstanding_read_xacts_at_hn, max_num_outstanding_read_xacts_at_hn_status ? "config DB" : "default"));
    `svt_xvm_debug("body", $sformatf("max_num_outstanding_write_xacts_at_hn is %0d as a result of %0s.", max_num_outstanding_write_xacts_at_hn, max_num_outstanding_write_xacts_at_hn_status ? "config DB" : "default"));
    `svt_xvm_debug("body", $sformatf("max_num_outstanding_cmo_xacts_at_hn is %0d as a result of %0s.", max_num_outstanding_cmo_xacts_at_hn, max_num_outstanding_cmo_xacts_at_hn_status ? "config DB" : "default"));
    `svt_xvm_debug("body", $sformatf("initiating_rn_node_idx_0 is %0d as a result of %0s.", initiating_rn_node_idx_0, initiating_rn_node_index_0_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("target_hn_f_node_index_0 is %0d as a result of %0s.", target_hn_node_idx_0, target_hn_node_index_0_status ? "config DB" : "Randomization")); 

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    //If max outstanding count for MakeReadUnique transactions has been programmed, use that to generate the outstanding MakeReadUniques
    if(max_num_outstanding_read_xacts_at_hn > 0) begin
      num_outstanding_xacts_to_generate = max_num_outstanding_read_xacts_at_hn;
      `svt_xvm_debug("body",$sformatf("max_num_outstanding_read_xacts_at_hn is set to a non-zero value (%0d). Hence, the value programmed in max_num_outstanding_xacts_at_hn will be ignored. The number of outstanding transactions issued by the sequence will be equal to max_num_outstanding_read_xacts_at_hn", max_num_outstanding_read_xacts_at_hn));
    end
    //If not, use the max outstanding transaction count
    else
      num_outstanding_xacts_to_generate = max_num_outstanding_xacts_at_hn;


    /**
     * If the cache_line_init_rn_f_node_index is part of active_participating_rn_f_nodes array then we can
     * issue MAKEREADUNIQUE transaction from the RN[cache_line_init_rn_f_node_index].
     */
    if (!(is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, cache_line_init_rn_f_node_index, array_idx))) begin
       `svt_xvm_error("body", $sformatf("cache_line_init_rn_f_node_index should be expected to be active participating RN-F node,but it is not i.e cache_line_init_rn_f_node_index = 'h%d",cache_line_init_rn_f_node_index));
    end

    /**
     * If the initiating_rn_node_idx_0 is part of active_participating_rn_f_nodes array then we can
     * issue MAKEREADUNIQUE transaction from the RN[initiating_rn_node_idx_0].
     */
    if (!(is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_node_idx_0, array_idx))) begin
       `svt_xvm_error("body", $sformatf("initiating_rn_node_idx_0 should be expected to be active participating RN-F node,but it is not i.e initiating_rn_node_idx_0 = 'h%d",initiating_rn_node_idx_0));
       initiating_rn_node_idx_0 = cache_line_init_rn_f_node_index;
    end

    for(int i = 0; i < sequence_length; i++) begin

      `svt_xvm_debug("body",$sformatf("Starting cache initialization for %0d addresses from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d", num_outstanding_xacts_to_generate, cache_line_init_rn_f_node_index, target_hn_node_idx_0));

      for(int k=0; k<num_outstanding_xacts_to_generate; k++) begin
      
        /** Write data into Cache of Randomly selected first RN with address of randomly selected HN Node */
        `svt_xvm_do_on_with(makeunique_seq[k], p_sequencer.rn_virt_seqr[cache_line_init_rn_f_node_index].rn_xact_seqr,
        {
          sequence_length == 1;
          set_unique_addr_value == 1;
          hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
          seq_hn_node_idx == target_hn_node_idx_0;
          use_seq_is_non_secure_access == 0;
        })
        /** Waiting for above MakeUnique transaction to complete */ 
        `svt_xvm_debug("body", $sformatf("%0s Waiting for MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) to end",`SVT_CHI_PRINT_PREFIX(makeunique_seq[k].write_tran),k, makeunique_seq[k].write_tran.hn_node_idx, makeunique_seq[k].write_tran.tgt_id));
         makeunique_seq[k].write_tran.wait_end();
        `svt_xvm_debug("body", $sformatf("%0s MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) ended",`SVT_CHI_PRINT_PREFIX(makeunique_seq[k].write_tran),k, makeunique_seq[k].write_tran.hn_node_idx, makeunique_seq[k].write_tran.tgt_id));

        `svt_xvm_verbose("body", $sformatf("MakeUnique transaction [%0d]  is %0s", k,makeunique_seq[k].write_tran.sprint()));

        `svt_xvm_do_on_with(copyback_seq[k], p_sequencer.rn_virt_seqr[cache_line_init_rn_f_node_index].rn_xact_seqr,{
           sequence_length == 1;
           seq_xact_type == svt_chi_transaction::WRITEBACKFULL;
           seq_order_type  == svt_chi_transaction::NO_ORDERING_REQUIRED;
           seq_copyback_req_order_enable == 0;  
           hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
           min_addr           == makeunique_seq[k].write_tran.addr;
           max_addr           == makeunique_seq[k].write_tran.addr;     
           use_seq_is_non_secure_access == 1;              
         })

        copyback_seq[k].copyback_tran.wait_end(); 

        `svt_xvm_do_on_with(read_seq[k], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
        {
          sequence_length == 1;
          seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
          if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision >= svt_chi_node_configuration::ISSUE_E) {
           seq_txn_id         == (k*3);
          }
          else{
           seq_txn_id         == (k % num_outstanding_xacts_to_generate);
          }
          hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
          min_addr == makeunique_seq[k].write_tran.addr;
          max_addr == makeunique_seq[k].write_tran.addr;
          use_seq_is_non_secure_access == 1;
          data_in_cache == makeunique_seq[k].data_in_cache;
          by_pass_read_data_check == 0;
          seq_xact_type == svt_chi_transaction::READSHARED;
        }
        )
        read_seq[k].read_tran.wait_end();
        txn_address = read_seq[k].read_tran.addr;

        /** Checking the cacheline state as the expected valid state to initiatlize the MAKEREADUNIQUE transaction is SC,SD */ 
        rn_is_valid = get_rn_cache_status(initiating_rn_node_idx_0, txn_address, rn_is_unique, rn_is_clean);

        //At this point the Cache state is either I, SC, SD.
        //If it is I ,silently moving to Shared state.
        if (!rn_is_valid) begin
          // Do a MAKEUNIQUE transaction from initiating_rn_node_idx_0
          `svt_xvm_do_on_with(makeunique_seq_1[k], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
          {
            sequence_length == 1;
            hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
            min_addr           == makeunique_seq[k].write_tran.addr;
            max_addr           == makeunique_seq[k].write_tran.addr;     
            seq_mem_attr_allocate_hint == makeunique_seq[k].write_tran.mem_attr_allocate_hint;
            seq_snp_attr_snp_domain_type == makeunique_seq[k].write_tran.snp_attr_snp_domain_type;
            seq_is_non_secure_access == makeunique_seq[k].write_tran.is_non_secure_access;
            use_seq_is_non_secure_access == 1;        
          }
          )
          `svt_xvm_debug("body", $sformatf("%0s Waiting for MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) to end %d",`SVT_CHI_PRINT_PREFIX(makeunique_seq_1[k].write_tran),k, makeunique_seq_1[k].write_tran.hn_node_idx, makeunique_seq_1[k].write_tran.tgt_id,num_outstanding_xacts_to_generate));
          // Waiting for current MakeUnique transaction to complete 
          makeunique_seq_1[k].write_tran.wait_end();

          update_cache_status = update_rn_cache_status(initiating_rn_node_idx_0, makeunique_seq[k].write_tran.addr, 0, -1);
          rn_is_valid = get_rn_cache_status(initiating_rn_node_idx_0, makeunique_seq[k].write_tran.addr, rn_is_unique, rn_is_clean);
        end        
      end //outstanding loop

      `svt_xvm_debug("body",$sformatf("Ended cache initialization for %0d addresses from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d",
                                        num_outstanding_xacts_to_generate, cache_line_init_rn_f_node_index, target_hn_node_idx_0));
        
      /** Retriving address from the transactions */
      for(int k=0; k<num_outstanding_xacts_to_generate; k++) begin 
         addr_collection_q.push_back(makeunique_seq[k].output_xacts[0].addr);
         seq_is_non_secure_access_q.push_back(makeunique_seq[k].output_xacts[0].is_non_secure_access);
      end

      /** Printing the address from the queue */
      foreach(addr_collection_q[i]) begin
        `svt_xvm_debug("addr_collection_queue", $sformatf("addr_collection_q[%0d] is %0h, with is_non_secure_access %0b",i,addr_collection_q[i], seq_is_non_secure_access_q[i]));
      end

      `svt_xvm_debug("body",$sformatf("Starting transmission of MakeReadUnique type transactions for %0d addresses from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d with suspend_comp_ack set to 1",num_outstanding_xacts_to_generate, initiating_rn_node_idx_0, target_hn_node_idx_0));
      
      for(int j=0; j<num_outstanding_xacts_to_generate; j++) begin 
        /** Randomly selected first RN-F fires a read transaction with MAKEUNIQUE 
         *  transaction address of randomly selected HN Node.
         */
        `svt_xvm_do_on_with(makereadunique_seq[j], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
        {
          sequence_length == 1;
          seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
          if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision >= svt_chi_node_configuration::ISSUE_E) {
           seq_txn_id         == (j*3);
          }
          else{
           seq_txn_id         == (j % num_outstanding_xacts_to_generate);
          }
          hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
          min_addr == addr_collection_q[j];
          max_addr == addr_collection_q[j];
          seq_is_non_secure_access == seq_is_non_secure_access_q[i]; 
          use_seq_is_non_secure_access == 1;
          data_in_cache == makeunique_seq[j].data_in_cache;
          by_pass_read_data_check == 0;
          seq_xact_type == svt_chi_transaction::MAKEREADUNIQUE;
        }
        )
        `svt_xvm_debug("body", $sformatf("%0s Transmitting MakeReadUnique Transaction [%0d] targeted to HN (idx %0d, id %0d) ",`SVT_CHI_PRINT_PREFIX(makereadunique_seq[j].makereadunique_tran),j, makereadunique_seq[j].makereadunique_tran.hn_node_idx, makereadunique_seq[j].makereadunique_tran.tgt_id));
        `svt_xvm_verbose("body", $sformatf("MakeReadUnique Transaction [%0d] is %0s",j,makereadunique_seq[j].makereadunique_tran.sprint()));
      end//outstanding

      /** Event to Resume the Suspended Response of above trasactions */ 
      foreach(makereadunique_seq[rd]) begin
        fork
          automatic int _rd = rd;
          begin
            `svt_xvm_debug("body", $sformatf("%0s MakeReadUnique transaction [%0d] targeted to HN (idx %0d, id %0d), suspend_comp_ack %0b: waiting for response from interconnect",`SVT_CHI_PRINT_PREFIX(makereadunique_seq[_rd].makereadunique_tran),_rd,makereadunique_seq[_rd].makereadunique_tran.hn_node_idx, makereadunique_seq[_rd].makereadunique_tran.tgt_id,makereadunique_seq[_rd].makereadunique_tran.suspend_comp_ack));
            fork
            begin
              fork
                begin
                  makereadunique_seq[_rd].makereadunique_tran.wait_for_tx_compack_prereqs();// begin
                end
                begin
                  wait(makereadunique_seq[_rd].makereadunique_tran.req_status == svt_chi_transaction::RETRY);// begin
                end
              join_any
              disable fork;
            end
            join
            received_read_responses++;
            `svt_xvm_debug("body", $sformatf("%0s MakeReadUnique transaction [%0d] targeted to HN (idx %0d, id %0d), suspend_comp_ack %0b: received response from interconnect. Total responses received %0d",`SVT_CHI_PRINT_PREFIX(makereadunique_seq[_rd].makereadunique_tran),_rd, makereadunique_seq[_rd].makereadunique_tran.hn_node_idx, makereadunique_seq[_rd].makereadunique_tran.tgt_id,makereadunique_seq[_rd].makereadunique_tran.suspend_comp_ack, received_read_responses));       
          end
        join_none  
      end

      /** Wait until All Comp responses are received at RN */
      `svt_xvm_debug("body",$sformatf("Completed initiation of MakeReadUnique type transactions for %0d addresses from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d with suspend_comp_ack set to 1, and waiting to receive responses from interconnect.", num_outstanding_xacts_to_generate, initiating_rn_node_idx_0, target_hn_node_idx_0)); 
      wait(received_read_responses == num_outstanding_xacts_to_generate); 
      outstanding_xact_count_reached = 1;
      `svt_xvm_debug("body",$sformatf("Received responses from interconnect to MakeReadUnique type transactions for %0d addresses from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d with suspend_comp_ack set to 1",num_outstanding_xacts_to_generate, initiating_rn_node_idx_0, target_hn_node_idx_0));
      
      /** Self Check1: To check suspend_comp_ack should not be modified to zero by the VIP
       *  before reseting from test bench
       */
      foreach (makereadunique_seq[self_check_idx1]) begin
        if (!makereadunique_seq[self_check_idx1].makereadunique_tran.is_terminated()) begin
          if (makereadunique_seq[self_check_idx1].makereadunique_tran.suspend_comp_ack == 0) begin
            `svt_xvm_error("body", $sformatf("%0s suspend_comp_ack should be 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(makereadunique_seq[self_check_idx1].makereadunique_tran)));
          end
          else begin
            `svt_xvm_debug("body", $sformatf("%0s suspend_comp_ack is 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(makereadunique_seq[self_check_idx1].makereadunique_tran)));
          end
        end
      end  

      /** Self Check2: To check end_event should not be 1 before resuming the
       *  transaction from test bench
       */
      foreach(makereadunique_seq[self_check_idx2]) begin
        if (!makereadunique_seq[self_check_idx2].makereadunique_tran.is_terminated()) begin
          if (makereadunique_seq[self_check_idx2].makereadunique_tran.end_event.is_on() == 1) begin
            `svt_xvm_error("body", $sformatf("Unexpected: %0s Transaction's end_event triggered when suspend_comp_ack is still 1.", `SVT_CHI_PRINT_PREFIX(makereadunique_seq[self_check_idx2].makereadunique_tran)));
          end
          else begin
            `svt_xvm_debug("body", $sformatf("Expected: %0s Transaction's end_event is not triggered when suspend_comp_ack is still 1.", `SVT_CHI_PRINT_PREFIX(makereadunique_seq[self_check_idx2].makereadunique_tran)));
          end
        end
      end
 
      /** Self Check 3: To check that the current_outstanding_*_xact_count in the RN
       * is as per the transactions inititated by the sequence
       */
      if(makereadunique_seq[0].shared_status.prot_status.current_outstanding_xact_count != num_outstanding_xacts_to_generate)
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding transactions from the sequence but the outstanding transaction count in the shared status of RN%0d is %0d", num_outstanding_xacts_to_generate, initiating_rn_node_idx_0, makereadunique_seq[0].shared_status.prot_status.current_outstanding_xact_count));
      /** Check if the outstanding MakeReadUnique xact counter is set correctly in the shared status of the RN agent */
      if(makereadunique_seq[0].shared_status.prot_status.current_outstanding_read_xact_count != num_outstanding_xacts_to_generate) begin
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding MakeReadUnique transactions from the sequence but the outstanding MakeReadUnique transaction count in the shared status of RN%0d is %0d", num_outstanding_xacts_to_generate, initiating_rn_node_idx_0, makereadunique_seq[0].shared_status.prot_status.current_outstanding_read_xact_count));
      end

      `svt_xvm_debug("body", $sformatf("RN%0d: Number of outstanding transactions : %0d, Number of outstanding read xacts : %0d", initiating_rn_node_idx_0, makereadunique_seq[0].shared_status.prot_status.current_outstanding_xact_count, makereadunique_seq[0].shared_status.prot_status.current_outstanding_read_xact_count));

      if(use_seq_flag_to_resume_response_for_outstanding_xact) begin
        `svt_xvm_debug("body",$sformatf("Waiting for resume_response_for_outstanding_xact to be set to 1"));
        wait(resume_response_for_outstanding_xact == 1);
        `svt_xvm_debug("body",$sformatf("resume_response_for_outstanding_xact is set to 1"));
      end

      /** Resuming all CompAck responses of above MakeReadUnique transactions from RN */
      foreach(makereadunique_seq[rd]) begin
        `svt_xvm_debug("body",$sformatf("Received responses for all MakeReadUnique type transactions from interconnect, resuming the transactions by setting svt_chi_rn_transaction::suspend_comp_ack set to 0 %0s",`SVT_CHI_PRINT_PREFIX(makereadunique_seq[rd].makereadunique_tran)));
        makereadunique_seq[rd].makereadunique_tran.suspend_comp_ack=0;
        `svt_xvm_debug("body", $sformatf("For iteration %0d, received_read_responses is %0d,suspend_comp_ack is %b and exp_comp_ack is %b After Resume", rd,received_read_responses,makereadunique_seq[rd].makereadunique_tran.suspend_comp_ack,makereadunique_seq[rd].makereadunique_tran.exp_comp_ack));
      end

      /** Waiting for above read outstanding transactions to complete */
      `svt_xvm_debug("body",$sformatf("Waiting for completion of all the outstanding MakeReadUnique type transactions")); 
      foreach (makereadunique_seq[index_1]) begin
        `svt_xvm_debug("body", $sformatf("Waiting for above makereadunique_seq[%0d] transaction %0s to end", index_1, `SVT_CHI_PRINT_PREFIX(makereadunique_seq[index_1].makereadunique_tran)));
        makereadunique_seq[index_1].makereadunique_tran.wait_end();
        
        /** Self Check4: To check suspend_comp_ack should not be 1 after reseting from test bench
         *  after the transaction completes
         */
        if (!makereadunique_seq[index_1].makereadunique_tran.is_terminated()) begin
          if (makereadunique_seq[index_1].makereadunique_tran.suspend_comp_ack == 1) begin
            `svt_xvm_error("body", $sformatf("%0s suspend_comp_ack should be 0 as it should be reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(makereadunique_seq[index_1].makereadunique_tran)));
          end
          else begin
            `svt_xvm_debug("body", $sformatf("%0s suspend_comp_ack is 0 as it is reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(makereadunique_seq[index_1].makereadunique_tran)));
          end
        end
      end 
      `svt_xvm_debug("body",$sformatf("Received completions for all read type outstanding transactions"));
      
      /** Targetted HN IDs from both RNs should be same */
      foreach(makereadunique_seq[self_check_idx3]) begin
        int hn_idx_0;
        hn_idx_0 = sys_cfg.get_hn_idx(makereadunique_seq[self_check_idx3].makereadunique_tran.addr);
        if (target_hn_node_idx_0 == hn_idx_0) begin
          // pass
          `svt_xvm_debug("body", $sformatf("Targeted HN Index from the RN is same as expected.  rn[%0d] to hn_idx[%0d]", initiating_rn_node_idx_0, hn_idx_0));
        end
        else begin
          // fail
          `svt_xvm_error("body", $sformatf("Targeted HN Index from the RN is different, which is unexpected.  rn[%0d] %0s transaction to hn_idx[%0d]", initiating_rn_node_idx_0, `SVT_CHI_PRINT_PREFIX(makereadunique_seq[self_check_idx3].output_xacts[0]), hn_idx_0));
        end
      end

      /** Reset received_read_responses to Zero */
      received_read_responses = 0;

      /** Delete the contents of address collection queue */
      addr_collection_q.delete();

    end //sequence_length
    /** 
     * To check the Interconnect HN Node shall responds to all 
     * outstanding read tranactions to RN.<br>
     * Check done by System monitor(List of checkers)<br>
     *  #- read_data_integrity_check
     *  #- coherent_and_snoop_data_match_check
     *  .  
     */

    `uvm_info("body", "Exiting...", UVM_HIGH)
  endtask: body

  virtual task post_start();
    super.post_start();
    drop_phase_objection();
  endtask
  
endclass: svt_chi_system_protocol_flow_ctrl_makereadunique_outstanding_same_rn_same_hn_virtual_sequence

function svt_chi_system_protocol_flow_ctrl_makereadunique_outstanding_same_rn_same_hn_virtual_sequence::new(string name="svt_chi_system_protocol_flow_ctrl_makereadunique_outstanding_same_rn_same_hn_virtual_sequence");
  super.new(name);
endfunction

//====================================================================================
/**
 * @groupname CHI_OUTSTANDING_RD_TYPE  
 *    #- This sequence requires at least one HN node to be present in the Interconnect.<br>
 *    #- This sequence requires two initiating active and participating RN.<br>
 *    #- If another active and participating RN-F exists, perform cache<br>
 *       initialization to a randomly selected HN.<br>
 *    #- Initiate maximum number of MakeReadUnique type transactions with<br> 
 *       svt_chi_rn_transaction::suspend_comp_ack set  to 1 from two initiating RN's to randomly<br> 
 *       selected HN in non blocking mode. <br>
 *       - This ensures that the maximum outstanding transaction limit is reached at the<br> 
 *         same HN.<br> 
 *       - Maximum number of outstanding transactions at the HN is as per either #max_num_outstanding_read_xacts_at_hn or
 *         #max_num_outstanding_xacts_at_hn, which can be controlled through config DB.
 *       - Also, the two different RN will not transmit CompAck corresponding to these transactions<br>
 *       until svt_chi_rn_transaction::suspend_comp_ack is set to 0 from the seqeunce.<br>
 *       .
 *    #- The addresses of these MakeReadUnique transactions are such that:<br>
 *       - Same as initialized cache line addresses if cache initialization is performed<br>
 *       - Otherwise, random addresses targeting the same HN<br>
 *       .
 *    #- Once the RN receives the responses for all the outstanding transactions from<br>
 *       HN, svt_chi_rn_transaction::suspend_comp_ack is set to 0 for all the outstanding<br>
 *       transactions. <br>
 *       This ensures that the CompAck for these transactions can be resumed<br> 
 *       from different RN.<br>
 *    #- Check that the HN responds properly for all outstanding MakeReadUnique type<br>
 *       transactions and these are completed successfully.<br>
 *    #- This sequence requires SVT_CHI_ISSUE_E_ENABLE macro to be defined and
 *       svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_E or later.<br>
 *    .
 *
 */
 class svt_chi_system_protocol_flow_ctrl_makereadunique_outstanding_diff_rn_same_hn_virtual_sequence extends svt_chi_system_base_virtual_sequence;

  //-----------------------------------------------------------------------------  
  // Member attributes
  //-----------------------------------------------------------------------------  
  /** Parameter that controls the enabling of transactions in non-blocking mode from the sequence */
  bit enable_outstanding = 0;

  /** Represents the received read responses */
  int received_read_responses = 0;

  /** To display contents of Active Participating RN's nodes info. */
  string str_node_info;

  /** UVM/OVM Object Utility macro */
  `svt_xvm_object_utils(svt_chi_system_protocol_flow_ctrl_makereadunique_outstanding_diff_rn_same_hn_virtual_sequence)
  
  //-----------------------------------------------------------------------------  
  // Methods
  //-----------------------------------------------------------------------------
  /** Constructor */
  extern function new(string name="svt_chi_system_protocol_flow_ctrl_makereadunique_outstanding_diff_rn_same_hn_virtual_sequence"); 
  
  // -----------------------------------------------------------------------------
  virtual task pre_start();
    bit enable_outstanding_status;
    `svt_xvm_debug("pre_start",$sformatf("Entering ..."));
    super.pre_start();
    raise_phase_objection();
    enable_outstanding_status = uvm_config_db#(bit)::get(m_sequencer, get_type_name(), "enable_outstanding", enable_outstanding);
    `svt_xvm_debug("body", $sformatf("enable_outstanding is %0b as a result of %0s", enable_outstanding, (enable_outstanding_status?"config DB":"default setting")));
    `svt_xvm_debug("pre_start",$sformatf("Exiting ..."));
  endtask // pre_start

  // -----------------------------------------------------------------------------
  /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting RN-F Nodes = 2 
   *  #- svt_chi_node_configuration::chi_spec_revision >= svt_chi_node_configuration::ISSUE_E
   *  .
   */
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    
    /** local variables */
    int num_supporting_rn_f_nodes;
    string str_is_supported_info_prefix = "";
    string str_is_supported_info = "";
    string str_is_supported_info_suffix = "Modify configurations through svt_chi_node_configuration::chi_spec_revision\n";

    /** Supporting Request Nodes required */
    int required_num_supporting_rn_f_nodes = 0;
    int required_num_hn_nodes = 1;
    int num_hn_f_nodes;
    int array_idx;
    string str_idx0_info = "";
    string str_idx1_info = ""; 
    bit    is_rn_idx_0_participating, is_rn_idx_1_participating; 
    `svt_xvm_debug("is_supported",$sformatf("Entering..."));

    /** By default is_supported is 0 */
    is_supported = 0;

    /** Check for minimum required HN-F nodes */
    num_hn_f_nodes = hn_f_nodes.size();
    
    /** Check requirment of number of HN nodes needed */
    if (num_hn_f_nodes < required_num_hn_nodes) begin
      issue_is_supported_failure($sformatf("This sequence requires minimum %0d HN-F nodes to be present in the system. Number of HN-F nodes are %0d. Program number of HN nodes using svt_chi_system_configuration::num_hn. Program the HN interface type using svt_chi_system_configuration::chi_addr_cfg.hn_interface_type[].", required_num_hn_nodes, num_hn_f_nodes));
      return 0;      
    end
    
    /** Set minimum required supporting RN-F nodes */   
    required_num_supporting_rn_f_nodes = 2;

    /** Check for minimum required RN-F nodes. */
    num_supporting_rn_f_nodes = active_participating_rn_f_nodes.size();

    /** Check the requirement of RN-F nodes */
    if (num_supporting_rn_f_nodes) begin
      /** Display the contents of Active Participating RN-F Nodes */
      foreach (active_participating_rn_f_nodes[j]) begin
        str_node_info = {str_node_info, $sformatf(" %0d", active_participating_rn_f_nodes[j])};
      end      
      `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_f_nodes are %0s", str_node_info));
    end
    
    /** Check the required supporting Request Nodes */
    
    str_is_supported_info_prefix = $sformatf("Number of Supporting RN-F Node(s)  - Minimum Required : %0d Current : %0d", required_num_supporting_rn_f_nodes,num_supporting_rn_f_nodes);
    if ((initiating_rn_node_index_0_status==0)&&(valid_initiating_rn_f_node_index_0==0)) begin
        str_idx0_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN-Fs that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)";
    end
    else begin
      is_rn_idx_0_participating = is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_node_idx_0, array_idx);
      if (!is_rn_idx_0_participating) begin
        str_idx0_info = $sformatf("initiating_rn_node_idx_0 %0d is not valid for this sequence. The RN-F corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)", initiating_rn_node_idx_0, initiating_rn_node_idx_0);
      end
    end

    if ((initiating_rn_node_index_1_status==0)&&(valid_initiating_rn_f_node_index_1==0)) begin
      str_idx1_info = "Valid initiating_rn_node_idx_1 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN-Fs that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)";
    end 
    else begin
      is_rn_idx_1_participating = is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_node_idx_1, array_idx);
      if (!is_rn_idx_1_participating) begin
        str_idx1_info = $sformatf("initiating_rn_node_idx_1 %0d is not valid for this sequence. The RN-F corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)", initiating_rn_node_idx_1, initiating_rn_node_idx_1);
      end
    end 

    if (is_rn_idx_0_participating && is_rn_idx_1_participating) begin
      is_supported = 1;
      if(max_num_outstanding_read_xacts_at_hn > 0) begin
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].num_outstanding_read_xact < (max_num_outstanding_read_xacts_at_hn/2)) begin
          str_idx0_info = $sformatf("Programmed value of max_num_outstanding_read_xacts_at_hn_status is %0d. But num_outstanding_read_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_read_xact of the initiating RN node must be equal to or greater than half of max_num_outstanding_read_xacts_at_hn_status of the target HN", max_num_outstanding_read_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_0_participating].num_outstanding_read_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].num_outstanding_read_xact < (max_num_outstanding_read_xacts_at_hn/2)) begin
          str_idx1_info = $sformatf("Programmed value of max_num_outstanding_read_xacts_at_hn_status is %0d. But num_outstanding_read_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_read_xact of the initiating RN node must be equal to or greater than half of max_num_outstanding_read_xacts_at_hn_status of the target HN", max_num_outstanding_read_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_1_participating].num_outstanding_read_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
      end else begin
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].num_outstanding_xact < (max_num_outstanding_xacts_at_hn/2)) begin
          str_idx0_info = $sformatf("Programmed value of max_num_outstanding_xacts_at_hn_status is %0d. But num_outstanding_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_xact of the initiating RN node must be equal to or greater than half of max_num_outstanding_xacts_at_hn of the target HN", max_num_outstanding_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_0_participating].num_outstanding_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].num_outstanding_xact < (max_num_outstanding_xacts_at_hn/2)) begin
          str_idx1_info = $sformatf("Programmed value of max_num_outstanding_xacts_at_hn_status is %0d. But num_outstanding_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_xact of the initiating RN node must be equal to or greater than half of max_num_outstanding_xacts_at_hn of the target HN", max_num_outstanding_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_1_participating].num_outstanding_xact, initiating_rn_node_idx_1);
          is_supported = 0;
        end
      end
    end 

    if (!is_supported) begin
      str_is_supported_info = $sformatf("%0s%0s",str_idx0_info, str_idx1_info);
      if (is_rn_idx_0_participating && is_rn_idx_1_participating) begin
        issue_is_supported_failure($sformatf("This sequence cannot be run based on the current system configuration.\n\
                                              %0s\n\
                                              %0s \n\
                                              Modify configurations through \n\
                                              svt_chi_system_configuration::num_rn,\n\
                                              svt_chi_node_configuration::is_active,\n\
                                              svt_chi_system_configuration::participating_rn_nodes[]\n\
                                              ", str_is_supported_info_prefix, str_is_supported_info));
      end
      else begin
        issue_is_supported_failure($sformatf("This sequence cannot be run based on the current node configurations of RN%0d and/or RN%0d.\n\
                                              %0s \n\
                                              Modify configurations through \n\
                                              svt_chi_node_configuration::num_outstanding_xact,\n\
                                              svt_chi_node_configuration::num_outstanding_read_xact,\n\
                                              ",str_is_supported_info, initiating_rn_node_idx_0, initiating_rn_node_idx_1));
      end
    end    

    if (!is_target_hn_idx_valid_for_curr_cfg()) begin
      is_supported = 0;
      `svt_xvm_note("is_supported", "not a valid hn_idx based on random_tgt_id_enable for current cfg");
    end

    /** Checking the Spec revision **/
    if(is_supported) begin
      str_is_supported_info_prefix = "This sequence cannot be run based on the current configuration.\n";
      str_is_supported_info = "";

      if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision < svt_chi_node_configuration::ISSUE_E) begin
        is_supported = 0;
        str_is_supported_info = $sformatf("svt_chi_node_configuration::chi_spec_revision is not set to svt_chi_node_configuration::ISSUE_E or later for initiating requester node %0d. Writeevictorevict can only be issued from RN when svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_E or later ", initiating_rn_node_idx_0);
      end else begin
        is_supported = 1;
      end  

      if (!is_supported) begin
        string str_complete_is_supported_info = {str_is_supported_info_prefix, str_is_supported_info, str_is_supported_info_suffix};
        issue_is_supported_failure(str_complete_is_supported_info);
      end
    end
  endfunction : is_supported  

  // -----------------------------------------------------------------------------
  virtual task body();
    /** Queue of addresses, used by the transactions generated */
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0]                    addr_collection_q[$];
    bit seq_is_non_secure_access_q[$];
    int                                                   array_idx;
    int                                                   num_outstanding_xacts_to_generate;
    /** Queue for collecting the Address to send Copyback transactions */
    bit[`SVT_CHI_MAX_ADDR_WIDTH -1:0] rn_f_node_idx_0_copyback_addr_queue[$];                      
    bit[`SVT_CHI_MAX_ADDR_WIDTH -1:0] rn_f_node_idx_1_copyback_addr_queue[$];     
    bit rn_f_node_idx_0_copyback_non_secure_queue[$];                      
    bit rn_f_node_idx_1_copyback_non_secure_queue[$];                      
    /** Queue to collect Unique transaction id's */    
    int txn_id_arr[$];
    
    /** Sub sequences initiated from this sequence */
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq[int];
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq_0[int];
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq_1[int];
    svt_chi_rn_copyback_type_transaction_directed_sequence copyback_seq[int];

    /** Sub Read type transaction directed sequences initiated from this sequence */
    svt_chi_rn_read_type_transaction_directed_sequence read_seq[int];
    svt_chi_rn_read_type_transaction_directed_sequence read_seq_1[int];

    /** Sub MakeReadUnique type transaction directed sequences initiated from this sequence */
    svt_chi_rn_makereadunique_type_transaction_directed_sequence makereadunique_seq[int];
    svt_chi_rn_makereadunique_type_transaction_directed_sequence makereadunique_seq_0[int];
    svt_chi_rn_makereadunique_type_transaction_directed_sequence makereadunique_seq_1[int];

    /** Flag to track whether cache initialization needs to be performed or not*/
    bit perform_cache_initialization;
    string str_node_types = "";
    int unsigned sel_initiating_rn_node_idx_0, sel_initiating_rn_node_index_1; 
    bit rn_is_valid, rn_is_unique,rn_is_clean;
    bit[`SVT_CHI_MAX_ADDR_WIDTH-1:0] txn_address;

    super.body();
    `svt_xvm_debug("body", "Entering ...");

    max_num_outstanding_xacts_at_hn_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(),"max_num_outstanding_xacts_at_hn",max_num_outstanding_xacts_at_hn);
    max_num_outstanding_read_xacts_at_hn_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(),"max_num_outstanding_read_xacts_at_hn",max_num_outstanding_read_xacts_at_hn);
    max_num_outstanding_write_xacts_at_hn_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(),"max_num_outstanding_write_xacts_at_hn",max_num_outstanding_write_xacts_at_hn);
    max_num_outstanding_cmo_xacts_at_hn_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(),"max_num_outstanding_cmo_xacts_at_hn",max_num_outstanding_cmo_xacts_at_hn);

    str_node_types = "Initiating nodes are of RN-F type.";
    cache_line_init_rn_f_node_index = initiating_rn_f_node_index_0;          
    sel_initiating_rn_node_idx_0 = initiating_rn_f_node_index_0;
    sel_initiating_rn_node_index_1 = initiating_rn_f_node_index_1;

    `svt_xvm_debug("body", $sformatf("%0s perform_cache_initialization = %0b. cache_line_init_rn_f_node_index = %0d. sel_initiating_rn_node_idx_0 = %0d.", str_node_types, perform_cache_initialization, cache_line_init_rn_f_node_index, sel_initiating_rn_node_idx_0));
    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :sel_initiating_rn_node_idx_0;
    initiating_rn_node_idx_1 = initiating_rn_node_index_1_status ? initiating_rn_node_index_1_from_config_db :sel_initiating_rn_node_index_1;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_f_node_index_0;

    `svt_xvm_debug("body", $sformatf("max_num_outstanding_xacts_at_hn is %0d as a result of %0s.", max_num_outstanding_xacts_at_hn, max_num_outstanding_xacts_at_hn_status ? "config DB" : "default"));
    `svt_xvm_debug("body", $sformatf("max_num_outstanding_read_xacts_at_hn is %0d as a result of %0s.", max_num_outstanding_read_xacts_at_hn, max_num_outstanding_read_xacts_at_hn_status ? "config DB" : "default"));
    `svt_xvm_debug("body", $sformatf("max_num_outstanding_write_xacts_at_hn is %0d as a result of %0s.", max_num_outstanding_write_xacts_at_hn, max_num_outstanding_write_xacts_at_hn_status ? "config DB" : "default"));
    `svt_xvm_debug("body", $sformatf("max_num_outstanding_cmo_xacts_at_hn is %0d as a result of %0s.", max_num_outstanding_cmo_xacts_at_hn, max_num_outstanding_cmo_xacts_at_hn_status ? "config DB" : "default"));
    `svt_xvm_debug("body", $sformatf("initiating_rn_node_idx_0 is %0d as a result of %0s.", initiating_rn_node_idx_0, initiating_rn_node_index_0_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("target_hn_f_node_index_0 is %0d as a result of %0s.", target_hn_node_idx_0, target_hn_node_index_0_status ? "config DB" : "Randomization")); 

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    //If max outstanding count for MakeReadUnique transactions has been programmed, use that to generate the outstanding MakeReadUniques
    if(max_num_outstanding_read_xacts_at_hn > 0) begin
      num_outstanding_xacts_to_generate = max_num_outstanding_read_xacts_at_hn;
      `svt_xvm_debug("body",$sformatf("max_num_outstanding_read_xacts_at_hn is set to a non-zero value (%0d). Hence, the value programmed in max_num_outstanding_xacts_at_hn will be ignored. The number of outstanding transactions issued by the sequence will be equal to max_num_outstanding_read_xacts_at_hn", max_num_outstanding_read_xacts_at_hn));
    end
    //If not, use the max outstanding transaction count
    else
      num_outstanding_xacts_to_generate = max_num_outstanding_xacts_at_hn;

    /**
     * If the initiating_rn_node_idx_0 is part of active_participating_rn_f_nodes array then we can
     * issue MAKEREADUNIQUE transaction from the RN[initiating_rn_node_idx_0].
     */
    if (!(is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_node_idx_0, array_idx))) begin
       `svt_xvm_error("body", $sformatf("initiating_rn_node_idx_0 should be expected to be active participating RN-F node,but it is not i.e initiating_rn_node_idx_0 = 'h%d",initiating_rn_node_idx_0));
    end

    if (!(is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_node_idx_1, array_idx))) begin
       `svt_xvm_error("body", $sformatf("initiating_rn_node_idx_1 should be expected to be active participating RN-F node,but it is not i.e initiating_rn_node_idx_1 = 'h%d",initiating_rn_node_idx_1));
    end

    for(int i = 0; i < sequence_length; i++) begin
      `svt_xvm_debug("body",$sformatf("Starting cache initialization for %0d addresses from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d", num_outstanding_xacts_to_generate, cache_line_init_rn_f_node_index, target_hn_node_idx_0));

      /** Collecting txn_id */
      if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision >= svt_chi_node_configuration::ISSUE_E) begin
        for(int id=0; id <= `SVT_CHI_SPEC_PERMITTED_MAX_TXNID_VALUE_FOR_ISSUE_E; id++) begin
          txn_id_arr.push_back(id);
        end
      end
      else if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision >= svt_chi_node_configuration::ISSUE_D) begin
        for(int id=0; id <= `SVT_CHI_SPEC_PERMITTED_MAX_TXNID_VALUE_FOR_ISSUE_D; id++) begin
          txn_id_arr.push_back(id);
        end
      end else begin
        for(int id=0; id <= `SVT_CHI_SPEC_PERMITTED_MAX_TXNID_VALUE_UPTO_ISSUE_C; id++) begin
          txn_id_arr.push_back(id);
        end
      end

      /** Shuffling all collected txn_id */
      txn_id_arr.shuffle;

      /** Initiating outstanding MakeUnique transactions from different RN-Fs
       *  to initialise the cache line state to UD state.  
       */
      for (int k=0; k<num_outstanding_xacts_to_generate; k++) begin
        automatic int initiating_rn_index;
        if (k%2)begin
          initiating_rn_index = initiating_rn_node_idx_1;
        end 
        else begin
          initiating_rn_index = initiating_rn_node_idx_0;
        end 

        // Initialize the Makeunique transaction
        `svt_xvm_do_on_with(makeunique_seq[k], p_sequencer.rn_virt_seqr[initiating_rn_index].rn_xact_seqr,{
          sequence_length    == 1;
          hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
          seq_hn_node_idx  == target_hn_node_idx_0;
          use_seq_is_non_secure_access == 0;        
        })
        
        `svt_xvm_debug("body", $sformatf("%0s Waiting for MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) to end %d",`SVT_CHI_PRINT_PREFIX(makeunique_seq[k].write_tran),k, makeunique_seq[k].write_tran.hn_node_idx, makeunique_seq[k].write_tran.tgt_id,num_outstanding_xacts_to_generate));
        // Waiting for current MakeUnique transaction to complete 
        makeunique_seq[k].write_tran.wait_end();

        //Checking if transaction is dropped
        if (makeunique_seq[k].output_xacts[0].is_xact_dropped) begin
          `svt_xvm_debug("body", $sformatf("%0s First set of MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) is Droppped. Re-randomizing the transaction.",`SVT_CHI_PRINT_PREFIX(makeunique_seq[k].write_tran),k, makeunique_seq[k].write_tran.hn_node_idx, makeunique_seq[k].write_tran.tgt_id));
          k--;
        end
        else begin
          if (k%2)begin
            rn_f_node_idx_1_copyback_addr_queue.push_back(makeunique_seq[k].write_tran.addr);
            rn_f_node_idx_1_copyback_non_secure_queue.push_back(makeunique_seq[k].write_tran.is_non_secure_access);
          end 
          else begin
            rn_f_node_idx_0_copyback_addr_queue.push_back(makeunique_seq[k].write_tran.addr);
            rn_f_node_idx_0_copyback_non_secure_queue.push_back(makeunique_seq[k].write_tran.is_non_secure_access);
          end 
          `svt_xvm_debug("body", $sformatf("%0s MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) ended",`SVT_CHI_PRINT_PREFIX(makeunique_seq[k].write_tran),k, makeunique_seq[k].write_tran.hn_node_idx, makeunique_seq[k].write_tran.tgt_id));
          `svt_xvm_verbose("body", $sformatf("MakeUnique transaction [%0d]  is %0s", k,makeunique_seq[k].write_tran.sprint()));
        end //end of else condition of cache state check

        // Initiating the Copyback transaction write the dirty data to main memory
        `svt_xvm_do_on_with(copyback_seq[k], p_sequencer.rn_virt_seqr[initiating_rn_index].rn_xact_seqr,{
          sequence_length    == 1;
          seq_txn_id == makeunique_seq[k].write_tran.txn_id;
          seq_xact_type == svt_chi_transaction::WRITEBACKFULL;
          seq_order_type  == svt_chi_transaction::NO_ORDERING_REQUIRED;
          seq_copyback_req_order_enable == 0;                        
          hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
          min_addr           == makeunique_seq[k].write_tran.addr;
          max_addr           == makeunique_seq[k].write_tran.addr;     
          seq_is_non_secure_access == makeunique_seq[k].write_tran.is_non_secure_access;
          use_seq_is_non_secure_access == 1;        
        })
        
        `svt_xvm_debug("body", $sformatf("%0s Transmitting Copyback Transaction [%0d] targeted to HN (idx %0d, id %0d) ",`SVT_CHI_PRINT_PREFIX(copyback_seq[k].copyback_tran),k, copyback_seq[k].copyback_tran.hn_node_idx, copyback_seq[k].copyback_tran.tgt_id));
        // Waiting for current Copyback transaction to complete 
        copyback_seq[k].copyback_tran.wait_end();

        // Do a READSHARED transaction from initiating_rn_index
        `svt_xvm_do_on_with(read_seq[k], p_sequencer.rn_virt_seqr[initiating_rn_index].rn_xact_seqr,
        {
          sequence_length == 1;
          data_in_cache == makeunique_seq[k].write_tran.data;
          seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
          hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
          min_addr           == makeunique_seq[k].write_tran.addr;
          max_addr           == makeunique_seq[k].write_tran.addr;     
          seq_xact_type      == svt_chi_transaction::READSHARED;
          seq_mem_attr_allocate_hint == makeunique_seq[k].write_tran.mem_attr_allocate_hint;
          seq_snp_attr_snp_domain_type == makeunique_seq[k].write_tran.snp_attr_snp_domain_type;
          seq_is_non_secure_access == makeunique_seq[k].write_tran.is_non_secure_access;
          use_seq_is_non_secure_access == 1;        
        }
        )
        /** Waiting for Read type transaction to complete */ 
        read_seq[k].read_tran.wait_end(); 

        /** Checking the cacheline state as the expected valid state to initiatlize the MAKEREADUNIQUE transaction is SC,SD */ 
        rn_is_valid = get_rn_cache_status(initiating_rn_index, txn_address, rn_is_unique, rn_is_clean);

        //At this point the Cache state is either I, SC, SD.
        //If it is I ,silently moving to Shared state.
        if (!rn_is_valid) begin
          // Do a MAKEUNIQUE transaction from initiating_rn_index
          `svt_xvm_do_on_with(makeunique_seq_1[k], p_sequencer.rn_virt_seqr[initiating_rn_index].rn_xact_seqr,
          {
            sequence_length == 1;
            hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
            min_addr           == makeunique_seq[k].write_tran.addr;
            max_addr           == makeunique_seq[k].write_tran.addr;     
            seq_mem_attr_allocate_hint == makeunique_seq[k].write_tran.mem_attr_allocate_hint;
            seq_snp_attr_snp_domain_type == makeunique_seq[k].write_tran.snp_attr_snp_domain_type;
            seq_is_non_secure_access == makeunique_seq[k].write_tran.is_non_secure_access;
            use_seq_is_non_secure_access == 1;        
          }
          )
          `svt_xvm_debug("body", $sformatf("%0s Waiting for MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) to end %d",`SVT_CHI_PRINT_PREFIX(makeunique_seq_1[k].write_tran),k, makeunique_seq_1[k].write_tran.hn_node_idx, makeunique_seq_1[k].write_tran.tgt_id,num_outstanding_xacts_to_generate));
          // Waiting for current MakeUnique transaction to complete 
          makeunique_seq_1[k].write_tran.wait_end();

          update_cache_status = update_rn_cache_status(initiating_rn_index, makeunique_seq[k].write_tran.addr, 0, -1);
          rn_is_valid = get_rn_cache_status(initiating_rn_index, makeunique_seq[k].write_tran.addr, rn_is_unique, rn_is_clean);
        end        

        if ((!rn_is_valid) || (rn_is_valid && rn_is_unique)) begin
          `svt_error("body", $sformatf("Invalid cache state rn_is_valid = %0d rn_is_unique = %0d ",rn_is_valid,rn_is_unique));
        end        
      end //end of cache initiatlization.

      `svt_xvm_debug("body",$sformatf("Ended cache initialization for %0d addresses from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d",
                                        num_outstanding_xacts_to_generate, cache_line_init_rn_f_node_index, target_hn_node_idx_0));
        
      /** Retriving address from the transactions */
      for(int k=0; k<num_outstanding_xacts_to_generate; k++) begin 
         addr_collection_q.push_back(makeunique_seq[k].output_xacts[0].addr);
         seq_is_non_secure_access_q.push_back(makeunique_seq[k].output_xacts[0].is_non_secure_access);
      end

      `svt_xvm_debug("body",$sformatf("Starting transmission of MakeReadUnique type transactions for %0d addresses from p_sequencer.rn_virt_seqr[%0d] to HN idx %0d with suspend_comp_ack set to 1",num_outstanding_xacts_to_generate, initiating_rn_node_idx_0, target_hn_node_idx_0));

      /** Initiating outstanding MAKEREADUNIQUE transactions from two Random RN-Fs.  
       *  Initial cache line state is:
       *   SC, SD:  svt_chi_transaction::MAKEREADUNIQUE  
       */
        fork
          begin
          /** 
           * Do 128 transactions from two different RNs to all MAKEUNIQUE 
           * transaction address of same HN node
           */ 
            for(int j = 0; j < (num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2); j++) begin
              automatic bit[`SVT_CHI_MAX_ADDR_WIDTH -1:0] txn_addr;                                      
              automatic bit txn_is_non_secure_access;                                      
              automatic bit[(`SVT_CHI_TXN_ID_WIDTH-1):0]txn_id   = txn_id_arr.pop_front();
              txn_addr = rn_f_node_idx_0_copyback_addr_queue.pop_front();
              txn_is_non_secure_access = rn_f_node_idx_0_copyback_non_secure_queue.pop_front();
              `svt_xvm_do_on_with(makereadunique_seq[j], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,{
                sequence_length == 1;
                seq_txn_id == txn_id;
                seq_order_type  == svt_chi_transaction::NO_ORDERING_REQUIRED;
                hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                min_addr           == txn_addr;
                max_addr           == txn_addr;     
                seq_is_non_secure_access == txn_is_non_secure_access;
                use_seq_is_non_secure_access == 1;       
                data_in_cache        == makeunique_seq[j].write_tran.data;
                by_pass_read_data_check == 0;
                seq_xact_type == svt_chi_transaction::MAKEREADUNIQUE;
                })

              `svt_xvm_debug("body", $sformatf("%0s Transmitting MAKEREADUNIQUE Transaction [%0d] targeted to HN (idx %0d, id %0d) ",`SVT_CHI_PRINT_PREFIX(makereadunique_seq[j].makereadunique_tran),j, makereadunique_seq[j].makereadunique_tran.hn_node_idx, makereadunique_seq[j].makereadunique_tran.tgt_id));
              `svt_xvm_verbose("body", $sformatf("MAKEREADUNIQUE Transaction [%0d] is %0s", j,makereadunique_seq[j].makereadunique_tran.sprint()));
            end  
          end  
          begin
            for(int j = 0; j < num_outstanding_xacts_to_generate/2; j++) begin
              automatic bit[`SVT_CHI_MAX_ADDR_WIDTH -1:0] txn_addr;                                      
              automatic bit txn_is_non_secure_access;                                      
              automatic bit[(`SVT_CHI_TXN_ID_WIDTH-1):0]txn_id   = txn_id_arr.pop_front();
              txn_addr = rn_f_node_idx_1_copyback_addr_queue.pop_front();
              txn_is_non_secure_access = rn_f_node_idx_1_copyback_non_secure_queue.pop_front();
              `svt_xvm_do_on_with(makereadunique_seq[((num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2)+j)], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,{
                sequence_length == 1;
                seq_txn_id == txn_id;
                seq_order_type  == svt_chi_transaction::NO_ORDERING_REQUIRED;
                hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                min_addr           == txn_addr;
                max_addr           == txn_addr;     
                seq_is_non_secure_access == txn_is_non_secure_access;
                use_seq_is_non_secure_access == 1;       
 //               seq_copyback_req_order_enable == 0;     
                data_in_cache        == makeunique_seq[((num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2)+j)].write_tran.data;
                by_pass_read_data_check == 0;
                seq_xact_type == svt_chi_transaction::MAKEREADUNIQUE;
                })
              `svt_xvm_debug("body", $sformatf("%0s Transmitting MAKEREADUNIQUE Transaction [%0d] targeted to HN (idx %0d, id %0d) ",`SVT_CHI_PRINT_PREFIX(makereadunique_seq[((num_outstanding_xacts_to_generate/2)+j)].makereadunique_tran),((num_outstanding_xacts_to_generate/2)+j), makereadunique_seq[((num_outstanding_xacts_to_generate/2)+j)].makereadunique_tran.hn_node_idx, makereadunique_seq[((num_outstanding_xacts_to_generate/2)+j)].makereadunique_tran.tgt_id));
              `svt_xvm_verbose("body", $sformatf("MAKEREADUNIQUE Transaction [%0d] is %0s", ((num_outstanding_xacts_to_generate/2)+j),makereadunique_seq[((num_outstanding_xacts_to_generate/2)+j)].makereadunique_tran.sprint()));
            end  
          end  
        join  

      /** Checking for the reception of all the Comp/Compdata from the Interconnect */
      foreach(makereadunique_seq[index_1]) begin
        fork
          automatic int _index_1 = index_1;
          begin
            `svt_xvm_debug("body", $sformatf("%0s Copyback transaction [%0d] targeted to HN (idx %0d, id %0d), suspend_comp_ack %0b: waiting for response from interconnect",`SVT_CHI_PRINT_PREFIX(makereadunique_seq[_index_1].makereadunique_tran),_index_1, makereadunique_seq[_index_1].makereadunique_tran.hn_node_idx, makereadunique_seq[_index_1].makereadunique_tran.tgt_id, makereadunique_seq[_index_1].makereadunique_tran.suspend_comp_ack));
            /** Waiting for either Comp response/Compdata/Retry reponse from the ICN */ 
            fork
            begin
              fork
                begin
                  /** Waiting for either Comp response from the ICN or req_status to be ACCEPT */ 
                  makereadunique_seq[_index_1].makereadunique_tran.wait_for_tx_compack_prereqs();
                end
                begin
                  /** Waiting for Retry response from the ICN or req_status to be RETRY */ 
                  wait(makereadunique_seq[_index_1].makereadunique_tran.req_status == svt_chi_transaction::RETRY);// begin
                end
              join_any
              disable fork;
            end
            join
            received_read_responses++;
            `svt_xvm_debug("body", $sformatf("%0s MakeReadUnique transaction [%0d] targeted to HN (idx %0d, id %0d), suspend_comp_ack %0b: received response from interconnect. Total responses received %0d",`SVT_CHI_PRINT_PREFIX(makereadunique_seq[_index_1].makereadunique_tran),_index_1, makereadunique_seq[_index_1].makereadunique_tran.hn_node_idx, makereadunique_seq[_index_1].makereadunique_tran.tgt_id, makereadunique_seq[_index_1].makereadunique_tran.suspend_comp_ack, received_read_responses));
          end
        join_none  
      end

      /** Wait until All Comp/Compdata responses are received at RN-Fs */
      `svt_xvm_debug("body",$sformatf("Completed initiation of Makereadunique transactions for %0d addresses from p_sequencer.rn_virt_seqr[%0d] and p_sequencer.rn_virt_seqr[%0d] to HN idx %0d with suspend_comp_ack set to 1, and waiting to receive responses from interconnect.",
                                num_outstanding_xacts_to_generate, initiating_rn_node_idx_0, initiating_rn_node_idx_1, target_hn_node_idx_0)); 
      wait(received_read_responses == num_outstanding_xacts_to_generate);
      `svt_xvm_debug("body",$sformatf("Received responses from interconnect to Makereadunique transactions for %0d addresses from p_sequencer.rn_virt_seqr[%0d] and p_sequencer.rn_virt_seqr[%0d] to HN idx %0d with suspend_comp_ack set to 1",
                                      num_outstanding_xacts_to_generate, initiating_rn_node_idx_0, initiating_rn_node_idx_1, target_hn_node_idx_0)); 

      /** Self Check1: To check suspend_comp_ack should not be modified to zero by the VIP
       *  before reseting from test bench.
       */
      foreach (makereadunique_seq[self_check_idx1]) begin
        if(!makereadunique_seq[self_check_idx1].makereadunique_tran.is_terminated()) begin 
          // Checking compack is expected for Makereadunique transactions.      
          if (makereadunique_seq[self_check_idx1].makereadunique_tran.suspend_comp_ack == 0) begin
            `svt_xvm_error("body", $sformatf("%0s suspend_comp_ack should be 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(makereadunique_seq[self_check_idx1].makereadunique_tran)));
          end
          else begin
            `svt_xvm_debug("body", $sformatf("%0s suspend_comp_ack is 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(makereadunique_seq[self_check_idx1].makereadunique_tran)));
          end
        end
      end

      /** Self Check2: To check suspend_comp_ack should not be modified to zero by the VIP 
       *  before reseting from test bench.
       */ 
      foreach (makereadunique_seq[self_check_idx2]) begin
        if(!makereadunique_seq[self_check_idx2].makereadunique_tran.is_terminated()) begin 
          // Checking compack is expected for Makereadunique transactions.      
          /** Pass event is not triggered */
          if (makereadunique_seq[self_check_idx2].makereadunique_tran.end_event.is_on() == 1) begin
            `svt_xvm_error("body", $sformatf("Unexpected: %0s Transaction's end_event triggered when suspend_comp_ack is still 1.", `SVT_CHI_PRINT_PREFIX(makereadunique_seq[self_check_idx2].makereadunique_tran)));
          end
          /** Fail event has triggered */
          else begin
            `svt_xvm_debug("body", $sformatf("Expected: %0s Transaction's end_event is not triggered when suspend_comp_ack is still 1.", `SVT_CHI_PRINT_PREFIX(makereadunique_seq[self_check_idx2].makereadunique_tran)));
          end
        end
      end

      /** Self Check 3: To check that the current_outstanding_*_xact_count in the RNs
       * are as per the transactions inititated by the sequence
       */
      /** Check if the total outstanding xact counter is set correctly in the shared status of the RN agent */
      if(makereadunique_seq[0].shared_status.prot_status.current_outstanding_xact_count != (num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2))
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding transactions from the sequence but the outstanding transaction count in the shared status of RN%0d is %0d", (num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2), initiating_rn_node_idx_0, makereadunique_seq[0].shared_status.prot_status.current_outstanding_xact_count));
      /** Check if the outstanding Read xact counter is set correctly in the shared status of the RN agent */
      if(makereadunique_seq[0].shared_status.prot_status.current_outstanding_read_xact_count != (num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2)) begin
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding Copyback transactions from the sequence but the outstanding Read transaction count in the shared status of RN%0d is %0d", (num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2), initiating_rn_node_idx_0, makereadunique_seq[0].shared_status.prot_status.current_outstanding_read_xact_count));
      end
      /** Check if the total outstanding xact counter is set correctly in the shared status of the RN agent */
      if(makereadunique_seq[(num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2)].shared_status.prot_status.current_outstanding_xact_count != num_outstanding_xacts_to_generate/2)
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding transactions from the sequence but the outstanding transaction count in the shared status of RN%0d is %0d", num_outstanding_xacts_to_generate/2, initiating_rn_node_idx_1, makereadunique_seq[(num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2)].shared_status.prot_status.current_outstanding_xact_count));
      /** Check if the outstanding Write xact counter is set correctly in the shared status of the RN agent */
      if(makereadunique_seq[(num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2)].shared_status.prot_status.current_outstanding_read_xact_count != num_outstanding_xacts_to_generate/2) begin
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding Copyback transactions from the sequence but the outstanding Read transaction count in the shared status of RN%0d is %0d", num_outstanding_xacts_to_generate/2, initiating_rn_node_idx_1, makereadunique_seq[(num_outstanding_xacts_to_generate - num_outstanding_xacts_to_generate/2)].shared_status.prot_status.current_outstanding_read_xact_count));
      end

      `svt_xvm_debug("body", $sformatf("RN%0d: Number of outstanding transactions : %0d, Number of outstanding write xacts : %0d", initiating_rn_node_idx_0, makereadunique_seq[0].shared_status.prot_status.current_outstanding_xact_count, makereadunique_seq[0].shared_status.prot_status.current_outstanding_read_xact_count));
      `svt_xvm_debug("body", $sformatf("RN%0d: Number of outstanding transactions : %0d, Number of outstanding write xacts : %0d", initiating_rn_node_idx_1, makereadunique_seq[1].shared_status.prot_status.current_outstanding_xact_count, makereadunique_seq[1].shared_status.prot_status.current_outstanding_read_xact_count));

      /** Targeted HN IDs from both RN-Fs should be same */
      for(int index_3 = 0; index_3 < num_outstanding_xacts_to_generate/2; index_3++) begin
        int hn_idx_0, hn_idx_1;
        hn_idx_0 = sys_cfg.get_hn_idx(makereadunique_seq[index_3].output_xacts[0].addr);
        hn_idx_1 = sys_cfg.get_hn_idx(makereadunique_seq[((num_outstanding_xacts_to_generate/2) + index_3)].output_xacts[0].addr);
        if ((hn_idx_0 == target_hn_node_idx_0) && (hn_idx_0 == hn_idx_1)) begin
          /** pass */
          `svt_xvm_debug("body", $sformatf("Targeted HN Index from both RNs is same as expected.  rn[%0d] to hn_idx[%0d], rn[%0d] to hn_idx[%0d]", initiating_rn_node_idx_0, hn_idx_0, initiating_rn_node_idx_1, hn_idx_1));
        end
        else begin
          /** fail */
          `svt_xvm_error("body", $sformatf("Targeted HN Index from both RNs is different, which is unexpected.  rn[%0d] %0s transaction to hn_idx[%0d], rn[%0d] %0s transaction to hn_idx[%0d]",initiating_rn_node_idx_0, `SVT_CHI_PRINT_PREFIX( makereadunique_seq[index_3].output_xacts[0]), hn_idx_0, initiating_rn_node_idx_1, `SVT_CHI_PRINT_PREFIX( makereadunique_seq[((num_outstanding_xacts_to_generate/2)+index_3)].output_xacts[0]), hn_idx_1));
        end
      end  

      /** Resuming all Suspended Response of all above Copyback transactions  */
      foreach(makereadunique_seq[wr]) begin
        `svt_xvm_debug("body",$sformatf("Received responses for all Copyback type transactions from interconnect, resuming the transactions by setting svt_chi_rn_transaction::suspend_comp_ack set to 0 %0s",`SVT_CHI_PRINT_PREFIX(makereadunique_seq[wr].makereadunique_tran)));
        makereadunique_seq[wr].makereadunique_tran.suspend_comp_ack=0;
        `svt_xvm_debug("body", $sformatf("For iteration %0d : After Resume, received_read_responses is %0d,suspend_comp_ack is %0b ", wr,received_read_responses,makereadunique_seq[wr].makereadunique_tran.suspend_comp_ack));
      end

      /** Waiting for above copyback outstanding transactions to complete */
      foreach(makereadunique_seq[index_2]) begin
        `svt_xvm_debug("body", $sformatf("Waiting for above makereadunique_seq[%0d] transaction %0s to end", index_2, `SVT_CHI_PRINT_PREFIX(makereadunique_seq[index_2].makereadunique_tran)));
        makereadunique_seq[index_2].makereadunique_tran.wait_end(); 
        
        /** Self Check4: To check suspend_comp_ack should not be asserted after the transaction 
         *  completes as it is reseted from test bench
         */
        if (!makereadunique_seq[index_2].makereadunique_tran.is_terminated()) begin 
          if (makereadunique_seq[index_2].makereadunique_tran.suspend_comp_ack == 1) begin
            `svt_xvm_error("body", $sformatf("%0s suspend_comp_ack should be 0 as it has been reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(makereadunique_seq[index_2].makereadunique_tran)));
          end
          else begin
            `svt_xvm_debug("body", $sformatf("%0s suspend_comp_ack is 0 as it is reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(makereadunique_seq[index_2].makereadunique_tran)));
          end
        end
      end
     
      /** Empty the address and txn_id queues */
      rn_f_node_idx_0_copyback_addr_queue.delete();                      
      rn_f_node_idx_1_copyback_addr_queue.delete();                      
      rn_f_node_idx_0_copyback_non_secure_queue.delete();                      
      rn_f_node_idx_1_copyback_non_secure_queue.delete();                      
      txn_id_arr.delete();
      
      `svt_xvm_debug("body", "Exiting...")

      /** Reset received_read_responses to Zero */
      received_read_responses = 0;

      /** Delete the contents of address collection queue */
      addr_collection_q.delete();

    end //sequence_length
    /** 
     * To check the Interconnect HN Node shall responds to all 
     * outstanding read tranactions to RN.<br>
     * Check done by System monitor(List of checkers)<br>
     *  #- read_data_integrity_check 
     *  #- coherent_and_snoop_data_match_check
     */
 
    `uvm_info("body", "Exiting...", UVM_HIGH)
  endtask: body

  virtual task post_start();
    super.post_start();
    drop_phase_objection();
  endtask
  
endclass: svt_chi_system_protocol_flow_ctrl_makereadunique_outstanding_diff_rn_same_hn_virtual_sequence

function svt_chi_system_protocol_flow_ctrl_makereadunique_outstanding_diff_rn_same_hn_virtual_sequence::new(string name="svt_chi_system_protocol_flow_ctrl_makereadunique_outstanding_diff_rn_same_hn_virtual_sequence");
  super.new(name);
endfunction

//====================================================================================
/**
 * @groupname CHI_OUTSTANDING_RD_TYPE  
 *    #- This sequence requires at least two different HN node to be present in the Interconnect.<br>
 *    #- This sequence requires two initiating active and participating RN.<br>
 *    #- If another active and participating RN-F exists, perform cache<br>
 *       initialization to a randomly selected two different HN's.<br>
 *    #- Initiate maximum number of Read type transactions with<br> 
 *       svt_chi_rn_transaction::suspend_comp_ack set  to 1 from two initiating RN's to randomly<br> 
 *       selected different HN's in non blocking mode. <br>
 *       - This ensures that the maximum outstanding transaction limit is reached at the<br> 
 *         two differernt HN's.<br> 
 *       - Maximum number of outstanding transactions at the HN is as per either #max_num_outstanding_read_xacts_at_hn or
 *         #max_num_outstanding_xacts_at_hn, which can be controlled through config DB.  
 *       - Also, the two different RN will not transmit CompAck corresponding to these transactions<br>
 *       until svt_chi_rn_transaction::suspend_comp_ack is set to 0 from the seqeunce.<br>
 *       .
 *    #- The addresses of these Read transactions are such that:<br>
 *       - Same as initialized cache line addresses if cache initialization is performed<br>
 *       - Otherwise, random addresses targeting the different HN's<br>
 *       .
 *    #- Once the RN receives the responses for all the outstanding transactions from<br>
 *       different HN, svt_chi_rn_transaction::suspend_comp_ack is set to 0 for all the outstanding<br>
 *       transactions. <br>
 *       This ensures that the CompAck for these transactions can be resumed<br> 
 *       from different RN.<br>
 *    #- Check that the different HN responds properly for all outstanding Read type<br>
 *       transactions and these are completed successfully.<br>
 *    #- This sequence requires SVT_CHI_ISSUE_E_ENABLE macro to be defined and
 *       svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_E or later.<br>
 *    .
 *
 */

class svt_chi_system_protocol_flow_ctrl_makereadunique_outstanding_diff_rn_diff_hn_virtual_sequence extends svt_chi_system_base_virtual_sequence;

  //-----------------------------------------------------------------------------  
  // Member attributes
  //-----------------------------------------------------------------------------  
  /** Parameter that controls the enabling of transactions in non-blocking mode from the sequence */
  bit enable_outstanding = 0;

  /** Represents the received read responses */
  int received_read_responses = 0;

  /** To display contents of Active Participating RN's nodes info. */
  string str_node_info;

  /** Represents the received read sequences responses */
  int received_makereadunique_seq_1_responses = 0;
  int received_makereadunique_seq_2_responses = 0;

  /** UVM/OVM Object Utility macro */
  `svt_xvm_object_utils(svt_chi_system_protocol_flow_ctrl_makereadunique_outstanding_diff_rn_diff_hn_virtual_sequence)
  
  //-----------------------------------------------------------------------------  
  // Methods
  //-----------------------------------------------------------------------------
  /** Constructor */
  extern function new(string name="svt_chi_system_protocol_flow_ctrl_makereadunique_outstanding_diff_rn_diff_hn_virtual_sequence"); 
  
  // -----------------------------------------------------------------------------
  virtual task pre_start();
    bit enable_outstanding_status;
    `svt_xvm_debug("pre_start",$sformatf("Entering ..."));
    super.pre_start();
    raise_phase_objection();
    enable_outstanding_status = uvm_config_db#(bit)::get(m_sequencer, get_type_name(), "enable_outstanding", enable_outstanding);
    `svt_xvm_debug("body", $sformatf("enable_outstanding is %0b as a result of %0s", enable_outstanding, (enable_outstanding_status?"config DB":"default setting")));
    `svt_xvm_debug("pre_start",$sformatf("Exiting ..."));
  endtask // pre_start

  // -----------------------------------------------------------------------------
  /** 
   * Function to check if current system configuration meets requirements of this sequence.
   * This sequence requires following configurations
   *  #- minimum supporting RN-F Nodes = 2 
   *  #- minimum supporting HN-F Nodes = 2 
   *  #- svt_chi_node_configuration::chi_spec_revision >= svt_chi_node_configuration::ISSUE_E
   *  .
   */
  virtual function bit is_supported(svt_configuration cfg, bit silent = 0);
    
    /** local variables */
    int num_supporting_rn_f_nodes;
    string str_is_supported_info_prefix = "";
    string str_is_supported_info = "";
    string str_is_supported_info_suffix = "Modify configurations through svt_chi_node_configuration::chi_spec_revision\n";

    /** Supporting Request Nodes required */
    int required_num_supporting_rn_f_nodes = 0;
    int required_num_hn_nodes = 2;
    int num_hn_f_nodes;
    int array_idx;
    string str_idx0_info = "";
    string str_idx1_info = ""; 
    bit    is_rn_idx_0_participating, is_rn_idx_1_participating; 
    `svt_xvm_debug("is_supported",$sformatf("Entering..."));

    /** By default is_supported is 0 */
    is_supported = 0;

    /** Check for minimum required HN-F nodes */
    num_hn_f_nodes = hn_f_nodes.size();
    
    /** Check requirment of number of HN nodes needed */
    if (num_hn_f_nodes < required_num_hn_nodes) begin
      issue_is_supported_failure($sformatf("This sequence requires minimum %0d HN-F nodes to be present in the system. Number of HN-F nodes are %0d. Program number of HN nodes using svt_chi_system_configuration::num_hn. Program the HN interface type using svt_chi_system_configuration::chi_addr_cfg.hn_interface_type[].", required_num_hn_nodes, num_hn_f_nodes));
      return 0;      
    end
    
    /** Set minimum required supporting RN-F nodes */   
    required_num_supporting_rn_f_nodes = 2;

    /** Check for minimum required RN-F nodes. */
    num_supporting_rn_f_nodes = active_participating_rn_f_nodes.size();

    /** Check the requirement of RN-F nodes */
    if (num_supporting_rn_f_nodes) begin
      /** Display the contents of Active Participating RN-F Nodes */
      foreach (active_participating_rn_f_nodes[j]) begin
        str_node_info = {str_node_info, $sformatf(" %0d", active_participating_rn_f_nodes[j])};
      end      
      `svt_xvm_debug("is_supported", $sformatf("contents of active_participating_rn_f_nodes are %0s", str_node_info));
    end
    
    /** Check the required supporting Request Nodes */
    
    str_is_supported_info_prefix = $sformatf("Number of Supporting RN-F Node(s)  - Minimum Required : %0d Current : %0d", required_num_supporting_rn_f_nodes,num_supporting_rn_f_nodes);
    if ((initiating_rn_node_index_0_status==0)&&(valid_initiating_rn_f_node_index_0==0)) begin
        str_idx0_info = "Valid initiating_rn_node_idx_0 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN-Fs that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)";
    end
    else begin
      is_rn_idx_0_participating = is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_node_idx_0, array_idx);
      if (!is_rn_idx_0_participating) begin
        str_idx0_info = $sformatf("initiating_rn_node_idx_0 %0d is not valid for this sequence. The RN-F corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)", initiating_rn_node_idx_0, initiating_rn_node_idx_0);
      end
    end

    if ((initiating_rn_node_index_1_status==0)&&(valid_initiating_rn_f_node_index_1==0)) begin
      str_idx1_info = "Valid initiating_rn_node_idx_1 could not be found for this sequence. Program svt_chi_system_configuration::rn_cfg[] such that there exist RN-Fs that are active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)";
    end 
    else begin
      is_rn_idx_1_participating = is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_node_idx_1, array_idx);
      if (!is_rn_idx_1_participating) begin
        str_idx1_info = $sformatf("initiating_rn_node_idx_1 %0d is not valid for this sequence. The RN-F corresponding to svt_chi_system_configuration::rn_cfg[%0d] should be active(svt_chi_node_configuration::is_active should be 1) and  participating(should be part of the array svt_chi_system_configuyration::participating_rn_nodes[] with svt_chi_node_configuration::chi_interface_type set to svt_chi_node_configuration::RN_F)", initiating_rn_node_idx_1, initiating_rn_node_idx_1);
      end
    end 

    if (is_rn_idx_0_participating && is_rn_idx_1_participating) begin
      is_supported = 1;
      if(max_num_outstanding_read_xacts_at_hn > 0) begin
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].num_outstanding_read_xact < max_num_outstanding_read_xacts_at_hn) begin
          str_idx0_info = $sformatf("Programmed value of max_num_outstanding_read_xacts_at_hn_status is %0d. But num_outstanding_read_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_read_xact of the initiating RN node must be equal to or greater than max_num_outstanding_read_xacts_at_hn_status of the target HN", max_num_outstanding_read_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_0_participating].num_outstanding_read_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].num_outstanding_read_xact < max_num_outstanding_read_xacts_at_hn) begin
          str_idx1_info = $sformatf("Programmed value of max_num_outstanding_read_xacts_at_hn_status is %0d. But num_outstanding_read_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_read_xact of the initiating RN node must be equal to or greater than max_num_outstanding_read_xacts_at_hn_status of the target HN", max_num_outstanding_read_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_1_participating].num_outstanding_read_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
      end else begin
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].num_outstanding_xact < max_num_outstanding_xacts_at_hn) begin
          str_idx0_info = $sformatf("Programmed value of max_num_outstanding_xacts_at_hn_status is %0d. But num_outstanding_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_xact of the initiating RN node must be equal to or greater than max_num_outstanding_xacts_at_hn of the target HN", max_num_outstanding_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_0_participating].num_outstanding_xact, initiating_rn_node_idx_0);
          is_supported = 0;
        end
        if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].num_outstanding_xact < max_num_outstanding_xacts_at_hn) begin
          str_idx1_info = $sformatf("Programmed value of max_num_outstanding_xacts_at_hn_status is %0d. But num_outstanding_xact of initiating RN node, RN%0d is %0d. The value of num_outstanding_xact of the initiating RN node must be equal to or greater than max_num_outstanding_xacts_at_hn of the target HN", max_num_outstanding_xacts_at_hn, sys_cfg.rn_cfg[is_rn_idx_1_participating].num_outstanding_xact, initiating_rn_node_idx_1);
          is_supported = 0;
        end
      end            
    end 

    if (!is_supported) begin
      str_is_supported_info = $sformatf("%0s%0s",str_idx0_info, str_idx1_info);
      if (is_rn_idx_0_participating && is_rn_idx_1_participating) begin
        issue_is_supported_failure($sformatf("This sequence cannot be run based on the current system configuration.\n\
                                              %0s\n\
                                              %0s \n\
                                              Modify configurations through \n\
                                              svt_chi_system_configuration::num_rn,\n\
                                              svt_chi_node_configuration::is_active,\n\
                                              svt_chi_system_configuration::participating_rn_nodes[]\n\
                                              ", str_is_supported_info_prefix, str_is_supported_info));
      end
      else begin
        issue_is_supported_failure($sformatf("This sequence cannot be run based on the current node configurations of RN%0d and/or RN%0d.\n\
                                              %0s \n\
                                              Modify configurations through \n\
                                              svt_chi_node_configuration::num_outstanding_xact,\n\
                                              svt_chi_node_configuration::num_outstanding_read_xact,\n\
                                              ",str_is_supported_info, initiating_rn_node_idx_0, initiating_rn_node_idx_1));
      end
    end    

    if (!is_target_hn_idx_valid_for_curr_cfg()) begin
      is_supported = 0;
      `svt_xvm_note("is_supported", "not a valid hn_idx based on random_tgt_id_enable for current cfg");
    end

        /** Checking the Spec revision **/
    if(is_supported) begin
      str_is_supported_info_prefix = "This sequence cannot be run based on the current configuration.\n";
      str_is_supported_info = "";

      if(sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision < svt_chi_node_configuration::ISSUE_E) begin
        is_supported = 0;
        str_is_supported_info = $sformatf("svt_chi_node_configuration::chi_spec_revision is not set to svt_chi_node_configuration::ISSUE_E or later for initiating requester node %0d. Writeevictorevict can only be issued from RN when svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_E or later ", initiating_rn_node_idx_0);
      end else begin
        is_supported = 1;
      end  

      if (!is_supported) begin
        string str_complete_is_supported_info = {str_is_supported_info_prefix, str_is_supported_info, str_is_supported_info_suffix};
        issue_is_supported_failure(str_complete_is_supported_info);
      end
    end
  endfunction : is_supported  

  // -----------------------------------------------------------------------------
  virtual task body();
    int received_read_responses=0;
    bit rn_is_valid, rn_is_unique,rn_is_clean;
    bit[`SVT_CHI_MAX_ADDR_WIDTH-1:0] txn_address;
    int NUM_OUTSTANDING_XACT;

    /** Setting transaction id width */
    int txn_id_width=`SVT_CHI_TXN_ID_WIDTH;

    /** Queue of RN-F's, intitiating Copyback transactions */
    int initiating_rn_f_node_idx_1_queue[$];
    int initiating_rn_f_node_idx_0_queue[$];

    /** Queue of addresses, used by the transactions generated */
    bit[`SVT_CHI_MAX_ADDR_WIDTH -1:0] rn_f_node_idx_0_copyback_addr_queue[$];                      
    bit[`SVT_CHI_MAX_ADDR_WIDTH -1:0] rn_f_node_idx_1_copyback_addr_queue[$];                      
    bit rn_f_node_idx_0_copyback_non_secure_queue[$];                      
    bit rn_f_node_idx_1_copyback_non_secure_queue[$];                      


    /** Queue of Unique transaction id's, used by the transactions generated */
    int rn_f_node_idx_0_txn_id_queue[$];
    int rn_f_node_idx_1_txn_id_queue[$];

    /** Sub Read type transaction cache initialization directed sequences initiated from this sequence */
    svt_chi_rn_read_type_transaction_directed_sequence read_seq[int];

    /** Sub MakeReadunique transaction directed sequences initiated from this sequence */
    svt_chi_rn_makereadunique_type_transaction_directed_sequence makereadunique_seq[int];

    /** Queue of addresses, used by the transactions generated */
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0]                    addr_collection_queue1[$];
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0]                    addr_collection_queue2[$];
    bit seq_is_non_secure_access_queue1[$];
    bit seq_is_non_secure_access_queue2[$];
    int                                                   array_idx;
    int                                                   num_outstanding_xacts_to_generate;

    /** Sub sequences initiated from this sequence */
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq[int];
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq_0[int];
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq_1[int];

    /** Sub CopyBack type transaction directed sequences initiated from this sequence */
    svt_chi_rn_copyback_type_transaction_directed_sequence copyback_seq[int];

    /** Sub Read type transaction directed sequences initiated from this sequence */
    svt_chi_rn_read_type_transaction_directed_sequence read_seq_0[int];
    svt_chi_rn_read_type_transaction_directed_sequence read_seq_1[int];

    /** Sub MakeReadUnique type transaction directed sequences initiated from this sequence */
    svt_chi_rn_makereadunique_type_transaction_directed_sequence makereadunique_seq_2[int];
    svt_chi_rn_makereadunique_type_transaction_directed_sequence makereadunique_seq_1[int];

    /** Flag to track whether cache initialization needs to be performed or not*/
    string str_node_types = "";
    int unsigned sel_initiating_rn_node_idx_0, sel_initiating_rn_node_index_1; 

    /** Represents the RN node indices which are used by the sequence 
     *  to initiate the transactions.
     *  cacheline_initiating_rn_node_idx is applicable for only makereadunique transactions
     *  so that cacheline state can be moved to SC state by issueing a READSHARED transaction from this node index.
     */
    int unsigned cacheline_initiating_rn_node_idx;

    super.body();
    `svt_xvm_debug("body", "Entering ...");

    max_num_outstanding_xacts_at_hn_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(),"max_num_outstanding_xacts_at_hn",max_num_outstanding_xacts_at_hn);
    max_num_outstanding_read_xacts_at_hn_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(),"max_num_outstanding_read_xacts_at_hn",max_num_outstanding_read_xacts_at_hn);
    max_num_outstanding_write_xacts_at_hn_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(),"max_num_outstanding_write_xacts_at_hn",max_num_outstanding_write_xacts_at_hn);
    max_num_outstanding_cmo_xacts_at_hn_status = svt_config_int_db#(int unsigned)::get(null, get_full_name(),"max_num_outstanding_cmo_xacts_at_hn",max_num_outstanding_cmo_xacts_at_hn);

    str_node_types = "Initiating nodes are of RN-F type.";
    sel_initiating_rn_node_idx_0 = initiating_rn_f_node_index_0;
    sel_initiating_rn_node_index_1 = initiating_rn_f_node_index_1;

    `svt_xvm_debug("body", $sformatf("%0s sel_initiating_rn_node_idx_0 = %0d.", str_node_types, sel_initiating_rn_node_idx_0));
    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :sel_initiating_rn_node_idx_0;
    initiating_rn_node_idx_1 = initiating_rn_node_index_1_status ? initiating_rn_node_index_1_from_config_db :sel_initiating_rn_node_index_1;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_f_node_index_0;
    target_hn_node_idx_1 = target_hn_node_index_1_status ? target_hn_node_index_1_from_config_db :target_hn_f_node_index_1;

    `svt_xvm_debug("body", $sformatf("max_num_outstanding_xacts_at_hn is %0d as a result of %0s.", max_num_outstanding_xacts_at_hn, max_num_outstanding_xacts_at_hn_status ? "config DB" : "default"));
    `svt_xvm_debug("body", $sformatf("max_num_outstanding_read_xacts_at_hn is %0d as a result of %0s.", max_num_outstanding_read_xacts_at_hn, max_num_outstanding_read_xacts_at_hn_status ? "config DB" : "default"));
    `svt_xvm_debug("body", $sformatf("max_num_outstanding_write_xacts_at_hn is %0d as a result of %0s.", max_num_outstanding_write_xacts_at_hn, max_num_outstanding_write_xacts_at_hn_status ? "config DB" : "default"));
    `svt_xvm_debug("body", $sformatf("max_num_outstanding_cmo_xacts_at_hn is %0d as a result of %0s.", max_num_outstanding_cmo_xacts_at_hn, max_num_outstanding_cmo_xacts_at_hn_status ? "config DB" : "default"));
    `svt_xvm_debug("body", $sformatf("initiating_rn_node_idx_0 is %0d as a result of %0s.", initiating_rn_node_idx_0, initiating_rn_node_index_0_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("initiating_rn_node_idx_1 is %0d as a result of %0s.", initiating_rn_node_idx_1, initiating_rn_node_index_1_status ? "config DB" : "Randomization"));
    `svt_xvm_debug("body", $sformatf("target_hn_f_node_index_0 is %0d as a result of %0s.", target_hn_node_idx_0, target_hn_node_index_0_status ? "config DB" : "Randomization")); 
    `svt_xvm_debug("body", $sformatf("target_hn_node_idx_1 is %0d as a result of %0s.", target_hn_node_idx_1, target_hn_node_index_1_status ? "config DB" : "Randomization"));  

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    //If max outstanding count for MakeReadUnique transactions has been programmed, use that to generate the outstanding MakeReadUniques
    if(max_num_outstanding_read_xacts_at_hn > 0) begin
      num_outstanding_xacts_to_generate = max_num_outstanding_read_xacts_at_hn;
      `svt_xvm_debug("body",$sformatf("max_num_outstanding_read_xacts_at_hn is set to a non-zero value (%0d). Hence, the value programmed in max_num_outstanding_xacts_at_hn will be ignored. The number of outstanding transactions issued by the sequence will be equal to max_num_outstanding_read_xacts_at_hn", max_num_outstanding_read_xacts_at_hn));
    end
    //If not, use the max outstanding transaction count
    else
      num_outstanding_xacts_to_generate = max_num_outstanding_xacts_at_hn;

    /**
     * If the initiating_rn_node_idx_0 is part of active_participating_rn_f_nodes array then we can
     * issue MAKEREADUNIQUE transaction from the RN[initiating_rn_node_idx_0].
     */
    if (!(is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_node_idx_0, array_idx))) begin
       `svt_xvm_error("body", $sformatf("initiating_rn_node_idx_0 should be expected to be active participating RN-F node,but it is not i.e initiating_rn_node_idx_0 = 'h%d",initiating_rn_node_idx_0));
    end

    if (!(is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_node_idx_1, array_idx))) begin
       `svt_xvm_error("body", $sformatf("initiating_rn_node_idx_1 should be expected to be active participating RN-F node,but it is not i.e initiating_rn_node_idx_1 = 'h%d",initiating_rn_node_idx_1));
    end

    //If max outstanding count for read transactions has been programmed, use that to generate the outstanding MakeReadUnique
    if(max_num_outstanding_read_xacts_at_hn > 0) begin
      NUM_OUTSTANDING_XACT = (max_num_outstanding_read_xacts_at_hn * 2);
      `svt_xvm_debug("body",$sformatf("max_num_outstanding_read_xacts_at_hn is set to a non-zero value (%0d). Hence, the value programmed in max_num_outstanding_xacts_at_hn will be ignored. The number of outstanding transactions issued by the sequence will be equal to max_num_outstanding_read_xacts_at_hn", max_num_outstanding_read_xacts_at_hn));
    end
    else
      NUM_OUTSTANDING_XACT = (max_num_outstanding_xacts_at_hn * 2);
    `svt_xvm_debug("body", $sformatf("Number of NUM_OUTSTANDING_XACT is %0d",NUM_OUTSTANDING_XACT));

    for(int i = 0; i < sequence_length; i++) begin
      /** Collecting txn_id */
      if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision >= svt_chi_node_configuration::ISSUE_E) begin
        for(int id=0; id <= `SVT_CHI_SPEC_PERMITTED_MAX_TXNID_VALUE_FOR_ISSUE_E; id++) begin
          rn_f_node_idx_0_txn_id_queue.push_back(id);
        end
      end
      else if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision >= svt_chi_node_configuration::ISSUE_D) begin
        for(int id=0; id <= `SVT_CHI_SPEC_PERMITTED_MAX_TXNID_VALUE_FOR_ISSUE_D; id++) begin
          rn_f_node_idx_0_txn_id_queue.push_back(id);
        end
      end else begin
        for(int id=0; id <= `SVT_CHI_SPEC_PERMITTED_MAX_TXNID_VALUE_UPTO_ISSUE_C; id++) begin
          rn_f_node_idx_0_txn_id_queue.push_back(id);
        end
      end
      if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision >= svt_chi_node_configuration::ISSUE_E) begin
        for(int id=0; id <= `SVT_CHI_SPEC_PERMITTED_MAX_TXNID_VALUE_FOR_ISSUE_E; id++) begin
          rn_f_node_idx_1_txn_id_queue.push_back(id);
        end
      end
      else if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision >= svt_chi_node_configuration::ISSUE_D) begin
        for(int id=0; id <= `SVT_CHI_SPEC_PERMITTED_MAX_TXNID_VALUE_FOR_ISSUE_D; id++) begin
          rn_f_node_idx_1_txn_id_queue.push_back(id);
        end
      end else begin
        for(int id=0; id <= `SVT_CHI_SPEC_PERMITTED_MAX_TXNID_VALUE_UPTO_ISSUE_C; id++) begin
          rn_f_node_idx_1_txn_id_queue.push_back(id);
        end
      end

      /** Shuffling all collected txn_id */
      rn_f_node_idx_0_txn_id_queue.shuffle;
      rn_f_node_idx_1_txn_id_queue.shuffle;

      /** Initiating outstanding MakeUnique transactions followed by Wribackfull followed by 
       *  Readshared from different RN-Fs
       *  to initialise the cache line state to SC or SD state and for below transaction.  
       *  MAKEREADUNIQUE.
       */
      for(int l=0; l<NUM_OUTSTANDING_XACT ; l++) begin
        automatic int initiating_rn_index;
        
        if (l%2)begin
          initiating_rn_index = initiating_rn_node_idx_1;
          initiating_rn_f_node_idx_1_queue.push_back(initiating_rn_index);
        end 
        else begin
          initiating_rn_index = initiating_rn_node_idx_0;
          initiating_rn_f_node_idx_0_queue.push_back(initiating_rn_index);
        end 

        `svt_xvm_do_on_with(makeunique_seq_0[l], p_sequencer.rn_virt_seqr[initiating_rn_index].rn_xact_seqr,{
          sequence_length    == 1;
          hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
          use_seq_is_non_secure_access == 0;
          if(l == 0)
          {
            seq_hn_node_idx    == target_hn_node_idx_0;                                        
          }
          else if (l < NUM_OUTSTANDING_XACT/4)
          {
            seq_hn_node_idx == makeunique_seq_0[0].seq_hn_node_idx;                                   
          }
          else if (l == NUM_OUTSTANDING_XACT/4)
          {
            seq_hn_node_idx    == target_hn_node_idx_1;                                        
          }
          else if (l < NUM_OUTSTANDING_XACT/2)
          {
            seq_hn_node_idx == makeunique_seq_0[NUM_OUTSTANDING_XACT/4].seq_hn_node_idx;                                   
          }
          else if ((l >= NUM_OUTSTANDING_XACT/2) && (l < NUM_OUTSTANDING_XACT*3/4))
          {
            seq_hn_node_idx == makeunique_seq_0[0].seq_hn_node_idx;                                   
          }
          else
          {
            seq_hn_node_idx == makeunique_seq_0[NUM_OUTSTANDING_XACT/4].seq_hn_node_idx;                                   
          }
        })
        
        /** Retrieving 512 addresses from output transactions generated by the sequence  */
        if (l%2)begin
          rn_f_node_idx_1_copyback_addr_queue.push_back(makeunique_seq_0[l].write_tran.addr);
          rn_f_node_idx_1_copyback_non_secure_queue.push_back(makeunique_seq_0[l].write_tran.is_non_secure_access);
        end 
        else begin
          rn_f_node_idx_0_copyback_addr_queue.push_back(makeunique_seq_0[l].write_tran.addr);
          rn_f_node_idx_0_copyback_non_secure_queue.push_back(makeunique_seq_0[l].write_tran.is_non_secure_access);
        end 

        `svt_xvm_debug("body", $sformatf("%0s Waiting for MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) to end",`SVT_CHI_PRINT_PREFIX(makeunique_seq_0[l].write_tran),l, makeunique_seq_0[l].write_tran.hn_node_idx, makeunique_seq_0[l].write_tran.tgt_id));
        makeunique_seq_0[l].write_tran.wait_end(); 
        `svt_xvm_debug("body", $sformatf("%0s MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) ended",`SVT_CHI_PRINT_PREFIX(makeunique_seq_0[l].write_tran),l, makeunique_seq_0[l].write_tran.hn_node_idx, makeunique_seq_0[l].write_tran.tgt_id));

        // Initiating the Copyback transaction write the dirty data to main memory
        `svt_xvm_do_on_with(copyback_seq[l], p_sequencer.rn_virt_seqr[initiating_rn_index].rn_xact_seqr,{
          sequence_length    == 1;
          seq_txn_id == makeunique_seq_0[l].write_tran.txn_id;
          seq_xact_type == svt_chi_transaction::WRITEBACKFULL;
          seq_order_type  == svt_chi_transaction::NO_ORDERING_REQUIRED;
          seq_copyback_req_order_enable == 0;                        
          hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
          min_addr           == makeunique_seq_0[l].write_tran.addr;
          max_addr           == makeunique_seq_0[l].write_tran.addr;     
          seq_is_non_secure_access == makeunique_seq_0[l].write_tran.is_non_secure_access;
          use_seq_is_non_secure_access == 1;        
        })
        
        `svt_xvm_debug("body", $sformatf("%0s Transmitting Copyback Transaction [%0d] targeted to HN (idx %0d, id %0d) ",`SVT_CHI_PRINT_PREFIX(copyback_seq[l].copyback_tran),l, copyback_seq[l].copyback_tran.hn_node_idx, copyback_seq[l].copyback_tran.tgt_id));

        // Waiting for current Copyback transaction to complete 
        copyback_seq[l].copyback_tran.wait_end();

        // Do a READCLEAN transaction from initiating_rn_index
        `svt_xvm_do_on_with(read_seq[l], p_sequencer.rn_virt_seqr[initiating_rn_index].rn_xact_seqr,
        {
          sequence_length == 1;
          data_in_cache == makeunique_seq_0[l].write_tran.data;
          seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
          hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
          min_addr           == makeunique_seq_0[l].write_tran.addr;
          max_addr           == makeunique_seq_0[l].write_tran.addr;     
          seq_xact_type      == svt_chi_transaction::READSHARED;
          seq_mem_attr_allocate_hint == makeunique_seq_0[l].write_tran.mem_attr_allocate_hint;
          seq_snp_attr_snp_domain_type == makeunique_seq_0[l].write_tran.snp_attr_snp_domain_type;
          seq_is_non_secure_access == makeunique_seq_0[l].write_tran.is_non_secure_access;
          use_seq_is_non_secure_access == 1;        
        }
        )
        `svt_xvm_debug("body", $sformatf("%0s Transmitting Read Transaction [%0d] targeted to HN (idx %0d, id %0d) ",`SVT_CHI_PRINT_PREFIX(read_seq[l].read_tran),l, read_seq[l].read_tran.hn_node_idx, read_seq[l].read_tran.tgt_id));

        /** Waiting for Read type transaction to complete */ 
        read_seq[l].read_tran.wait_end(); 
        txn_address = read_seq[l].read_tran.addr;

        /** Checking the cacheline state as the expected valid state to initiatlize the MAKEREADUNIQUE transaction is SC,SD */ 
        rn_is_valid = get_rn_cache_status(initiating_rn_index, txn_address, rn_is_unique, rn_is_clean);

        //At this point the Cache state is either I, SC, SD.
        //If it is I ,silently moving to Shared state.
        if (!rn_is_valid) begin
          // Do a MAKEUNIQUE transaction from initiating_rn_index
          `svt_xvm_do_on_with(makeunique_seq_1[l], p_sequencer.rn_virt_seqr[initiating_rn_index].rn_xact_seqr,
          {
            sequence_length == 1;
            hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
            min_addr           == makeunique_seq_0[l].write_tran.addr;
            max_addr           == makeunique_seq_0[l].write_tran.addr;     
            seq_mem_attr_allocate_hint == makeunique_seq_0[l].write_tran.mem_attr_allocate_hint;
            seq_snp_attr_snp_domain_type == makeunique_seq_0[l].write_tran.snp_attr_snp_domain_type;
            seq_is_non_secure_access == makeunique_seq_0[l].write_tran.is_non_secure_access;
            use_seq_is_non_secure_access == 1;        
          }
          )
          `svt_xvm_debug("body", $sformatf("%0s Waiting for MakeUnique transaction [%0d] targeted to HN (idx %0d, id %0d) to end %d",`SVT_CHI_PRINT_PREFIX(makeunique_seq_1[l].write_tran),l, makeunique_seq_1[l].write_tran.hn_node_idx, makeunique_seq_1[l].write_tran.tgt_id,num_outstanding_xacts_to_generate));
          // Waiting for current MakeUnique transaction to complete 
          makeunique_seq_1[l].write_tran.wait_end();

          update_cache_status = update_rn_cache_status(initiating_rn_index, makeunique_seq_0[l].write_tran.addr, 0, -1);
          rn_is_valid = get_rn_cache_status(initiating_rn_index, makeunique_seq_0[l].write_tran.addr, rn_is_unique, rn_is_clean);
        end        
        //If final cache state is Unique after ReadShared, silently move to shared state
        else if (rn_is_valid && rn_is_unique) begin
          update_cache_status = update_rn_cache_status(initiating_rn_index, read_seq[l].read_tran.addr, 0, -1);
          rn_is_valid = get_rn_cache_status(initiating_rn_index, read_seq[l].read_tran.addr, rn_is_unique, rn_is_clean);
        end

        if ((!rn_is_valid) || (rn_is_valid && rn_is_unique)) begin
          `svt_error("body", $sformatf("Invalid cache state rn_is_valid = %0d rn_is_unique = %0d ",rn_is_valid,rn_is_unique));
        end
      end //forloop of 512 MakeUnique follewed by Writebackfull followed by READSHARED.

      /** Initiating outstanding Makereadunique transactions from different Random RN-F.  
       *  Initial cache line state is:
       *   SC, SD : svt_chi_transaction::MAKEREADUNIQUE  
       */
      for(int j = 0; j < NUM_OUTSTANDING_XACT/2; j++) begin
        automatic int initiating_rn_index;

        fork
          begin
            automatic bit[`SVT_CHI_MAX_ADDR_WIDTH -1:0] txn_addr;                                      
            automatic bit txn_is_non_secure_access;
            automatic bit[(`SVT_CHI_TXN_ID_WIDTH-1):0]txn_id;
            txn_addr = rn_f_node_idx_1_copyback_addr_queue.pop_front();
            txn_is_non_secure_access = rn_f_node_idx_1_copyback_non_secure_queue.pop_front();
            txn_id = rn_f_node_idx_1_txn_id_queue.pop_front();
            
            `svt_xvm_do_on_with(makereadunique_seq[j], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,{
                sequence_length == 1;
                seq_txn_id == txn_id;
                seq_order_type  == svt_chi_transaction::NO_ORDERING_REQUIRED;
                hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
                min_addr           == txn_addr;
                max_addr           == txn_addr;     
                seq_is_non_secure_access == txn_is_non_secure_access;
                use_seq_is_non_secure_access == 1;       
                data_in_cache        == makeunique_seq_0[j].write_tran.data;
                by_pass_read_data_check == 0;
                seq_xact_type == svt_chi_transaction::MAKEREADUNIQUE;
              })
            `svt_xvm_debug("body", $sformatf("%0s Transmitting MAKEREADUNIQUE Transaction [%0d] targeted to HN (idx %0d, id %0d)",`SVT_CHI_PRINT_PREFIX(makereadunique_seq[j].makereadunique_tran),j, makereadunique_seq[j].makereadunique_tran.hn_node_idx, makereadunique_seq[j].makereadunique_tran.tgt_id));
            `svt_xvm_verbose("body", $sformatf("MAKEREADUNIQUE Transaction [%0d] is %0s", j,makereadunique_seq[j].makereadunique_tran.sprint()));
        end//begin
          begin
            automatic bit[`SVT_CHI_MAX_ADDR_WIDTH -1:0] txn_addr;                                      
            automatic bit txn_is_non_secure_access;
            automatic bit[(`SVT_CHI_TXN_ID_WIDTH-1):0]txn_id;
            txn_addr = rn_f_node_idx_0_copyback_addr_queue.pop_front();
            txn_is_non_secure_access = rn_f_node_idx_0_copyback_non_secure_queue.pop_front();
            txn_id = rn_f_node_idx_0_txn_id_queue.pop_front();
            `svt_xvm_do_on_with(makereadunique_seq[((NUM_OUTSTANDING_XACT/2) + j)], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,{
              sequence_length == 1;
              seq_txn_id == txn_id;
              seq_order_type  == svt_chi_transaction::NO_ORDERING_REQUIRED;
              hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
              min_addr           == txn_addr;
              max_addr           == txn_addr;     
              seq_is_non_secure_access == txn_is_non_secure_access;
              use_seq_is_non_secure_access == 1;       
              data_in_cache        == makeunique_seq_0[((NUM_OUTSTANDING_XACT/2) + j)].write_tran.data;
              by_pass_read_data_check == 0;
              seq_xact_type == svt_chi_transaction::MAKEREADUNIQUE;
              })
            `svt_xvm_debug("body", $sformatf("%0s Transmitting MAKEREADUNIQUE Transaction [%0d] targeted to HN (idx %0d, id %0d)",`SVT_CHI_PRINT_PREFIX(makereadunique_seq[((NUM_OUTSTANDING_XACT/2) + j)].makereadunique_tran),((NUM_OUTSTANDING_XACT/2) + j), makereadunique_seq[((NUM_OUTSTANDING_XACT/2) + j)].makereadunique_tran.hn_node_idx, makereadunique_seq[((NUM_OUTSTANDING_XACT/2) + j)].makereadunique_tran.tgt_id));
            `svt_xvm_verbose("body", $sformatf("MAKEREADUNIQUE Transaction [%0d] is %0s", ((NUM_OUTSTANDING_XACT/2) + j),makereadunique_seq[((NUM_OUTSTANDING_XACT/2) + j)].makereadunique_tran.sprint()));
          end//begin
        join       
      end//forloop of MakeReadUnique

      /** Checking for the reception of all the CompData/Comp from the Interconnect */
      foreach(makereadunique_seq[index_1]) begin
        fork
            automatic int _index_1 = index_1;
          begin
          `svt_xvm_debug("body", $sformatf("%0s MakeReadUnique transaction [%0d] targeted to HN (idx %0d, id %0d), suspend_comp_ack %0b: waiting for response from interconnect",`SVT_CHI_PRINT_PREFIX(makereadunique_seq[_index_1].makereadunique_tran),_index_1, makereadunique_seq[_index_1].makereadunique_tran.hn_node_idx, makereadunique_seq[_index_1].makereadunique_tran.tgt_id,makereadunique_seq[_index_1].makereadunique_tran.suspend_comp_ack));
            
            //Wait until a CompData/Comp/RetryAck is received for the generated MakeReadUnique transactions
            fork
            begin
              fork
                begin
                  /** Waiting for either Comp response from the ICN or req_status to be ACCEPT */ 
                  makereadunique_seq[_index_1].makereadunique_tran.wait_for_tx_compack_prereqs();
                end
                begin
                  /** Waiting for Retry response from the ICN or req_status to be RETRY */ 
                  wait(makereadunique_seq[_index_1].makereadunique_tran.req_status == svt_chi_transaction::RETRY);
                end
              join_any
              disable fork;
            end
            join
            received_read_responses++;
            
            `svt_xvm_debug("body", $sformatf("%0s MakeReadUnique transaction [%0d] targeted to HN (idx %0d, id %0d), suspend_comp_ack %0b: waiting for response from interconnect. Total responses received %0d",`SVT_CHI_PRINT_PREFIX(makereadunique_seq[_index_1].makereadunique_tran),_index_1, makereadunique_seq[_index_1].makereadunique_tran.hn_node_idx, makereadunique_seq[_index_1].makereadunique_tran.tgt_id, makereadunique_seq[_index_1].makereadunique_tran.suspend_comp_ack, received_read_responses));
          end
        join_none  
      end
     
      `svt_xvm_debug("body", $sformatf(" Waiting for the CompData/Comp from HN to Resume the Suspended Response of MakeReadUnique transactions "));
      /** Waiting for the CompData/Comp from HN to Resume the Suspended Response of all above MakeReadUnique transactions */ 
      wait(received_read_responses == NUM_OUTSTANDING_XACT); 
      
      /** Self Check1: To check suspend_comp_ack should not be modified to zero by the VIP
       *  before reseting from test bench.
       */
      foreach (makereadunique_seq[self_check_idx1]) begin
        if(!makereadunique_seq[self_check_idx1].makereadunique_tran.is_terminated()) begin 
          if (makereadunique_seq[self_check_idx1].makereadunique_tran.suspend_comp_ack == 0) begin
            `svt_xvm_error("body", $sformatf("%0s suspend_comp_ack should be 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(makereadunique_seq[self_check_idx1].makereadunique_tran)));
          end
          else begin
            `svt_xvm_debug("body", $sformatf("%0s suspend_comp_ack is 1 as it's not yet reset from the sequence.", `SVT_CHI_PRINT_PREFIX(makereadunique_seq[self_check_idx1].makereadunique_tran)));
          end
        end  
      end

      /** Self Check2: To check transaction is not ended by the VIP before resuming the 
       *  suspend_comp_ack to zero from the test bench<br>
       */
      foreach (makereadunique_seq[self_check_idx2]) begin
        if(!makereadunique_seq[self_check_idx2].makereadunique_tran.is_terminated()) begin 
          /** Fail  event has triggered */
          if (makereadunique_seq[self_check_idx2].makereadunique_tran.end_event.is_on() == 1) begin
            `svt_xvm_error("body", $sformatf("Unexpected: %0s Transaction's end_event triggered when suspend_comp_ack is still 1.", `SVT_CHI_PRINT_PREFIX(makereadunique_seq[self_check_idx2].makereadunique_tran)));
          end
          /** Pass  event is not triggered */
          else begin
            `svt_xvm_debug("body", $sformatf("Expected: %0s Transaction's end_event is not triggered when suspend_comp_ack is still 1.", `SVT_CHI_PRINT_PREFIX(makereadunique_seq[self_check_idx2].makereadunique_tran)));
          end
        end
      end
 
      /** Self Check 3: To check that the current_outstanding_*_xact_count in the RNs
       * are as per the transactions inititated by the sequence
       */
      /** Check if the total outstanding xact counter is set correctly in the shared status of the RN agent */
      if(makereadunique_seq[0].shared_status.prot_status.current_outstanding_xact_count != NUM_OUTSTANDING_XACT/2)
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding transactions from the sequence but the outstanding transaction count in the shared status of RN%0d is %0d", NUM_OUTSTANDING_XACT/2, initiating_rn_node_idx_0, makereadunique_seq[0].shared_status.prot_status.current_outstanding_xact_count));
      /** Check if the outstanding MakeReadUnique xact counter is set correctly in the shared status of the RN agent */
      if(makereadunique_seq[0].shared_status.prot_status.current_outstanding_read_xact_count != NUM_OUTSTANDING_XACT/2) begin
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding MakeReadUnique transactions from the sequence but the outstanding read transaction count in the shared status of RN%0d is %0d", NUM_OUTSTANDING_XACT/2, initiating_rn_node_idx_0, makereadunique_seq[0].shared_status.prot_status.current_outstanding_read_xact_count));
      end
      /** Check if the total outstanding xact counter is set correctly in the shared status of the RN agent */
      if(makereadunique_seq[1].shared_status.prot_status.current_outstanding_xact_count != NUM_OUTSTANDING_XACT/2)
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding transactions from the sequence but the outstanding transaction count in the shared status of RN%0d is %0d", NUM_OUTSTANDING_XACT/2, initiating_rn_node_idx_1, makereadunique_seq[1].shared_status.prot_status.current_outstanding_xact_count));
      /** Check if the outstanding Read xact counter is set correctly in the shared status of the RN agent */
      if(makereadunique_seq[1].shared_status.prot_status.current_outstanding_read_xact_count != NUM_OUTSTANDING_XACT/2) begin
        `svt_xvm_error("body", $sformatf("Issued %0d outstanding MakeReadUnique transactions from the sequence but the outstanding Read transaction count in the shared status of RN%0d is %0d", NUM_OUTSTANDING_XACT/2, initiating_rn_node_idx_1, makereadunique_seq[1].shared_status.prot_status.current_outstanding_read_xact_count));
      end

      `svt_xvm_debug("body", $sformatf("RN%0d: Number of outstanding transactions : %0d, Number of outstanding read xacts : %0d", initiating_rn_node_idx_0, makereadunique_seq[0].shared_status.prot_status.current_outstanding_xact_count, makereadunique_seq[0].shared_status.prot_status.current_outstanding_read_xact_count));
      `svt_xvm_debug("body", $sformatf("RN%0d: Number of outstanding transactions : %0d, Number of outstanding read xacts : %0d", initiating_rn_node_idx_1, makereadunique_seq[1].shared_status.prot_status.current_outstanding_xact_count, makereadunique_seq[1].shared_status.prot_status.current_outstanding_read_xact_count));

      /** Resuming the Suspended Response of all above MakeReadUnique transactions  */
      foreach(makereadunique_seq[wr]) begin
        `svt_xvm_debug("body",$sformatf("Received responses for all MakeReadUnique transactions from interconnect, resuming the transactions by setting svt_chi_rn_transaction::suspend_comp_ack set to 0 %0s",`SVT_CHI_PRINT_PREFIX(makereadunique_seq[wr].makereadunique_tran)));
        makereadunique_seq[wr].makereadunique_tran.suspend_comp_ack=0; 
        `svt_xvm_debug("body", $sformatf("For iteration %0d : After Resume, received_read_responses is %0d,suspend_comp_ack is %0b", wr,received_read_responses,makereadunique_seq[wr].makereadunique_tran.suspend_comp_ack));
      end

      `svt_xvm_debug("body",$sformatf("Waiting for completion of all the outstanding MakeReadUnique type transactions"));
      /** Waiting for above MakeReadUnique outstanding transactions to complete */ 
      foreach(makereadunique_seq[index_5]) begin
        `svt_xvm_debug("body", $sformatf("Waiting for above MakeReadUnique[%0d] transaction %0s to end", index_5, `SVT_CHI_PRINT_PREFIX(makereadunique_seq[index_5].makereadunique_tran)));
        makereadunique_seq[index_5].makereadunique_tran.wait_end(); 

        /** Self Check4: To check suspend_comp_ack should not be asserted after
         * the transaction completes as it is reseted from test bench
         */
        if(!makereadunique_seq[index_5].makereadunique_tran.is_terminated()) begin 
          if (makereadunique_seq[index_5].makereadunique_tran.suspend_comp_ack == 1) begin
            `svt_xvm_error("body", $sformatf("%0s suspend_comp_ack  should be 0 as it should be reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(makereadunique_seq[index_5].makereadunique_tran)));
          end
          else begin
            `svt_xvm_debug("body", $sformatf("%0s suspend_comp_ack is 0 as it is reset from test bench before the transaction is complete.", `SVT_CHI_PRINT_PREFIX(makereadunique_seq[index_5].makereadunique_tran)));
          end
        end
      end

      // Targetted HN IDs from both RNs should be different. This check is currently enabled only when
      // the number of outstanding transactions to be issued to an HN is a multiple of 4,ie, NUM_OUTSTANDING_XACT is a multiple of 8
      if((NUM_OUTSTANDING_XACT % 8) == 0) begin
        for(int i = 0; i<NUM_OUTSTANDING_XACT/2; i++)begin
          int hn_idx_0, hn_idx_1;
          hn_idx_0 = sys_cfg.get_hn_idx(makereadunique_seq[i].output_xacts[0].addr);
          hn_idx_1 = sys_cfg.get_hn_idx(makereadunique_seq[(NUM_OUTSTANDING_XACT/2) + i].output_xacts[0].addr);
          if((i < NUM_OUTSTANDING_XACT/8) || ((i >= NUM_OUTSTANDING_XACT/4) && (i < 3*NUM_OUTSTANDING_XACT/8))) begin
            if ((hn_idx_0 == hn_idx_1) && (hn_idx_0 == target_hn_node_idx_0)) begin
              `svt_xvm_debug("body", $sformatf("Targeted HN Index from both RNs are same as expected.  rn[%0d] to hn_idx[%0d], rn[%0d] to hn_idx[%0d] and they match with the target_hn_node_idx_0 %0d", initiating_rn_node_idx_0, hn_idx_0, initiating_rn_node_idx_1, hn_idx_1,target_hn_node_idx_0));
            end
            else begin
              `svt_xvm_error("body", $sformatf("Targeted HN Index from one or both of the RNs are different from first target node index, which is unexpected.  rn[%0d] %0s transaction to hn_idx[%0d], rn[%0d] %0s transaction to hn_idx[%0d] and the target_hn_node_idx_0 is %0d", initiating_rn_node_idx_0, `SVT_CHI_PRINT_PREFIX(makereadunique_seq[2*i].output_xacts[0]), hn_idx_0, initiating_rn_node_idx_1, `SVT_CHI_PRINT_PREFIX( makereadunique_seq[2*i + 1].output_xacts[0]), hn_idx_1,target_hn_node_idx_0));
            end
          end
          else if((i < NUM_OUTSTANDING_XACT/4) || ((i >= 3*NUM_OUTSTANDING_XACT/8) && (i < NUM_OUTSTANDING_XACT/2))) begin
            if ((hn_idx_0 == hn_idx_1) && (hn_idx_0 == target_hn_node_idx_1)) begin
              `svt_xvm_debug("body", $sformatf("Targeted HN Index from both RNs are same as expected.  rn[%0d] to hn_idx[%0d], rn[%0d] to hn_idx[%0d] and they match with the target_hn_node_idx_1 %0d", initiating_rn_node_idx_0, hn_idx_0, initiating_rn_node_idx_1, hn_idx_1,target_hn_node_idx_1));
            end
            else begin
              `svt_xvm_error("body", $sformatf("Targeted HN Index from one or both of the RNs are different from first target node index, which is unexpected.  rn[%0d] %0s transaction to hn_idx[%0d], rn[%0d] %0s transaction to hn_idx[%0d] and the target_hn_node_idx_1 is %0d", initiating_rn_node_idx_0,`SVT_CHI_PRINT_PREFIX(makereadunique_seq[2*i].output_xacts[0]),hn_idx_0, initiating_rn_node_idx_1, `SVT_CHI_PRINT_PREFIX(makereadunique_seq[2*i + 1].output_xacts[0]),hn_idx_1,target_hn_node_idx_1));
            end
          end
        end
      end

      /** Empty the address ,RN-F's and txn_id queues */
      rn_f_node_idx_0_copyback_addr_queue.delete();
      rn_f_node_idx_1_copyback_addr_queue.delete();
      rn_f_node_idx_0_copyback_non_secure_queue.delete();
      rn_f_node_idx_1_copyback_non_secure_queue.delete();
      rn_f_node_idx_0_txn_id_queue.delete();
      rn_f_node_idx_1_txn_id_queue.delete();    
      initiating_rn_f_node_idx_1_queue.delete();  
      initiating_rn_f_node_idx_0_queue.delete();

      /** Reset received_read_responses to Zero */
      received_read_responses = 0;

    end//forloop of sequence_length

    /** 
     * To check the Interconnect HN Node shall responds to all 
     * outstanding read tranactions to RN.<br>
     * Check done by System monitor(List of checkers)<br>
     *  #- read_data_integrity_check 
     *  #- coherent_and_snoop_data_match_check
     */
 
    `uvm_info("body", "Exiting...", UVM_HIGH)
  endtask: body

  virtual task post_start();
    super.post_start();
    drop_phase_objection();
  endtask
  
endclass: svt_chi_system_protocol_flow_ctrl_makereadunique_outstanding_diff_rn_diff_hn_virtual_sequence

function svt_chi_system_protocol_flow_ctrl_makereadunique_outstanding_diff_rn_diff_hn_virtual_sequence::new(string name="svt_chi_system_protocol_flow_ctrl_makereadunique_outstanding_diff_rn_diff_hn_virtual_sequence");
  super.new(name);
endfunction


/**
 * @groupname CHI_SYS_HAZARD
 *   #- This sequence provides a scenario to test how components handle various hazard conditions
 *      applicable for read and write transactions.<br>
 *   #- Send MAKEUNIQUE transaction to random address from random RN.<br>
 *   #- Send WRITEBACKFULL transaction to the same address from same RN.<br>
 *   #- Send READSHARED transaction to the same address from same or differnet RN so the cacheline state is moved to SC state.<br>
 *   #- After the cache initialization we can program the RN's to initiate the hazard transactions accordingly.<br>
 *   #- Send MAKEREADUNIQUE type of transaction to the same address from the RN having the cachelinestate in SC state.<br>
 *   #- Send Write type of transaction to the same address from a different RN.<br>
 *   #- Check the order in which the two requests are processed by HN.<br>
 *   #- This sequence requires SVT_CHI_ISSUE_E_ENABLE macro to be defined and
 *      svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_E or later.<br>
 *   .
 *
 */
class svt_chi_system_protocol_flow_ctrl_hn_makereadunique_write_hazard_directed_virtual_sequence extends svt_chi_system_protocol_flow_ctrl_xact_hazard_virtual_sequence;

  /** Parameter that controls the number of transactions that will be generated */
  rand int unsigned sequence_length = 10;

  rand bit enable_outstanding = 0;

  bit enable_outstanding_status = 0;

  /** Constrain the sequence length to a reasonable value */
  constraint reasonable_sequence_length {
    sequence_length <= 100;
  }

  /** UVM Object Utility macro */
  `uvm_object_utils(svt_chi_system_protocol_flow_ctrl_hn_makereadunique_write_hazard_directed_virtual_sequence)

  extern function new(string name="svt_chi_system_protocol_flow_ctrl_hn_makereadunique_write_hazard_directed_virtual_sequence"); 

  virtual task pre_body();
    raise_phase_objection();
  endtask
  
  virtual task body();
    bit                           status;
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0] txn_address;
    bit [`SVT_CHI_MAX_DATA_WIDTH -1:0] txn_data;
    bit txn_mem_attr_allocate_hint, txn_snp_attr_snp_domain_type, txn_is_non_secure_access;
    int array_idx;

    /** Sub sequences initiated from this sequence */
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq_0, makeunique_seq_1;
    svt_chi_rn_copyback_type_transaction_directed_sequence copyback_seq_0;
    svt_chi_rn_read_type_transaction_directed_sequence readshared_seq_0;

    /** Sub MakeReadUnique type transaction directed sequences initiated from this sequence */
    svt_chi_rn_makereadunique_type_transaction_directed_sequence makereadunique_seq[int];
    svt_chi_rn_write_type_transaction_directed_sequence write_seq_0[int];

    `uvm_info("body", "Entered ...", UVM_HIGH)
    require_issue_e_chi_spec_revision = 1;

    super.body();
    // Default
    enable_outstanding = 0;
    status = uvm_config_db #(int unsigned)::get(null, get_full_name(), "sequence_length", sequence_length);
    `uvm_info("body", $sformatf("sequence_length is %0d as a result of %0s.", sequence_length, status ? "config DB" : "randomization"), UVM_HIGH);

    enable_outstanding_status = uvm_config_db#(bit)::get(m_sequencer, get_type_name(), "enable_outstanding", enable_outstanding);
    `uvm_info("body", $sformatf("enable_outstanding is %0b as a result of %0s", enable_outstanding, (enable_outstanding_status?"config DB":"default setting")), UVM_HIGH);

    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :initiating_rn_f_node_index_0;
    initiating_rn_node_idx_1 = initiating_rn_node_index_1_status ? initiating_rn_node_index_1_from_config_db :initiating_rn_f_node_index_1;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_f_node_index_0;

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /**
     * If the initiating_rn_node_idx_0 is part of active_participating_rn_f_nodes array then we can
     * issue MAKEREADUNIQUE transaction from the RN[initiating_rn_node_idx_0].
     */
    if (!(is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_node_idx_0, array_idx))) begin
       `svt_xvm_error("body", $sformatf("initiating_rn_node_idx_0 should be expected to be active participating RN-F node,but it is not i.e initiating_rn_node_idx_0 = 'h%d",initiating_rn_node_idx_0));
    end

    /**
     * If the initiating_rn_node_idx_1 is part of active_participating_rn_f_nodes array then we can
     * issue WRITE type transaction from the RN[initiating_rn_node_idx_1].
     */
    if (!(is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_node_idx_1, array_idx))) begin
       `svt_xvm_error("body", $sformatf("initiating_rn_node_idx_1 should be expected to be active participating RN-F node,but it is not i.e initiating_rn_node_idx_1 = 'h%d",initiating_rn_node_idx_1));
    end

    str_initiating_rn_node_indices = "";
    /** Display the contents of Active Participating RN-F Nodes */
    foreach (active_participating_rn_f_nodes[j]) begin
      str_initiating_rn_node_indices = {str_initiating_rn_node_indices, $sformatf(" %0d", active_participating_rn_f_nodes[j])};
    end 
    str_initiating_rn_node_indices = {str_initiating_rn_node_indices, $sformatf("\n RN nodes used to initiate the transactions are initiating_rn_node_idx_0 : %0d, initiating_rn_node_idx_1 : %0d", initiating_rn_node_idx_0, initiating_rn_node_idx_1)};
    `svt_xvm_debug("body", $sformatf("contents of active_participating_rn_f_nodes and RN nodes used to initiate the transactions are %0s", str_initiating_rn_node_indices));

    for(int i = 0; i < sequence_length; i++) begin

      /** Write data into Cache of Randomly selected first RN with address of randomly selected HN Node */
      `svt_xvm_do_on_with(makeunique_seq_0, p_sequencer.rn_virt_seqr[cache_initializing_rn_node_index].rn_xact_seqr,
      {
        sequence_length == 1;
        hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
        seq_hn_node_idx == target_hn_node_idx_0;
        use_seq_is_non_secure_access == 0;
      })

      /** Wait for MakeUnique transactions to finish */ 
      makeunique_seq_0.write_tran.wait_end();
      txn_address = makeunique_seq_0.output_xacts[0].addr;
      txn_data = makeunique_seq_0.data_in_cache;
      txn_mem_attr_allocate_hint = makeunique_seq_0.output_xacts[0].mem_attr_allocate_hint;
      txn_snp_attr_snp_domain_type = makeunique_seq_0.output_xacts[0].snp_attr_snp_domain_type;
      txn_is_non_secure_access = makeunique_seq_0.output_xacts[0].is_non_secure_access;

      /** Writeback the data to the main memory at the respective address. */ 
      `svt_xvm_do_on_with(copyback_seq_0, p_sequencer.rn_virt_seqr[cache_initializing_rn_node_index].rn_xact_seqr,
      {
        sequence_length == 1;
        data_in_cache == txn_data;
        seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
        hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
        min_addr == txn_address;
        max_addr == txn_address;
        seq_xact_type == svt_chi_transaction::WRITEBACKFULL;
        seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
        seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
        seq_is_non_secure_access == txn_is_non_secure_access;
        use_seq_is_non_secure_access == 1;               
      }
      )
      /** Waiting for copyback transaction to complete */ 
      copyback_seq_0.copyback_tran.wait_end();

      `svt_xvm_do_on_with(readshared_seq_0, p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
      {
        sequence_length == 1;
        seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
        hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
        min_addr           == txn_address;
        max_addr           == txn_address;
        seq_is_non_secure_access   == txn_is_non_secure_access; 
        seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
        seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
        use_seq_is_non_secure_access == 1;
        data_in_cache == makeunique_seq_0.data_in_cache;
        by_pass_read_data_check == 0;
        seq_xact_type == svt_chi_transaction::READSHARED;
      }
      )
      readshared_seq_0.read_tran.wait_end();

      txn_address = readshared_seq_0.read_tran.addr;

      /** Checking the cacheline state as the expected valid state to initiatlize the MAKEREADUNIQUE transaction is SC,SD */ 
      rn0_is_valid = get_rn_cache_status(initiating_rn_node_idx_0, txn_address, rn0_is_unique, rn0_is_clean);

      //At this point the Cache state is either I, SC, SD.
      //If it is I ,silently moving to Shared state.
      if (!rn0_is_valid) begin
        // Do a MAKEUNIQUE transaction from initiating_rn_node_idx_0
        `svt_xvm_do_on_with(makeunique_seq_1, p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
        {
          sequence_length == 1;
          hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
          min_addr           == txn_address;
          max_addr           == txn_address;     
          seq_mem_attr_allocate_hint == makeunique_seq_0.write_tran.mem_attr_allocate_hint;
          seq_snp_attr_snp_domain_type == makeunique_seq_0.write_tran.snp_attr_snp_domain_type;
          seq_is_non_secure_access == makeunique_seq_0.write_tran.is_non_secure_access;
          use_seq_is_non_secure_access == 1;        
        }
        )
        `svt_xvm_debug("body", $sformatf("%0s Waiting for MakeUnique transaction targeted to HN (idx %0d, id %0d) to end",`SVT_CHI_PRINT_PREFIX(makeunique_seq_1.write_tran), makeunique_seq_1.write_tran.hn_node_idx, makeunique_seq_1.write_tran.tgt_id));
        // Waiting for current MakeUnique transaction to complete 
        makeunique_seq_1.write_tran.wait_end();

        update_cache_status = update_rn_cache_status(initiating_rn_node_idx_0, makeunique_seq_0.write_tran.addr, 0, -1);
        rn0_is_valid = get_rn_cache_status(initiating_rn_node_idx_0, makeunique_seq_0.write_tran.addr, rn0_is_unique, rn0_is_clean);
      end        

      /* MAKEREADUNIQUE-WRITE hazard at HN **/
      fork 
        begin      
`ifndef SVT_CHI_ENABLE_MULTI_CLOCK
          @ (posedge sys_cfg.chi_if.clk);
`else
          @ (posedge sys_cfg.chi_if.rn_clk[initiating_rn_node_idx_0]);
`endif          
          xact_hazard_sema_0.get();
          /** Initiate a read type transaction from initiating_rn_node_idx_0 to txn_address. */ 
          `svt_xvm_do_on_with(makereadunique_seq[i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
          {
            sequence_length == 1;
            seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
            hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
            min_addr          == txn_address;
            max_addr          == txn_address;
            use_seq_is_non_secure_access == 1;
            data_in_cache == makeunique_seq_0.data_in_cache;
            by_pass_read_data_check == 0;
            seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
            seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
            seq_is_non_secure_access == txn_is_non_secure_access;
            seq_xact_type == svt_chi_transaction::MAKEREADUNIQUE;
          }
          )
          xact_hazard_sema_0.put();
          /** Waiting for Read type transaction to complete */ 
          makereadunique_seq[i].makereadunique_tran.wait_end(); 
        end
        begin
`ifndef SVT_CHI_ENABLE_MULTI_CLOCK
          @ (posedge sys_cfg.chi_if.clk);
`else
          @ (posedge sys_cfg.chi_if.rn_clk[initiating_rn_node_idx_1]);
`endif          
          xact_hazard_sema_1.get();
          /** Initiate a write type transaction from initiating_rn_node_idx_1 to txn_address. */ 
          `svt_xvm_do_on_with(write_seq_0[i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,
            {
            `ifdef SVT_CHI_ISSUE_E_ENABLE
             if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision == svt_chi_node_configuration::ISSUE_A ){
               seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL};
             }            
             else if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision >= svt_chi_node_configuration::ISSUE_E ) {
               if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 0) {
                 seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEZERO, svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL};
               }   
               else if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 1){
                 seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEZERO, svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL, svt_chi_transaction::WRITEUNIQUEFULLSTASH, svt_chi_transaction::WRITEUNIQUEPTLSTASH};
               }        
             }
             else if ((sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision < svt_chi_node_configuration::ISSUE_E ) && (sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision > svt_chi_node_configuration::ISSUE_A )){
               if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 0) {
                 seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL};
               }
               else if (sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 1) {
                 seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL, svt_chi_transaction::WRITEUNIQUEFULLSTASH, svt_chi_transaction::WRITEUNIQUEPTLSTASH};
               }
             }
            `elsif SVT_CHI_ISSUE_B_ENABLE
             if(sys_cfg.rn_cfg[initiating_rn_node_idx_1].chi_spec_revision == svt_chi_node_configuration::ISSUE_A || sys_cfg.rn_cfg[initiating_rn_node_idx_1].cache_stashing_enable == 0) {
               seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL};
             }
             else{
               seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL, svt_chi_transaction::WRITEUNIQUEFULLSTASH, svt_chi_transaction::WRITEUNIQUEPTLSTASH};
             }
            `else
               seq_xact_type inside {svt_chi_transaction::WRITEUNIQUEFULL, svt_chi_transaction::WRITEUNIQUEPTL};
            `endif
             sequence_length               == 1;
             seq_order_type   != svt_chi_transaction::NO_ORDERING_REQUIRED;
             hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
             min_addr          == txn_address;
             max_addr          == txn_address;
             seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
             seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
             seq_is_non_secure_access == txn_is_non_secure_access;
             use_seq_is_non_secure_access == 1;               
            }
          )
          xact_hazard_sema_1.put();
          /** Wait for write type transactions to finish */ 
          write_seq_0[i].write_tran.wait_end();
        end
      join
    end

    `uvm_info("body", "Exiting...", UVM_HIGH)
  endtask: body

  virtual task post_body();
    drop_phase_objection();
  endtask

endclass: svt_chi_system_protocol_flow_ctrl_hn_makereadunique_write_hazard_directed_virtual_sequence

function svt_chi_system_protocol_flow_ctrl_hn_makereadunique_write_hazard_directed_virtual_sequence::new(string name="svt_chi_system_protocol_flow_ctrl_hn_makereadunique_write_hazard_directed_virtual_sequence");
  super.new(name);
endfunction

/**
 * @groupname CHI_SYS_HAZARD
 *   #- This sequence provides a scenario to test how components handle various hazard conditions
 *      applicable for read and write transactions.<br>
 *   #- Send MAKEUNIQUE transaction to random address from random RN.<br>
 *   #- Send WRITEBACKFULL transaction to the same address from same RN.<br>
 *   #- Send READSHARED transaction to the same address from same or differnet RN so the cacheline state is moved to SC state.<br>
 *   #- After the cache initialization we can program the RN's to initiate the hazard transactions accordingly.<br>
 *   #- Send MAKEREADUNIQUE type of transaction to the same address from the RN having the cachelinestate in SC state.<br>
 *   #- Send Read type of transaction to the same address from a different RN.<br>
 *   #- Check the order in which the two requests are processed by HN.<br>
 *   #- This sequence requires SVT_CHI_ISSUE_E_ENABLE macro to be defined and
 *      svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_E or later.<br>
 *   .
 *
 */

class svt_chi_system_protocol_flow_ctrl_hn_makereadunique_read_hazard_directed_virtual_sequence extends svt_chi_system_protocol_flow_ctrl_xact_hazard_virtual_sequence;

  /** Parameter that controls the number of transactions that will be generated */
  rand int unsigned sequence_length = 10;

  rand bit enable_outstanding = 0;

  bit enable_outstanding_status = 0;

  /** Constrain the sequence length to a reasonable value */
  constraint reasonable_sequence_length {
    sequence_length <= 100;
  }

  /** UVM Object Utility macro */
  `uvm_object_utils(svt_chi_system_protocol_flow_ctrl_hn_makereadunique_read_hazard_directed_virtual_sequence)

  extern function new(string name="svt_chi_system_protocol_flow_ctrl_hn_makereadunique_read_hazard_directed_virtual_sequence"); 

  virtual task pre_body();
    raise_phase_objection();
  endtask
 
  virtual task body();
    bit                           status;
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0] txn_address;
    bit [`SVT_CHI_MAX_DATA_WIDTH -1:0] txn_data;
    bit txn_mem_attr_allocate_hint, txn_snp_attr_snp_domain_type, txn_is_non_secure_access;
    int array_idx;

    /** Sub sequences initiated from this sequence */
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq_0, makeunique_seq_1;
    svt_chi_rn_copyback_type_transaction_directed_sequence copyback_seq_0;
    svt_chi_rn_read_type_transaction_directed_sequence readshared_seq;

    /** Sub MakeReadUnique type transaction directed sequences initiated from this sequence */
    svt_chi_rn_makereadunique_type_transaction_directed_sequence makereadunique_seq[int];
    svt_chi_rn_read_type_transaction_directed_sequence read_seq_0[int];

    `uvm_info("body", "Entered ...", UVM_HIGH)
    require_issue_e_chi_spec_revision = 1;

    super.body();
    // Default
    enable_outstanding = 0;
    status = uvm_config_db #(int unsigned)::get(null, get_full_name(), "sequence_length", sequence_length);
    `uvm_info("body", $sformatf("sequence_length is %0d as a result of %0s.", sequence_length, status ? "config DB" : "randomization"), UVM_HIGH);

    enable_outstanding_status = uvm_config_db#(bit)::get(m_sequencer, get_type_name(), "enable_outstanding", enable_outstanding);
    `uvm_info("body", $sformatf("enable_outstanding is %0b as a result of %0s", enable_outstanding, (enable_outstanding_status?"config DB":"default setting")), UVM_HIGH);

    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :initiating_rn_f_node_index_0;
    initiating_rn_node_idx_1 = initiating_rn_node_index_1_status ? initiating_rn_node_index_1_from_config_db :initiating_rn_f_node_index_1;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_f_node_index_0;

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /**
     * If the initiating_rn_node_idx_0 is part of active_participating_rn_f_nodes array then we can
     * issue MAKEREADUNIQUE transaction from the RN[initiating_rn_node_idx_0].
     */
    if (!(is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_node_idx_0, array_idx))) begin
       `svt_xvm_error("body", $sformatf("initiating_rn_node_idx_0 should be expected to be active participating RN-F node,but it is not i.e initiating_rn_node_idx_0 = 'h%d",initiating_rn_node_idx_0));
    end

    /**
     * If the initiating_rn_node_idx_1 is part of active_participating_rn_f_nodes array then we can
     * issue READ TYPE transaction from the RN[initiating_rn_node_idx_1].
     */
    if (!(is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_node_idx_1, array_idx))) begin
       `svt_xvm_error("body", $sformatf("initiating_rn_node_idx_1 should be expected to be active participating RN-F node,but it is not i.e initiating_rn_node_idx_1 = 'h%d",initiating_rn_node_idx_1));
    end

    str_initiating_rn_node_indices = "";
    /** Display the contents of Active Participating RN-F Nodes */
    foreach (active_participating_rn_f_nodes[j]) begin
      str_initiating_rn_node_indices = {str_initiating_rn_node_indices, $sformatf(" %0d", active_participating_rn_f_nodes[j])};
    end 

    str_initiating_rn_node_indices = {str_initiating_rn_node_indices, $sformatf("\n RN nodes used to initiate the transactions are initiating_rn_node_idx_0 : %0d, initiating_rn_node_idx_1 : %0d", initiating_rn_node_idx_0, initiating_rn_node_idx_1)};
    `svt_xvm_debug("body", $sformatf("contents of active_participating_rn_f_nodes and RN nodes used to initiate the transactions are %0s", str_initiating_rn_node_indices));

    for(int i = 0; i < sequence_length; i++) begin

      /** Write data into Cache of Randomly selected first RN with address of randomly selected HN Node */
      `svt_xvm_do_on_with(makeunique_seq_0, p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
      {
        sequence_length == 1;
        hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
        seq_hn_node_idx == target_hn_node_idx_0;
        use_seq_is_non_secure_access == 0;
      })

      /** Wait for MakeUnique transactions to finish */ 
      makeunique_seq_0.write_tran.wait_end();
      txn_address = makeunique_seq_0.output_xacts[0].addr;
      txn_data = makeunique_seq_0.data_in_cache;
      txn_mem_attr_allocate_hint = makeunique_seq_0.output_xacts[0].mem_attr_allocate_hint;
      txn_snp_attr_snp_domain_type = makeunique_seq_0.output_xacts[0].snp_attr_snp_domain_type;
      txn_is_non_secure_access = makeunique_seq_0.output_xacts[0].is_non_secure_access;

      /** Writeback the data to the main memory at the respective address. */ 
      `svt_xvm_do_on_with(copyback_seq_0, p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
      {
        sequence_length == 1;
        data_in_cache == txn_data;
        seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
        hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
        min_addr == txn_address;
        max_addr == txn_address;
        seq_xact_type == svt_chi_transaction::WRITEBACKFULL;
        seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
        seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
        seq_is_non_secure_access == txn_is_non_secure_access;
        use_seq_is_non_secure_access == 1;               
      }
      )
      /** Waiting for copyback transaction to complete */ 
      copyback_seq_0.copyback_tran.wait_end();

      `svt_xvm_do_on_with(readshared_seq, p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
      {
        sequence_length == 1;
        seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
        hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
        min_addr           == txn_address;
        max_addr           == txn_address;
        seq_is_non_secure_access   == txn_is_non_secure_access; 
        seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
        seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
        use_seq_is_non_secure_access == 1;
        data_in_cache == makeunique_seq_0.data_in_cache;
        by_pass_read_data_check == 0;
        seq_xact_type == svt_chi_transaction::READSHARED;
      }
      )
      readshared_seq.read_tran.wait_end();

      txn_address = readshared_seq.read_tran.addr;

      /** Checking the cacheline state as the expected valid state to initiatlize the MAKEREADUNIQUE transaction is SC,SD */ 
      rn0_is_valid = get_rn_cache_status(initiating_rn_node_idx_0, txn_address, rn0_is_unique, rn0_is_clean);

      //At this point the Cache state is either I, SC, SD.
      //If it is I ,silently moving to Shared state.
      if (!rn0_is_valid) begin
        // Do a MAKEUNIQUE transaction from initiating_rn_node_idx_0
        `svt_xvm_do_on_with(makeunique_seq_1, p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
        {
          sequence_length == 1;
          hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
          min_addr           == txn_address;
          max_addr           == txn_address;     
          seq_mem_attr_allocate_hint == makeunique_seq_0.write_tran.mem_attr_allocate_hint;
          seq_snp_attr_snp_domain_type == makeunique_seq_0.write_tran.snp_attr_snp_domain_type;
          seq_is_non_secure_access == makeunique_seq_0.write_tran.is_non_secure_access;
          use_seq_is_non_secure_access == 1;        
        }
        )
        `svt_xvm_debug("body", $sformatf("%0s Waiting for MakeUnique transaction targeted to HN (idx %0d, id %0d) to end",`SVT_CHI_PRINT_PREFIX(makeunique_seq_1.write_tran), makeunique_seq_1.write_tran.hn_node_idx, makeunique_seq_1.write_tran.tgt_id));
        // Waiting for current MakeUnique transaction to complete 
        makeunique_seq_1.write_tran.wait_end();

        update_cache_status = update_rn_cache_status(initiating_rn_node_idx_0, makeunique_seq_0.write_tran.addr, 0, -1);
        rn0_is_valid = get_rn_cache_status(initiating_rn_node_idx_0, makeunique_seq_0.write_tran.addr, rn0_is_unique, rn0_is_clean);
      end        

      /* MAKEREADUNIQUE-READ hazard at HN **/
      fork 
        begin      
`ifndef SVT_CHI_ENABLE_MULTI_CLOCK
          @ (posedge sys_cfg.chi_if.clk);
`else
          @ (posedge sys_cfg.chi_if.rn_clk[initiating_rn_node_idx_0]);
`endif          
          xact_hazard_sema_0.get();
          /** Initiate a read type transaction from initiating_rn_node_idx_0 to txn_address. */ 
          `svt_xvm_do_on_with(makereadunique_seq[i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
          {
            sequence_length == 1;
            seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
            hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
            min_addr          == txn_address;
            max_addr          == txn_address;
            use_seq_is_non_secure_access == 1;
            data_in_cache == makeunique_seq_0.data_in_cache;
            by_pass_read_data_check == 0;
            seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
            seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
            seq_is_non_secure_access == txn_is_non_secure_access;
            seq_xact_type == svt_chi_transaction::MAKEREADUNIQUE;
          }
          )
          xact_hazard_sema_0.put();
          /** Waiting for Read type transaction to complete */ 
          makereadunique_seq[i].makereadunique_tran.wait_end(); 
        end
        begin
`ifndef SVT_CHI_ENABLE_MULTI_CLOCK
          @ (posedge sys_cfg.chi_if.clk);
`else
          @ (posedge sys_cfg.chi_if.rn_clk[initiating_rn_node_idx_1]);
`endif          
          xact_hazard_sema_1.get();
          /** Initiate a read type transaction from initiating_rn_node_idx_1 to txn_address. */ 
          `svt_xvm_do_on_with(read_seq_0[i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,
          {
            sequence_length == 1;
            data_in_cache == txn_data;
            seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
            hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
            min_addr == txn_address;
            max_addr == txn_address;
            by_pass_read_data_check == 1;
            seq_xact_type != svt_chi_transaction::READNOSNP;
            seq_xact_type != svt_chi_transaction::CLEANUNIQUE;
            seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
            seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
            seq_is_non_secure_access == txn_is_non_secure_access;
            use_seq_is_non_secure_access == 1;               
            if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type != svt_chi_transaction::READNOTSHAREDDIRTY;
            if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A || sys_cfg.readspec_enable == 0) seq_xact_type != svt_chi_transaction::READSPEC;
            if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type != svt_chi_transaction::READONCECLEANINVALID;
            if (sys_cfg.rn_cfg[initiating_rn_node_idx_0].chi_spec_revision == svt_chi_node_configuration::ISSUE_A) seq_xact_type != svt_chi_transaction::READONCEMAKEINVALID;
          }
          )
          xact_hazard_sema_1.put();
          /** Waiting for Read type transaction to complete */ 
          read_seq_0[i].read_tran.wait_end(); 
        end
      join
    end

    `uvm_info("body", "Exiting...", UVM_HIGH)
  endtask: body

  virtual task post_body();
    drop_phase_objection();
  endtask

endclass: svt_chi_system_protocol_flow_ctrl_hn_makereadunique_read_hazard_directed_virtual_sequence

function svt_chi_system_protocol_flow_ctrl_hn_makereadunique_read_hazard_directed_virtual_sequence::new(string name="svt_chi_system_protocol_flow_ctrl_hn_makereadunique_read_hazard_directed_virtual_sequence");
  super.new(name);
endfunction

/**
 * @groupname CHI_SYS_HAZARD
 *    #- This sequence provides a scenario to test how components handle various hazard conditions
 *       applicable for copyback and makereadunique transactions.<br>
 *    #- Send MAKEUNIQUE transaction to random address from random RN.<br>
 *    #- Send WRITEBACKFULL transaction to the same address from same RN.<br>
 *    #- Send READSHARED transaction to the same address from same or differnet RN so the cacheline state is moved to SC state.<br>
 *    #- Send READSHARED transaction to the same address from differnet RN so the cacheline state is moved to SC state.<br>
 *    #- After the cache initialization we can program the RN's to initiate the hazard transactions accordingly.<br>
 *    #- Send MAKEREADUNIQUE type of transaction to the same address from the RN having the cachelinestate in SC state.<br>
 *    #- Send WRITEEVICTFULL Copyback transaction to the same address from a different RN.<br>
 *    #- Check the order in which the two requests are processed by HN.<br>
 *    #- This sequence requires SVT_CHI_ISSUE_E_ENABLE macro to be defined and
 *       svt_chi_node_configuration::chi_spec_revision is set to svt_chi_node_configuration::ISSUE_E or later.<br>
 *    .
 *
 */

class svt_chi_system_protocol_flow_ctrl_hn_makereadunique_copyback_hazard_directed_virtual_sequence extends svt_chi_system_protocol_flow_ctrl_xact_hazard_virtual_sequence;

  /** Parameter that controls the number of transactions that will be generated */
  rand int unsigned sequence_length = 10;

  rand bit enable_outstanding = 0;

  bit enable_outstanding_status = 0;

  /** Constrain the sequence length to a reasonable value */
  constraint reasonable_sequence_length {
    sequence_length <= 100;
  }

  /** UVM Object Utility macro */
  `uvm_object_utils(svt_chi_system_protocol_flow_ctrl_hn_makereadunique_copyback_hazard_directed_virtual_sequence)

  extern function new(string name="svt_chi_system_protocol_flow_ctrl_hn_makereadunique_copyback_hazard_directed_virtual_sequence"); 

  virtual task pre_body();
    raise_phase_objection();
  endtask
 
  virtual task body();
    bit                           status;
    bit [`SVT_CHI_MAX_ADDR_WIDTH -1:0] txn_address;
    bit [`SVT_CHI_MAX_DATA_WIDTH -1:0] txn_data;
    bit txn_mem_attr_allocate_hint, txn_snp_attr_snp_domain_type, txn_is_non_secure_access;
    int array_idx;

    /** Sub sequences initiated from this sequence */
    svt_chi_rn_makeunique_cache_initialization_directed_sequence makeunique_seq_0,makeunique_seq_1;
    svt_chi_rn_copyback_type_transaction_directed_sequence copyback_seq_0, copyback_seq_1;
    svt_chi_rn_read_type_transaction_directed_sequence readshared_seq_0, readshared_seq_1;

    /** Sub MakeReadUnique type transaction directed sequences initiated from this sequence */
    svt_chi_rn_makereadunique_type_transaction_directed_sequence makereadunique_seq[int];
    svt_chi_rn_copyback_type_transaction_directed_sequence copyback_seq[int];

    `uvm_info("body", "Entered ...", UVM_HIGH)
    require_issue_e_chi_spec_revision = 1;

    super.body();
    // Default
    enable_outstanding = 0;
    status = uvm_config_db #(int unsigned)::get(null, get_full_name(), "sequence_length", sequence_length);
    `uvm_info("body", $sformatf("sequence_length is %0d as a result of %0s.", sequence_length, status ? "config DB" : "randomization"), UVM_HIGH);

    enable_outstanding_status = uvm_config_db#(bit)::get(m_sequencer, get_type_name(), "enable_outstanding", enable_outstanding);
    `uvm_info("body", $sformatf("enable_outstanding is %0b as a result of %0s", enable_outstanding, (enable_outstanding_status?"config DB":"default setting")), UVM_HIGH);

    initiating_rn_node_idx_0 = initiating_rn_node_index_0_status ? initiating_rn_node_index_0_from_config_db :initiating_rn_f_node_index_0;
    initiating_rn_node_idx_1 = initiating_rn_node_index_1_status ? initiating_rn_node_index_1_from_config_db :initiating_rn_f_node_index_1;
    target_hn_node_idx_0 = target_hn_node_index_0_status ? target_hn_node_index_0_from_config_db :target_hn_f_node_index_0;

    /** check if current environment is supported or not */ 
    if(!is_supported(sys_cfg, silent))  begin
      `svt_xvm_note("body",$sformatf("This sequence cannot be run based on the current system configuration. Exiting..."))
      return;
    end

    /**
     * If the initiating_rn_node_idx_0 is part of active_participating_rn_f_nodes array then we can
     * issue MAKEREADUNIQUE transaction from the RN[initiating_rn_node_idx_0].
     */
    if (!(is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_node_idx_0, array_idx))) begin
       `svt_xvm_error("body", $sformatf("initiating_rn_node_idx_0 should be expected to be active participating RN-F node,but it is not i.e initiating_rn_node_idx_0 = 'h%d",initiating_rn_node_idx_0));
    end

    /**
     * If the initiating_rn_node_idx_1 is part of active_participating_rn_f_nodes array then we can
     * issue COPYBACK transaction from the RN[initiating_rn_node_idx_1].
     */
    if (!(is_value_found_in_int_assoc_array(active_participating_rn_f_nodes, initiating_rn_node_idx_1, array_idx))) begin
       `svt_xvm_error("body", $sformatf("initiating_rn_node_idx_1 should be expected to be active participating RN-F node,but it is not i.e initiating_rn_node_idx_1 = 'h%d",initiating_rn_node_idx_1));
    end

    str_initiating_rn_node_indices = "";

    /** Display the contents of Active Participating RN-F Nodes */
    foreach (active_participating_rn_f_nodes[j]) begin
      str_initiating_rn_node_indices = {str_initiating_rn_node_indices, $sformatf(" %0d", active_participating_rn_f_nodes[j])};
    end 
    str_initiating_rn_node_indices = {str_initiating_rn_node_indices, $sformatf("\n RN nodes used to initiate the transactions are initiating_rn_node_idx_0 : %0d, initiating_rn_node_idx_1 : %0d ", initiating_rn_node_idx_0, initiating_rn_node_idx_1)};
    `svt_xvm_debug("body", $sformatf("contents of active_participating_rn_f_nodes and RN nodes used to initiate the transactions are %0s", str_initiating_rn_node_indices));

    for(int i = 0; i < sequence_length; i++) begin

      /** Write data into Cache of Randomly selected first RN with address of randomly selected HN Node */
      `svt_xvm_do_on_with(makeunique_seq_0, p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
      {
        sequence_length == 1;
        hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_HN_NODE_IDX_RAND_TYPE;
        seq_hn_node_idx == target_hn_node_idx_0;
        use_seq_is_non_secure_access == 0;
      })

      /** Wait for MakeUnique transactions to finish */ 
      makeunique_seq_0.write_tran.wait_end();
      txn_address = makeunique_seq_0.output_xacts[0].addr;
      txn_data = makeunique_seq_0.data_in_cache;
      txn_mem_attr_allocate_hint = makeunique_seq_0.output_xacts[0].mem_attr_allocate_hint;
      txn_snp_attr_snp_domain_type = makeunique_seq_0.output_xacts[0].snp_attr_snp_domain_type;
      txn_is_non_secure_access = makeunique_seq_0.output_xacts[0].is_non_secure_access;

      /** Writeback the data to the main memory at the respective address. */ 
      `svt_xvm_do_on_with(copyback_seq_0, p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
      {
        sequence_length == 1;
        data_in_cache == makeunique_seq_0.data_in_cache;
        seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
        hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
        min_addr == txn_address;
        max_addr == txn_address;
        seq_xact_type == svt_chi_transaction::WRITEBACKFULL;
        seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
        seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
        seq_is_non_secure_access == txn_is_non_secure_access;
        use_seq_is_non_secure_access == 1;               
      }
      )
      /** Waiting for copyback transaction to complete */ 
      copyback_seq_0.copyback_tran.wait_end();

      `svt_xvm_do_on_with(readshared_seq_0, p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
      {
        sequence_length == 1;
        seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
        hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
        min_addr           == txn_address;
        max_addr           == txn_address;
        seq_is_non_secure_access   == txn_is_non_secure_access; 
        seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
        seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
        use_seq_is_non_secure_access == 1;
        data_in_cache == makeunique_seq_0.data_in_cache;
        by_pass_read_data_check == 0;
        seq_xact_type == svt_chi_transaction::READSHARED;
      }
      )
      readshared_seq_0.read_tran.wait_end();

      txn_address = readshared_seq_0.read_tran.addr;

      `svt_xvm_do_on_with(readshared_seq_1, p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,
      {
        sequence_length == 1;
        seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
        hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
        min_addr           == txn_address;
        max_addr           == txn_address;
        seq_is_non_secure_access   == txn_is_non_secure_access; 
        seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
        seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
        use_seq_is_non_secure_access == 1;
        data_in_cache == makeunique_seq_0.data_in_cache;
        by_pass_read_data_check == 0;
        seq_xact_type == svt_chi_transaction::READSHARED;
      }
      )
      readshared_seq_1.read_tran.wait_end();

      //SC is the valid initial state for MakeReadUnique transaction
      //SC is the valid initial state for WriteEvictFull transaction
      /* MAKEREADUNIQUE-COPYBACK hazard at HN **/
      fork 
        begin      
`ifndef SVT_CHI_ENABLE_MULTI_CLOCK
          @ (posedge sys_cfg.chi_if.clk);
`else
          @ (posedge sys_cfg.chi_if.rn_clk[initiating_rn_node_idx_0]);
`endif        
          xact_hazard_sema_0.get();
          /** Initiate a read type transaction from initiating_rn_node_idx_0 to txn_address. */ 
          //  RN should be in SC state to generate MAKEREADUNIQUE 
          `svt_xvm_do_on_with(makereadunique_seq[i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_0].rn_xact_seqr,
          {
            sequence_length == 1;
            seq_order_type == svt_chi_transaction::NO_ORDERING_REQUIRED;
            hn_addr_rand_type  == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
            min_addr          == txn_address;
            max_addr          == txn_address;
            use_seq_is_non_secure_access == 1;
            data_in_cache == makeunique_seq_0.data_in_cache;
            by_pass_read_data_check == 0;
            seq_mem_attr_allocate_hint == txn_mem_attr_allocate_hint;
            seq_snp_attr_snp_domain_type == txn_snp_attr_snp_domain_type;
            seq_is_non_secure_access == txn_is_non_secure_access;
            seq_xact_type == svt_chi_transaction::MAKEREADUNIQUE;
          }
          )
          xact_hazard_sema_0.put();
          /** Waiting for MAKEREADUNIQUE type transaction to complete */ 
          makereadunique_seq[i].makereadunique_tran.wait_end(); 
        end
        begin
`ifndef SVT_CHI_ENABLE_MULTI_CLOCK
          @ (posedge sys_cfg.chi_if.clk);
`else
          @ (posedge sys_cfg.chi_if.rn_clk[initiating_rn_node_idx_1]);
`endif        
          xact_hazard_sema_1.get();
          /** Firing CopyBack transaction from a Random RN   
           *    svt_chi_transaction::WRITEEVICTFULL. 
           */
          `svt_xvm_do_on_with(copyback_seq[i], p_sequencer.rn_virt_seqr[initiating_rn_node_idx_1].rn_xact_seqr,{
            sequence_length == 1;
            seq_order_type  == svt_chi_transaction::NO_ORDERING_REQUIRED;
            seq_copyback_req_order_enable == 0;                                          
            seq_is_non_secure_access == txn_is_non_secure_access;
            use_seq_is_non_secure_access == 1;       
            seq_xact_type == svt_chi_transaction::WRITEEVICTFULL;
            hn_addr_rand_type == svt_chi_rn_transaction_base_sequence::DIRECTED_ADDR_RANGE_RAND_TYPE;
            min_addr          == txn_address;
            max_addr          == txn_address;
            })
  
          xact_hazard_sema_1.put();
          /** Waiting for Copyback type transaction to complete */ 
          copyback_seq[i].copyback_tran.wait_end(); 
        end
      join
    end

    `uvm_info("body", "Exiting...", UVM_HIGH)
  endtask: body

  virtual task post_body();
    drop_phase_objection();
  endtask

endclass: svt_chi_system_protocol_flow_ctrl_hn_makereadunique_copyback_hazard_directed_virtual_sequence

function svt_chi_system_protocol_flow_ctrl_hn_makereadunique_copyback_hazard_directed_virtual_sequence::new(string name="svt_chi_system_protocol_flow_ctrl_hn_makereadunique_copyback_hazard_directed_virtual_sequence");
  super.new(name);
endfunction
`endif //   SVT_CHI_ISSUE_E_ENABLE
`endif //GUARD_SVT_CHI_SYSTEM_VIRTUAL_SEQUENCE_COLLECTION_SV 
