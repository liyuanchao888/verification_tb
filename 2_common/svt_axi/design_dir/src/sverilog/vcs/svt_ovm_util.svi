//=======================================================================
// COPYRIGHT (C) 2010-2016 SYNOPSYS INC.
// This software and the associated documentation are confidential and
// proprietary to Synopsys, Inc. Your use or disclosure of this software
// is subject to the terms and conditions of a written license agreement
// between you, or your company, and Synopsys, Inc. In the event of
// publications, the following notice is applicable:
//
// ALL RIGHTS RESERVED
//
// The entire notice above must be reproduced on all authorized copies.
//
//-----------------------------------------------------------------------

`ifndef GUARD_SVT_OVM_UTIL_SVI
`define GUARD_SVT_OVM_UTIL_SVI

// -------------------------------------------------------------------------
// SVT Message macros should be used instead of the methedology specific
// message formatting routines
// -------------------------------------------------------------------------

// =============================================================================
// The OVM object macros do not currently support arrays of real properties.
// The following sets of macros implement this using the same strategy that
// the other object macros have used.
// =============================================================================

`ifndef ovm_print_qda_real3

`define ovm_print_qda_real3(F, P, T) \
  begin \
    ovm_printer p__; \
    ovm_printer_knobs k__; \
    int curr, max__; max__=0; curr=0; \
    if(P!=null) p__ = P; \
    else p__ = ovm_default_printer; \
    foreach(F[i__]) max__++; \
    p__.print_array_header (`"F`", max__,`"T``(integral)`"); \
    k__ = p__.knobs; \
    if((p__.knobs.depth == -1) || (p__.m_scope.depth() < p__.knobs.depth+1)) \
    begin \
      foreach(F[i__]) begin \
        if(k__.begin_elements == -1 || k__.end_elements == -1 || curr < k__.begin_elements ) begin \
          p__.print_field_real(p__.index_string(curr), F[curr], "["); \
        end \
        else break; \
        curr++; \
      end \
      if(curr<max__) begin \
        if((max__-k__.end_elements) > curr) curr = max__-k__.end_elements; \
        if(curr<k__.begin_elements) curr = k__.begin_elements; \
        else begin \
          p__.print_array_range(k__.begin_elements, curr-1); \
        end \
        for(curr=curr; curr<max__; ++curr) begin \
          p__.print_field_real(p__.index_string(curr), F[curr], "["); \
        end \
      end \
    end \
    p__.print_array_footer(max__); \
    p__.print_footer(); \
  end
 
`endif

`ifndef ovm_print_array_real2

`define ovm_print_array_real2(F, P) \
  `ovm_print_qda_real3(F, P, da)

`endif

`ifndef ovm_print_array_real

`define ovm_print_array_real(F) \
  `ovm_print_array_real2(F, ovm_default_printer)
   
`endif

`ifndef m_ovm_record_array_real

// m_ovm_record_array_real
// ------------------------

`define m_ovm_record_array_real(ARG, RECORDER) \
  begin \
    if(RECORDER.tr_handle != 0) begin\
      for(int i__=0; i__<ARG.size(); ++i__) \
        RECORDER.record_field_real($sformatf(`"ARG[%0d]`", i__), ARG[i__]); \
    end \
  end

`endif //  `ifndef m_ovm_record_array_real

`ifndef m_ovm_record_sarray_real

// m_ovm_record_sarray_real
// ------------------------

`define m_ovm_record_sarray_real(ARG, RECORDER) \
  begin \
    if(RECORDER.tr_handle != 0) begin\
      foreach(ARG[i__]) \
        RECORDER.record_field_real($sformatf(`"ARG[%0d]`", i__), ARG[i__]); \
    end \
  end

`endif //  `ifndef m_ovm_record_sarray_real

`ifndef M_OVM_FIELD_DATA_ARRAY_REAL

// M_OVM_FIELD_DATA_ARRAY_REAL
// ---------------------------

`define M_OVM_FIELD_DATA_ARRAY_REAL(ARG,FLAG) \
   begin \
   if((what__ & (FLAG)) || (what__ >= OVM_MACRO_EXTRAS)) begin \
     case (what__) \
       OVM_COMPARE: \
         if ( !((FLAG)&OVM_NOCOMPARE) && (tmp_data__ != null) ) begin \
           int i__; \
           $cast(local_data__, tmp_data__); \
           if(ARG.size() != local_data__.``ARG.size()) begin \
             int s1__, s2__; \
             m_sc.stringv = ""; \
             s1__ = ARG.size(); s2__ = local_data__.ARG.size(); \
             $swrite(m_sc.stringv, "lhs size = %0d : rhs size = %0d", s1__, s2__);\
             ovm_auto_options_object.comparer.print_msg(m_sc.stringv); \
           end \
           for(i__=0; i__<ARG.size() && i__<local_data__.ARG.size(); ++i__) \
             if(ARG[i__] != local_data__.ARG[i__]) begin \
               real ls__, rs__; \
               ls__ = ARG[i__]; rs__ = local_data__.ARG[i__]; \
               ovm_auto_options_object.comparer.scope.down_element(i__, null);\
               $swrite(m_sc.stringv, "lhs = %0f : rhs = %0f", ls__, rs__); \
               ovm_auto_options_object.comparer.print_msg(m_sc.stringv); \
               ovm_auto_options_object.comparer.scope.up_element(null);\
             end \
         end \
       OVM_COPY: \
         if(!((FLAG)&OVM_NOCOPY) && (tmp_data__ != null) ) \
          begin \
           int i__; \
           $cast(local_data__, tmp_data__); \
           /*Resizing of array is done in ovm_field_array* macro*/ \
           for(i__=0; i__ < ARG.size(); ++i__) \
             ARG[i__] = local_data__.ARG[i__] ; \
         end \
       OVM_PRINT: \
         begin \
           if((FLAG)&OVM_NOPRINT != 0 && \
                          ovm_auto_options_object.printer.knobs.print_fields == 1) \
             `ovm_print_array_real2(ARG, ovm_auto_options_object.printer) \
         end \
       OVM_RECORD: \
         begin \
           if(((FLAG)&OVM_NORECORD) == 0 && !m_sc.array_warning_done) begin \
             `m_ovm_record_array_real(ARG, ovm_auto_options_object.recorder) \
           end \
         end \
     endcase \
   end \
   end 

`endif

`ifndef M_OVM_FIELD_ARRAY_REAL_PACK

`define M_OVM_FIELD_ARRAY_REAL_PACK(ARG,FLAG) \
   case(what__) \
      OVM_PACK: \
        if(((FLAG)&OVM_NOPACK) == 0) \
        begin \
          if((((FLAG)&OVM_ABSTRACT) && ovm_auto_options_object.packer.abstract) || \
              (!((FLAG)&OVM_ABSTRACT) && ovm_auto_options_object.packer.physical)) begin \
            if(ovm_auto_options_object.packer.use_metadata == 1) \
              ovm_auto_options_object.packer.pack_field_int(ARG.size(), 32); \
            foreach(ARG[i]) \
              ovm_auto_options_object.packer.pack_real(ARG[i]); \
          end \
        end \
      OVM_UNPACK: \
        if(((FLAG)&OVM_NOPACK) == 0) \
        begin \
          if((((FLAG)&OVM_ABSTRACT) && ovm_auto_options_object.packer.abstract) || \
              (!((FLAG)&OVM_ABSTRACT) && ovm_auto_options_object.packer.physical)) begin \
            if(ovm_auto_options_object.packer.use_metadata) begin \
              int s_; \
              s_ = ovm_auto_options_object.packer.unpack_field_int(32); \
              ARG = new[s_]; \
            end \
            foreach(ARG[i]) \
              ARG[i] = ovm_auto_options_object.packer.unpack_real(); \
          end \
        end \
  endcase

`endif

`ifndef M_OVM_FIELD_SET_ARRAY_REAL

`define M_OVM_FIELD_SET_ARRAY_REAL(ARRAY, RHS, FLAG) \
  if((what__ >= OVM_START_FUNCS && what__ <= OVM_END_FUNCS) && (((FLAG)&OVM_READONLY) == 0)) begin \
    int index__; \
    bit wildcard_index__; \
    index__ = ovm_get_array_index_int(str__, wildcard_index__); \
    if(what__==OVM_SETINT) \
    begin \
      if(ovm_is_array(str__) ) begin\
        if(wildcard_index__) begin \
          for(int index__=0; index__<ARRAY.size(); ++index__) begin \
            if(ovm_is_match(str__, {m_sc.scope.get_arg(),$sformatf("[%0d]", index__)})) begin \
              ARRAY[index__] = RHS; \
              m_sc.status = 1; \
            end \
          end \
        end \
        else if(ovm_is_match(str__, {m_sc.scope.get_arg(),$sformatf("[%0d]", index__)})) begin \
          ARRAY[index__] = RHS; \
          m_sc.status = 1; \
        end \
        else if(what__==OVM_SET && ovm_is_match(str__, m_sc.scope.get_arg())) begin \
          int size__; \
          size__ = m_sc.bitstream; \
          ARRAY = new[size__](ARRAY); \
          m_sc.status = 1; \
        end \
      end \
      else if(what__==OVM_SET && ovm_is_match(str__, m_sc.scope.get_arg())) begin \
        int size__; \
        size__ = m_sc.bitstream; \
        ARRAY = new[size__](ARRAY); \
        m_sc.status = 1; \
      end \
    end \
    else if(what__==OVM_SET && ovm_is_match(str__, m_sc.scope.get_arg())) begin \
     int size__; \
     size__ = m_sc.bitstream; \
     ARRAY = new[size__](ARRAY); \
     m_sc.status = 1; \
    end \
 end

`endif //  `ifndef M_OVM_FIELD_SET_ARRAY_REAL


`ifndef M_OVM_FIELD_DATA_SARRAY_REAL

// M_OVM_FIELD_DATA_SARRAY_REAL
// ---------------------------

`define M_OVM_FIELD_DATA_SARRAY_REAL(ARG,FLAG) \
   begin \
   if((what__ & (FLAG)) || (what__ >= OVM_MACRO_EXTRAS)) begin \
     case (what__) \
       OVM_COMPARE: \
         if ( !((FLAG)&OVM_NOCOMPARE) && (tmp_data__ != null) ) begin \
           int i__; \
           $cast(local_data__, tmp_data__); \
           for(i__=0; i__<$size(ARG) && i__<$size(local_data__.ARG); ++i__) \
             if(ARG[i__] != local_data__.ARG[i__]) begin \
               real ls__, rs__; \
               ls__ = ARG[i__]; rs__ = local_data__.ARG[i__]; \
               ovm_auto_options_object.comparer.scope.down_element(i__, null);\
               $swrite(m_sc.stringv, "lhs = %0f : rhs = %0f", ls__, rs__); \
               ovm_auto_options_object.comparer.print_msg(m_sc.stringv); \
               ovm_auto_options_object.comparer.scope.up_element(null);\
             end \
         end \
       OVM_COPY: \
         if(!((FLAG)&OVM_NOCOPY) && (tmp_data__ != null) ) \
          begin \
           int i__; \
           $cast(local_data__, tmp_data__); \
           /*Resizing of array is done in ovm_field_array* macro*/ \
           for(i__=0; i__ < $size(ARG); ++i__) \
             ARG[i__] = local_data__.ARG[i__] ; \
         end \
       OVM_PRINT: \
         begin \
           if((FLAG)&OVM_NOPRINT != 0 && \
                          ovm_auto_options_object.printer.knobs.print_fields == 1) \
             `ovm_print_array_real2(ARG, ovm_auto_options_object.printer) \
         end \
       OVM_RECORD: \
         begin \
           if(((FLAG)&OVM_NORECORD) == 0 && !m_sc.array_warning_done) begin \
             `m_ovm_record_sarray_real(ARG, ovm_auto_options_object.recorder) \
           end \
         end \
     endcase \
   end \
   end 

`endif //  `ifndef M_OVM_FIELD_DATA_SARRAY_REAL

`ifndef M_OVM_FIELD_SARRAY_REAL_PACK

`define M_OVM_FIELD_SARRAY_REAL_PACK(ARG,FLAG) \
   case(what__) \
      OVM_PACK: \
        if(((FLAG)&OVM_NOPACK) == 0) \
        begin \
          if((((FLAG)&OVM_ABSTRACT) && ovm_auto_options_object.packer.abstract) || \
              (!((FLAG)&OVM_ABSTRACT) && ovm_auto_options_object.packer.physical)) begin \
            foreach(ARG[i]) \
              ovm_auto_options_object.packer.pack_real(ARG[i]); \
          end \
        end \
      OVM_UNPACK: \
        if(((FLAG)&OVM_NOPACK) == 0) \
        begin \
          if((((FLAG)&OVM_ABSTRACT) && ovm_auto_options_object.packer.abstract) || \
              (!((FLAG)&OVM_ABSTRACT) && ovm_auto_options_object.packer.physical)) begin \
            foreach(ARG[i]) \
              ARG[i] = ovm_auto_options_object.packer.unpack_real(); \
          end \
        end \
  endcase

`endif //  `ifndef M_OVM_FIELD_SARRAY_REAL_PACK

`ifndef M_OVM_FIELD_SET_SARRAY_REAL

`define M_OVM_FIELD_SET_SARRAY_REAL(ARRAY, RHS, FLAG) \
  if((what__ >= OVM_START_FUNCS && what__ <= OVM_END_FUNCS) && (((FLAG)&OVM_READONLY) == 0)) begin \
    int index__; \
    bit wildcard_index__; \
    index__ = ovm_get_array_index_int(str__, wildcard_index__); \
    if(what__==OVM_SETINT) \
    begin \
      if(ovm_is_array(str__) ) begin\
        if(wildcard_index__) begin \
          foreach(ARRAY[index__]) begin \
            if(ovm_is_match(str__, {m_sc.scope.get_arg(),$sformatf("[%0d]", index__)})) begin \
              ARRAY[index__] = RHS; \
              m_sc.status = 1; \
            end \
          end \
        end \
        else if(ovm_is_match(str__, {m_sc.scope.get_arg(),$sformatf("[%0d]", index__)})) begin \
          ARRAY[index__] = RHS; \
          m_sc.status = 1; \
        end \
        else if(what__==OVM_SET && ovm_is_match(str__, m_sc.scope.get_arg())) begin \
          /* TODO: Do we need this block. */ \
          m_sc.status = 1; \
        end \
      end \
      else if(what__==OVM_SET && ovm_is_match(str__, m_sc.scope.get_arg())) begin \
        /* TODO: Do we need this block. */ \
        m_sc.status = 1; \
      end \
    end \
    else if(what__==OVM_SET && ovm_is_match(str__, m_sc.scope.get_arg())) begin \
     /* TODO: Do we need this block. */ \
     m_sc.status = 1; \
    end \
 end

`endif //  `ifndef M_OVM_FIELD_SET_SARRAY_REAL


//vikas

`ifndef M_OVM_FIELD_DATA_QUEUE_REAL

// M_OVM_FIELD_DATA_QUEUE_REAL
// ---------------------------

`define M_OVM_FIELD_DATA_QUEUE_REAL(ARG,FLAG) \
   begin \
   if((what__ & (FLAG)) || (what__ >= OVM_MACRO_EXTRAS)) begin \
     case (what__) \
       OVM_COMPARE: \
         if ( !((FLAG)&OVM_NOCOMPARE) && (tmp_data__ != null) ) begin \
           int i__; \
           $cast(local_data__, tmp_data__); \
           if(ARG.size() != local_data__.``ARG.size()) begin \
             int s1__, s2__; \
             m_sc.stringv = ""; \
             s1__ = ARG.size(); s2__ = local_data__.ARG.size(); \
             $swrite(m_sc.stringv, "lhs size = %0d : rhs size = %0d", s1__, s2__);\
             ovm_auto_options_object.comparer.print_msg(m_sc.stringv); \
           end \
           for(i__=0; i__<ARG.size() && i__<local_data__.ARG.size(); ++i__) \
             if(ARG[i__] != local_data__.ARG[i__]) begin \
               real ls__, rs__; \
               ls__ = ARG[i__]; rs__ = local_data__.ARG[i__]; \
               ovm_auto_options_object.comparer.scope.down_element(i__, null);\
               $swrite(m_sc.stringv, "lhs = %0f : rhs = %0f", ls__, rs__); \
               ovm_auto_options_object.comparer.print_msg(m_sc.stringv); \
               ovm_auto_options_object.comparer.scope.up_element(null);\
             end \
         end \
       OVM_COPY: \
         if(!((FLAG)&OVM_NOCOPY) && (tmp_data__ != null) ) \
          begin \
           int i__; \
           $cast(local_data__, tmp_data__); \
           /*Resizing of array is done in ovm_field_array* macro*/ \
           for(i__=0; i__ < ARG.size(); ++i__) \
             ARG[i__] = local_data__.ARG[i__] ; \
         end \
       OVM_PRINT: \
         begin \
           if((FLAG)&OVM_NOPRINT != 0 && \
                          ovm_auto_options_object.printer.knobs.print_fields == 1) \
             `ovm_print_array_real2(ARG, ovm_auto_options_object.printer) \
         end \
       OVM_RECORD: \
         begin \
           if(((FLAG)&OVM_NORECORD) == 0 && !m_sc.array_warning_done) begin \
             `m_ovm_record_array_real(ARG, ovm_auto_options_object.recorder) \
           end \
         end \
     endcase \
   end \
   end 

`endif //  `ifndef M_OVM_FIELD_DATA_QUEUE_REAL

`ifndef M_OVM_FIELD_QUEUE_REAL_PACK

`define M_OVM_FIELD_QUEUE_REAL_PACK(ARG,FLAG) \
   case(what__) \
      OVM_PACK: \
        if(((FLAG)&OVM_NOPACK) == 0) \
        begin \
          if((((FLAG)&OVM_ABSTRACT) && ovm_auto_options_object.packer.abstract) || \
              (!((FLAG)&OVM_ABSTRACT) && ovm_auto_options_object.packer.physical)) begin \
            if(ovm_auto_options_object.packer.use_metadata == 1) \
              ovm_auto_options_object.packer.pack_field_int(ARG.size(), 32); \
            foreach(ARG[i]) \
              ovm_auto_options_object.packer.pack_real(ARG[i]); \
          end \
        end \
      OVM_UNPACK: \
        if(((FLAG)&OVM_NOPACK) == 0) \
        begin \
          if((((FLAG)&OVM_ABSTRACT) && ovm_auto_options_object.packer.abstract) || \
              (!((FLAG)&OVM_ABSTRACT) && ovm_auto_options_object.packer.physical)) begin \
            if(ovm_auto_options_object.packer.use_metadata) begin \
              int s_; \
              s_ = ovm_auto_options_object.packer.unpack_field_int(32); \
              /* ARG = new[s_]; */ \
            end \
            foreach(ARG[i]) \
              ARG[i] = ovm_auto_options_object.packer.unpack_real(); \
          end \
        end \
  endcase

`endif //  `ifndef M_OVM_FIELD_QUEUE_REAL_PACK


`ifndef M_OVM_FIELD_SET_QUEUE_REAL

`define M_OVM_FIELD_SET_QUEUE_REAL(ARRAY, RHS, FLAG) \
  if((what__ >= OVM_START_FUNCS && what__ <= OVM_END_FUNCS) && (((FLAG)&OVM_READONLY) == 0)) begin \
    int index__; \
    bit wildcard_index__; \
    index__ = ovm_get_array_index_int(str__, wildcard_index__); \
    if(what__==OVM_SETINT) \
    begin \
      if(ovm_is_array(str__) ) begin\
        if(wildcard_index__) begin \
          foreach(ARRAY[index__]) begin \
            if(ovm_is_match(str__, {m_sc.scope.get_arg(),$sformatf("[%0d]", index__)})) begin \
              ARRAY[index__] = RHS; \
              m_sc.status = 1; \
            end \
          end \
        end \
        else if(ovm_is_match(str__, {m_sc.scope.get_arg(),$sformatf("[%0d]", index__)})) begin \
          ARRAY[index__] = RHS; \
          m_sc.status = 1; \
        end \
        else if(what__==OVM_SET && ovm_is_match(str__, m_sc.scope.get_arg())) begin \
          /* TODO: Do we need this block. */ \
          m_sc.status = 1; \
        end \
      end \
      else if(what__==OVM_SET && ovm_is_match(str__, m_sc.scope.get_arg())) begin \
        /* TODO: Do we need this block. */ \
        m_sc.status = 1; \
      end \
    end \
    else if(what__==OVM_SET && ovm_is_match(str__, m_sc.scope.get_arg())) begin \
     /* TODO: Do we need this block. */ \
     m_sc.status = 1; \
    end \
 end

`endif //  `ifndef M_OVM_FIELD_SET_QUEUE_REAL


`ifndef ovm_field_array_real

// MACRO: `ovm_field_array_real
//
// Implements the data operations for a one-dimensional dynamic array of
// reals.
//
//|  `ovm_field_array_real(ARG,FLAG)
//
// ~ARG~ is a one-dimensional dynamic array of reals,
// and ~FLAG~ is a bitwise OR of one or more flag settings as described in
// <Field Macros> above.

`define ovm_field_array_real(ARG,FLAG) \
  begin \
  if(what__==OVM_CHECK_FIELDS) m_do_field_check(`"ARG`"); \
  m_sc.scope.down(`"ARG`",null); \
  if(what__==OVM_COPY && !((FLAG)&OVM_NOCOPY)) begin \
    if(local_data__!=null) begin \
      ARG = new [local_data__.ARG.size()](local_data__.ARG); \
    end \
    else begin \
      ARG.delete(); \
    end \
  end \
  `M_OVM_FIELD_DATA_ARRAY_REAL(ARG,FLAG) \
  `M_OVM_FIELD_ARRAY_REAL_PACK(ARG,FLAG) \
  `M_OVM_FIELD_SET_ARRAY_REAL(ARG, m_sc.bitstream, FLAG) \
  m_sc.scope.up(null); \
  end

`endif //  `ifndef ovm_field_array_real


`ifndef ovm_field_sarray_real

// MACRO: `ovm_field_sarray_real
//
// Implements the data operations for a one-dimensional dynamic array of
// reals.
//
//|  `ovm_field_sarray_real(ARG,FLAG)
//
// ~ARG~ is a one-dimensional dynamic array of reals,
// and ~FLAG~ is a bitwise OR of one or more flag settings as described in
// <Field Macros> above.

`define ovm_field_sarray_real(ARG,FLAG) \
  begin \
  if(what__==OVM_CHECK_FIELDS) m_do_field_check(`"ARG`"); \
  m_sc.scope.down(`"ARG`",null); \
  `M_OVM_FIELD_DATA_SARRAY_REAL(ARG,FLAG) \
  `M_OVM_FIELD_SARRAY_REAL_PACK(ARG,FLAG) \
  `M_OVM_FIELD_SET_SARRAY_REAL(ARG, m_sc.bitstream, FLAG) \
  m_sc.scope.up(null); \
  end

`endif //  `ifndef ovm_field_sarray_real


`ifndef ovm_field_queue_real

// MACRO: `ovm_field_queue_real
//
// Implements the data operations for a one-dimensional queue of reals.
//
//|  `ovm_field_queue_real(ARG,FLAG)
//
// ~ARG~ is a one-dimensional queue of reals,
// and ~FLAG~ is a bitwise OR of one or more flag settings as described in
// <Field Macros> above.

`define ovm_field_queue_real(ARG,FLAG) \
  begin \
  if(what__==OVM_CHECK_FIELDS) m_do_field_check(`"ARG`"); \
  m_sc.scope.down(`"ARG`",null); \
  `M_OVM_FIELD_DATA_QUEUE_REAL(ARG,FLAG) \
  `M_OVM_FIELD_QUEUE_REAL_PACK(ARG,FLAG) \
  `M_OVM_FIELD_SET_QUEUE_REAL(ARG, m_sc.bitstream, FLAG) \
  m_sc.scope.up(null); \
  end

`endif //  `ifndef ovm_field_queue_real

`define SVT_XVM(obj)          ovm_``obj
`define SVT_XVM_UC(obj)       OVM_``obj

`define SVT_FATAL_VERBOSITY   OVM_NONE
`define SVT_ERROR_VERBOSITY   OVM_NONE
`define SVT_WARNING_VERBOSITY OVM_NONE
`define SVT_NORMAL_VERBOSITY  OVM_LOW
`define SVT_TRACE_VERBOSITY   OVM_MEDIUM
`define SVT_DEBUG_VERBOSITY   OVM_HIGH
`define SVT_VERBOSE_VERBOSITY OVM_FULL

`ifdef SVT_DISABLE_ALL_MSG
 `define svt_fatal(id, msg) do begin end while (0)
 `define svt_error(id, msg)  do begin end while (0)
 `define svt_warning(id, msg) do begin end while (0)
`else
`define svt_fatal(id, msg) \
  do \
    if (reporter.ovm_report_enabled(OVM_NONE,OVM_FATAL,id)) \
      reporter.ovm_report_fatal(id, msg, OVM_NONE, `ovm_file, `ovm_line); \
  while (0)

`define svt_error(id, msg) \
  do \
    begin \
      if (reporter.ovm_report_enabled(OVM_NONE,OVM_ERROR,id)) \
        reporter.ovm_report_error(id, msg, OVM_NONE, `ovm_file, `ovm_line); \
    end \
  while (0)

`define svt_warning(id, msg) \
  do \
    if (reporter.ovm_report_enabled(OVM_NONE,OVM_WARNING,id)) \
      reporter.ovm_report_warning(id, msg, OVM_NONE, `ovm_file, `ovm_line); \
  while (0)
`endif // !`ifdef SVT_DISABLE_ALL_MSG

// Generates a message with OVM_NONE verbosity.  This should be used extremely sparingly.
`define svt_insuppressible_note(id, msg) \
  do \
    /* The check to see if the report is enabled is skipped because we always want to generate this message. */ \
    reporter.ovm_report_info(id, msg, OVM_NONE, `ovm_file, `ovm_line); \
  while (0)

`ifdef SVT_DISABLE_MSG
`define svt_note(id, msg) do begin end while (0)
`define svt_trace(id, msg) do begin end while (0)
`define svt_debug(id, msg) do begin end while (0)
`define svt_verbose(id, msg) do begin end while (0)
`else
`define svt_note(id, msg) \
  do \
    if (reporter.ovm_report_enabled(OVM_LOW,OVM_INFO,id)) \
      reporter.ovm_report_info(id, msg, OVM_LOW, `ovm_file, `ovm_line); \
  while (0)

`define svt_trace(id, msg) \
  do \
    if (reporter.ovm_report_enabled(OVM_MEDIUM,OVM_INFO,id)) \
      reporter.ovm_report_info(id, msg, OVM_MEDIUM, `ovm_file, `ovm_line); \
  while (0)

`define svt_debug(id, msg) \
  do \
    if (reporter.ovm_report_enabled(OVM_HIGH,OVM_INFO,id)) \
      reporter.ovm_report_info(id, msg, OVM_HIGH, `ovm_file, `ovm_line); \
  while (0)

`define svt_verbose(id, msg) \
  do \
    if (reporter.ovm_report_enabled(OVM_FULL,OVM_INFO,id)) \
      reporter.ovm_report_info(id, msg, OVM_FULL, `ovm_file, `ovm_line); \
  while (0)
`endif // !`ifdef SVT_DISABLE_MSG

`ifdef SVT_DISABLE_ALL_MSG
 `define svt_fatal_context(id, msg, clientfile, clientline) do begin end while (0)
 `define svt_error_context(id, msg, clientfile, clientline) do begin end while (0)
 `define svt_warning_context(id, msg, clientfile, clientline) do begin end while (0)
`else
`define svt_fatal_context(id, msg, clientfile, clientline) \
`ifdef ovm_fatal_context \
  do \
    if ((clientfile != "") || (clientline != 0)) begin \
`ifdef OVM_REPORT_DISABLE_FILE \
      clientfile = ""; \
`endif \
`ifdef OVM_REPORT_DISABLE_LINE \
      clientline = 0; \
`endif \
      if (reporter.ovm_report_enabled(OVM_NONE,OVM_FATAL,id)) \
        reporter.ovm_report_fatal(id, msg, OVM_NONE, clientfile, clientline); \
    end else \
      `ovm_fatal_context(id, msg, reporter) \
  while (0) \
`else \
  `svt_fatal(id, msg) \
`endif

`define svt_error_context(id, msg, clientfile, clientline) \
`ifdef ovm_error_context \
  do \
    if ((clientfile != "") || (clientline != 0)) begin \
`ifdef OVM_REPORT_DISABLE_FILE \
      clientfile = ""; \
`endif \
`ifdef OVM_REPORT_DISABLE_LINE \
      clientline = 0; \
`endif \
      if (reporter.ovm_report_enabled(OVM_NONE,OVM_ERROR,id)) \
        reporter.ovm_report_error(id, msg, OVM_NONE, clientfile, clientline); \
    end else \
      `ovm_error_context(id, msg, reporter) \
  while (0) \
`else \
  `svt_error(id, msg) \
`endif

`define svt_warning_context(id, msg, clientfile, clientline) \
`ifdef ovm_warning_context \
  do \
    if ((clientfile != "") || (clientline != 0)) begin \
`ifdef OVM_REPORT_DISABLE_FILE \
      clientfile = ""; \
`endif \
`ifdef OVM_REPORT_DISABLE_LINE \
      clientline = 0; \
`endif \
      if (reporter.ovm_report_enabled(OVM_NONE,OVM_WARNING,id)) \
        reporter.ovm_report_warning(id, msg, OVM_NONE, clientfile, clientline); \
    end else \
      `ovm_warning_context(id, msg, reporter) \
  while (0) \
`else \
  `svt_warning(id, msg) \
`endif
`endif // !`ifdef SVT_DISABLE_ALL_MSG

`ifdef SVT_DISABLE_MSG
 `define svt_note_context(id, msg, clientfile, clientline) do begin end while (0)
 `define svt_trace_context(id, msg, clientfile, clientline) do begin end while (0)
 `define svt_debug_context(id, msg, clientfile, clientline) do begin end while (0)
 `define svt_verbose_context(id, msg, clientfile, clientline) do begin end while (0)
`else
`define svt_note_context(id, msg, clientfile, clientline) \
`ifdef ovm_info_context \
  do \
    if ((clientfile != "") || (clientline != 0)) begin \
`ifdef OVM_REPORT_DISABLE_FILE \
      clientfile = ""; \
`endif \
`ifdef OVM_REPORT_DISABLE_LINE \
      clientline = 0; \
`endif \
      if (reporter.ovm_report_enabled(OVM_LOW,OVM_INFO,id)) \
        reporter.ovm_report_info(id, msg, OVM_LOW, clientfile, clientline); \
    end else \
      `ovm_info_context(id, msg, OVM_LOW, reporter) \
  while (0) \
`else \
  `svt_note(id, msg) \
`endif

`define svt_trace_context(id, msg, clientfile, clientline) \
`ifdef ovm_info_context \
  do \
    if ((clientfile != "") || (clientline != 0)) begin \
`ifdef OVM_REPORT_DISABLE_FILE \
      clientfile = ""; \
`endif \
`ifdef OVM_REPORT_DISABLE_LINE \
      clientline = 0; \
`endif \
      if (reporter.ovm_report_enabled(OVM_MEDIUM,OVM_INFO,id)) \
        reporter.ovm_report_info(id, msg, OVM_MEDIUM, clientfile, clientline); \
    end else \
      `ovm_info_context(id, msg, OVM_MEDIUM, reporter) \
  while (0) \
`else \
  `svt_trace(id, msg) \
`endif

`define svt_debug_context(id, msg, clientfile, clientline) \
`ifdef ovm_info_context \
  do \
    if ((clientfile != "") || (clientline != 0)) begin \
`ifdef OVM_REPORT_DISABLE_FILE \
      clientfile = ""; \
`endif \
`ifdef OVM_REPORT_DISABLE_LINE \
      clientline = 0; \
`endif \
      if (reporter.ovm_report_enabled(OVM_HIGH,OVM_INFO,id)) \
        reporter.ovm_report_info(id, msg, OVM_HIGH, clientfile, clientline); \
    end else \
      `ovm_info_context(id, msg, OVM_HIGH, reporter) \
  while (0) \
`else \
  `svt_debug(id, msg) \
`endif

`define svt_verbose_context(id, msg, clientfile, clientline) \
`ifdef ovm_info_context \
  do \
    if ((clientfile != "") || (clientline != 0)) begin \
 `ifdef OVM_REPORT_DISABLE_FILE \
      clientfile = ""; \
`endif \
`ifdef OVM_REPORT_DISABLE_LINE \
      clientline = 0; \
`endif \
     if (reporter.ovm_report_enabled(OVM_FULL,OVM_INFO,id)) \
        reporter.ovm_report_info(id, msg, OVM_FULL, clientfile, clientline); \
    end else \
      `ovm_info_context(id, msg, OVM_FULL, reporter) \
  while (0) \
`else \
  `svt_verbose(id, msg) \
`endif
`endif // !`ifdef SVT_DISABLE_MSG

`ifdef SVT_DISABLE_ALL_MSG
 `define svt_xvm_fatal(id, msg) begin end
 `define svt_xvm_error(id, msg) begin end
 `define svt_xvm_warning(id, msg) begin end
`else
`define svt_xvm_fatal(id, msg) \
  `ovm_fatal(id, msg)

`define svt_xvm_error(id, msg) \
  `ovm_error(id, msg)

`define svt_xvm_warning(id, msg) \
  `ovm_warning(id, msg)
`endif // !`ifdef SVT_DISABLE_ALL_MSG

`ifdef SVT_DISABLE_MSG
`define svt_xvm_note(id, msg) begin end
`define svt_xvm_trace(id, msg) begin end
`define svt_xvm_debug(id, msg) begin end
`define svt_xvm_verbose(id, msg) begin end
`else
`define svt_xvm_note(id, msg) \
  `ovm_info(id, msg, OVM_LOW)

`define svt_xvm_trace(id, msg) \
  `ovm_info(id, msg, OVM_MEDIUM)

`define svt_xvm_debug(id, msg) \
  `ovm_info(id, msg, OVM_HIGH)

`define svt_xvm_verbose(id, msg) \
  `ovm_info(id, msg, OVM_FULL)
`endif // !`ifdef SVT_DISABLE_MSG

// -------------------------------------------------------------------------
// Define common callback macros
// -------------------------------------------------------------------------

`define svt_callback_utils(T)

`ifdef SVT_OVM_2_1_1_3
`define SVT_GET_GLOBAL_CBS get
`define SVT_ADD_CB add
`define SVT_DELETE_CB delete
`else
`define SVT_GET_GLOBAL_CBS get_global_cbs
`define SVT_ADD_CB add_cb
`define SVT_DELETE_CB delete_cb
`endif

`ifdef SVT_PRE_OVM_2_1_2
`ifdef SVT_OVM_2_1_1_3

// OVM 2.1.1_3 flips the order of CB and T in the callback macros.

`define svt_xvm_do_callbacks(T,CB,METHOD) \
  `ovm_do_callbacks(T,CB,METHOD)

`define svt_xvm_do_obj_callbacks(T,CB,OBJ,METHOD) \
  `ovm_do_obj_callbacks(T,CB,OBJ,METHOD)

`define svt_xvm_register_cb(T,CB) \
  `ovm_register_cb(T,CB)

`else

// OVM 2.1.1 (including 2.1_1 and 2.1_2) and earlier contain a bug which prevents the
// `ovm_do_callbacks macro from being used from within a forked thread.  This workaround
// is just a copy of the fix that is in OVM 2.1.2.
`define svt_xvm_do_callbacks(T,CB,METHOD_CALL) \
  `svt_xvm_do_obj_callbacks(T,CB,this,METHOD_CALL)

`define svt_xvm_do_obj_callbacks(T,CB,OBJ,METHOD_CALL) \
   begin \
     ovm_callbacks #(T,CB) cbs = ovm_callbacks #(T,CB)::`SVT_GET_GLOBAL_CBS(); \
     ovm_queue #(CB) cbq; \
     if (cbs.exists(OBJ)) begin \
     /* Make a copy of the queue in case the user tries changing the queue */ \
     /* inside the callback. For example, for a one-shot callback. */ \
     cbq = cbs.get(OBJ); \
     cbq = new cbq; \
     for (int i=0; i<cbq.size();i++) begin \
       CB cb = cbq.get(i); \
       if (cb.is_enabled()) \
         cb.METHOD_CALL; \
     end \
     end \
   end

`define svt_xvm_register_cb(T,CB)

`endif
`else

// This workaround is present in the official OVM 2.1.2 distribution, but it seems that
// the version that ships with IUS is versioned as 2.1.2 but does not contain this fix.
// Due to this we will always apply this workaround until we find that Cadence fixes this
// in their internal distribution.
`ifdef CDNS_VERSION

`define svt_xvm_do_callbacks(T,CB,METHOD_CALL) \
  `svt_xvm_do_obj_callbacks(T,CB,this,METHOD_CALL)

`define svt_xvm_do_obj_callbacks(T,CB, OBJ,METHOD_CALL) \
   begin \
     ovm_callbacks #(T,CB) cbs = ovm_callbacks #(T,CB)::`SVT_GET_GLOBAL_CBS(); \
     ovm_queue #(CB) cbq; \
     if (cbs.exists(OBJ)) begin \
       /* Make a copy of the queue in case the user tries changing the queue */ \
       /* inside the callback. For example, for a one-shot callback. */ \
       cbq = cbs.get(OBJ); \
       cbq = new cbq; \
       /* The ovm_pool::get() method can return a null value -- watch out for it */ \
       for (int i=0; cbq!=null && i<cbq.size();i++) begin \
         CB cb = cbq.get(i); \
         if (cb.is_enabled()) \
           cb.METHOD_CALL; \
       end \
     end \
   end

`else

`define svt_xvm_do_callbacks(T,CB,METHOD) \
  `ovm_do_callbacks(CB,T,METHOD)

`define svt_xvm_do_obj_callbacks(T,CB,OBJ,METHOD) \
  `ovm_do_obj_callbacks(CB,T,OBJ,METHOD)

`endif

`define svt_xvm_register_cb(T,CB)

`endif

`define svt_xvm_typedef_cb(T,CB,POOL) \
  typedef svt_callbacks#(T,CB) POOL

`define svt_do_callbacks(T,CB,METHOD) \
  `svt_xvm_do_callbacks(T,CB,METHOD)

`define svt_do_obj_callbacks(T,CB,OBJ,METHOD) \
  `svt_xvm_do_obj_callbacks(T,CB,OBJ,METHOD)

// -------------------------------------------------------------------------
// Define common methodology name macros
// -------------------------------------------------------------------------
`define SVT_DATA_METHODOLOGY_KEYWORD     ovm
`define SVT_DATA_METHODOLOGY_KEYWORD_UC  OVM

// -------------------------------------------------------------------------
// Define a common macro to declare a base object type
// -------------------------------------------------------------------------
`define SVT_DATA_BASE_OBJECT_TYPE ovm_object

// -------------------------------------------------------------------------
// Define a wrapper for the display methods
// -------------------------------------------------------------------------
`define SVT_DATA_DISPLAY_KEYWORD print
`define SVT_DATA_PSDISPLAY_KEYWORD sprint
`define SVT_DATA_DISPLAY(prefix) print()
`define SVT_DATA_PSDISPLAY(prefix) sprint()
`define SVT_DATA_LOG_KEYWORD reporter
`define SVT_DATA_COPY clone
`define SVT_DATA_BYTE_PACK pack
`define SVT_DATA_BYTE_UNPACK unpack
`define SVT_DATA_GET_OBJECT_HIERNAME get_full_name
`define SVT_DATA_GET_OBJECT_TYPENAME get_type_name

// -------------------------------------------------------------------------
// Make SVT names for common constants
// -------------------------------------------------------------------------

`define SVT_PACKER_MAX_BYTES `OVM_PACKER_MAX_BYTES

// -------------------------------------------------------------------------
// Mapping of the flags to the OVM automation macros to common SVT flags
// -------------------------------------------------------------------------

// 1-to-1 mapping to OVM automation flags
`define SVT_NOCOPY     (1<<1)
`define SVT_NOCOMPARE  (1<<3)
`define SVT_NOPRINT    (1<<5)
`define SVT_NORECORD   (1<<7)
`define SVT_NODEFPRINT (1<<16)
`define SVT_NOPACK     (1<<9)
`define SVT_PHYSICAL   (1<<13)
`define SVT_ABSTRACT   (1<<14)
`define SVT_READONLY   (1<<16)
`define SVT_ALL_ON     'b000010101010101
`define SVT_DEFAULT    'b000000101010101

// In cases where we are overriding the underlying routines for OVM but not for
// OVM/VMM, or for OVM but not for OVM/VMM, then the `SVT_VMM_<FEATURE> flags may be used
`ifdef SVT_OVM_TECHNOLOGY
 `define SVT_UVM_NOCOPY `SVT_NOCOPY
 `define SVT_VMM_NOCOPY 0
 `define SVT_UVM_NOCOMPARE `SVT_NOCOMPARE
 `define SVT_VMM_NOCOMPARE 0
 `define SVT_UVM_NOPRINT `SVT_NOPRINT
 `define SVT_VMM_NOPRINT 0
 `define SVT_UVM_NORECORD `SVT_NORECORD
 `define SVT_VMM_NORECORD 0
 `define SVT_UVM_NODEFPRINT `SVT_NODEFPRINT
 `define SVT_VMM_NODEFPRINT 0
 `define SVT_UVM_NOPACK `SVT_NOPACK
 `define SVT_VMM_NOPACK 0
`endif

`define SVT_BIN       'h1000000
`define SVT_DEC       'h2000000
`define SVT_UNSIGNED  'h3000000
`define SVT_OCT       'h4000000
`define SVT_HEX       'h5000000
`define SVT_STRING    'h6000000
`define SVT_TIME      'h7000000
`define SVT_ENUM      'h8000000

// Arguments that can be or'ed in to the FLAG.  Note that this only affects
// OVM.  To affect VMM, the third argument on the object field macros must be
// used.
`define SVT_DEEP      'h400
`define SVT_SHALLOW   'h800
`ifdef SVT_ENABLE_REFERENCE_NORECORD
// To allow for VIPs that haven't added NORECORD to their shorthand macros,
// automatically assume NORECORD if REFERENCE has been set.
`define SVT_REFERENCE 'h1000 | `SVT_NORECORD
`else
`define SVT_REFERENCE 'h1000
`endif

// VMM do_how_e enumerations affect how vmm_data based objects are compared
// and copied.  These arguments should be or'ed in to the third argument of
// the object field macros.
`define SVT_HOW_NOCOPY      'h001
`define SVT_HOW_REFCOPY     'h002
`define SVT_HOW_DEEPCOPY    'h004
`define SVT_HOW_TO_COPY     'h007
`define SVT_HOW_NOCOMPARE   'h008
`define SVT_HOW_REFCOMPARE  'h010
`define SVT_HOW_DEEPCOMPARE 'h020
`define SVT_HOW_TO_COMPARE  'h038
`define SVT_HOW_NONE        'h009
`define SVT_HOW_REF         'h012
`define SVT_HOW_DEEP        'h024

// Conversion to VMM automation flags
`define SVT_MAP_TO_VMM_AUTOMATION_FLAGS(value) \
 (DO_ALL & \
  (((value) & `SVT_NOPRINT) ? ~DO_PRINT : DO_ALL) & \
  (((value) & `SVT_NOCOPY) ? ~DO_COPY : DO_ALL) & \
  (((value) & `SVT_NOCOMPARE) ? ~DO_COMPARE : DO_ALL) & \
  (((value) & `SVT_NOPACK) ? ~(DO_PACK|DO_UNPACK) : DO_ALL)) \


// -------------------------------------------------------------------------
// Mapping of the OVM automation macros to a common SVT macro
// -------------------------------------------------------------------------

`define svt_data_member_begin(class_type) \
/** @cond SVDOC */ \
  `ovm_object_utils_begin(class_type)
 
`define svt_data_param_member_begin(class_type) \
/** @cond SVDOC */ \
  `ovm_object_param_utils_begin(class_type)
 
/**
 * Macro combining the ovm_object_utils_begin and ovm_object_param_utils_begin
 * macro features. Mostly modeled after ovm_object_utils_begin but also
 * designed to provide a 'non-parameterized' type name when registering the
 * object with the factory. This type name, and the type it is associated
 * with, corresponds to the 'default' parameterized object.
 */
`define svt_data_param_member_w_type_name_begin(class_type,class_type_no_params) \
/** @cond SVDOC */ \
  `ovm_object_registry_internal(class_type_no_params,class_type_no_params) \
  `ovm_object_create_func(class_type) \
  `ovm_get_type_name_func(class_type) \
  `ovm_field_utils_begin(class_type) 
 
`define svt_data_member_end(class_type) \
  `ovm_object_utils_end \
/** @endcond */

`define svt_field_real_begin \
`ifdef SVT_MULTI_SIM_REAL_COMPARE_TOO_PRECISE \
  if (what__ == OVM_COMPARE) begin \
    svt_sequence_item_base seq_item_base; \
    if ($cast(seq_item_base, this)) begin \
      seq_item_base.substitute_fuzzy_real_comparer(ovm_auto_options_object); \
    end \
  end \
`endif

`define svt_field_real_end \
`ifdef SVT_MULTI_SIM_REAL_COMPARE_TOO_PRECISE \
  if (what__ == OVM_COMPARE) begin \
    svt_sequence_item_base seq_item_base; \
    if ($cast(seq_item_base, this)) begin \
      seq_item_base.restore_real_comparer(ovm_auto_options_object); \
    end \
  end \
`endif

`define svt_field_real(ARG,FLAG) \
 `svt_field_real_begin \
 `ovm_field_real(ARG,FLAG) \
 `svt_field_real_end

`define svt_field_int(ARG,FLAG) \
 `ovm_field_int(ARG,FLAG)

`define svt_field_enum(T,ARG,FLAG) \
 `ovm_field_enum(T,ARG,FLAG)

`define svt_field_object(ARG,FLAG,HOW) \
 `ovm_field_object(ARG,FLAG)

`define svt_field_event(ARG,FLAG) \
 `ovm_field_event(ARG,FLAG)

`define svt_field_string(ARG,FLAG) \
 `ovm_field_string(ARG,FLAG)

`define svt_field_array_enum(T,ARG,FLAG) \
 `ovm_field_array_enum(T,ARG,FLAG)

`define svt_field_array_real(ARG,FLAG) \
 `ovm_field_array_real(ARG,FLAG)

`define svt_field_sarray_real(ARG,FLAG) \
 `ovm_field_sarray_real(ARG,FLAG)

`define svt_field_queue_real(ARG,FLAG) \
 `ovm_field_queue_real(ARG,FLAG)

`define svt_field_array_int(ARG,FLAG) \
 `ovm_field_array_int(ARG,FLAG)

`define svt_field_sarray_int(ARG,FLAG) \
 `ovm_field_sarray_int(ARG,FLAG)

`define svt_field_sarray_enum(T,ARG,FLAG) \
 `ovm_field_sarray_enum(T,ARG,FLAG)

`define svt_field_array_object(ARG,FLAG,HOW) \
 `ovm_field_array_object(ARG,FLAG)

`define svt_field_sarray_object(ARG,FLAG,HOW) \
 `ovm_field_sarray_object(ARG,FLAG)

`define svt_field_array_string(ARG,FLAG) \
 `ovm_field_array_string(ARG,FLAG)

`define svt_field_sarray_string(ARG,FLAG) \
 `ovm_field_sarray_string(ARG,FLAG)

`define svt_field_queue_enum(T,ARG,FLAG) \
 `ovm_field_queue_enum(T,ARG,FLAG)

`define svt_field_queue_int(ARG,FLAG) \
 `ovm_field_queue_int(ARG,FLAG)

`define svt_field_queue_object(ARG,FLAG,HOW) \
 `ovm_field_queue_object(ARG,FLAG)

`define svt_field_queue_string(ARG,FLAG) \
 `ovm_field_queue_string(ARG,FLAG)

`define svt_field_queue_handle(ARG,FLAG) \
 `ovm_field_queue_object(ARG, FLAG|OVM_REFERENCE)

`define svt_field_aa_int_string(ARG, FLAG) \
 `ovm_field_aa_int_string(ARG,FLAG)

`define svt_field_aa_string_string(ARG, FLAG) \
 `ovm_field_aa_string_string(ARG,FLAG)

`define svt_field_aa_object_string(ARG, FLAG, HOW) \
 `ovm_field_aa_object_string(ARG,FLAG)

`define svt_field_aa_int_int(ARG, FLAG) \
 `ovm_field_aa_int_int(ARG, FLAG)

`define svt_field_aa_int_int_unsigned(ARG, FLAG) \
 `ovm_field_aa_int_int_unsigned(ARG, FLAG)

`define svt_field_aa_int_integer(ARG, FLAG) \
 `ovm_field_aa_int_integer(ARG, FLAG)

`define svt_field_aa_int_integer_unsigned(ARG, FLAG) \
 `ovm_field_aa_int_integer_unsigned(ARG, FLAG)

`define svt_field_aa_int_byte(ARG, FLAG) \
 `ovm_field_aa_int_byte(ARG, FLAG)

`define svt_field_aa_int_byte_unsigned(ARG, FLAG) \
 `ovm_field_aa_int_byte_unsigned(ARG, FLAG)

`define svt_field_aa_int_shortint(ARG, FLAG) \
 `ovm_field_aa_int_shortint(ARG, FLAG)

`define svt_field_aa_int_shortint_unsigned(ARG, FLAG) \
 `ovm_field_aa_int_shortint_unsigned(ARG, FLAG)

`define svt_field_aa_int_longint(ARG, FLAG) \
 `ovm_field_aa_int_longint(ARG, FLAG)

`define svt_field_aa_int_longint_unsigned(ARG, FLAG) \
 `ovm_field_aa_string_int(ARG, FLAG)

`define svt_field_aa_int_key(KEY, ARG, FLAG) \
 `ovm_field_aa_int_key(KEY, ARG, FLAG)

`define svt_field_aa_string_int(ARG, FLAG) \
 `ovm_field_aa_string_int(ARG, FLAG)

`define svt_field_aa_object_int(ARG, FLAG, HOW) \
 `ovm_field_aa_object_int(ARG, FLAG)

`define svt_field_handle(ARG,FLAG) \
 `ovm_field_object(ARG,FLAG|OVM_REFERENCE)

`define svt_field_handle_sarray(ARG,FLAG) \
 `ovm_field_sarray_object(ARG,FLAG|OVM_REFERENCE)

`define svt_field_handle_array(ARG,FLAG) \
 `ovm_field_array_object(ARG,FLAG|OVM_REFERENCE)

`define svt_field_handle_aa_int(ARG,FLAG) \
 `ovm_field_aa_object_int(ARG, FLAG|OVM_REFERENCE)

`define svt_field_handle_aa_string(ARG,FLAG) \
 `ovm_field_aa_object_string(ARG, FLAG|OVM_REFERENCE)

// -------------------------------------------------------------------------
// Mapping of the OVM sequence macros to a common SVT macro
// -------------------------------------------------------------------------

// OVM Sequence Macros
// The first set of macros rely solely on the OVM provided macros. The second set
// collapse the OVM macros to improved the compile times.
`ifdef SVT_OVM_UTIL_DISABLE_SEQ_MACRO_ACCEL
`define svt_xvm_create(SEQ_OR_ITEM) `ovm_create(SEQ_OR_ITEM)
`define svt_xvm_do(SEQ_OR_ITEM) `ovm_do(SEQ_OR_ITEM)
`define svt_xvm_do_pri(SEQ_OR_ITEM, PRIORITY) `ovm_do_pri(SEQ_OR_ITEM, PRIORITY)
`define svt_xvm_do_with(SEQ_OR_ITEM, CONSTRAINTS) `ovm_do_with(SEQ_OR_ITEM, CONSTRAINTS)
`define svt_xvm_do_pri_with(SEQ_OR_ITEM, PRIORITY, CONSTRAINTS) `ovm_do_pri_with(SEQ_OR_ITEM, PRIORITY, CONSTRAINTS)
`define svt_xvm_create_on(SEQ_OR_ITEM, SEQR) `ovm_create_on(SEQ_OR_ITEM, SEQR)
`define svt_xvm_do_on(SEQ_OR_ITEM, SEQR) `ovm_do_on(SEQ_OR_ITEM, SEQR)
`define svt_xvm_do_on_pri(SEQ_OR_ITEM, SEQR, PRIORITY) `ovm_do_on_pri(SEQ_OR_ITEM, SEQR, PRIORITY)
`define svt_xvm_do_on_with(SEQ_OR_ITEM, SEQR, CONSTRAINTS) `ovm_do_on_with(SEQ_OR_ITEM, SEQR, CONSTRAINTS)
`define svt_xvm_do_on_pri_with(SEQ_OR_ITEM, SEQR, PRIORITY, CONSTRAINTS) `ovm_do_on_pri_with(SEQ_OR_ITEM, SEQR, PRIORITY, CONSTRAINTS)
`define svt_xvm_send(SEQ_OR_ITEM) `ovm_send(SEQ_OR_ITEM)
`define svt_xvm_send_pri(SEQ_OR_ITEM, PRIORITY) `ovm_send_pri(SEQ_OR_ITEM, PRIORITY)
`define svt_xvm_rand_send(SEQ_OR_ITEM) `ovm_rand_send(SEQ_OR_ITEM)
`define svt_xvm_rand_send_pri(SEQ_OR_ITEM, PRIORITY) `ovm_rand_send_pri(SEQ_OR_ITEM, PRIORITY)
`define svt_xvm_rand_send_with(SEQ_OR_ITEM, CONSTRAINTS) `ovm_rand_send_with(SEQ_OR_ITEM, CONSTRAINTS)
`define svt_xvm_rand_send_pri_with(SEQ_OR_ITEM, PRIORITY, CONSTRAINTS) `ovm_rand_send_pri_with(SEQ_OR_ITEM, PRIORITY, CONSTRAINTS)
`else
`define svt_xvm_create(SEQ_OR_ITEM) \
  `svt_xvm_create_on(SEQ_OR_ITEM, m_sequencer)
`define svt_xvm_do(SEQ_OR_ITEM) \
  `svt_xvm_do_on_pri(SEQ_OR_ITEM, m_sequencer, -1)
`define svt_xvm_do_pri(SEQ_OR_ITEM, PRIORITY) \
  `svt_xvm_do_on_pri(SEQ_OR_ITEM, m_sequencer, PRIORITY)
`define svt_xvm_do_with(SEQ_OR_ITEM, CONSTRAINTS) \
  `svt_xvm_do_on_pri_with(SEQ_OR_ITEM, m_sequencer, -1, CONSTRAINTS)
`define svt_xvm_do_pri_with(SEQ_OR_ITEM, PRIORITY, CONSTRAINTS) \
  `svt_xvm_do_on_pri_with(SEQ_OR_ITEM, m_sequencer, PRIORITY, CONSTRAINTS)
`define svt_xvm_create_on(SEQ_OR_ITEM, SEQR) \
  $cast(SEQ_OR_ITEM, create_item(SEQ_OR_ITEM.get_type(), SEQR, `"SEQ_OR_ITEM`"));
`define svt_xvm_do_on(SEQ_OR_ITEM, SEQR) \
  `svt_xvm_do_on_pri(SEQ_OR_ITEM, SEQR, -1)
`define svt_xvm_do_on_pri(SEQ_OR_ITEM, SEQR, PRIORITY) \
  begin \
    `svt_xvm_create_on(SEQ_OR_ITEM, SEQR) \
    SEQ_OR_ITEM.priority_start(this, PRIORITY); \
    if (!SEQ_OR_ITEM.randomize()) \
      `svt_xvm_warning("RNDFLD", "Randomization failed in ovm_do_on action") \
    SEQ_OR_ITEM.priority_finish(this, PRIORITY); \
  end
`define svt_xvm_do_on_with(SEQ_OR_ITEM, SEQR, CONSTRAINTS) \
  `svt_xvm_do_on_pri_with(SEQ_OR_ITEM, SEQR, -1, CONSTRAINTS)
`define svt_xvm_do_on_pri_with(SEQ_OR_ITEM, SEQR, PRIORITY, CONSTRAINTS) \
  begin \
    `svt_xvm_create_on(SEQ_OR_ITEM, SEQR) \
    SEQ_OR_ITEM.priority_start(this, PRIORITY); \
    if (!SEQ_OR_ITEM.randomize() with CONSTRAINTS ) \
      `svt_xvm_warning("RNDFLD", "Randomization failed in ovm_do_with action") \
    SEQ_OR_ITEM.priority_finish(this, PRIORITY); \
  end
`define svt_xvm_send(SEQ_OR_ITEM) \
  `svt_xvm_send_pri(SEQ_OR_ITEM, -1)
`define svt_xvm_send_pri(SEQ_OR_ITEM, PRIORITY) \
  SEQ_OR_ITEM.priority_start(this, PRIORITY); \
  SEQ_OR_ITEM.priority_finish(this, PRIORITY);
`define svt_xvm_rand_send(SEQ_OR_ITEM) \
  `svt_xvm_rand_send_pri(SEQ_OR_ITEM, -1)
`define svt_xvm_rand_send_pri(SEQ_OR_ITEM, PRIORITY) \
  begin \
    SEQ_OR_ITEM.priority_start(this, PRIORITY); \
    if (!SEQ_OR_ITEM.randomize()) \
      `svt_xvm_warning("RNDFLD", "Randomization failed in ovm_rand_send action") \
    SEQ_OR_ITEM.priority_finish(this, PRIORITY); \
  end
`define svt_xvm_rand_send_with(SEQ_OR_ITEM, CONSTRAINTS) \
  `svt_xvm_rand_send_pri_with(SEQ_OR_ITEM, -1, CONSTRAINTS)
`define svt_xvm_rand_send_pri_with(SEQ_OR_ITEM, PRIORITY, CONSTRAINTS) \
  begin \
    SEQ_OR_ITEM.priority_start(this, PRIORITY); \
    if (!SEQ_OR_ITEM.randomize() with CONSTRAINTS ) \
      `svt_xvm_warning("RNDFLD", "Randomization failed in ovm_rand_send_with action") \
    SEQ_OR_ITEM.priority_finish(this, PRIORITY); \
  end
`endif

// For these two macros, since they are only called in situations where there are no
// fields to be copied, compared, etc., we exclude the field utility macros from
// what we provide. Clients needing field utility macro support should use the
// begin/end macros instead of the combined macros.
`define svt_xvm_object_utils(T) \
   `ovm_object_registry_internal(T,T)  \
   `ovm_object_create_func(T) \
   `ovm_get_type_name_func(T)
`define svt_xvm_object_param_utils(T) \
   `ovm_object_registry_param(T)  \
   `ovm_object_create_func(T)

// Common OVM Macros used by data objects, sequences, and other structures shared with UVM
`define svt_xvm_object_utils_begin(T) `ovm_object_utils_begin(T)
`define svt_xvm_object_param_utils_begin(T) `ovm_object_param_utils_begin(T) 
`define svt_xvm_object_utils_end `ovm_object_utils_end
`define svt_xvm_component_utils(T) `ovm_component_utils(T)
`define svt_xvm_component_param_utils(T) `ovm_component_param_utils(T)
`define svt_xvm_component_utils_begin(T) `ovm_component_utils_begin(T)
`define svt_xvm_component_param_utils_begin(T) `ovm_component_param_utils_begin(T)
`define svt_xvm_component_utils_end `ovm_component_utils_end
`define svt_xvm_declare_p_sequencer(SEQUENCER) `ovm_declare_p_sequencer(SEQUENCER)
`define svt_xvm_field_int(ARG,FLAG) `ovm_field_int(ARG,FLAG)
`define svt_xvm_field_queue_int(ARG,FLAG) `ovm_field_queue_int(ARG,FLAG)
`define svt_xvm_field_object(ARG,FLAG) `ovm_field_object(ARG,FLAG)
`define svt_xvm_field_array_object(ARG,FLAG) `ovm_field_array_object(ARG,FLAG)
`define SVT_XVM_ALL_ON OVM_ALL_ON
`define SVT_XVM_REFERENCE OVM_REFERENCE

// -------------------------------------------------------------------------
// Useful TLM Macros
// -------------------------------------------------------------------------

/**
 * Macro used to declare a blocking put imp that supports an 'index' argument to the 'write'.
 * The implementation object must provide the 'put_<SFX>' method, which must include the
 * additional 'ix' parameter. The client constructing the '_imp' instance must set the 'imp_ix'
 * value post construction and prior to any 'put' attempt.
 * Modeled after 'ovm_blocking_put_imp_decl'.
 */
`define svt_xvm_ix_blocking_put_imp_decl(SFX) \
class ovm_blocking_put_imp``SFX #(type T=int, type IMP=int) \
  extends ovm_port_base #(tlm_if_base #(T,T)); \
  int imp_ix = 0; \
  `OVM_IMP_COMMON(`TLM_BLOCKING_PUT_MASK,`"ovm_blocking_put_imp``SFX`",IMP) \
  task put(input T t); \
    m_imp.put``SFX(imp_ix, t); \
  endtask \
  \
endclass

/**
 * Macro used to declare an analysis imp that supports an 'index' argument to the 'write'.
 * The implementation object must provide the 'write_<SFX>' method, which must include the
 * additional 'ix' parameter. The client constructing the '_imp' instance must set the 'imp_ix'
 * value post construction and prior to any 'write' attempt.
 * Modeled after 'ovm_analysis_imp_decl'.
 */
`define svt_xvm_ix_analysis_imp_decl(SFX) \
class ovm_analysis_imp``SFX #(type T=int, type IMP=int) \
  extends ovm_port_base #(tlm_if_base #(T,T)); \
  int imp_ix = 0; \
  `OVM_IMP_COMMON(`TLM_ANALYSIS_MASK,`"ovm_analysis_imp``SFX`",IMP) \
  function void write( input T t); \
    m_imp.write``SFX(imp_ix, t); \
  endfunction \
  \
endclass

// -------------------------------------------------------------------------
// Common Event/Notify Macros
// -------------------------------------------------------------------------

/** Macro used to declare a notification event instance for the current methodology */
`define svt_decl_event(evname) \
  ovm_event evname;

/** Macro used to create a notification event instance for the current methodology */
`define svt_create_event(evname,evtype) \
  /* Just drop the evtype */ \
  evname = new(`SVT_DATA_UTIL_ARG_TO_STRING(evname));

/** Macro used to create a notification event instance in the indicated pool for the current methodology */
`define svt_create_pool_event(evpool,evname,evtype) \
  /* Just drop the evtype */ \
  evname = evpool.get(`SVT_DATA_UTIL_ARG_TO_STRING(evname));

/** Macro used to signal a notification event for the current methodology */
`define svt_trigger_event(evowner,evname) \
  evowner.evname.trigger();

/** Macro used to signal a notification event and corresponding data for the current methodology */
`define svt_trigger_data_event(evowner,evname,evdata) \
  evowner.evname.trigger(evdata);

/** Macro used to signal a notification event and corresponding data for the current methodology, but with a 'copy' of the original data */
`define svt_trigger_copy_data_event(evowner,evname,evdata) \
  evowner.evname.trigger(evdata.clone());

/** Macro used to check the is_on state for a notification event in the current methodology. */
`define svt_event_is_on(evowner,evname) \
  evowner.evname.is_on()

/** Macro used to wait for a notification event in the current methodology */
`define svt_wait_event_trigger(evowner,evname) \
  evowner.evname.wait_trigger();

/** Macro used to wait for a 'persistent' notification event in the current methodology */
`define svt_wait_event_ptrigger(evowner,evname) \
  evowner.evname.wait_ptrigger();

/** Macro used to wait for an 'on' notification event in the current methodology */
`define svt_wait_event_on(evowner,evname) \
  evowner.evname.wait_on();

/** Macro used to wait for an 'off' notification event in the current methodology */
`define svt_wait_event_off(evowner,evname) \
  evowner.evname.wait_off();

/** Macro used to use the notification event accessor function for the current methodology to retrieve the status for the notification event */
`define svt_event_status(evowner,evname) \
  evowner.evname.get_trigger_data()

/** Macro used to get the notification event status */
`define svt_get_event_status(evowner,evname,evstatus) \
  evstatus = `svt_event_status(evowner,evname);

/** Macro used to reset a notification event in the current methodology */
`define svt_reset_event(evowner,evname) \
  /* Only request the wakeup if the event is currently on */ \
  evowner.evname.reset(evowner.evname.is_on());

// -------------------------------------------------------------------------
// Common Event/Notify Macros for working with named events
// -------------------------------------------------------------------------

/** Macro used to create a named notification event instance for the current methodology */
`define svt_create_named_event(evowner,evname,evtype) \
  evowner.evname = evowner.event_pool.get(`SVT_DATA_UTIL_ARG_TO_STRING(evname));

/** Macro used to signal a named notification event for the current methodology */
`define svt_trigger_named_event(evowner,evname) \
  svt_event_pool::trigger_event(evowner.event_pool, `SVT_DATA_UTIL_ARG_TO_STRING(evname));

/** Macro used to signal a named notification event and corresponding data for the current methodology */
`define svt_trigger_named_data_event(evowner,evname,evdata) \
  svt_event_pool::trigger_event(evowner.event_pool, `SVT_DATA_UTIL_ARG_TO_STRING(evname), evdata);

/** Macro used to signal a named notification event and corresponding data for the current methodology, but with a 'copy' of the original data */
`define svt_trigger_named_copy_data_event(evowner,evname,evdata) \
  svt_event_pool::trigger_event(evowner.event_pool, `SVT_DATA_UTIL_ARG_TO_STRING(evname), evdata.clone());

/** Macro used to check the is_on state for a named notification event in the current methodology. */
`define svt_get_named_event_is_on(evowner,evname,ison) \
  ison = svt_event_pool::get_event_is_on(evowner.event_pool, `SVT_DATA_UTIL_ARG_TO_STRING(evname));

/** Macro used to wait for a named notification event in the current methodology */
`define svt_wait_named_event_trigger(evowner,evname) \
  svt_event_pool::wait_event_trigger(evowner.event_pool, `SVT_DATA_UTIL_ARG_TO_STRING(evname));

/** Macro used to wait for an 'on' named notification event in the current methodology */
`define svt_wait_named_event_on(evowner,evname) \
  svt_event_pool::wait_event_on(evowner.event_pool, `SVT_DATA_UTIL_ARG_TO_STRING(evname));

/** Macro used to wait for an 'off' named notification event in the current methodology */
`define svt_wait_named_event_off(evowner,evname) \
  svt_event_pool::wait_event_off(evowner.event_pool, `SVT_DATA_UTIL_ARG_TO_STRING(evname));

/** Macro used to get the named notification event status */
`define svt_get_named_event_status(evowner,evname,evstatus) \
  evstatus = svt_event_pool::get_event_trigger_data(evowner.event_pool, `SVT_DATA_UTIL_ARG_TO_STRING(evname));

/** Macro used to reset a named notification event in the current methodology */
`define svt_reset_named_event(evowner,evname) \
  svt_event_pool::reset_event(evowner.event_pool, `SVT_DATA_UTIL_ARG_TO_STRING(evname));

`endif // GUARD_SVT_OVM_UTIL_SVI
