
`ifndef GUARD_SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_SVI
`define GUARD_SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_SVI

/** @cond PRIVATE */

//======================================================================
// Transaction level coverage macros 
//====================================================================== 
`define SVT_AXI_MAX_SIZED_1         1024'b0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_TRANS_SET_INST_NAME(group_name) \
   group_name.set_inst_name($sformatf("%0s_%0s", cfg.inst, `SVT_DATA_UTIL_ARG_TO_STRING(group_name)));
    
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_FUNCTION_COV_SAMPLE_SET_NAME(cover_point,dependency,port_kind,signal_1,signal_2,cov_dependency_event) \
  function void svt_axi_port_monitor_def_cov_callback::cov_sample_``dependency (); \
    int count = 0; \
    if(port_kind == svt_axi_port_configuration::AXI_MASTER) begin \
      if(cfg.master_if != null) begin \
        if(cfg.master_if.``signal_2) begin \
          fork \
            wait(!cfg.master_if.``signal_2); \
            for(int i = 0; i < cfg.cov_num_clks_``dependency; i++) begin \
              @(posedge cfg.master_if.internal_aclk);\
              if(cfg.master_if.``signal_1 == 0) begin \
                count++; \
              end \
              else\
                break; \
              if(count == cfg.cov_num_clks_``dependency) \
                cov_``cover_point =  1; \
              else \
                cov_``cover_point =  0; \
            end \
            ->``cov_dependency_event; \
          join_none \
        end \
      end \
    end \
    if(port_kind == svt_axi_port_configuration::AXI_SLAVE) begin \
      if(cfg.slave_if != null) begin \
        if(cfg.slave_if.``signal_2) begin \
          fork \
            wait(!cfg.slave_if.``signal_2); \
            for(int i = 0; i < cfg.cov_num_clks_``dependency; i++) begin \
              @(posedge cfg.slave_if.internal_aclk);\
              if(cfg.slave_if.``signal_1 == 0) begin \
                count++; \
              end \
              else\
                break; \
              if(count == cfg.cov_num_clks_``dependency) \
                cov_``cover_point =  1; \
              else \
                cov_``cover_point =  0; \
            end \
            ->``cov_dependency_event; \
          join_none \
        end \
      end \
    end \
  endfunction \

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_COHERENT_READ_XACT_TYPE \
  coherent_read_xact_type : coverpoint cov_item.coherent_xact_type iff(cov_coherent_xact_type_flag){ \
    bins coherent_readnosnoop_xact   = {svt_axi_transaction::READNOSNOOP}; \
    bins coherent_readonce_xact   = {svt_axi_transaction::READONCE}; \
    bins coherent_readshared_xact   = {svt_axi_transaction::READSHARED}; \
    bins coherent_readclean_xact   = {svt_axi_transaction::READCLEAN}; \
    bins coherent_readnotshareddirty_xact   = {svt_axi_transaction::READNOTSHAREDDIRTY}; \
    bins coherent_readunique_xact   = {svt_axi_transaction::READUNIQUE}; \
    bins coherent_cleanunique_xact   = {svt_axi_transaction::CLEANUNIQUE}; \
    bins coherent_makeunique_xact   = {svt_axi_transaction::MAKEUNIQUE}; \
    bins coherent_cleanshared_xact   = {svt_axi_transaction::CLEANSHARED}; \
`ifdef SVT_ACE5_ENABLE \
    bins coherent_cleansharedpersist_xact = {svt_axi_transaction::CLEANSHAREDPERSIST}; \
`endif \
    bins coherent_cleaninvalid_xact   = {svt_axi_transaction::CLEANINVALID}; \
    bins coherent_makeinvalid_xact   = {svt_axi_transaction::MAKEINVALID}; \
    bins coherent_dvmcomplete_xact   = {svt_axi_transaction::DVMCOMPLETE}; \
    bins coherent_dvmmessage_xact   = {svt_axi_transaction::DVMMESSAGE}; \
    bins coherent_readbarrier_xact   = {svt_axi_transaction::READBARRIER}; \
    ignore_bins ignore_coh_read_xact_ace_lite = {svt_axi_transaction::READCLEAN,svt_axi_transaction::READNOTSHAREDDIRTY, \
                                                 svt_axi_transaction::READUNIQUE,svt_axi_transaction::CLEANUNIQUE, \
                                                 svt_axi_transaction::MAKEUNIQUE,svt_axi_transaction::READSHARED, \
                                                 svt_axi_transaction::DVMCOMPLETE,svt_axi_transaction::DVMMESSAGE} \
                                                   iff(cfg.axi_interface_type == svt_axi_port_configuration::ACE_LITE); \
    ignore_bins ignore_barrier       = {svt_axi_transaction::READBARRIER} iff(cfg.barrier_enable == 1'b0); \
    ignore_bins ignore_dvm       = {svt_axi_transaction::DVMMESSAGE,svt_axi_transaction::DVMCOMPLETE} iff(cfg.dvm_enable == 1'b0); \
    option.weight = 1; \
  }
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_COHERENT_READ_XACT_TYPE_NO_DVM_NO_BARRIER_NO_READNOSNOOP \
  coherent_read_xact_type : coverpoint master_coherent_xact_type { \
    bins coherent_readonce_xact   = {svt_axi_transaction::READONCE}; \
    bins coherent_readshared_xact   = {svt_axi_transaction::READSHARED}; \
    bins coherent_readclean_xact   = {svt_axi_transaction::READCLEAN}; \
    bins coherent_readnotshareddirty_xact   = {svt_axi_transaction::READNOTSHAREDDIRTY}; \
    bins coherent_readunique_xact   = {svt_axi_transaction::READUNIQUE}; \
    bins coherent_cleanunique_xact   = {svt_axi_transaction::CLEANUNIQUE}; \
    bins coherent_makeunique_xact   = {svt_axi_transaction::MAKEUNIQUE}; \
    bins coherent_cleanshared_xact   = {svt_axi_transaction::CLEANSHARED}; \
    `ifdef SVT_ACE5_ENABLE \
    bins coherent_cleansharedpersist_xact = {svt_axi_transaction::CLEANSHAREDPERSIST}; \
     `endif \
    bins coherent_cleaninvalid_xact   = {svt_axi_transaction::CLEANINVALID}; \
    bins coherent_makeinvalid_xact   = {svt_axi_transaction::MAKEINVALID}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_SLAVE_PORT_ID \
  slave_port_id : coverpoint slave_id { \
    bins slave_id[] = {[0 : (num_slaves - 1)]}; \
  }

`ifdef SVT_AXI_MON_CFG_BASED_COV_GRP_DEF
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_COHERENT_READ_XACT_TYPE_DVM_UNSET_BARRIER_SET \
  coherent_read_xact_type : coverpoint cov_item.coherent_xact_type iff(cov_coherent_xact_type_flag){ \
    bins coherent_readnosnoop_xact   = {svt_axi_transaction::READNOSNOOP}; \
    bins coherent_readonce_xact   = {svt_axi_transaction::READONCE}; \
    bins coherent_readshared_xact   = {svt_axi_transaction::READSHARED}; \
    bins coherent_readclean_xact   = {svt_axi_transaction::READCLEAN}; \
    bins coherent_readnotshareddirty_xact   = {svt_axi_transaction::READNOTSHAREDDIRTY}; \
    bins coherent_readunique_xact   = {svt_axi_transaction::READUNIQUE}; \
    bins coherent_cleanunique_xact   = {svt_axi_transaction::CLEANUNIQUE}; \
    bins coherent_makeunique_xact   = {svt_axi_transaction::MAKEUNIQUE}; \
    bins coherent_cleanshared_xact   = {svt_axi_transaction::CLEANSHARED}; \
    `ifdef SVT_ACE5_ENABLE \
    bins coherent_cleansharedpersist_xact = {svt_axi_transaction::CLEANSHAREDPERSIST}; \
     `endif \
    bins coherent_cleaninvalid_xact   = {svt_axi_transaction::CLEANINVALID}; \
    bins coherent_makeinvalid_xact   = {svt_axi_transaction::MAKEINVALID}; \
    bins coherent_readbarrier_xact   = {svt_axi_transaction::READBARRIER}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_COHERENT_READ_XACT_TYPE_DVM_UNSET_BARRIER_UNSET \
  coherent_read_xact_type : coverpoint cov_item.coherent_xact_type iff(cov_coherent_xact_type_flag){ \
    bins coherent_readnosnoop_xact   = {svt_axi_transaction::READNOSNOOP}; \
    bins coherent_readonce_xact   = {svt_axi_transaction::READONCE}; \
    bins coherent_readshared_xact   = {svt_axi_transaction::READSHARED}; \
    bins coherent_readclean_xact   = {svt_axi_transaction::READCLEAN}; \
    bins coherent_readnotshareddirty_xact   = {svt_axi_transaction::READNOTSHAREDDIRTY}; \
    bins coherent_readunique_xact   = {svt_axi_transaction::READUNIQUE}; \
    bins coherent_cleanunique_xact   = {svt_axi_transaction::CLEANUNIQUE}; \
    bins coherent_makeunique_xact   = {svt_axi_transaction::MAKEUNIQUE}; \
    bins coherent_cleanshared_xact   = {svt_axi_transaction::CLEANSHARED}; \
     `ifdef SVT_ACE5_ENABLE \
    bins coherent_cleansharedpersist_xact = {svt_axi_transaction::CLEANSHAREDPERSIST}; \
     `endif \
   bins coherent_cleaninvalid_xact   = {svt_axi_transaction::CLEANINVALID}; \
    bins coherent_makeinvalid_xact   = {svt_axi_transaction::MAKEINVALID}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_COHERENT_READ_XACT_TYPE_DVM_SET_BARRIER_UNSET \
  coherent_read_xact_type : coverpoint cov_item.coherent_xact_type iff(cov_coherent_xact_type_flag){ \
    bins coherent_readnosnoop_xact   = {svt_axi_transaction::READNOSNOOP}; \
    bins coherent_readonce_xact   = {svt_axi_transaction::READONCE}; \
    bins coherent_readshared_xact   = {svt_axi_transaction::READSHARED}; \
    bins coherent_readclean_xact   = {svt_axi_transaction::READCLEAN}; \
    bins coherent_readnotshareddirty_xact   = {svt_axi_transaction::READNOTSHAREDDIRTY}; \
    bins coherent_readunique_xact   = {svt_axi_transaction::READUNIQUE}; \
    bins coherent_cleanunique_xact   = {svt_axi_transaction::CLEANUNIQUE}; \
    bins coherent_makeunique_xact   = {svt_axi_transaction::MAKEUNIQUE}; \
    bins coherent_cleanshared_xact   = {svt_axi_transaction::CLEANSHARED}; \
     `ifdef SVT_ACE5_ENABLE \
    bins coherent_cleansharedpersist_xact = {svt_axi_transaction::CLEANSHAREDPERSIST}; \
     `endif \
   bins coherent_cleaninvalid_xact   = {svt_axi_transaction::CLEANINVALID}; \
    bins coherent_makeinvalid_xact   = {svt_axi_transaction::MAKEINVALID}; \
    bins coherent_dvmcomplete_xact   = {svt_axi_transaction::DVMCOMPLETE}; \
    bins coherent_dvmmessage_xact   = {svt_axi_transaction::DVMMESSAGE}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_COHERENT_READ_XACT_TYPE_DVM_SET_BARRIER_SET \
  coherent_read_xact_type : coverpoint cov_item.coherent_xact_type iff(cov_coherent_xact_type_flag){ \
    bins coherent_readnosnoop_xact   = {svt_axi_transaction::READNOSNOOP}; \
    bins coherent_readonce_xact   = {svt_axi_transaction::READONCE}; \
    bins coherent_readshared_xact   = {svt_axi_transaction::READSHARED}; \
    bins coherent_readclean_xact   = {svt_axi_transaction::READCLEAN}; \
    bins coherent_readnotshareddirty_xact   = {svt_axi_transaction::READNOTSHAREDDIRTY}; \
    bins coherent_readunique_xact   = {svt_axi_transaction::READUNIQUE}; \
    bins coherent_cleanunique_xact   = {svt_axi_transaction::CLEANUNIQUE}; \
    bins coherent_makeunique_xact   = {svt_axi_transaction::MAKEUNIQUE}; \
    bins coherent_cleanshared_xact   = {svt_axi_transaction::CLEANSHARED}; \
     `ifdef SVT_ACE5_ENABLE \
    bins coherent_cleansharedpersist_xact = {svt_axi_transaction::CLEANSHAREDPERSIST}; \
     `endif \
   bins coherent_cleaninvalid_xact   = {svt_axi_transaction::CLEANINVALID}; \
    bins coherent_makeinvalid_xact   = {svt_axi_transaction::MAKEINVALID}; \
    bins coherent_dvmcomplete_xact   = {svt_axi_transaction::DVMCOMPLETE}; \
    bins coherent_dvmmessage_xact   = {svt_axi_transaction::DVMMESSAGE}; \
    bins coherent_readbarrier_xact   = {svt_axi_transaction::READBARRIER}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_COHERENT_READ_XACT_TYPE_ACE_LITE_DVM_UNSET_BARRIER_SET \
  coherent_read_xact_type : coverpoint cov_item.coherent_xact_type iff(cov_coherent_xact_type_flag){ \
    bins coherent_readnosnoop_xact   = {svt_axi_transaction::READNOSNOOP}; \
    bins coherent_readonce_xact   = {svt_axi_transaction::READONCE}; \
    bins coherent_cleanshared_xact   = {svt_axi_transaction::CLEANSHARED}; \
    `ifdef SVT_ACE5_ENABLE \
    bins coherent_cleansharedpersist_xact = {svt_axi_transaction::CLEANSHAREDPERSIST}; \
     `endif \
    bins coherent_cleaninvalid_xact   = {svt_axi_transaction::CLEANINVALID}; \
    bins coherent_makeinvalid_xact   = {svt_axi_transaction::MAKEINVALID}; \
    bins coherent_readbarrier_xact   = {svt_axi_transaction::READBARRIER}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_COHERENT_READ_XACT_TYPE_ACE_LITE_DVM_UNSET_BARRIER_UNSET \
  coherent_read_xact_type : coverpoint cov_item.coherent_xact_type iff(cov_coherent_xact_type_flag){ \
    bins coherent_readnosnoop_xact   = {svt_axi_transaction::READNOSNOOP}; \
    bins coherent_readonce_xact   = {svt_axi_transaction::READONCE}; \
    bins coherent_cleanshared_xact   = {svt_axi_transaction::CLEANSHARED}; \
    `ifdef SVT_ACE5_ENABLE \
    bins coherent_cleansharedpersist_xact = {svt_axi_transaction::CLEANSHAREDPERSIST}; \
     `endif \
    bins coherent_cleaninvalid_xact   = {svt_axi_transaction::CLEANINVALID}; \
    bins coherent_makeinvalid_xact   = {svt_axi_transaction::MAKEINVALID}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_COHERENT_READ_XACT_TYPE_ACE_LITE_DVM_SET_BARRIER_SET \
  coherent_read_xact_type : coverpoint cov_item.coherent_xact_type iff(cov_coherent_xact_type_flag){ \
    bins coherent_readnosnoop_xact   = {svt_axi_transaction::READNOSNOOP}; \
    bins coherent_readonce_xact   = {svt_axi_transaction::READONCE}; \
    bins coherent_cleanshared_xact   = {svt_axi_transaction::CLEANSHARED}; \
     `ifdef SVT_ACE5_ENABLE \
    bins coherent_cleansharedpersist_xact = {svt_axi_transaction::CLEANSHAREDPERSIST}; \
     `endif \
   bins coherent_cleaninvalid_xact   = {svt_axi_transaction::CLEANINVALID}; \
    bins coherent_makeinvalid_xact   = {svt_axi_transaction::MAKEINVALID}; \
    bins coherent_readbarrier_xact   = {svt_axi_transaction::READBARRIER}; \
    bins coherent_dvmmessage_xact   = {svt_axi_transaction::DVMMESSAGE}; \
    bins coherent_readbarrier_xact   = {svt_axi_transaction::READBARRIER}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_COHERENT_READ_XACT_TYPE_ACE_LITE_DVM_SET_BARRIER_UNSET \
  coherent_read_xact_type : coverpoint cov_item.coherent_xact_type iff(cov_coherent_xact_type_flag){ \
    bins coherent_readnosnoop_xact   = {svt_axi_transaction::READNOSNOOP}; \
    bins coherent_readonce_xact   = {svt_axi_transaction::READONCE}; \
    bins coherent_cleanshared_xact   = {svt_axi_transaction::CLEANSHARED}; \
    `ifdef SVT_ACE5_ENABLE \
    bins coherent_cleansharedpersist_xact = {svt_axi_transaction::CLEANSHAREDPERSIST}; \
     `endif \
    bins coherent_cleaninvalid_xact   = {svt_axi_transaction::CLEANINVALID}; \
    bins coherent_makeinvalid_xact   = {svt_axi_transaction::MAKEINVALID}; \
    bins coherent_dvmmessage_xact   = {svt_axi_transaction::DVMMESSAGE}; \
    bins coherent_dvmcomplete_xact  = {svt_axi_transaction::DVMCOMPLETE}; \
    bins coherent_readbarrier_xact   = {svt_axi_transaction::READBARRIER}; \
    option.weight = 1; \
  }
 
 `define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_COHERENT_READ_XACT_TYPE_DEF \
  coherent_read_xact_type : coverpoint cov_item.coherent_xact_type iff(cov_coherent_xact_type_flag){ \
    bins coherent_readnosnoop_xact   = {svt_axi_transaction::READNOSNOOP}; \
    bins coherent_readonce_xact   = {svt_axi_transaction::READONCE}; \
    bins coherent_readshared_xact   = {svt_axi_transaction::READSHARED}; \
    bins coherent_readclean_xact   = {svt_axi_transaction::READCLEAN}; \
    bins coherent_readnotshareddirty_xact   = {svt_axi_transaction::READNOTSHAREDDIRTY}; \
    bins coherent_readunique_xact   = {svt_axi_transaction::READUNIQUE}; \
    bins coherent_cleanunique_xact   = {svt_axi_transaction::CLEANUNIQUE}; \
    bins coherent_makeunique_xact   = {svt_axi_transaction::MAKEUNIQUE}; \
    bins coherent_cleanshared_xact   = {svt_axi_transaction::CLEANSHARED}; \
    `ifdef SVT_ACE5_ENABLE \
    bins coherent_cleansharedpersist_xact = {svt_axi_transaction::CLEANSHAREDPERSIST}; \
     `endif \
    bins coherent_cleaninvalid_xact   = {svt_axi_transaction::CLEANINVALID}; \
    bins coherent_makeinvalid_xact   = {svt_axi_transaction::MAKEINVALID}; \
    option.weight = 1; \
  }
`endif


`ifdef SVT_ACE5_ENABLE
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_STREAM_ID \
   stream_id : coverpoint cov_item.stream_id iff(cov_stream_id_flag){ \
    bins stream_id_range_min = {0};\
`ifdef SVT_MULTI_SIM_COVPOINT_GREATER_THAN_32_BITS \
     // Need to come up with an alternative \
`else \
     bins stream_id_range_mid = {[1:(64'd2**(`SVT_AXI_MAX_MMUSID_WIDTH)-2)]}; \
     bins stream_id_range_max = {((64'd2**(`SVT_AXI_MAX_MMUSID_WIDTH))-1)}; \
`endif \
    option.weight = 1; \
}

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_SUB_STREAM_ID \
   sub_stream_id : coverpoint cov_item.sub_stream_id iff(cov_sub_stream_id_flag){ \
     bins sub_stream_id_range_min = {0};\
`ifdef SVT_MULTI_SIM_COVPOINT_GREATER_THAN_32_BITS \
     // Need to come up with an alternative \
`else \
     bins sub_stream_id_range_mid = {[1:(64'd2**(`SVT_AXI_MAX_MMUSSID_WIDTH)-2)]}; \
     bins sub_stream_id_range_max = {((64'd2**(`SVT_AXI_MAX_MMUSSID_WIDTH))-1)}; \
`endif \
   option.weight = 1; \
}

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_SEC_OR_NON_SEC_STREAM \
  sec_or_non_sec_stream : coverpoint cov_item.secure_or_non_secure_stream iff(cov_secure_or_non_secure_stream_flag){ \
   bins secure_stream = {1}; \
   bins non_secure_stream = {0}; \
   option.weight = 1; \
}  

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_SUB_STREAM_ID_VALID \
  sub_stream_id_valid : coverpoint cov_item.sub_stream_id_valid iff(cov_sub_stream_id_valid_flag){ \
   bins sub_stream_id_valid = {1}; \
   bins sub_stream_id_invalid = {0}; \
   option.weight =1; \
} 
 
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_STASH_NID \
   stash_nid : coverpoint cov_item.stash_nid iff(cov_stash_nid_flag){ \
      bins stash_nid_range_min = {0};\
`ifdef SVT_MULTI_SIM_COVPOINT_GREATER_THAN_32_BITS \
     // Need to come up with an alternative \
`else \
     bins stash_nid_range_mid = {[1:(64'd2**(`SVT_AXI_STASH_NID_WIDTH)-2)]}; \
     bins stash_nid_range_max = {((64'd2**(`SVT_AXI_STASH_NID_WIDTH))-1)}; \
`endif \
    option.weight = 1; \
}

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_STASH_LPID \
   stash_lpid : coverpoint cov_item.stash_lpid iff(cov_stash_lpid_flag){ \
       bins stash_lpid_range_min = {0};\
`ifdef SVT_MULTI_SIM_COVPOINT_GREATER_THAN_32_BITS \
     // Need to come up with an alternative \
`else \
     bins stash_lpid_range_mid = {[1:(64'd2**(`SVT_AXI_STASH_LPID_WIDTH)-2)]}; \
     bins stash_lpid_range_max = {((64'd2**(`SVT_AXI_STASH_LPID_WIDTH))-1)}; \
`endif \
  option.weight = 1; \
}

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_STASH_NID_VALID \
  stash_nid_valid : coverpoint cov_item.stash_nid_valid iff(cov_stash_nid_valid_flag){ \
   bins stash_nid_valid = {1}; \
   bins stash_nid_invalid = {0}; \
   option.weight = 1; \
}  

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_STASH_LPID_VALID \
  stash_lpid_valid : coverpoint cov_item.stash_lpid_valid iff(cov_stash_lpid_valid_flag){ \
   bins stash_lpid_valid = {1}; \
   bins stash_lpid_invalid = {0}; \
   option.weight =1; \
}  

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_ATOMIC_BURST_TYPE \
  atomic_burst_type : coverpoint cov_item.burst_type iff(cov_atomic_burst_type_flag){ \
    bins incr_burst = {svt_axi_transaction::INCR}; \
    bins wrap_burst = {svt_axi_transaction::WRAP}; \
  option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_RDATA_CHUNK_BURST_TYPE \
  chunk_burst_type : coverpoint cov_item.burst_type iff(cov_chunk_burst_type_flag){ \
    bins incr_burst = {svt_axi_transaction::INCR}; \
    bins wrap_burst = {svt_axi_transaction::WRAP}; \
  option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_RCHUNK_LENGTH \
  chunk_length : coverpoint cov_item.chunk_length iff(cov_chunk_length_flag){ \
    bins chunk_length[] =  {[1:((1<<`SVT_AXI_MAX_CHUNK_NUM_WIDTH)-1)]}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_RCHUNKSTRB\
  rchunkstrb :  coverpoint cov_rchunkstrb iff(cov_chunkstrb_flag){ \
`ifdef SVT_AXI_MAX_CHUNK_STROBE_WIDTH_2 \
    bins rchunkstrb_val_1  = {2'b01};\
    bins rchunkstrb_val_2  = {2'b10};\
    bins rchunkstrb_val_3  = {2'b11};\
`elsif SVT_AXI_MAX_CHUNK_STROBE_WIDTH_4 \
    bins rchunkstrb_val_1  = {4'b0001};\
    bins rchunkstrb_val_2  = {4'b0010};\
    bins rchunkstrb_val_3  = {4'b0011};\
    bins rchunkstrb_val_4  = {4'b0100};\
    bins rchunkstrb_val_5  = {4'b0101};\
    bins rchunkstrb_val_6  = {4'b0110};\
    bins rchunkstrb_val_7  = {4'b0111};\
    bins rchunkstrb_val_8  = {4'b1000};\
    bins rchunkstrb_val_9  = {4'b1001};\
    bins rchunkstrb_val_10  = {4'b1010};\
    bins rchunkstrb_val_11  = {4'b1011};\
    bins rchunkstrb_val_12  = {4'b1100};\
    bins rchunkstrb_val_13  = {4'b1101};\
    bins rchunkstrb_val_14  = {4'b1110};\
    bins rchunkstrb_val_15  = {4'b1111};\
    wildcard bins rchunkstrb_bit_position_1  = {4'b???1};\
    wildcard bins rchunkstrb_bit_position_2  = {4'b??1?};\
    wildcard bins rchunkstrb_bit_position_8  = {4'b?1??};\
    wildcard bins rchunkstrb_bit_position_15  = {4'b1???};\
`elsif SVT_AXI_MAX_CHUNK_STROBE_WIDTH_8 \
    wildcard bins rchunkstrb_bit_position_1  = {'b????_???1};\
    wildcard bins rchunkstrb_bit_position_2  = {'b????_??1?};\
    wildcard bins rchunkstrb_bit_position_4  = {'b????_?1??};\
    wildcard bins rchunkstrb_bit_position_8  = {'b????_1???};\
    wildcard bins rchunkstrb_bit_position_16  = {'b???1_????};\
    wildcard bins rchunkstrb_bit_position_32  = {'b??1?_????};\
    wildcard bins rchunkstrb_bit_position_64  = {'b?1??_????};\
    wildcard bins rchunkstrb_bit_position_128  = {'b1???_????};\
    bins rchunkstrb_all_8bit_ones = {8'b1111_1111};\
`endif \
  option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_RCHUNKNUM\
  rchunknum :  coverpoint cov_rchunknum iff(cov_chunknum_flag){ \
`ifdef SVT_AXI_MAX_CHUNK_NUM_WIDTH_5 \
    bins rchunknum_val[]  = { [5'b0 : 5'h1F] };\
`elsif SVT_AXI_MAX_CHUNK_NUM_WIDTH_6 \
    bins rchunknum_val_0[]  = { [6'h0 : 6'h7] };\
    bins rchunknum_val_1[]  = { [6'h8 : 6'hF] };\
    bins rchunknum_val_2[]  = { [6'h11 : 6'h18] };\
    bins rchunknum_val_3[]  = { [6'h19 : 6'h1F] };\
    bins rchunknum_val_4[]  = { [6'h21 : 6'h28] };\
    bins rchunknum_val_5[]  = { [6'h29 : 6'h2F] };\
    bins rchunknum_val_6[]  = { [6'h31 : 6'h38] };\
    bins rchunknum_val_7[]  = { [6'h39 : 6'h3F] };\
`elsif SVT_AXI_MAX_CHUNK_NUM_WIDTH_7 \
    bins rchunknum_val_0[]  = { [7'h0 : 7'hF] };\
    bins rchunknum_val_1[]  = { [7'h10 : 7'h1F] };\
    bins rchunknum_val_2[]  = { [7'h20 : 7'h2F] };\
    bins rchunknum_val_3[]  = { [7'h30 : 7'h3F] };\
    bins rchunknum_val_4[]  = { [7'h40 : 7'h4F] };\
    bins rchunknum_val_5[]  = { [7'h50 : 7'h5F] };\
    bins rchunknum_val_6[]  = { [7'h60 : 7'h6F] };\
    bins rchunknum_val_7[]  = { [7'h70 : 7'h7F] };\
`elsif SVT_AXI_MAX_CHUNK_NUM_WIDTH_8 \
    bins rchunknum_val_0[]  = { [8'h0 : 8'h1F] };\
    bins rchunknum_val_1[]  = { [8'h20 : 8'h3F] };\
    bins rchunknum_val_2[]  = { [8'h40 : 8'h5F] };\
    bins rchunknum_val_3[]  = { [8'h60 : 8'h7F] };\
    bins rchunknum_val_4[]  = { [8'h80 : 8'h9F] };\
    bins rchunknum_val_5[]  = { [8'hA0 : 8'hBF] };\
    bins rchunknum_val_6[]  = { [8'hC0 : 8'hDF] };\
    bins rchunknum_val_7[]  = { [8'hE0 : 8'hFF] };\
`endif \
  option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_RDATA_CHUNK_BURST_SIZE \
  chunk_burst_size : coverpoint cov_item.burst_size iff(cov_chunk_burst_size_flag){ \
    bins burst_size_128bit  = {svt_axi_transaction::BURST_SIZE_128BIT}; \
    bins burst_size_256bit  = {svt_axi_transaction::BURST_SIZE_256BIT}; \
    bins burst_size_512bit  = {svt_axi_transaction::BURST_SIZE_512BIT}; \
    bins burst_size_1024bit = {svt_axi_transaction::BURST_SIZE_1024BIT}; \
    `SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_RDATA_CHUNK_TRANSFER_SIZE_BURST_SIZE_IGNORE_BINS\
 option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_ATOMIC_COMP_BURST_SIZE \
  atomic_comp_burst_size : coverpoint cov_item.burst_size iff(cov_atomic_comp_burst_size_flag){ \
    bins burst_size_8bit    = {svt_axi_transaction::BURST_SIZE_8BIT}; \
    bins burst_size_16bit   = {svt_axi_transaction::BURST_SIZE_16BIT}; \
    bins burst_size_32bit   = {svt_axi_transaction::BURST_SIZE_32BIT}; \
    bins burst_size_64bit   = {svt_axi_transaction::BURST_SIZE_64BIT}; \
    bins burst_size_128bit  = {svt_axi_transaction::BURST_SIZE_128BIT}; \
    bins burst_size_256bit  = {svt_axi_transaction::BURST_SIZE_256BIT}; \
 option.weight = 1; \
  }

 `define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_ATOMIC_NONCOMP_BURST_SIZE \
  atomic_non_comp_burst_size : coverpoint cov_item.burst_size iff(cov_atomic_non_comp_burst_size_flag){ \
    bins burst_size_8bit    = {svt_axi_transaction::BURST_SIZE_8BIT}; \
    bins burst_size_16bit   = {svt_axi_transaction::BURST_SIZE_16BIT}; \
    bins burst_size_32bit   = {svt_axi_transaction::BURST_SIZE_32BIT}; \
    bins burst_size_64bit   = {svt_axi_transaction::BURST_SIZE_64BIT}; \
    bins burst_size_128bit  = {svt_axi_transaction::BURST_SIZE_128BIT}; \
 option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_ATOMIC_COMP_XACT_TYPE \
    atomic_comp_xact_type : coverpoint cov_item.atomic_transaction_type iff(cov_atomic_comp_xact_type_flag){ \
    bins atomic_compare_xact   = {svt_axi_transaction::COMPARE}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_ATOMIC_NONCOMP_XACT_TYPE \
  atomic_noncomp_xact_type : coverpoint cov_item.atomic_transaction_type iff(cov_atomic_noncomp_xact_type_flag){ \
    bins atomic_swap_xact  = {svt_axi_transaction::SWAP}; \
    bins atomic_load_xact  = {svt_axi_transaction::LOAD}; \
    bins atomic_store_xact = {svt_axi_transaction::STORE}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_ATOMIC_COMP_OP_TYPE \
    atomic_comp_op_type : coverpoint cov_item.atomic_xact_op_type iff(cov_atomic_comp_op_type_flag){ \
    bins atomic_compare   = {svt_axi_transaction::ATOMICCOMPARE}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_ATOMIC_NONCOMP_OP_TYPE \
  atomic_noncomp_op_type : coverpoint cov_item.atomic_xact_op_type iff(cov_atomic_noncomp_op_type_flag){ \
    bins atomic_store_add   =  {svt_axi_transaction::ATOMICSTORE_ADD }; \
    bins atomic_store_clr   =  {svt_axi_transaction::ATOMICSTORE_CLR }; \
    bins atomic_store_eor   =  {svt_axi_transaction::ATOMICSTORE_EOR }; \
    bins atomic_store_set   =  {svt_axi_transaction::ATOMICSTORE_SET }; \
    bins atomic_store_smax  =  {svt_axi_transaction::ATOMICSTORE_SMAX }; \
    bins atomic_store_smin  =  {svt_axi_transaction::ATOMICSTORE_SMIN }; \
    bins atomic_store_umax  =  {svt_axi_transaction::ATOMICSTORE_UMAX }; \
    bins atomic_store_umin  =  {svt_axi_transaction::ATOMICSTORE_UMIN }; \
    bins atomic_load_add    =  {svt_axi_transaction::ATOMICLOAD_ADD }; \
    bins atomic_load_clr    =  {svt_axi_transaction::ATOMICLOAD_CLR }; \
    bins atomic_load_eor    =  {svt_axi_transaction::ATOMICLOAD_EOR }; \
    bins atomic_load_set    =  {svt_axi_transaction::ATOMICLOAD_SET }; \
    bins atomic_load_smax   =  {svt_axi_transaction::ATOMICLOAD_SMAX }; \
    bins atomic_load_smin   =  {svt_axi_transaction::ATOMICLOAD_SMIN }; \
    bins atomic_load_umax   =  {svt_axi_transaction::ATOMICLOAD_UMAX }; \
    bins atomic_load_umin   =  {svt_axi_transaction::ATOMICLOAD_UMIN }; \
    bins atomic_swap        =  {svt_axi_transaction::ATOMICSWAP }; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_ENDIAN_TYPE \
  endian_type : coverpoint cov_item.endian iff(cov_endian_flag){ \
   bins little_endian = {svt_axi_transaction::LITTLE_ENDIAN}; \
   bins big_endian = {svt_axi_transaction::BIG_ENDIAN}; \
   option.weight = 1; \
 }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_COHERENT_STASH_XACT_TYPE \
  coherent_stash_xact_type : coverpoint cov_item.coherent_xact_type iff(cov_coherent_stash_xact_type_flag){ \
    bins coherent_writeuniqueptlstash_xact = {svt_axi_transaction::WRITEUNIQUEPTLSTASH}; \
    bins coherent_writeuniquefullstash_xact = {svt_axi_transaction::WRITEUNIQUEFULLSTASH}; \
    bins coherent_stashonceshared_xact = {svt_axi_transaction::STASHONCESHARED}; \
    bins coherent_stashonceunique_xact = {svt_axi_transaction::STASHONCEUNIQUE}; \
    bins coherent_stashtranslation_xact = {svt_axi_transaction::STASHTRANSLATION}; \
    option.weight = 1; \
 }

`endif

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_COHERENT_WRITE_XACT_TYPE \
  coherent_write_xact_type : coverpoint cov_item.coherent_xact_type iff(cov_coherent_xact_type_flag){ \
    bins coherent_writenosnoop_xact   = {svt_axi_transaction::WRITENOSNOOP}; \
    bins coherent_writeunique_xact   = {svt_axi_transaction::WRITEUNIQUE}; \
    bins coherent_writelineunique_xact   = {svt_axi_transaction::WRITELINEUNIQUE}; \
    bins coherent_writeclean_xact   = {svt_axi_transaction::WRITECLEAN}; \
    bins coherent_writeback_xact   = {svt_axi_transaction::WRITEBACK}; \
    bins coherent_evict_xact   = {svt_axi_transaction::EVICT}; \
    bins coherent_writebarrier_xact   = {svt_axi_transaction::WRITEBARRIER}; \
    bins coherent_writeevict_xact   = {svt_axi_transaction::WRITEEVICT}; \
    ignore_bins ignore_coh_write_xact_ace_lite = {svt_axi_transaction::WRITECLEAN,svt_axi_transaction::WRITEBACK, \
                                                  svt_axi_transaction::EVICT} \
                                                   iff(cfg.axi_interface_type == svt_axi_port_configuration::ACE_LITE); \
    ignore_bins ignore_barrier       = {svt_axi_transaction::WRITEBARRIER} iff(cfg.barrier_enable == 1'b0); \
    ignore_bins ignore_writeevict    = {svt_axi_transaction::WRITEEVICT} iff(cfg.writeevict_enable == 1'b0); \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_COHERENT_WRITE_XACT_TYPE_SNOOP_GENERATE \
  coherent_write_xact_type_gen_snoop : coverpoint coherent_write_xact_type_generate_snoop { \
    bins coherent_writeunique_xact   = {svt_axi_transaction::WRITEUNIQUE}; \
    bins coherent_writelineunique_xact   = {svt_axi_transaction::WRITELINEUNIQUE}; \
    option.weight = 1; \
   }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_COHERENT_WRITE_XACT_TYPE_WRITEEVICT_SNOOP_GENERATE \
  coherent_write_xact_type_gen_snoop : coverpoint coherent_write_xact_type_generate_snoop { \
    bins coherent_writeunique_xact   = {svt_axi_transaction::WRITEUNIQUE}; \
    bins coherent_writelineunique_xact   = {svt_axi_transaction::WRITELINEUNIQUE}; \
    bins coherent_writeclean_xact   = {svt_axi_transaction::WRITECLEAN}; \
    bins coherent_writeback_xact   = {svt_axi_transaction::WRITEBACK}; \
    bins coherent_evict_xact   = {svt_axi_transaction::EVICT}; \
    bins coherent_writeevict_xact   = {svt_axi_transaction::WRITEEVICT}; \
    option.weight = 1; \
   }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_COHERENT_WRITE_XACT_TYPE_NO_WRITEEVICT_SNOOP_GENERATE \
  coherent_write_xact_type_gen_snoop : coverpoint coherent_write_xact_type_generate_snoop { \
    bins coherent_writeunique_xact   = {svt_axi_transaction::WRITEUNIQUE}; \
    bins coherent_writelineunique_xact   = {svt_axi_transaction::WRITELINEUNIQUE}; \
    bins coherent_writeclean_xact   = {svt_axi_transaction::WRITECLEAN}; \
    bins coherent_writeback_xact   = {svt_axi_transaction::WRITEBACK}; \
    bins coherent_evict_xact   = {svt_axi_transaction::EVICT}; \
    option.weight = 1; \
   }

`ifdef SVT_AXI_MON_CFG_BASED_COV_GRP_DEF

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_COHERENT_WRITE_XACT_TYPE_NOT_ACE_LITE_NO_BARRIER_NO_WRITEEVICT \
  coherent_write_xact_type : coverpoint cov_item.coherent_xact_type iff(cov_coherent_xact_type_flag){ \
    bins coherent_writenosnoop_xact   = {svt_axi_transaction::WRITENOSNOOP}; \
    bins coherent_writeunique_xact   = {svt_axi_transaction::WRITEUNIQUE}; \
    bins coherent_writelineunique_xact   = {svt_axi_transaction::WRITELINEUNIQUE}; \
    bins coherent_writeclean_xact   = {svt_axi_transaction::WRITECLEAN}; \
    bins coherent_writeback_xact   = {svt_axi_transaction::WRITEBACK}; \
    bins coherent_evict_xact   = {svt_axi_transaction::EVICT}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_COHERENT_WRITE_XACT_TYPE_NOT_ACE_LITE_NO_BARRIER_WRITEEVICT \
  coherent_write_xact_type : coverpoint cov_item.coherent_xact_type iff(cov_coherent_xact_type_flag){ \
    bins coherent_writenosnoop_xact   = {svt_axi_transaction::WRITENOSNOOP}; \
    bins coherent_writeunique_xact   = {svt_axi_transaction::WRITEUNIQUE}; \
    bins coherent_writelineunique_xact   = {svt_axi_transaction::WRITELINEUNIQUE}; \
    bins coherent_writeclean_xact   = {svt_axi_transaction::WRITECLEAN}; \
    bins coherent_writeback_xact   = {svt_axi_transaction::WRITEBACK}; \
    bins coherent_evict_xact   = {svt_axi_transaction::EVICT}; \
    bins coherent_writeevict_xact   = {svt_axi_transaction::WRITEEVICT}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_COHERENT_WRITE_XACT_TYPE_NOT_ACE_LITE_BARRIER_NO_WRITEEVICT \
  coherent_write_xact_type : coverpoint cov_item.coherent_xact_type iff(cov_coherent_xact_type_flag){ \
    bins coherent_writenosnoop_xact   = {svt_axi_transaction::WRITENOSNOOP}; \
    bins coherent_writeunique_xact   = {svt_axi_transaction::WRITEUNIQUE}; \
    bins coherent_writelineunique_xact   = {svt_axi_transaction::WRITELINEUNIQUE}; \
    bins coherent_writeclean_xact   = {svt_axi_transaction::WRITECLEAN}; \
    bins coherent_writeback_xact   = {svt_axi_transaction::WRITEBACK}; \
    bins coherent_evict_xact   = {svt_axi_transaction::EVICT}; \
    bins coherent_writebarrier_xact   = {svt_axi_transaction::WRITEBARRIER}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_COHERENT_WRITE_XACT_TYPE_NOT_ACE_LITE_BARRIER_WRITEEVICT \
  coherent_write_xact_type : coverpoint cov_item.coherent_xact_type iff(cov_coherent_xact_type_flag){ \
    bins coherent_writenosnoop_xact   = {svt_axi_transaction::WRITENOSNOOP}; \
    bins coherent_writeunique_xact   = {svt_axi_transaction::WRITEUNIQUE}; \
    bins coherent_writelineunique_xact   = {svt_axi_transaction::WRITELINEUNIQUE}; \
    bins coherent_writeclean_xact   = {svt_axi_transaction::WRITECLEAN}; \
    bins coherent_writeback_xact   = {svt_axi_transaction::WRITEBACK}; \
    bins coherent_evict_xact   = {svt_axi_transaction::EVICT}; \
    bins coherent_writebarrier_xact   = {svt_axi_transaction::WRITEBARRIER}; \
    bins coherent_writeevict_xact   = {svt_axi_transaction::WRITEEVICT}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_COHERENT_WRITE_XACT_TYPE_ACE_LITE_NO_BARRIER \
  coherent_write_xact_type : coverpoint cov_item.coherent_xact_type iff(cov_coherent_xact_type_flag){ \
    bins coherent_writenosnoop_xact   = {svt_axi_transaction::WRITENOSNOOP}; \
    bins coherent_writeunique_xact   = {svt_axi_transaction::WRITEUNIQUE}; \
    bins coherent_writelineunique_xact   = {svt_axi_transaction::WRITELINEUNIQUE}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_COHERENT_WRITE_XACT_TYPE_ACE_LITE_BARRIER \
  coherent_write_xact_type : coverpoint cov_item.coherent_xact_type iff(cov_coherent_xact_type_flag){ \
    bins coherent_writenosnoop_xact   = {svt_axi_transaction::WRITENOSNOOP}; \
    bins coherent_writeunique_xact   = {svt_axi_transaction::WRITEUNIQUE}; \
    bins coherent_writelineunique_xact   = {svt_axi_transaction::WRITELINEUNIQUE}; \
    bins coherent_writebarrier_xact   = {svt_axi_transaction::WRITEBARRIER}; \
    option.weight = 1; \
  }

`endif

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_IGNORE_COHERENT_WRITE_XACT_TYPE_CROSS \
 ignore_bins ignore_writenosnoop_states = ((binsof(coherent_write_xact_type) intersect {svt_axi_transaction::WRITENOSNOOP}) && (binsof(initial_cache_line_state) intersect {svt_axi_transaction::INVALID}) && (!binsof(final_cache_line_state) intersect {svt_axi_transaction::INVALID})); \
 
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_IGNORE_UPDATE_CACHE_COHERENT_WRITE_XACT_TYPE_CROSS \
 ignore_bins ignore_writenosnoop_states_update_cache = ((binsof(coherent_write_xact_type) intersect {svt_axi_transaction::WRITENOSNOOP}) && (binsof(initial_cache_line_state) intersect {svt_axi_transaction::UNIQUECLEAN,svt_axi_transaction::UNIQUEDIRTY}) && (!binsof(final_cache_line_state) intersect {svt_axi_transaction::UNIQUECLEAN})); \
 
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_IGNORE_COHERENT_WRITEUNIQUEORLINE_XACT_TYPE_CROSS \
 ignore_bins Ignore_writeuniqueorline_states = ((binsof(coherent_write_xact_type) intersect {svt_axi_transaction::WRITEUNIQUE,svt_axi_transaction::WRITELINEUNIQUE}) && (binsof(initial_cache_line_state) intersect {svt_axi_transaction::INVALID}) && (!binsof(final_cache_line_state) intersect {svt_axi_transaction::INVALID})) || ((binsof(coherent_write_xact_type) intersect {svt_axi_transaction::WRITEUNIQUE,svt_axi_transaction::WRITELINEUNIQUE}) && (binsof(initial_cache_line_state) intersect {svt_axi_transaction::UNIQUECLEAN,svt_axi_transaction::SHAREDCLEAN}) && (!binsof(final_cache_line_state) intersect {svt_axi_transaction::SHAREDCLEAN})); \
 
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_IGNORE_COHERENT_WRITEBACK_XACT_TYPE_CROSS \
 ignore_bins Ignore_writeback_states = ((binsof(coherent_write_xact_type) intersect {svt_axi_transaction::WRITEBACK}) && (binsof(initial_cache_line_state) intersect {svt_axi_transaction::UNIQUEDIRTY,svt_axi_transaction::SHAREDDIRTY}) && (!binsof(final_cache_line_state) intersect {svt_axi_transaction::INVALID})); \

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_IGNORE_COHERENT_WRITEEVICT_XACT_TYPE_CROSS \
 ignore_bins Ignore_writeevict_states = ((binsof(coherent_write_xact_type) intersect {svt_axi_transaction::WRITEEVICT}) && (!binsof(initial_cache_line_state) intersect {svt_axi_transaction::UNIQUECLEAN})) || ((binsof(coherent_write_xact_type) intersect {svt_axi_transaction::WRITEEVICT}) && (binsof(initial_cache_line_state) intersect {svt_axi_transaction::UNIQUECLEAN}) && (!binsof(final_cache_line_state) intersect {svt_axi_transaction::INVALID})); \
 
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_IGNORE_COHERENT_WRITECLEAN_XACT_TYPE_CROSS \
 ignore_bins Ignore_writeclean_states = ((binsof(coherent_write_xact_type) intersect {svt_axi_transaction::WRITECLEAN}) && (binsof(initial_cache_line_state) intersect {svt_axi_transaction::UNIQUEDIRTY}) && (!binsof(final_cache_line_state) intersect {svt_axi_transaction::UNIQUECLEAN})) || ((binsof(coherent_write_xact_type) intersect {svt_axi_transaction::WRITECLEAN}) && (binsof(initial_cache_line_state) intersect {svt_axi_transaction::SHAREDDIRTY}) && (!binsof(final_cache_line_state) intersect {svt_axi_transaction::SHAREDCLEAN})); \

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_IGNORE_COHERENT_EVICT_XACT_TYPE_CROSS \
 ignore_bins Ignore_evict_states = ((binsof(coherent_write_xact_type) intersect {svt_axi_transaction::EVICT}) && (binsof(initial_cache_line_state) intersect {svt_axi_transaction::UNIQUECLEAN,svt_axi_transaction::SHAREDCLEAN}) &&  (!binsof(final_cache_line_state) intersect {svt_axi_transaction::INVALID})); \

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_IGNORE_COHERENT_READ_XACT_TYPE_CROSS \
 ignore_bins ignore_readnosnoop_states = ((binsof(coherent_read_xact_type) intersect {svt_axi_transaction::READNOSNOOP}) && (binsof(initial_cache_line_state) intersect {svt_axi_transaction::INVALID}) && (!binsof(final_cache_line_state) intersect {svt_axi_transaction::INVALID})); \

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_IGNORE_UPDATE_CACHE_COHERENT_READ_XACT_TYPE_CROSS \
 ignore_bins ignore_readnosnoop_states_update_cache = ((binsof(coherent_read_xact_type) intersect {svt_axi_transaction::READNOSNOOP}) && (binsof(initial_cache_line_state) intersect {svt_axi_transaction::INVALID}) && (!binsof(final_cache_line_state) intersect {svt_axi_transaction::INVALID,svt_axi_transaction::UNIQUECLEAN})); \

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_IGNORE_COHERENT_READONCE_XACT_TYPE_CROSS \
 ignore_bins Ignore_readonce_states = ((binsof(coherent_read_xact_type) intersect {svt_axi_transaction::READONCE}) && (binsof(initial_cache_line_state) intersect {svt_axi_transaction::INVALID}) && (!binsof(final_cache_line_state) intersect {svt_axi_transaction::INVALID}));\

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_IGNORE_COHERENT_READCLEAN_XACT_TYPE_CROSS \
 ignore_bins Ignore_readclean_states = ((binsof(coherent_read_xact_type) intersect {svt_axi_transaction::READCLEAN}) && (binsof(initial_cache_line_state) intersect {svt_axi_transaction::INVALID}) && (!binsof(final_cache_line_state) intersect {svt_axi_transaction::UNIQUECLEAN,svt_axi_transaction::SHAREDCLEAN})); \

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_IGNORE_COHERENT_READNOTSHAREDDIRTY_XACT_TYPE_CROSS \
 ignore_bins Ignore_readnotshareddirty_states = ((binsof(coherent_read_xact_type) intersect {svt_axi_transaction::READNOTSHAREDDIRTY}) && (binsof(initial_cache_line_state) intersect {svt_axi_transaction::INVALID}) && (!binsof(final_cache_line_state) intersect {svt_axi_transaction::UNIQUECLEAN,svt_axi_transaction::UNIQUEDIRTY,svt_axi_transaction::SHAREDCLEAN})); \

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_IGNORE_COHERENT_READSHARED_XACT_TYPE_CROSS \
 ignore_bins Ignore_readshared_states = ((binsof(coherent_read_xact_type) intersect {svt_axi_transaction::READSHARED}) && (binsof(initial_cache_line_state) intersect {svt_axi_transaction::INVALID}) && (!binsof(final_cache_line_state) intersect {svt_axi_transaction::UNIQUECLEAN,svt_axi_transaction::UNIQUEDIRTY,svt_axi_transaction::SHAREDCLEAN,svt_axi_transaction::SHAREDDIRTY})); \

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_IGNORE_COHERENT_READUNIQUE_XACT_TYPE_CROSS \
 ignore_bins Ignore_readunique_states = ((binsof(coherent_read_xact_type) intersect {svt_axi_transaction::READUNIQUE}) && (binsof(initial_cache_line_state) intersect {svt_axi_transaction::INVALID}) && (!binsof(final_cache_line_state) intersect {svt_axi_transaction::UNIQUECLEAN,svt_axi_transaction::UNIQUEDIRTY})); \

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_IGNORE_COHERENT_CLEANUNIQUE_XACT_TYPE_CROSS \
 ignore_bins Ignore_cleanunique_states = ((binsof(coherent_read_xact_type) intersect {svt_axi_transaction::CLEANUNIQUE}) && (binsof(initial_cache_line_state) intersect {svt_axi_transaction::SHAREDCLEAN}) && (!binsof(final_cache_line_state) intersect {svt_axi_transaction::UNIQUECLEAN})) || ((binsof(coherent_read_xact_type) intersect {svt_axi_transaction::CLEANUNIQUE}) && (binsof(initial_cache_line_state) intersect {svt_axi_transaction::SHAREDDIRTY}) &&  (!binsof(final_cache_line_state) intersect {svt_axi_transaction::UNIQUEDIRTY})); \

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_IGNORE_COHERENT_MAKEUNIQUE_XACT_TYPE_CROSS \
 ignore_bins Ignore_makeunique_states = ((binsof(coherent_read_xact_type) intersect {svt_axi_transaction::MAKEUNIQUE}) && (binsof(initial_cache_line_state) intersect {svt_axi_transaction::INVALID,svt_axi_transaction::SHAREDCLEAN,svt_axi_transaction::SHAREDDIRTY}) && (!binsof(final_cache_line_state) intersect {svt_axi_transaction::UNIQUEDIRTY})); \

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_IGNORE_COHERENT_CLEANSHARED_XACT_TYPE_CROSS \
`ifdef SVT_ACE5_ENABLE \
 ignore_bins Ignore_cleanshared_states = ((binsof(coherent_read_xact_type) intersect {svt_axi_transaction::CLEANSHARED,svt_axi_transaction::CLEANSHAREDPERSIST}) && (binsof(initial_cache_line_state) intersect {svt_axi_transaction::INVALID}) && (!binsof(final_cache_line_state) intersect {svt_axi_transaction::INVALID})) || ((binsof(coherent_read_xact_type) intersect {svt_axi_transaction::CLEANSHARED,svt_axi_transaction::CLEANSHAREDPERSIST}) && (binsof(initial_cache_line_state) intersect {svt_axi_transaction::UNIQUECLEAN}) && (!binsof(final_cache_line_state) intersect {svt_axi_transaction::UNIQUECLEAN})) || ((binsof(coherent_read_xact_type) intersect {svt_axi_transaction::CLEANSHARED,svt_axi_transaction::CLEANSHAREDPERSIST}) && (binsof(initial_cache_line_state) intersect {svt_axi_transaction::SHAREDCLEAN}) && (!binsof(final_cache_line_state) intersect {svt_axi_transaction::UNIQUECLEAN,svt_axi_transaction::SHAREDCLEAN})); \
`else \
 ignore_bins Ignore_cleanshared_states = ((binsof(coherent_read_xact_type) intersect {svt_axi_transaction::CLEANSHARED}) && (binsof(initial_cache_line_state) intersect {svt_axi_transaction::INVALID}) && (!binsof(final_cache_line_state) intersect {svt_axi_transaction::INVALID})) || ((binsof(coherent_read_xact_type) intersect {svt_axi_transaction::CLEANSHARED}) && (binsof(initial_cache_line_state) intersect {svt_axi_transaction::UNIQUECLEAN}) && (!binsof(final_cache_line_state) intersect {svt_axi_transaction::UNIQUECLEAN})) || ((binsof(coherent_read_xact_type) intersect {svt_axi_transaction::CLEANSHARED}) && (binsof(initial_cache_line_state) intersect {svt_axi_transaction::SHAREDCLEAN}) && (!binsof(final_cache_line_state) intersect {svt_axi_transaction::UNIQUECLEAN,svt_axi_transaction::SHAREDCLEAN})); \
`endif \

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_IGNORE_COHERENT_CLEANINVALID_XACT_TYPE_CROSS \
 ignore_bins Ignore_cleaninvalid_states = ((binsof(coherent_read_xact_type) intersect {svt_axi_transaction::CLEANINVALID}) && (binsof(initial_cache_line_state) intersect {svt_axi_transaction::INVALID}) && (!binsof(final_cache_line_state) intersect {svt_axi_transaction::INVALID})); \

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_IGNORE_COHERENT_MAKEINVALID_XACT_TYPE_CROSS \
 ignore_bins Ignore_makeinvalid_states = ((binsof(coherent_read_xact_type) intersect {svt_axi_transaction::MAKEINVALID}) && (binsof(initial_cache_line_state) intersect {svt_axi_transaction::INVALID}) && (!binsof(final_cache_line_state) intersect {svt_axi_transaction::INVALID})); \

 
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_STREAM_XACT_TYPE \
  stream_xact_type : coverpoint cov_stream_xact_type iff(cov_stream_xact_type_flag){ \
    bins byte_stream = {svt_axi_transaction::BYTE_STREAM}; \
    bins continuous_aligned_stream = {svt_axi_transaction::CONTINUOUS_ALIGNED_STREAM}; \
    bins continuous_unaligned_stream = {svt_axi_transaction::CONTINUOUS_UNALIGNED_STREAM}; \
    bins sparse_stream = {svt_axi_transaction::SPARSE_STREAM}; \
    bins user_stream = {svt_axi_transaction::USER_STREAM}; \
    ignore_bins ignore_byte_stream = {svt_axi_transaction::BYTE_STREAM} iff(cfg.byte_stream_enable==0); \
    ignore_bins ignore_continuous_aligned_stream = {svt_axi_transaction::CONTINUOUS_ALIGNED_STREAM} iff(cfg.continuous_aligned_stream_enable==0); \
    ignore_bins ignore_continuous_unaligned_stream = {svt_axi_transaction::CONTINUOUS_UNALIGNED_STREAM} iff(cfg.continuous_unaligned_stream_enable==0); \
    ignore_bins ignore_sparse_stream = {svt_axi_transaction::SPARSE_STREAM} iff(cfg.sparse_stream_enable==0); \
    ignore_bins ignore_user_stream = {svt_axi_transaction::USER_STREAM} iff(cfg.user_stream_enable==0); \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_STREAM_TID \
stream_tid : coverpoint cov_item.tid iff (cov_stream_tid_flag) { \
`ifndef INCA \
  bins tid_within_range[] = {[0:((1<<cfg.tid_width)-1)]}; \
  ignore_bins ignore_tid_beyond_range = {[(1<<cfg.tid_width):$]}; \
`endif \
ignore_bins ignore_tid_if_disabled = {[0:$]} iff (cfg.tid_enable==0); \
}

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_STREAM_TDEST \
stream_tdest : coverpoint cov_item.tdest iff (cov_stream_tdest_flag) { \
`ifndef INCA \
  bins tdest_within_range[] = {[0:((1<<cfg.tdest_width)-1)]}; \
  ignore_bins ignore_tdest_beyond_range = {[(1<<cfg.tdest_width):$]}; \
`endif \
ignore_bins ignore_tdest_if_disabled = {[0:$]} iff (cfg.tdest_enable==0); \
}

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_DOMAIN_TYPE \
  domain_type : coverpoint cov_item.domain_type iff(cov_domain_type_flag){ \
    bins domain_non_shareable           = {svt_axi_transaction::NONSHAREABLE}; \
    bins domain_inner_shareable         = {svt_axi_transaction::INNERSHAREABLE}; \
    bins domain_outer_shareable         = {svt_axi_transaction::OUTERSHAREABLE}; \
    bins domain_system_shareable        = {svt_axi_transaction::SYSTEMSHAREABLE}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_BARRIER_TYPE \
  barrier_type : coverpoint cov_item.barrier_type iff(cov_barrier_type_flag){ \
    bins barrier_normal_respect    = {svt_axi_transaction::NORMAL_ACCESS_RESPECT_BARRIER}; \
    bins barrier_memory            = {svt_axi_transaction::MEMORY_BARRIER}; \
    bins barrier_normal_ignore     = {svt_axi_transaction::NORMAL_ACCESS_IGNORE_BARRIER}; \
    bins barrier_synchronization   = {svt_axi_transaction::SYNC_BARRIER}; \
    ignore_bins ignore_barrier      = {svt_axi_transaction::MEMORY_BARRIER, \
                                       svt_axi_transaction::SYNC_BARRIER} iff(cfg.barrier_enable == 1'b0); \
    option.weight = 1; \
  }
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_BARRIER_SET \
  barrier_type : coverpoint cov_item.barrier_type iff(cov_barrier_type_flag){ \
    bins barrier_normal_respect    = {svt_axi_transaction::NORMAL_ACCESS_RESPECT_BARRIER}; \
    bins barrier_memory            = {svt_axi_transaction::MEMORY_BARRIER}; \
    bins barrier_normal_ignore     = {svt_axi_transaction::NORMAL_ACCESS_IGNORE_BARRIER}; \
    bins barrier_synchronization   = {svt_axi_transaction::SYNC_BARRIER}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_BARRIER_UNSET \
  barrier_type : coverpoint cov_item.barrier_type iff(cov_barrier_type_flag){ \
    bins barrier_normal_respect    = {svt_axi_transaction::NORMAL_ACCESS_RESPECT_BARRIER}; \
    bins barrier_normal_ignore     = {svt_axi_transaction::NORMAL_ACCESS_IGNORE_BARRIER}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_COHERENT_DVMMESSAGE_TYPE \
  ardvm_message_type : coverpoint cov_item.addr[14:12] iff(cov_ardvm_message_flag){ \
    bins message_tlb_invalidate                        = {3'b000}; \
    bins message_branch_predictor_invalidate           = {3'b001}; \
    bins message_physical_instruction_cache_invalidate = {3'b010}; \
    bins message_virtual_instruction_cache_invalidate  = {3'b011}; \
    bins message_synchronization                       = {3'b100}; \
    bins message_hint                                  = {3'b110}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_COHERENT_DVM_RESPONSE_TYPE \
  ardvm_resp : coverpoint cov_dvm_rresp iff(cov_ardvm_message_flag){ \
    bins message_accept         = {4'b0000}; \
    bins message_reject         = {4'b0010}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_COHERENT_RRESP_TYPE \
  coh_rresp : coverpoint cov_coherent_rresp iff(cov_coherent_rresp_flag){ \
    bins coherent_rresp_shared_clean         = {svt_axi_transaction::SHARED_CLEAN}; \
    bins coherent_rresp_shared_dirty         = {svt_axi_transaction::SHARED_DIRTY}; \
    bins coherent_rresp_unique_clean         = {svt_axi_transaction::UNIQUE_CLEAN}; \
    bins coherent_rresp_unique_dirty         = {svt_axi_transaction::UNIQUE_DIRTY}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_COHERENT_DVMMESSAGE_TYPE_PHY_INST_INVL \
  ardvm_message_type : coverpoint cov_item.addr[14:12] iff(cov_ardvm_message_flag){ \
    bins   message_physical_instruction_cache_invalidate = {3'b010}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_SNOOP_DVMMESSAGE_TYPE_PHY_INST_INVL \
  acdvm_message_type : coverpoint cov_snoop_item.snoop_addr[14:12] iff(cov_acdvm_message_flag){ \
    bins   message_physical_instruction_cache_invalidate = {3'b010}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_COHERENT_DVMMESSAGE_TYPE_VIR_INST_INVL \
  ardvm_message_type : coverpoint cov_item.addr[14:12] iff(cov_ardvm_message_flag){ \
    bins message_virtual_instruction_cache_invalidate  = {3'b011}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_SNOOP_DVMMESSAGE_TYPE_VIR_INST_INVL \
  acdvm_message_type : coverpoint cov_snoop_item.snoop_addr[14:12] iff(cov_acdvm_message_flag){ \
    bins message_virtual_instruction_cache_invalidate  = {3'b011}; \
    option.weight = 1; \
  }
  
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_COHERENT_DVMMESSAGE_TYPE_TLB_INVL \
  ardvm_message_type : coverpoint cov_item.addr[14:12] iff(cov_ardvm_message_flag){ \
    bins message_tlb_invalidate                        = {3'b000}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_SNOOP_DVMMESSAGE_TYPE_TLB_INVL \
  acdvm_message_type : coverpoint cov_snoop_item.snoop_addr[14:12] iff(cov_acdvm_message_flag){ \
    bins message_tlb_invalidate                        = {3'b000}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_COHERENT_DVMMESSAGE_TYPE_BP_INVL \
  ardvm_message_type : coverpoint cov_item.addr[14:12] iff(cov_ardvm_message_flag){ \
    bins  message_branch_predictor_invalidate            = {3'b001}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_SNOOP_DVMMESSAGE_TYPE_BP_INVL \
  acdvm_message_type : coverpoint cov_snoop_item.snoop_addr[14:12] iff(cov_acdvm_message_flag){ \
    bins  message_branch_predictor_invalidate            = {3'b001}; \
    option.weight = 1; \
  } 

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_COHERENT_DVM_HYPERVISOR_TYPE \
  ardvm_hypervisor_type : coverpoint cov_item.addr[11:10] iff(cov_ardvm_message_flag){ \
    bins all_guest_os                            = {2'b10}; \
    bins hypervisor_and_all_guest_os             = {2'b00}; \
    bins hypervisor                              = {2'b11}; \
    bins el                                      = {2'b01}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_SNOOP_DVM_HYPERVISOR_TYPE \
  acdvm_hypervisor_type : coverpoint cov_snoop_item.snoop_addr[11:10] iff(cov_acdvm_message_flag){ \
    bins all_guest_os                            = {2'b10}; \
    bins hypervisor_and_all_guest_os             = {2'b00}; \
    bins hypervisor                              = {2'b11}; \
    bins el                                      = {2'b01}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_COHERENT_DVM_SECURITY_TYPE \
  ardvm_security_type : coverpoint cov_item.addr[9:8] iff(cov_ardvm_message_flag){ \
    bins no_secure             = {2'b11}; \
    bins secure                = {2'b10}; \
    bins secure_and_no_secure  = {2'b00}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_SNOOP_DVM_SECURITY_TYPE \
  acdvm_security_type : coverpoint cov_snoop_item.snoop_addr[9:8] iff(cov_acdvm_message_flag){ \
    bins no_secure             = {2'b11}; \
    bins secure                = {2'b10}; \
    bins secure_and_no_secure  = {2'b00}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_COHERENT_DVM_VMID_ASID \
  ardvm_vmid_asid_or_virtindex: coverpoint cov_item.addr[6:5] iff(cov_ardvm_message_flag){ \
    bins  neither_vmid_asid            = {2'b00}; \
    bins  asid                         = {2'b01}; \
    bins  vmid                         = {2'b10}; \
    bins  vmid_asid                    = {2'b11}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_COHERENT_DVM_VIRT_INDEX \
  ardvm_virtindex: coverpoint cov_item.addr[6:5] iff(cov_ardvm_message_flag){ \
    bins  invl_by_virtindex            = {2'b11}; \
    bins  invl_without_virtindex       = {2'b00}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_COHERENT_DVM_LEAF_ENTRY \
  ardvm_leaf_entry : coverpoint cov_item.addr[4] iff(cov_ardvm_message_flag){ \
    bins leaf_entry_only      = {1'b1}; \
    bins not_leaf_entry       = {1'b0}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_COHERENT_DVM_VA \
  ardvm_va : coverpoint cov_item.addr[0] iff(cov_ardvm_message_flag){ \
    bins invalidate_by_va            = {1'b1}; \
    bins invalidate_not_by_va        = {1'b0}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_SNOOP_DVM_VA \
  acdvm_va : coverpoint cov_snoop_item.snoop_addr[0] iff(cov_acdvm_message_flag){ \
    bins invalidate_by_va            = {1'b1}; \
    bins invalidate_not_by_va        = {1'b0}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_COHERENT_DVM_STAGE_ONE_TWO \
  ardvm_stage_one_two : coverpoint cov_item.addr[3:2] iff(cov_ardvm_message_flag){ \
    bins stage_one_invalidate      = {2'b01}; \
    bins stage_two_invalidate      = {2'b10}; \
    bins nots1s2_invalidate        = {2'b00}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_COHERENT_DVM_ADDR_MODE_BITS \
  ardvm_addr_mode_bits : coverpoint dvm_addr_mode_bits_coverpoint[5:0] iff(cov_ardvm_message_flag){ \
  `ifdef SVT_AXI_PORT_MONITOR_DEF_COV_VMID_UNSET \
    bins invl_all                         = {6'b000000}; \
    bins invl_by_va                       = {6'b000001}; \
    bins invl_by_va_leaf_entry_only       = {6'b001001}; \
    bins invl_by_asid                     = {6'b010000}; \
    bins invl_by_asid_and_va              = {6'b010001}; \
    bins invl_by_asid_va_leaf_entry_only  = {6'b011001}; \
  `else \
    bins invl_all_guestOS_stage1_invl_only= {6'b100010}; \
    bins invl_all_guestOS_stage1_stage2   = {6'b100000}; \
    bins invl_by_va_guestOS               = {6'b100001}; \
    bins invl_by_va_guestOS_leaf_entry_only= {6'b101001}; \
    bins invl_by_asid_guestOS             = {6'b110000}; \
    bins invl_by_asid_va_guestOS          = {6'b110001}; \
    bins invl_by_asid_va_guestOS_leaf_entry_only = {6'b111001}; \
    bins invl_by_ipa_guestOS              = {6'b100101}; \
    bins invl_by_ipa_guestOS_leaf_entry_only = {6'b101101}; \
  `endif \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_ACSNOOP_DVM_ADDR_MODE_BITS \
  acdvm_addr_mode_bits : coverpoint snoop_dvm_addr_mode_bits_coverpoint[5:0] iff(cov_acdvm_message_flag){ \
  `ifdef SVT_AXI_PORT_MONITOR_DEF_COV_VMID_UNSET \
    bins invl_all                         = {6'b000000}; \
    bins invl_by_va                       = {6'b000001}; \
    bins invl_by_va_leaf_entry_only       = {6'b001001}; \
    bins invl_by_asid                     = {6'b010000}; \
    bins invl_by_asid_and_va              = {6'b010001}; \
    bins invl_by_asid_va_leaf_entry_only  = {6'b011001}; \
  `else \
    bins invl_all_guestOS_stage1_invl_only= {6'b100010}; \
    bins invl_all_guestOS_stage1_stage2   = {6'b100000}; \
    bins invl_by_va_guestOS               = {6'b100001}; \
    bins invl_by_va_guestOS_leaf_entry_only= {6'b101001}; \
    bins invl_by_asid_guestOS             = {6'b110000}; \
    bins invl_by_asid_va_guestOS          = {6'b110001}; \
    bins invl_by_asid_va_guestOS_leaf_entry_only = {6'b111001}; \
    bins invl_by_ipa_guestOS              = {6'b100101}; \
    bins invl_by_ipa_guestOS_leaf_entry_only = {6'b101101}; \
  `endif \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_COHERENT_DVM_MESSAGE_VIRT_INST_CACHE_INVL_BITS \
  dvm_message_virt_inst_cache_invl_bits : coverpoint dvm_message_virt_inst_cache_invl_bits_coverpoint[7:0] iff(cov_ardvm_message_flag){ \
 `ifdef SVT_AXI_PORT_MONITOR_DEF_COV_VMID_UNSET \
   bins invl_all_sec_non_sec_hypervisor_and_all_guest_os ={8 'b00000000}; \
   bins invl_all_non_sec_hypervisor_and_all_guest_os ={8 'b00110000}; \
   bins invl_by_asid_and_va_sec_all_guest_os ={8'b10100011}; \
   bins invl_by_va_non_sec_hypervisor ={8'b11110001}; \
 `else \
   bins invl_all_non_sec_guest_os ={8'b10110100}; \
   bins invl_by_asid_and_va_non_sec_guest_os ={8'b10110111}; \
 `endif \
   option.weight = 1; \
}

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_SNOOP_DVM_MESSAGE_VIRT_INST_CACHE_INVL_BITS \
  snoop_dvm_message_virt_inst_cache_invl_bits : coverpoint snoop_dvm_message_virt_inst_cache_invl_bits_coverpoint[7:0] iff(cov_acdvm_message_flag){ \
 `ifdef SVT_AXI_PORT_MONITOR_DEF_COV_VMID_UNSET \
   bins invl_all_sec_non_sec_hypervisor_and_all_guest_os ={8 'b00000000}; \
   bins invl_all_non_sec_hypervisor_and_all_guest_os ={8 'b00110000}; \
   bins invl_by_asid_and_va_sec_all_guest_os ={8'b10100011}; \
   bins invl_by_va_non_sec_hypervisor ={8'b11110001}; \
 `else \
   bins invl_all_non_sec_guest_os ={8'b10110100}; \
   bins invl_by_asid_and_va_non_sec_guest_os ={8'b10110111}; \
 `endif \
   option.weight = 1; \
}

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_COHERENT_DVM_MESSAGE_PHY_INST_CACHE_INVL_BITS \
  dvm_message_phy_inst_cache_invl_bits : coverpoint dvm_message_phy_inst_cache_invl_bits_coverpoint[5:0] iff(cov_ardvm_message_flag){ \
 `ifdef SVT_AXI_PORT_MONITOR_DEF_COV_VMID_UNSET \
   bins invl_all_sec_phy_inst_cache ={8 'b100000}; \
   bins invl_by_pa_without_virt_index_sec_phy_inst_cache ={6'b100001}; \
   bins invl_all_non_sec_phy_inst_cache  ={6 'b110000}; \
   bins invl_by_pa_without_virt_index_non_sec_phy_inst_cache ={6 'b110001}; \
 `else \
   bins invl_by_pa_with_virt_index_sec_phy_inst_cache ={6 'b100111}; \
   bins invl_by_pa_with_virt_index_non_sec_phy_inst_cache ={6 'b110111}; \
 `endif \
   option.weight = 1; \
}

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_SNOOP_DVM_MESSAGE_PHY_INST_CACHE_INVL_BITS \
  snoop_dvm_message_phy_inst_cache_invl_bits : coverpoint snoop_dvm_message_phy_inst_cache_invl_bits_coverpoint[5:0] iff(cov_acdvm_message_flag){ \
 `ifdef SVT_AXI_PORT_MONITOR_DEF_COV_VMID_UNSET \
   bins invl_all_sec_phy_inst_cache ={8 'b100000}; \
   bins invl_by_pa_without_virt_index_sec_phy_inst_cache ={6'b100001}; \
   bins invl_all_non_sec_phy_inst_cache  ={6 'b110000}; \
   bins invl_by_pa_without_virt_index_non_sec_phy_inst_cache ={6 'b110001}; \
 `else \
   bins invl_by_pa_with_virt_index_sec_phy_inst_cache ={6 'b100111}; \
   bins invl_by_pa_with_virt_index_non_sec_phy_inst_cache ={6 'b110111}; \
 `endif \
   option.weight = 1; \
}

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_COHERENT_DVM_ARADDR_FIRSTPART_VA_OR_VMID \
  araddr_dvm_firstpart_va_or_vmid : coverpoint dvm_araddr_firstpart_va_vmid_coverpoint iff(cov_dvm_araddr_viraddr_or_vmid_flag){ \
    bins dvm_araddr_bits_31to24_range_1         = {['h0:'h3F]};\
    bins dvm_araddr_bits_31to24_range_2         = {['h40:'h7F]};\
    bins dvm_araddr_bits_31to24_range_3         = {['h80:'hBF]};\
    bins dvm_araddr_bits_31to24_range_4         = {['hC0:'hFF]};\
    option.weight = 1; \
  }
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_COHERENT_DVM_ARADDR_FIRSTPART_VA_OR_VMID_6_BIT_0 \
  araddr_dvm_firstpart_va_or_vmid : coverpoint dvm_araddr_firstpart_va_vmid_coverpoint iff(cov_dvm_araddr_viraddr_or_vmid_flag){ \
    bins dvm_araddr_bits_31to24_range_1         = {['h0:'h3F]};\
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_SNOOP_DVM_ARADDR_FIRSTPART_VA_OR_VMID_6_BIT_0 \
  acaddr_dvm_firstpart_va_or_vmid : coverpoint snoop_dvm_araddr_firstpart_va_vmid_coverpoint iff(cov_snoop_dvm_araddr_viraddr_or_vmid_flag){ \
    bins dvm_araddr_bits_31to24_range_1         = {['h0:'h3F]};\
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_SNOOP_DVM_ARADDR_FIRSTPART_VA_OR_VMID \
  acaddr_dvm_firstpart_va_or_vmid : coverpoint snoop_dvm_araddr_firstpart_va_vmid_coverpoint iff(cov_snoop_dvm_araddr_viraddr_or_vmid_flag){ \
    bins dvm_araddr_bits_31to24_range_1         = {['h0:'h3F]};\
    bins dvm_araddr_bits_31to24_range_2         = {['h40:'h7F]};\
    bins dvm_araddr_bits_31to24_range_3         = {['h80:'hBF]};\
    bins dvm_araddr_bits_31to24_range_4         = {['hC0:'hFF]};\
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_COHERENT_DVM_ARADDR_FIRSTPART_VA_OR_ASID \
  araddr_dvm_firsrpart_va_or_asid : coverpoint dvm_araddr_firstpart_va_asid_coverpoint iff(cov_dvm_araddr_viraddr_or_asid_flag){ \
    bins dvm_araddr_bits_23to16_range_1         = {['h0:'h3F]};\
 `ifndef SVT_AXI_PORT_MONITOR_DEF_COV_VMID_UNSET \
    bins dvm_araddr_bits_23to16_range_2         = {['h40:'h7F]};\
    bins dvm_araddr_bits_23to16_range_3         = {['h80:'hBF]};\
    bins dvm_araddr_bits_23to16_range_4         = {['hC0:'hFF]};\
 `endif \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_SNOOP_DVM_ARADDR_FIRSTPART_VA_OR_ASID \
  acaddr_dvm_firstpart_va_or_asid : coverpoint snoop_dvm_araddr_firstpart_va_asid_coverpoint iff(cov_snoop_dvm_araddr_viraddr_or_asid_flag){ \
    bins dvm_araddr_bits_23to16_range_1         = {['h0:'h3F]};\
 `ifndef SVT_AXI_PORT_MONITOR_DEF_COV_VMID_UNSET \
    bins dvm_araddr_bits_23to16_range_2         = {['h40:'h7F]};\
    bins dvm_araddr_bits_23to16_range_3         = {['h80:'hBF]};\
    bins dvm_araddr_bits_23to16_range_4         = {['hC0:'hFF]};\
 `endif \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_COHERENT_DVM_ARADDR_FIRSTPART_MSB39TO32 \
  araddr_dvm_msb39to32_firstpart : coverpoint dvm_araddr_firstpart_msbto32_coverpoint iff(cov_dvm_araddr_firstpart_width8_flag){ \
    bins dvm_araddr_firstpart_range_1         = {['h0:'h3F]};\
    bins dvm_araddr_firstpart_range_2         = {['h40:'h7F]};\
    bins dvm_araddr_firstpart_range_3         = {['h80:'hBF]};\
    bins dvm_araddr_firstpart_range_4         = {['hC0:'hFF]};\
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_SNOOP_DVM_ARADDR_FIRSTPART_MSB39TO32 \
  acaddr_dvm_msb39to32_firstpart : coverpoint snoop_dvm_araddr_firstpart_msbto32_coverpoint iff(cov_snoop_dvm_araddr_firstpart_width8_flag){ \
    bins dvm_araddr_firstpart_range_1         = {['h0:'h3F]};\
    bins dvm_araddr_firstpart_range_2         = {['h40:'h7F]};\
    bins dvm_araddr_firstpart_range_3         = {['h80:'hBF]};\
    bins dvm_araddr_firstpart_range_4         = {['hC0:'hFF]};\
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_COHERENT_DVM_ARADDR_FIRSTPART_MSB43TO32 \
  araddr_dvm_msb43to32_firstpart : coverpoint dvm_araddr_firstpart_msbto32_coverpoint iff(cov_dvm_araddr_firstpart_width12_flag){ \
    bins dvm_araddr_firstpart_range_1         = {['h0:'h3FF]};\
    bins dvm_araddr_firstpart_range_2         = {['h400:'h7FF]};\
    bins dvm_araddr_firstpart_range_3         = {['h800:'hBFF]};\
    bins dvm_araddr_firstpart_range_4         = {['hC00:'hFFF]};\
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_SNOOP_DVM_ARADDR_FIRSTPART_MSB43TO32 \
  acaddr_dvm_msb43to32_firstpart : coverpoint snoop_dvm_araddr_firstpart_msbto32_coverpoint iff(cov_snoop_dvm_araddr_firstpart_width12_flag){ \
    bins dvm_araddr_firstpart_range_1         = {['h0:'h3FF]};\
    bins dvm_araddr_firstpart_range_2         = {['h400:'h7FF]};\
    bins dvm_araddr_firstpart_range_3         = {['h800:'hBFF]};\
    bins dvm_araddr_firstpart_range_4         = {['hC00:'hFFF]};\
    option.weight = 1; \
  } 

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_COHERENT_DVM_ARADDR_FIRSTPART_MSB47TO32 \
  araddr_dvm_msb47to32_firstpart : coverpoint dvm_araddr_firstpart_msbto32_coverpoint iff(cov_dvm_araddr_firstpart_width16_flag){ \
    bins dvm_araddr_firstpart_range_1         = {['h0:'h1FFF]};\
    bins dvm_araddr_firstpart_range_2         = {['h2000:'h9FFF]};\
    bins dvm_araddr_firstpart_range_3         = {['hA000:'hFFFF]};\
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_SNOOP_DVM_ARADDR_FIRSTPART_MSB47TO32 \
  acaddr_dvm_msb47to32_firstpart : coverpoint snoop_dvm_araddr_firstpart_msbto32_coverpoint iff(cov_snoop_dvm_araddr_firstpart_width16_flag){ \
    bins dvm_araddr_firstpart_range_1         = {['h0:'h1FFF]};\
    bins dvm_araddr_firstpart_range_2         = {['h2000:'h9FFF]};\
    bins dvm_araddr_firstpart_range_3         = {['hA000:'hFFFF]};\
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_COHERENT_DVM_ARADDR_FIRSTPART_MSB55TO32 \
  araddr_dvm_msb55to32_firstpart : coverpoint dvm_araddr_firstpart_msbto32_coverpoint iff(cov_dvm_araddr_firstpart_width24_flag){ \
    bins dvm_araddr_firstpart_range_1         = {['h0:'hFFFFF]};\
    bins dvm_araddr_firstpart_range_2         = {['h100000:'h6FFFFF]};\
    bins dvm_araddr_firstpart_range_3         = {['h700000:'hBFFFFF]};\
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_SNOOP_DVM_ARADDR_FIRSTPART_MSB55TO32 \
  acaddr_dvm_msb55to32_firstpart : coverpoint snoop_dvm_araddr_firstpart_msbto32_coverpoint iff(cov_snoop_dvm_araddr_firstpart_width24_flag){ \
    bins dvm_araddr_firstpart_range_1         = {['h0:'hFFFFF]};\
    bins dvm_araddr_firstpart_range_2         = {['h100000:'h6FFFFF]};\
    bins dvm_araddr_firstpart_range_3         = {['h700000:'hBFFFFF]};\
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_COHERENT_DVM_ARADDR_FIRSTPART_MSB63TO32 \
  araddr_dvm_msb63to32_firstpart : coverpoint  dvm_araddr_firstpart_msbto32_coverpoint iff(cov_dvm_araddr_firstpart_width32_flag){ \
    bins dvm_araddr_firstpart_range_1          = {[64'h0:64'hFFFFFFF]}; \
    bins dvm_araddr_firstpart_range_2          = {[64'h10000000:64'h8FFFFFFF]};\
    bins dvm_araddr_firstpart_range_3          = {[64'h90000000:64'hFFFFFFFF]};\
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_SNOOP_DVM_ARADDR_FIRSTPART_MSB63TO32 \
  acaddr_dvm_msb63to32_firstpart : coverpoint  snoop_dvm_araddr_firstpart_msbto32_coverpoint iff(cov_snoop_dvm_araddr_firstpart_width32_flag){ \
    bins dvm_acaddr_firstpart_range_1          = {[64'h0:64'hFFFFFFF]}; \
    bins dvm_acaddr_firstpart_range_2          = {[64'h10000000:64'h8FFFFFFF]};\
    bins dvm_acaddr_firstpart_range_3          = {[64'h90000000:64'hFFFFFFFF]};\
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_COHERENT_DVM_ARADDR_SECONDPART_32 \
  araddr_dvm_secondpart_32 : coverpoint dvm_araddr_secondpart_coverpoint iff(cov_dvm_araddr_secondpart_width32_flag){ \
    bins dvm_araddr_secondpart_range_1         = {['h0:'h1FFFFFF]}; \
    bins dvm_araddr_secondpart_range_2         = {['h2000000:'h9FFFFFF]};\
    bins dvm_araddr_secondpart_range_3         = {['hA000000:'hFFFFFFF]};\
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_SNOOP_DVM_ARADDR_SECONDPART_32 \
  acaddr_dvm_secondpart_32 : coverpoint snoop_dvm_araddr_secondpart_coverpoint iff(cov_snoop_dvm_araddr_secondpart_width32_flag){ \
    bins dvm_araddr_secondpart_range_1         = {['h0:'h1FFFFFF]}; \
    bins dvm_araddr_secondpart_range_2         = {['h2000000:'h9FFFFFF]};\
    bins dvm_araddr_secondpart_range_3         = {['hA000000:'hFFFFFFF]};\
    option.weight = 1; \
  }
  
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_COHERENT_DVM_ARADDR_SECONDPART_40 \
  araddr_dvm_secondpart_40 : coverpoint dvm_araddr_secondpart_coverpoint iff(cov_dvm_araddr_secondpart_width40_flag){ \
    bins dvm_araddr_secondpart_range_1         = {[64'h0:64'h1FFFFFFFF]};\
    bins dvm_araddr_secondpart_range_2         = {[64'h200000000:64'h9FFFFFFFF]};\
    bins dvm_araddr_secondpart_range_3         = {[64'hA00000000:64'hFFFFFFFFF]};\
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_SNOOP_DVM_ARADDR_SECONDPART_40 \
  acaddr_dvm_secondpart_40 : coverpoint snoop_dvm_araddr_secondpart_coverpoint iff(cov_snoop_dvm_araddr_secondpart_width40_flag){ \
    bins dvm_araddr_secondpart_range_1         = {[64'h0:64'h1FFFFFFFF]};\
    bins dvm_araddr_secondpart_range_2         = {[64'h200000000:64'h9FFFFFFFF]};\
    bins dvm_araddr_secondpart_range_3         = {[64'hA00000000:64'hFFFFFFFFF]};\
    option.weight = 1; \
  }  

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_COHERENT_DVM_ARADDR_SECONDPART_44 \
  araddr_dvm_secondpart_44 : coverpoint dvm_araddr_secondpart_coverpoint iff(cov_dvm_araddr_secondpart_width44_flag){ \
    bins dvm_araddr_secondpart_range_1         = {[64'h0:64'h3FFFFFFFFF]}; \
    bins dvm_araddr_secondpart_range_2         = {[64'h4000000000:64'h7FFFFFFFFF]};\
    bins dvm_araddr_secondpart_range_3         = {[64'h8000000000:64'hBFFFFFFFFF]};\
    bins dvm_araddr_secondpart_range_4         = {[64'hC000000000:64'hFFFFFFFFFF]};\
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_SNOOP_DVM_ARADDR_SECONDPART_44 \
  acaddr_dvm_secondpart_44 : coverpoint snoop_dvm_araddr_secondpart_coverpoint iff(cov_snoop_dvm_araddr_secondpart_width44_flag){ \
    bins dvm_araddr_secondpart_range_1         = {[64'h0:64'h3FFFFFFFFF]}; \
    bins dvm_araddr_secondpart_range_2         = {[64'h4000000000:64'h7FFFFFFFFF]};\
    bins dvm_araddr_secondpart_range_3         = {[64'h8000000000:64'hBFFFFFFFFF]};\
    bins dvm_araddr_secondpart_range_4         = {[64'hC000000000:64'hFFFFFFFFFF]};\
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_COHERENT_DVM_ARADDR_SECONDPART_48 \
  araddr_dvm_secondpart_48 : coverpoint dvm_araddr_secondpart_coverpoint iff(cov_dvm_araddr_secondpart_width48_flag){ \
    bins dvm_araddr_secondpart_range_1         = {[64'h0:64'h3FFFFFFFFFF]}; \
    bins dvm_araddr_secondpart_range_2         = {[64'h40000000000:64'h7FFFFFFFFFF]};\
    bins dvm_araddr_secondpart_range_3         = {[64'h80000000000:64'hBFFFFFFFFFF]};\
    bins dvm_araddr_secondpart_range_4         = {[64'hC0000000000:64'hFFFFFFFFFFF]};\
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_COHERENT_DVM_ARADDR_SECONDPART_56 \
  araddr_dvm_secondpart_56 : coverpoint dvm_araddr_secondpart_coverpoint iff(cov_dvm_araddr_secondpart_width56_flag){ \
    bins dvm_araddr_secondpart_range_1         = {[64'h0:64'h3FFFFFFFFFFFF]}; \
    bins dvm_araddr_secondpart_range_2         = {[64'h4000000000000:64'h7FFFFFFFFFFFF]};\
    bins dvm_araddr_secondpart_range_3         = {[64'h8000000000000:64'hBFFFFFFFFFFFF]};\
    bins dvm_araddr_secondpart_range_4         = {[64'hC000000000000:64'hFFFFFFFFFFFFF]};\
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_COHERENT_DVM_ARADDR_SECONDPART_64 \
  araddr_dvm_secondpart_64 : coverpoint dvm_araddr_secondpart_coverpoint iff(cov_dvm_araddr_secondpart_width64_flag){ \
    bins dvm_araddr_secondpart_range_1         = {[64'h0:64'h3FFFFFFFFFFFFFF]};\
    bins dvm_araddr_secondpart_range_2         = {[64'h400000000000000:64'h7FFFFFFFFFFFFFF]};\
    bins dvm_araddr_secondpart_range_3         = {[64'h800000000000000:64'hBFFFFFFFFFFFFFF]};\
    bins dvm_araddr_secondpart_range_4         = {[64'hC00000000000000:64'hFFFFFFFFFFFFFFF]};\
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_SNOOP_DVM_ARADDR_SECONDPART_48 \
  acaddr_dvm_secondpart_48 : coverpoint snoop_dvm_araddr_secondpart_coverpoint iff(cov_snoop_dvm_araddr_secondpart_width48_flag){ \
    bins dvm_araddr_secondpart_range_1         = {[64'h0:64'h3FFFFFFFFFF]}; \
    bins dvm_araddr_secondpart_range_2         = {[64'h40000000000:64'h7FFFFFFFFFF]};\
    bins dvm_araddr_secondpart_range_3         = {[64'h80000000000:64'hBFFFFFFFFFF]};\
    bins dvm_araddr_secondpart_range_4         = {[64'hC0000000000:64'hFFFFFFFFFFF]};\
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_SNOOP_DVM_ARADDR_SECONDPART_56 \
  acaddr_dvm_secondpart_56 : coverpoint snoop_dvm_araddr_secondpart_coverpoint iff(cov_snoop_dvm_araddr_secondpart_width56_flag){ \
    bins dvm_araddr_secondpart_range_1         = {[64'h0:64'h3FFFFFFFFFFFF]}; \
    bins dvm_araddr_secondpart_range_2         = {[64'h4000000000000:64'h7FFFFFFFFFFFF]};\
    bins dvm_araddr_secondpart_range_3         = {[64'h8000000000000:64'hBFFFFFFFFFFFF]};\
    bins dvm_araddr_secondpart_range_4         = {[64'hC000000000000:64'hFFFFFFFFFFFFF]};\
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_SNOOP_DVM_ARADDR_SECONDPART_64 \
  acaddr_dvm_secondpart_64 : coverpoint snoop_dvm_araddr_secondpart_coverpoint iff(cov_snoop_dvm_araddr_secondpart_width64_flag){ \
    bins dvm_acaddr_secondpart_range_1         = {[64'h0:64'h3FFFFFFFFFFFFFF]};\
    bins dvm_acaddr_secondpart_range_2         = {[64'h400000000000000:64'h7FFFFFFFFFFFFFF]};\
    bins dvm_acaddr_secondpart_range_3         = {[64'h800000000000000:64'hBFFFFFFFFFFFFFF]};\
    bins dvm_acaddr_secondpart_range_4         = {[64'hC00000000000000:64'hFFFFFFFFFFFFFFF]};\
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_DVM_OVERLAP_COVER_ACVALID \
 acvalid : coverpoint  axi_monitor_mp.axi_monitor_cb.acvalid  { \
   bins acvalid_val = {1}; \
   option.weight=0; \
   }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_DVM_OVERLAP_COVER_ARREADY_0 \
 arready_0 : coverpoint axi_monitor_mp.axi_monitor_cb.arready { \
   bins arready_val_0 = {0}; \
   option.weight=0; \
   }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_DVM_OVERLAP_COVER_RVALID_1 \
 rvalid_1 : coverpoint  axi_monitor_mp.axi_monitor_cb.rvalid  { \
   bins rvalid_val_1 = {1}; \
   option.weight=0; \
   }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_DVM_OVERLAP_COVER_RREADY_0 \
 rready_0 : coverpoint axi_monitor_mp.axi_monitor_cb.rready { \
   bins rready_val_0 = {0}; \
   option.weight=0; \
   }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_DVM_OVERLAP_COVER_BVALID_1 \
 bvalid_1 : coverpoint  axi_monitor_mp.axi_monitor_cb.bvalid  { \
   bins bvalid_val_1 = {1}; \
   option.weight=0; \
   }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_DVM_OVERLAP_COVER_BREADY_0 \
 bready_0 : coverpoint axi_monitor_mp.axi_monitor_cb.bready { \
   bins bready_val_0 = {0}; \
   option.weight=0; \
   }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_DVM_OVERLAP_COVER_AWREADY_0 \
 awready_0 : coverpoint axi_monitor_mp.axi_monitor_cb.awready { \
   bins awready_val_0 = {0}; \
   option.weight=0; \
   }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_DVM_OVERLAP_COVER_ACREADY \
 acready : coverpoint axi_monitor_mp.axi_monitor_cb.acready { \
   bins acready_val = {1}; \
   option.weight=0; \
   }
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_DVM_OVERLAP_COVER_ACSNOOP \
 acsnoop : coverpoint axi_monitor_mp.axi_monitor_cb.acsnoop { \
   bins acsnoop_val = {`SVT_AXI_ACE_SNOOP_TYPE_WIDTH'b1110 ,`SVT_AXI_ACE_SNOOP_TYPE_WIDTH'b1111}; \
   option.weight=0; \
   }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_DVM_OVERLAP_COVER_CRVALID \
 crvalid : coverpoint  axi_monitor_mp.axi_monitor_cb.crvalid  { \
   bins crvalid_val = {1}; \
   option.weight=0; \
   }
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_DVM_OVERLAP_COVER_CRREADY \
 crready : coverpoint  axi_monitor_mp.axi_monitor_cb.crready  { \
   bins crready_val = {1}; \
   option.weight=0; \
   }
`define SVT_ACE_SYS_MONITOR_DEF_COV_UTIL_ARVALID_1 \
   arvalid : coverpoint  axi_monitor_mp.axi_monitor_cb.arvalid  { \
   bins arvalid_val = {1};\
   option.weight=0;\
   }
`define SVT_ACE_SYS_MONITOR_DEF_COV_UTIL_ARREADY_1 \
   arready : coverpoint  axi_monitor_mp.axi_monitor_cb.arready  { \
   bins arready_val = {1};\
   option.weight=0;\
   }
`define SVT_ACE_SYS_MONITOR_DEF_COV_UTIL_AWVALID_1 \
   awvalid : coverpoint  axi_monitor_mp.axi_monitor_cb.awvalid  { \
   bins awvalid_val = {1};\
   option.weight=0;\
   }
`define SVT_ACE_SYS_MONITOR_DEF_COV_UTIL_AWREADY_1 \
   awready : coverpoint  axi_monitor_mp.axi_monitor_cb.awready  { \
   bins awready_val = {1};\
   option.weight=0;\
   } 
`define SVT_ACE_SYS_MONITOR_DEF_COV_UTIL_ACVALID_0 \
   acvalid_val : coverpoint  axi_monitor_mp.axi_monitor_cb.acvalid  { \
   bins acvalid = {0};\
   option.weight=0;\
   }
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_SNOOP_DVM_IGNORE_TLBINVL_MODES_VIRTADDR \
  ignore_bins ignore_bins_hypervisor_and_all_guest_os = (binsof(acdvm_hypervisor_type) intersect {2'b00}); \
`ifdef SVT_AXI_PORT_MONITOR_DEF_COV_VMID_UNSET \
  //Ignoring Invalid addr_mode_bits for hypervisor and el \
  ignore_bins ignore_bins_hypervisor_and_el_and_invalid_addr_mode = ((binsof(acdvm_hypervisor_type) intersect {2'b11,2'b01}) && \
                                                                    (!binsof(acdvm_addr_mode_bits) intersect {6'b000000,6'b000001,6'b001001})); \
  // Ignoring cross of hypervisor and secure type \
  ignore_bins ignore_bins_hypervisor_and_secure = ((binsof(acdvm_security_type) intersect {2'b10}) && (binsof(acdvm_hypervisor_type) intersect {2'b11})) ; \
  // Ignoring cross of el and non-secure type \
  ignore_bins ignore_bins_el_and_non_secure = ((binsof(acdvm_security_type) intersect {2'b11}) && (binsof(acdvm_hypervisor_type) intersect {2'b01})); \
  // Ignoring guest_os hypervisor from acdvm_hypervisor_type \
  ignore_bins ignore_bins_guest_os_hypervisor = (binsof(acdvm_hypervisor_type) intersect {2'b10}); \
  // Ignoring cross of secure and non_secure and hypervisor type \
  ignore_bins ignore_bins_hypervisor_and_el_and_secure_and_non_secure = ((binsof(acdvm_hypervisor_type) intersect {2'b11,2'b01}) && (binsof(acdvm_security_type) intersect {2'b00})); \
`else \
  // Ignoring hypervisor and el bin from acdvm_hypervisor_type \
  ignore_bins ignore_bins_hypervisor = (binsof(acdvm_hypervisor_type) intersect {2'b00,2'b11,2'b01}); \
  // Ignoring cross of secure and non_secure and guest os type \
  ignore_bins ignore_bins_guest_os_and_secure_and_non_secure = ((binsof(acdvm_hypervisor_type) intersect {2'b10}) && (binsof(acdvm_security_type) intersect {2'b00,2'b10})); \
  ignore_bins ignore_bins_no_secure_and_invl_by_va_hypervisor_all_guest_os = ((binsof(acdvm_security_type) intersect {2'b11}) && (binsof(acdvm_hypervisor_type) intersect {2'b10})); \
  ignore_bins ignore_bins_no_secure_and_invl_by_va_leaf_entry_only_hypervisor_all_guest_os = ((binsof(acdvm_security_type) intersect {2'b11}) && (binsof(acdvm_hypervisor_type) intersect {2'b10})); \
  ignore_bins ignore_bins_no_secure_and_invl_by_asid_hypervisor_all_guest_os = ((binsof(acdvm_security_type) intersect {2'b11}) && \
                                                                                (binsof(acdvm_hypervisor_type) intersect {2'b10})); \
  ignore_bins ignore_bins_no_secure_and_invl_by_asid_and_va_hypervisor_all_guest_os = ((binsof(acdvm_security_type) intersect {2'b11}) && (binsof(acdvm_hypervisor_type) intersect {2'b10})); \
  ignore_bins ignore_bins_no_secure_and_invl_by_asid_va_leaf_entry_only_hypervisor_all_guest_os = ((binsof(acdvm_security_type) intersect {2'b11}) && (binsof(acdvm_hypervisor_type) intersect {2'b10})); \
`endif \

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_COHERENT_DVM_IGNORE_TLBINVL_MODES_VIRTADDR \
  ignore_bins ignore_bins_hypervisor_and_all_guest_os = (binsof(ardvm_hypervisor_type) intersect {2'b00}); \
`ifdef SVT_AXI_PORT_MONITOR_DEF_COV_VMID_UNSET \
  //Ignoring Invalid addr_mode_bits for hypervisor and el \
  ignore_bins ignore_bins_hypervisor_and_el_and_invalid_addr_mode = ((binsof(ardvm_hypervisor_type) intersect {2'b11,2'b01}) && \
                                                                    (!binsof(ardvm_addr_mode_bits) intersect {6'b000000,6'b000001,6'b001001})); \
  // Ignoring cross of hypervisor and secure type \
  ignore_bins ignore_bins_hypervisor_and_secure = ((binsof(ardvm_security_type) intersect {2'b10}) && (binsof(ardvm_hypervisor_type) intersect {2'b11})) ; \
  // Ignoring cross of el and non-secure type \
  ignore_bins ignore_bins_el_and_non_secure = ((binsof(ardvm_security_type) intersect {2'b11}) && (binsof(ardvm_hypervisor_type) intersect {2'b01})); \
  // Ignoring guest_os hypervisor from ardvm_hypervisor_type \
  ignore_bins ignore_bins_guest_os_hypervisor = (binsof(ardvm_hypervisor_type) intersect {2'b10}); \
  // Ignoring cross of secure and non_secure and hypervisor type \
  ignore_bins ignore_bins_hypervisor_and_el_and_secure_and_non_secure = ((binsof(ardvm_hypervisor_type) intersect {2'b11,2'b01}) && (binsof(ardvm_security_type) intersect {2'b00})); \
`else \
  // Ignoring hypervisor and el bin from ardvm_hypervisor_type \
  ignore_bins ignore_bins_hypervisor = (binsof(ardvm_hypervisor_type) intersect {2'b00,2'b11,2'b01}); \
  // Ignoring cross of secure and non_secure and guest os type \
  ignore_bins ignore_bins_guest_os_and_secure_and_non_secure = ((binsof(ardvm_hypervisor_type) intersect {2'b10}) && (binsof(ardvm_security_type) intersect {2'b00,2'b10})); \
  ignore_bins ignore_bins_no_secure_and_invl_by_va_hypervisor_all_guest_os = ((binsof(ardvm_security_type) intersect {2'b11}) && (binsof(ardvm_hypervisor_type) intersect {2'b10})); \
  ignore_bins ignore_bins_no_secure_and_invl_by_va_leaf_entry_only_hypervisor_all_guest_os = ((binsof(ardvm_security_type) intersect {2'b11}) && (binsof(ardvm_hypervisor_type) intersect {2'b10})); \
  ignore_bins ignore_bins_no_secure_and_invl_by_asid_hypervisor_all_guest_os = ((binsof(ardvm_security_type) intersect {2'b11}) && \
                                                                                (binsof(ardvm_hypervisor_type) intersect {2'b10})); \
  ignore_bins ignore_bins_no_secure_and_invl_by_asid_and_va_hypervisor_all_guest_os = ((binsof(ardvm_security_type) intersect {2'b11}) && (binsof(ardvm_hypervisor_type) intersect {2'b10})); \
  ignore_bins ignore_bins_no_secure_and_invl_by_asid_va_leaf_entry_only_hypervisor_all_guest_os = ((binsof(ardvm_security_type) intersect {2'b11}) && (binsof(ardvm_hypervisor_type) intersect {2'b10})); \
`endif \

`ifndef SVT_AXI_MON_CFG_BASED_COV_GRP_DEF
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_SNOOP_ADDR \
  snoop_addr : coverpoint cov_snoop_item.snoop_addr  iff(cov_snoop_addr_flag){ \
    option.weight = 1; \
     bins addr_range_min = {0};\
`ifdef SVT_MULTI_SIM_COVPOINT_GREATER_THAN_32_BITS \
     // Need to come up with an alternative \
`else \
     bins addr_range_mid = {[1:(64'd2**(`SVT_AXI_ACE_SNOOP_ADDR_WIDTH)-2)]}; \
     bins addr_range_max = {((64'd2**(`SVT_AXI_ACE_SNOOP_ADDR_WIDTH))-1)}; \
     ignore_bins Ignore_addr_range_max = {((64'd2**(`SVT_AXI_ACE_SNOOP_ADDR_WIDTH))-1)} iff(cfg.axi_interface_type == svt_axi_port_configuration::AXI_ACE  ||  cfg.axi_interface_type == svt_axi_port_configuration::ACE_LITE); \
`endif \
  ignore_bins Ignore_addr_range_min = {0} iff(cfg.axi_interface_type == svt_axi_port_configuration::AXI_ACE  ||  cfg.axi_interface_type == svt_axi_port_configuration::ACE_LITE); \
  }
`endif
`ifdef SVT_AXI_MON_CFG_BASED_COV_GRP_DEF
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_SNOOP_ADDR \
  snoop_addr : coverpoint cov_snoop_item.snoop_addr  iff(cov_snoop_addr_flag){ \
    option.weight = 1; \
     bins addr_range_min = {0};\
`ifdef SVT_MULTI_SIM_COVPOINT_GREATER_THAN_32_BITS \
     // Need to come up with an alternative \
`else \
     bins addr_range_mid = {[1:(64'd2**(`SVT_AXI_ACE_SNOOP_ADDR_WIDTH)-2)]}; \
     bins addr_range_max = {((64'd2**(`SVT_AXI_ACE_SNOOP_ADDR_WIDTH))-1)}; \
     ignore_bins Ignore_addr_range_max = {((64'd2**(`SVT_AXI_ACE_SNOOP_ADDR_WIDTH))-1)}; \
`endif \
  ignore_bins Ignore_addr_range_min = {0}; \
  }
`endif

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_SNOOP_XACT_TYPE \
  snoop_xact_type : coverpoint cov_snoop_item.snoop_xact_type iff(cov_snoop_xact_type_flag){ \
    bins snoop_readonce_xact   = {svt_axi_snoop_transaction::READONCE}; \
    bins snoop_readshared_xact   = {svt_axi_snoop_transaction::READSHARED}; \
    bins snoop_readclean_xact   = {svt_axi_snoop_transaction::READCLEAN}; \
    bins snoop_readnotshareddirty_xact   = {svt_axi_snoop_transaction::READNOTSHAREDDIRTY}; \
    bins snoop_readunique_xact   = {svt_axi_snoop_transaction::READUNIQUE}; \
    bins snoop_cleanshared_xact   = {svt_axi_snoop_transaction::CLEANSHARED}; \
    bins snoop_cleaninvalid_xact   = {svt_axi_snoop_transaction::CLEANINVALID}; \
    bins snoop_makeinvalid_xact   = {svt_axi_snoop_transaction::MAKEINVALID}; \
    bins snoop_dvmcomplete_xact   = {svt_axi_snoop_transaction::DVMCOMPLETE}; \
    bins snoop_dvmmessage_xact   = {svt_axi_snoop_transaction::DVMMESSAGE}; \
    ignore_bins ignore_snoop_dvm = {svt_axi_snoop_transaction::DVMMESSAGE,svt_axi_snoop_transaction::DVMCOMPLETE} \
                                   iff(cfg.dvm_enable == 1'b0); \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_SNOOP_XACT_TYPE_ONE_ACE_ACELITE \
  snoop_xact_type : coverpoint cov_snoop_item.snoop_xact_type iff(cov_snoop_xact_type_flag){ \
    bins snoop_readonce_xact   = {svt_axi_snoop_transaction::READONCE}; \
    bins snoop_cleanshared_xact   = {svt_axi_snoop_transaction::CLEANSHARED}; \
    bins snoop_cleaninvalid_xact   = {svt_axi_snoop_transaction::CLEANINVALID}; \
    bins snoop_makeinvalid_xact   = {svt_axi_snoop_transaction::MAKEINVALID}; \
    bins snoop_dvmcomplete_xact   = {svt_axi_snoop_transaction::DVMCOMPLETE}; \
    bins snoop_dvmmessage_xact   = {svt_axi_snoop_transaction::DVMMESSAGE}; \
    ignore_bins ignore_snoop_dvm = {svt_axi_snoop_transaction::DVMMESSAGE,svt_axi_snoop_transaction::DVMCOMPLETE} \
                                   iff(cfg.dvm_enable == 1'b0); \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_SNOOP_XACT_TYPE_NO_DVM \
  snoop_xact_type : coverpoint master_snoop_xact_type { \
    bins snoop_readonce_xact   = {svt_axi_snoop_transaction::READONCE}; \
    bins snoop_readshared_xact   = {svt_axi_snoop_transaction::READSHARED}; \
    bins snoop_readclean_xact   = {svt_axi_snoop_transaction::READCLEAN}; \
    bins snoop_readnotshareddirty_xact   = {svt_axi_snoop_transaction::READNOTSHAREDDIRTY}; \
    bins snoop_readunique_xact   = {svt_axi_snoop_transaction::READUNIQUE}; \
    bins snoop_cleanshared_xact   = {svt_axi_snoop_transaction::CLEANSHARED}; \
    bins snoop_cleaninvalid_xact   = {svt_axi_snoop_transaction::CLEANINVALID}; \
    bins snoop_makeinvalid_xact   = {svt_axi_snoop_transaction::MAKEINVALID}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_SNOOP_XACT_TYPE_DVM_UNSET \
  snoop_xact_type : coverpoint cov_snoop_item.snoop_xact_type iff(cov_snoop_xact_type_flag){ \
    bins snoop_readonce_xact   = {svt_axi_snoop_transaction::READONCE}; \
    bins snoop_readshared_xact   = {svt_axi_snoop_transaction::READSHARED}; \
    bins snoop_readclean_xact   = {svt_axi_snoop_transaction::READCLEAN}; \
    bins snoop_readnotshareddirty_xact   = {svt_axi_snoop_transaction::READNOTSHAREDDIRTY}; \
    bins snoop_readunique_xact   = {svt_axi_snoop_transaction::READUNIQUE}; \
    bins snoop_cleanshared_xact   = {svt_axi_snoop_transaction::CLEANSHARED}; \
    bins snoop_cleaninvalid_xact   = {svt_axi_snoop_transaction::CLEANINVALID}; \
    bins snoop_makeinvalid_xact   = {svt_axi_snoop_transaction::MAKEINVALID}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_SNOOP_XACT_TYPE_DVM_UNSET_ONE_ACE_ACELITE \
  snoop_xact_type : coverpoint cov_snoop_item.snoop_xact_type iff(cov_snoop_xact_type_flag){ \
    bins snoop_readonce_xact   = {svt_axi_snoop_transaction::READONCE}; \
    bins snoop_cleanshared_xact   = {svt_axi_snoop_transaction::CLEANSHARED}; \
    bins snoop_cleaninvalid_xact   = {svt_axi_snoop_transaction::CLEANINVALID}; \
    bins snoop_makeinvalid_xact   = {svt_axi_snoop_transaction::MAKEINVALID}; \
    option.weight = 1; \
  }

`ifdef SVT_AXI_MON_CFG_BASED_COV_GRP_DEF
 `define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_SNOOP_XACT_TYPE_DVM_SET \
  snoop_xact_type : coverpoint cov_snoop_item.snoop_xact_type iff(cov_snoop_xact_type_flag){ \
    bins snoop_readonce_xact   = {svt_axi_snoop_transaction::READONCE}; \
    bins snoop_readshared_xact   = {svt_axi_snoop_transaction::READSHARED}; \
    bins snoop_readclean_xact   = {svt_axi_snoop_transaction::READCLEAN}; \
    bins snoop_readnotshareddirty_xact   = {svt_axi_snoop_transaction::READNOTSHAREDDIRTY}; \
    bins snoop_readunique_xact   = {svt_axi_snoop_transaction::READUNIQUE}; \
    bins snoop_cleanshared_xact   = {svt_axi_snoop_transaction::CLEANSHARED}; \
    bins snoop_cleaninvalid_xact   = {svt_axi_snoop_transaction::CLEANINVALID}; \
    bins snoop_makeinvalid_xact   = {svt_axi_snoop_transaction::MAKEINVALID}; \
    bins snoop_dvmcomplete_xact   = {svt_axi_snoop_transaction::DVMCOMPLETE}; \
    bins snoop_dvmmessage_xact   = {svt_axi_snoop_transaction::DVMMESSAGE}; \
    option.weight = 1; \
  }

 `define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_SNOOP_XACT_TYPE_DVM_SET_ONE_ACE_ACELITE \
  snoop_xact_type : coverpoint cov_snoop_item.snoop_xact_type iff(cov_snoop_xact_type_flag){ \
    bins snoop_readonce_xact   = {svt_axi_snoop_transaction::READONCE}; \
    bins snoop_cleanshared_xact   = {svt_axi_snoop_transaction::CLEANSHARED}; \
    bins snoop_cleaninvalid_xact   = {svt_axi_snoop_transaction::CLEANINVALID}; \
    bins snoop_makeinvalid_xact   = {svt_axi_snoop_transaction::MAKEINVALID}; \
    bins snoop_dvmcomplete_xact   = {svt_axi_snoop_transaction::DVMCOMPLETE}; \
    bins snoop_dvmmessage_xact   = {svt_axi_snoop_transaction::DVMMESSAGE}; \
    option.weight = 1; \
  }
`endif

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_ACSNOOP_CRRESP_IGNORE_BINS \
     ignore_bins Ig_invalid_cresp2 = (binsof(snoop_crresp) intersect {4'b1000, 4'b1001, 4'b1010, 4'b1011, \
                                                                      4'b1100, 4'b1101, 4'b1110, 4'b1111}) && \
                                     (binsof(snoop_xact_type) intersect {svt_axi_snoop_transaction::READUNIQUE, \
                                                              svt_axi_snoop_transaction::CLEANINVALID, svt_axi_snoop_transaction::MAKEINVALID}); \
      option.weight = 1; \

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_ACSNOOP_DVM_IGNORE_BINS \
      ignore_bins Ignore_dvm_xact_type = binsof(snoop_xact_type) intersect \
                                            { svt_axi_snoop_transaction::DVMMESSAGE,svt_axi_snoop_transaction::DVMCOMPLETE}; \

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_ACSNOOP_CACHE_STATE_IGNORE_BINS \
      ignore_bins Ignore_rc_rnsd_rs_states = ((binsof(snoop_xact_type) intersect \
                                                   {svt_axi_snoop_transaction::READCLEAN, \
                                                    svt_axi_snoop_transaction::READNOTSHAREDDIRTY, \
                                                    svt_axi_snoop_transaction::READSHARED}) && \
                                             (binsof(initial_cache_line_state) intersect  \
                                                    {svt_axi_snoop_transaction::INVALID}) && \
                                             (!binsof(final_cache_line_state) intersect  \
                                                    {svt_axi_snoop_transaction::INVALID})) || \
                                            ((binsof(snoop_xact_type) intersect \
                                                   {svt_axi_snoop_transaction::READCLEAN, \
                                                   svt_axi_snoop_transaction::READNOTSHAREDDIRTY, \
                                                   svt_axi_snoop_transaction::READSHARED}) && \
                                             (binsof(initial_cache_line_state) intersect  \
                                                    {svt_axi_snoop_transaction::UNIQUECLEAN}) && \
                                             (!binsof(final_cache_line_state) intersect \
                                                    {svt_axi_snoop_transaction::INVALID, \
                                                    svt_axi_snoop_transaction::SHAREDCLEAN})) || \
                                           ((binsof(snoop_xact_type) intersect \
                                                   {svt_axi_snoop_transaction::READCLEAN, \
                                                   svt_axi_snoop_transaction::READNOTSHAREDDIRTY, \
                                                   svt_axi_snoop_transaction::READSHARED}) && \
                                             (binsof(initial_cache_line_state) intersect  \
                                                    {svt_axi_snoop_transaction::UNIQUEDIRTY}) && \
                                             (binsof(final_cache_line_state) intersect  \
                                                    {svt_axi_snoop_transaction::UNIQUECLEAN, \
                                                    svt_axi_snoop_transaction::UNIQUEDIRTY})) || \
                                            ((binsof(snoop_xact_type) intersect \
                                                    {svt_axi_snoop_transaction::READCLEAN, \
                                                     svt_axi_snoop_transaction::READNOTSHAREDDIRTY, \
                                                     svt_axi_snoop_transaction::READSHARED}) && \
                                               (binsof(initial_cache_line_state) intersect  \
                                                    {svt_axi_snoop_transaction::SHAREDCLEAN}) && \
                                               (!binsof(final_cache_line_state) intersect  \
                                                    {svt_axi_snoop_transaction::INVALID, \
                                                    svt_axi_snoop_transaction::SHAREDCLEAN})) || \
                                            ((binsof(snoop_xact_type) intersect \
                                                    {svt_axi_snoop_transaction::READCLEAN, \
                                                     svt_axi_snoop_transaction::READNOTSHAREDDIRTY, \
                                                     svt_axi_snoop_transaction::READSHARED}) && \
                                               (binsof(initial_cache_line_state) intersect  \
                                                    {svt_axi_snoop_transaction::SHAREDDIRTY}) && \
                                               (binsof(final_cache_line_state) intersect  \
                                                    {svt_axi_snoop_transaction::UNIQUECLEAN, \
                                                    svt_axi_snoop_transaction::UNIQUEDIRTY})); \
      ignore_bins Ignore_ru_states = ((binsof(snoop_xact_type) intersect \
                                                   {svt_axi_snoop_transaction::READUNIQUE}) && \
                                             (!binsof(final_cache_line_state) intersect  \
                                                    {svt_axi_snoop_transaction::INVALID})); \

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_ACSNOOP_CACHE_STATE_ONE_ACE_ACELITE_IGNORE_BINS \
      ignore_bins Ignore_readonce_states =  ((binsof(snoop_xact_type) intersect \
                                                    {svt_axi_snoop_transaction::READONCE}) && \
                                               (binsof(initial_cache_line_state) intersect  \
                                                    {svt_axi_snoop_transaction::INVALID}) && \
                                               (!binsof(final_cache_line_state) intersect  \
                                                    {svt_axi_snoop_transaction::INVALID})) || \
                                            ((binsof(snoop_xact_type) intersect \
                                                    {svt_axi_snoop_transaction::READONCE}) && \
                                               (binsof(initial_cache_line_state) intersect  \
                                                    {svt_axi_snoop_transaction::UNIQUECLEAN}) && \
                                               (binsof(final_cache_line_state) intersect  \
                                                    {svt_axi_snoop_transaction::UNIQUEDIRTY, \
                                                    svt_axi_snoop_transaction::SHAREDDIRTY})) || \
                                            ((binsof(snoop_xact_type) intersect \
                                                    {svt_axi_snoop_transaction::READONCE}) && \
                                               (binsof(initial_cache_line_state) intersect  \
                                                    {svt_axi_snoop_transaction::UNIQUEDIRTY}) && \
                                               (binsof(final_cache_line_state) intersect  \
                                                    {svt_axi_snoop_transaction::UNIQUECLEAN})) || \
                                            ((binsof(snoop_xact_type) intersect \
                                                    {svt_axi_snoop_transaction::READONCE}) && \
                                               (binsof(initial_cache_line_state) intersect  \
                                                    {svt_axi_snoop_transaction::SHAREDCLEAN}) && \
                                               (!binsof(final_cache_line_state) intersect  \
                                                    {svt_axi_snoop_transaction::INVALID, \
                                                    svt_axi_snoop_transaction::SHAREDCLEAN})) || \
                                            ((binsof(snoop_xact_type) intersect \
                                                    {svt_axi_snoop_transaction::READONCE}) && \
                                               (binsof(initial_cache_line_state) intersect  \
                                                    {svt_axi_snoop_transaction::SHAREDDIRTY}) && \
                                               (binsof(final_cache_line_state) intersect  \
                                                    {svt_axi_snoop_transaction::UNIQUECLEAN, \
                                                    svt_axi_snoop_transaction::UNIQUEDIRTY})); \
      ignore_bins Ignore_ci_mi_states = ((binsof(snoop_xact_type) intersect \
                                                   {svt_axi_snoop_transaction::CLEANINVALID, \
                                                    svt_axi_snoop_transaction::MAKEINVALID}) && \
                                             (!binsof(final_cache_line_state) intersect  \
                                                    {svt_axi_snoop_transaction::INVALID})); \
          ignore_bins Ignore_cleanshared_states = ((binsof(snoop_xact_type) intersect \
                                                    {svt_axi_snoop_transaction::CLEANSHARED}) && \
                                               (binsof(initial_cache_line_state) intersect  \
                                                    {svt_axi_snoop_transaction::INVALID}) &&  \
                                               (!binsof(final_cache_line_state) intersect  \
                                                    {svt_axi_snoop_transaction::INVALID})) || \
                                               ((binsof(snoop_xact_type) intersect \
                                                    {svt_axi_snoop_transaction::CLEANSHARED}) && \
                                               (binsof(initial_cache_line_state) intersect  \
                                                    {svt_axi_snoop_transaction::UNIQUECLEAN}) && \
                                               (binsof(final_cache_line_state) intersect  \
                                                    {svt_axi_snoop_transaction::UNIQUEDIRTY, \
                                                     svt_axi_snoop_transaction::SHAREDDIRTY})) || \
                                               ((binsof(snoop_xact_type) intersect \
                                                    {svt_axi_snoop_transaction::CLEANSHARED}) && \
                                               (binsof(initial_cache_line_state) intersect  \
                                                    {svt_axi_snoop_transaction::UNIQUEDIRTY, \
                                                     svt_axi_snoop_transaction::SHAREDCLEAN, \
                                                     svt_axi_snoop_transaction::SHAREDDIRTY}) && \
                                               (!binsof(final_cache_line_state) intersect  \
                                                    {svt_axi_snoop_transaction::INVALID, \
                                                    svt_axi_snoop_transaction::SHAREDCLEAN})); \

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_SNOOP_BURST_LEN \
  snoop_burst_length : coverpoint cov_snoop_item.snoop_burst_length iff(cov_snoop_burst_length_flag){ \
    bins snoop_burst_length_1        = {svt_axi_snoop_transaction::SNOOPBURST_LENGTH_1_BEAT}; \
    bins snoop_burst_length_2        = {svt_axi_snoop_transaction::SNOOPBURST_LENGTH_2_BEATS}; \
    bins snoop_burst_length_4        = {svt_axi_snoop_transaction::SNOOPBURST_LENGTH_4_BEATS}; \
    bins snoop_burst_length_8        = {svt_axi_snoop_transaction::SNOOPBURST_LENGTH_8_BEATS}; \
    bins snoop_burst_length_16       = {svt_axi_snoop_transaction::SNOOPBURST_LENGTH_16_BEATS}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_SNOOP_PROT_TYPE \
  snoop_prot : coverpoint cov_snoop_item.snoop_prot iff(cov_snoop_prot_type_flag){ \
    bins data_secure_normal            = {svt_axi_transaction::DATA_SECURE_NORMAL}; \
    bins data_non_secure_normal        = {svt_axi_transaction::DATA_NON_SECURE_NORMAL}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_ACELITE_COHERENT_XACT_TYPE \
  coh_xact_from_ace_lite: coverpoint ace_lite_coh_xact_type { \
    bins readonce_coherent = {svt_axi_transaction::READONCE}; \
    bins cleanshared_coherent = {svt_axi_transaction::CLEANSHARED}; \
`ifdef SVT_ACE5_ENABLE \
    bins coherent_cleansharedpersist_xact = {svt_axi_transaction::CLEANSHAREDPERSIST}; \
`endif \
    bins cleaninvalid_coherent = {svt_axi_transaction::CLEANINVALID}; \
    bins makeinvalid_coherent = {svt_axi_transaction::MAKEINVALID}; \
    bins writeunique_coherent = {svt_axi_transaction::WRITEUNIQUE}; \
    bins writelineunique_coherent = {svt_axi_transaction::WRITELINEUNIQUE}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_ACE_COHERENT_XACT_TYPE \
   coh_xact_from_ace: coverpoint ace_coh_xact_type { \
    bins coherent_readonce_xact   = {svt_axi_transaction::READONCE}; \
    bins coherent_readshared_xact   = {svt_axi_transaction::READSHARED}; \
    bins coherent_readclean_xact   = {svt_axi_transaction::READCLEAN}; \
    bins coherent_readnotshareddirty_xact  = {svt_axi_transaction::READNOTSHAREDDIRTY}; \
    bins coherent_readunique_xact   = {svt_axi_transaction::READUNIQUE}; \
    bins coherent_cleanunique_xact   = {svt_axi_transaction::CLEANUNIQUE}; \
    bins coherent_makeunique_xact   = {svt_axi_transaction::MAKEUNIQUE}; \
    bins coherent_cleanshared_xact   = {svt_axi_transaction::CLEANSHARED}; \
`ifdef SVT_ACE5_ENABLE \
    bins coherent_cleansharedpersist_xact = {svt_axi_transaction::CLEANSHAREDPERSIST}; \
`endif \
    bins coherent_cleaninvalid_xact   = {svt_axi_transaction::CLEANINVALID}; \
    bins coherent_makeinvalid_xact   = {svt_axi_transaction::MAKEINVALID}; \
    bins writeunique_coherent = {svt_axi_transaction::WRITEUNIQUE}; \
    bins writelineunique_coherent = {svt_axi_transaction::WRITELINEUNIQUE}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_ACE_SNOOP_XACT_TYPE_FROM_ACE \
   snoop_xact_on_ace_master: coverpoint ace_master_snoop_xact_type { \
    bins snoop_readonce_xact   = {svt_axi_snoop_transaction::READONCE}; \
    bins snoop_readshared_xact   = {svt_axi_snoop_transaction::READSHARED}; \
    bins snoop_readclean_xact   = {svt_axi_snoop_transaction::READCLEAN}; \
    bins snoop_readnotshareddirty_xact  = {svt_axi_snoop_transaction::READNOTSHAREDDIRTY}; \
    bins snoop_readunique_xact   = {svt_axi_snoop_transaction::READUNIQUE}; \
    bins snoop_cleanshared_xact   = {svt_axi_snoop_transaction::CLEANSHARED}; \
    bins snoop_cleaninvalid_xact   = {svt_axi_snoop_transaction::CLEANINVALID}; \
    bins snoop_makeinvalid_xact   = {svt_axi_snoop_transaction::MAKEINVALID}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_ACE_SNOOP_XACT_TYPE_FROM_ACELITE \
   associate_snoop_xact_for_coh_xact_from_acelite_master: coverpoint ace_lite_master_snoop_xact_type { \
    bins snoop_readonce_xact = {svt_axi_snoop_transaction::READONCE}; \
    bins snoop_cleanshared_xact = {svt_axi_snoop_transaction::CLEANSHARED}; \
    bins snoop_cleaninvalid_xact = {svt_axi_snoop_transaction::CLEANINVALID}; \
    bins snoop_makeinvalid_xact = {svt_axi_snoop_transaction::MAKEINVALID}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_ACE_CRRESP \
  snoop_crresp_from_ace: coverpoint snoop_resp_from_ace_master[3:0] { \
    bins cresp_0000 = {4'b0000}; \
    bins cresp_1000 = {4'b1000}; \
    bins cresp_0001 = {4'b0001}; \
    bins cresp_1001 = {4'b1001}; \
    bins cresp_0101 = {4'b0101}; \
    bins cresp_1101 = {4'b1101}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_WASUNIQUE_SNOOP_CRRESP_TYPE \
  snoop_crresp_wu : coverpoint snoop_resp_from_ace_master[4] { \
    bins cresp_wasunique = {1'b1}; \
    bins cresp_wasnotunique = {1'b0}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_SNOOP_INITIAL_STATE \
  ace_init_cache_state: coverpoint ace_master_init_cache_state { \
    bins invalid_cache_state = {svt_axi_snoop_transaction::INVALID}; \
    bins uniqueclean_cache_state = {svt_axi_snoop_transaction::UNIQUECLEAN}; \
    bins sharedclean_cache_state = {svt_axi_snoop_transaction::SHAREDCLEAN}; \
    bins uniquedirty_cache_state = {svt_axi_snoop_transaction::UNIQUEDIRTY}; \
    bins shareddirty_cache_state = {svt_axi_snoop_transaction::SHAREDDIRTY}; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_SNOOP_FINAL_STATE \
  ace_final_cache_state: coverpoint ace_master_final_cache_state { \
    bins invalid_cache_state = {svt_axi_snoop_transaction::INVALID}; \
    bins uniqueclean_cache_state = {svt_axi_snoop_transaction::UNIQUECLEAN}; \
    bins sharedclean_cache_state = {svt_axi_snoop_transaction::SHAREDCLEAN}; \
    bins uniquedirty_cache_state = {svt_axi_snoop_transaction::UNIQUEDIRTY}; \
    bins shareddirty_cache_state = {svt_axi_snoop_transaction::SHAREDDIRTY}; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_WASUNIQUE_SNOOP_RRESP_TYPE \
  snoop_crresp_wu : coverpoint cov_crresp[4] iff(cov_snoop_resp_flag){ \
    bins cresp_wasunique = {1'b1}; \
    bins cresp_wasnotunique = {1'b0}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_SNOOP_RRESP_TYPE \
  snoop_crresp : coverpoint cov_crresp[3:0] iff(cov_snoop_resp_flag){ \
    bins cresp_x0000 = {4'b0000}; \
    bins cresp_x1000 = {4'b1000}; \
    bins cresp_x0001 = {4'b0001}; \
    bins cresp_x1001 = {4'b1001}; \
    bins cresp_x0101 = {4'b0101}; \
    bins cresp_x1101 = {4'b1101}; \
    //wildcard bins cresp_x0000 = {5'b?0000}; \
    //wildcard bins cresp_x1000 = {5'b?1000}; \
    //wildcard bins cresp_x0001 = {5'b?0001}; \
    //wildcard bins cresp_x1001 = {5'b?1001}; \
    //wildcard bins cresp_x0101 = {5'b?0101}; \
    //wildcard bins cresp_x1101 = {5'b?1101}; \
    //bins cresp_00000 = {5'b00000}; \
    //bins cresp_10000 = {5'b10000}; \
    //bins cresp_01000 = {5'b01000}; \
    //bins cresp_11000 = {5'b11000}; \
    //bins cresp_00001 = {5'b00001}; \
    //bins cresp_10001 = {5'b10001}; \
    //bins cresp_01001 = {5'b01001}; \
    //bins cresp_11001 = {5'b11001}; \
    //bins cresp_00101 = {5'b00101}; \
    //bins cresp_10101 = {5'b10101}; \
    //bins cresp_01101 = {5'b01101}; \
    //bins cresp_11101 = {5'b11101}; \
    //bins cresp_00010 = {5'b00010}; \
    //bins cresp_10010 = {5'b10010}; \
    //bins cresp_01010 = {5'b01010}; \
    //bins cresp_11010 = {5'b11010}; \
    //bins cresp_00011 = {5'b00011}; \
    //bins cresp_10011 = {5'b10011}; \
    //bins cresp_01011 = {5'b01011}; \
    //bins cresp_11011 = {5'b11011}; \
    //bins cresp_00111 = {5'b00111}; \
    //bins cresp_10111 = {5'b10111}; \
    //bins cresp_01111 = {5'b01111}; \
    //bins cresp_11111 = {5'b11111}; \
    wildcard ignore_bins ig_invalid_cresp1 = {5'b??1?0}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_SNOOP_DVMMESSAGE_TYPE \
  acdvm_message_type : coverpoint cov_snoop_item.snoop_addr[14:12]  iff(cov_acdvm_message_flag) { \
    bins message_tlb_invalidate                        = {3'b000}; \
    bins message_branch_predictor_invalidate           = {3'b001}; \
    bins message_physical_instruction_cache_invalidate = {3'b010}; \
    bins message_virtual_instruction_cache_invalidate  = {3'b011}; \
    bins message_synchronization                       = {3'b100}; \
    bins message_hint                                  = {3'b110}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_SNOOP_DVM_RESPONSE_TYPE \
   acdvm_resp : coverpoint cov_crresp iff(cov_acdvm_message_flag){ \
    bins message_accept         = {5'b00000}; \
    bins message_reject         = {5'b00010}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_QOS \
  qos : coverpoint cov_item.qos iff(cov_qos_type_flag){ \
    bins qos_range_0_1  = {[0:1]}; \
    bins qos_range_2_3  = {[2:3]}; \
    bins qos_range_4_7  = {[4:7]}; \
    bins qos_range_8_15  = {[8:15]}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_READ_XACT_TYPE \
  read_xact_type : coverpoint cov_xact_rd_wr_type iff(cov_xact_type_flag){ \
    bins read_xact   = {svt_axi_transaction::READ}; \
    option.weight = 1; \
}

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_WRITE_XACT_TYPE \
  write_xact_type : coverpoint cov_xact_rd_wr_type iff(cov_xact_type_flag){ \
    bins write_xact  = {svt_axi_transaction::WRITE}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_BURST_TYPE \
  burst_type : coverpoint cov_item.burst_type iff(cov_burst_type_flag){ \
    bins fixed_burst  = {svt_axi_transaction::FIXED} iff (cfg.axi_interface_type != svt_axi_port_configuration::AXI4_LITE);\
    bins incr_burst   = {svt_axi_transaction::INCR}; \
    bins wrap_burst   = {svt_axi_transaction::WRAP} iff(cfg.axi_interface_type != svt_axi_port_configuration::AXI4_LITE); \
    option.weight = 1; \
  }


`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_BURST_TYPE_AXI3_ACE \
  burst_type : coverpoint cov_item.burst_type iff(cov_burst_type_flag){ \
    bins fixed_burst  = {svt_axi_transaction::FIXED}; \
    bins incr_burst   = {svt_axi_transaction::INCR}; \
    bins wrap_burst   = {svt_axi_transaction::WRAP}; \
    option.weight = 1; \
  }

`ifdef SVT_AXI_MON_CFG_BASED_COV_GRP_DEF
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_BURST_TYPE_AXI4_LITE \
  burst_type : coverpoint cov_item.burst_type iff(cov_burst_type_flag){ \
    bins incr_burst   = {svt_axi_transaction::INCR}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_WRITE_XACT_TYPE_AXI3 \
  write_xact_type : coverpoint cov_xact_rd_wr_type iff(cov_xact_type_flag){ \
    bins write_xact  = {svt_axi_transaction::WRITE}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_WRITE_XACT_TYPE_ACE \
  write_xact_type : coverpoint cov_xact_rd_wr_type iff(cov_xact_type_flag){ \
    bins write_xact  = {svt_axi_transaction::WRITE}; \
    option.weight = 1; \
  }
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_READ_XACT_TYPE_AXI3 \
  read_xact_type : coverpoint cov_xact_rd_wr_type iff(cov_xact_type_flag){ \
    bins read_xact   = {svt_axi_transaction::READ}; \
    option.weight = 1; \
  }
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_READ_XACT_TYPE_ACE \
  read_xact_type : coverpoint cov_xact_rd_wr_type iff(cov_xact_type_flag){ \
    bins read_xact   = {svt_axi_transaction::READ}; \
    option.weight = 1; \
  }
`endif

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_BURST_LENGTH \
  burst_length : coverpoint cov_item.burst_length iff(cov_burst_length_flag){ \
    bins burst_length[] =  {[1:((1<<`SVT_AXI_MAX_BURST_LENGTH_WIDTH)-1)]}; \
    ignore_bins ignore_unsupported_burst_length_bins = {[`SVT_AXI_FIXED_IGNORE_MIN_VALUE:`SVT_AXI_FIXED_IGNORE_MAX_VALUE]}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_AXI3_BURST_LENGTH \
  burst_length : coverpoint cov_item.burst_length { \
    bins burst_length[] =  {[1:((1<<`SVT_AXI_MAX_BURST_LENGTH_WIDTH)-1)]}; \
    ignore_bins ignore_unsupported_burst_length_bins = {[`SVT_AXI_FIXED_IGNORE_MIN_VALUE:`SVT_AXI_FIXED_IGNORE_MAX_VALUE]}iff(cfg.axi_interface_type  == svt_axi_port_configuration::AXI3); \
    option.weight = 1; \
  } 

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_AXI4_BURST_LENGTH \
  burst_length : coverpoint cov_item.burst_length { \
    bins burst_length[] =  {[1:((1<<`SVT_AXI_MAX_BURST_LENGTH_WIDTH)-1)]}; \
    ignore_bins ignore_unsupported_burst_length_axi4 = {[`SVT_AXI4_IGNORE_MIN_VALUE:`SVT_AXI4_IGNORE_MAX_VALUE]}iff(cfg.axi_interface_type == svt_axi_port_configuration::AXI4); \
    option.weight = 1; \
  }

`ifdef SVT_AXI_MON_CFG_BASED_COV_GRP_DEF
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_BURST_LENGTH_AXI3 \
  burst_length : coverpoint cov_item.burst_length iff(cov_burst_length_flag){ \
    bins burst_length[] =  {[1:((1<<`SVT_AXI_MAX_BURST_LENGTH_WIDTH)-1)]}; \
    ignore_bins ignore_unsupported_burst_length_axi3 = {[`SVT_AXI3_IGNORE_MIN_VALUE:`SVT_AXI3_IGNORE_MAX_VALUE]};  \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_BURST_LENGTH_AXI4 \
  burst_length : coverpoint cov_item.burst_length iff(cov_burst_length_flag){ \
    bins burst_length[] =  {[1:((1<<`SVT_AXI_MAX_BURST_LENGTH_WIDTH)-1)]}; \
    ignore_bins ignore_unsupported_burst_length_axi4 = {[`SVT_AXI4_IGNORE_MIN_VALUE:`SVT_AXI4_IGNORE_MAX_VALUE]};  \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_BURST_LENGTH_AXI4_LITE \
  burst_length : coverpoint cov_item.burst_length iff(cov_burst_length_flag){ \
    bins burst_length_1 =  {1}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_BURST_LENGTH_ACE \
  burst_length : coverpoint cov_item.burst_length iff(cov_burst_length_flag){ \
    bins burst_length[] =  {[1:((1<<`SVT_AXI_MAX_BURST_LENGTH_WIDTH)-1)]}; \
    ignore_bins ignore_unsupported_burst_length_ace = {[`SVT_AXI_ACE_IGNORE_MIN_VALUE:`SVT_AXI_ACE_IGNORE_MAX_VALUE]}; \
    option.weight = 1; \
  }
`endif  
  
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_ADDR \
  addr : coverpoint cov_item.addr iff(cov_addr_flag){ \
    option.weight = 1; \
     bins addr_range_min = {0} iff((cfg.axi_interface_type != svt_axi_port_configuration::AXI_ACE)  ||  (cfg.axi_interface_type != svt_axi_port_configuration::ACE_LITE)) ; \
`ifdef SVT_MULTI_SIM_COVPOINT_GREATER_THAN_32_BITS \
     // Need to come up with an alternative \
`else \
     bins addr_range_mid = {[1:(64'd2**(cfg.addr_width)-2)]}; \
     bins addr_range_max = {((64'd2**(cfg.addr_width))-1)} iff((cfg.axi_interface_type != svt_axi_port_configuration::AXI_ACE) ||  (cfg.axi_interface_type != svt_axi_port_configuration::ACE_LITE)); \
`endif \
  }


`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_CACHE_TYPE_AXI4 \
  cache_type : coverpoint cov_item.cache_type { \
    bins rd_device_non_bufferable = {`SVT_AXI_4_ARCACHE_DEVICE_NON_BUFFERABLE}iff(cov_item.xact_type == svt_axi_transaction::READ);\
    bins rd_device_bufferable = {`SVT_AXI_4_ARCACHE_DEVICE_BUFFERABLE}iff(cov_item.xact_type == svt_axi_transaction::READ);\
    bins rd_normal_non_cacheable_non_bufferable = {`SVT_AXI_4_ARCACHE_NORMAL_NON_CACHABLE_NON_BUFFERABLE}iff(cov_item.xact_type == svt_axi_transaction::READ);\
    bins rd_normal_non_cacheable_bufferable = {`SVT_AXI_4_ARCACHE_NORMAL_NON_CACHABLE_BUFFERABLE}iff(cov_item.xact_type == svt_axi_transaction::READ);\
    bins rd_write_through_no_allocate = {`SVT_AXI_4_ARCACHE_WRITE_THROUGH_NO_ALLOCATE}iff(cov_item.xact_type == svt_axi_transaction::READ);\
    bins rd_write_through_read_allocate = {`SVT_AXI_4_ARCACHE_WRITE_THROUGH_READ_ALLOCATE}iff(cov_item.xact_type == svt_axi_transaction::READ);\
    bins rd_write_through_write_allocate = {`SVT_AXI_4_ARCACHE_WRITE_THROUGH_WRITE_ALLOCATE}iff(cov_item.xact_type == svt_axi_transaction::READ);\
    bins rd_write_through_read_and_write_allocate = {`SVT_AXI_4_ARCACHE_WRITE_THROUGH_READ_AND_WRITE_ALLOCATE}iff(cov_item.xact_type == svt_axi_transaction::READ);\
    bins rd_write_back_no_allocate = {`SVT_AXI_4_ARCACHE_WRITE_BACK_NO_ALLOCATE}iff(cov_item.xact_type == svt_axi_transaction::READ);\
    bins rd_write_back_read_allocate = {`SVT_AXI_4_ARCACHE_WRITE_BACK_READ_ALLOCATE}iff(cov_item.xact_type == svt_axi_transaction::READ);\
    bins rd_write_back_write_allocate = {`SVT_AXI_4_ARCACHE_WRITE_BACK_WRITE_ALLOCATE}iff(cov_item.xact_type == svt_axi_transaction::READ);\
    bins rd_write_back_read_and_write_allocate = {`SVT_AXI_4_ARCACHE_WRITE_BACK_READ_AND_WRITE_ALLOCATE}iff(cov_item.xact_type == svt_axi_transaction::READ);\
    bins wr_device_non_bufferable = {`SVT_AXI_4_AWCACHE_DEVICE_NON_BUFFERABLE}iff(cov_item.xact_type == svt_axi_transaction::WRITE);\
    bins wr_device_bufferable = {`SVT_AXI_4_AWCACHE_DEVICE_BUFFERABLE}iff(cov_item.xact_type == svt_axi_transaction::WRITE);\
    bins wr_normal_non_cacheable_non_bufferable = {`SVT_AXI_4_AWCACHE_NORMAL_NON_CACHABLE_NON_BUFFERABLE}iff(cov_item.xact_type == svt_axi_transaction::WRITE);\
    bins wr_normal_non_cacheable_bufferable = {`SVT_AXI_4_AWCACHE_NORMAL_NON_CACHABLE_BUFFERABLE}iff(cov_item.xact_type == svt_axi_transaction::WRITE);\
    bins wr_write_through_no_allocate = {`SVT_AXI_4_AWCACHE_WRITE_THROUGH_NO_ALLOCATE}iff(cov_item.xact_type == svt_axi_transaction::WRITE);\
    bins wr_write_through_read_allocate = {`SVT_AXI_4_AWCACHE_WRITE_THROUGH_READ_ALLOCATE}iff(cov_item.xact_type == svt_axi_transaction::WRITE);\
    bins wr_write_through_write_allocate = {`SVT_AXI_4_AWCACHE_WRITE_THROUGH_WRITE_ALLOCATE}iff(cov_item.xact_type == svt_axi_transaction::WRITE);\
    bins wr_write_through_read_and_write_allocate = {`SVT_AXI_4_AWCACHE_WRITE_THROUGH_READ_AND_WRITE_ALLOCATE}iff(cov_item.xact_type == svt_axi_transaction::WRITE);\
    bins wr_write_back_no_allocate = {`SVT_AXI_4_AWCACHE_WRITE_BACK_NO_ALLOCATE}iff(cov_item.xact_type == svt_axi_transaction::WRITE);\
    bins wr_write_back_read_allocate = {`SVT_AXI_4_AWCACHE_WRITE_BACK_READ_ALLOCATE}iff(cov_item.xact_type == svt_axi_transaction::WRITE);\
    bins wr_write_back_write_allocate = {`SVT_AXI_4_AWCACHE_WRITE_BACK_WRITE_ALLOCATE}iff(cov_item.xact_type == svt_axi_transaction::WRITE);\
    bins wr_write_back_read_and_write_allocate = {`SVT_AXI_4_AWCACHE_WRITE_BACK_READ_AND_WRITE_ALLOCATE}iff(cov_item.xact_type == svt_axi_transaction::WRITE);\
    ignore_bins ignore_rsvd = {4,5,8,9,12,13}; \
   option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_BURST_SIZE_AXI3 \
  axi_burst_size  : coverpoint cov_item.burst_size { \
    bins burst_size_8bit    = {svt_axi_transaction::BURST_SIZE_8BIT}; \
    bins burst_size_16bit   = {svt_axi_transaction::BURST_SIZE_16BIT}; \
    bins burst_size_32bit   = {svt_axi_transaction::BURST_SIZE_32BIT}; \
    bins burst_size_64bit   = {svt_axi_transaction::BURST_SIZE_64BIT}; \
    bins burst_size_128bit  = {svt_axi_transaction::BURST_SIZE_128BIT}; \
    bins burst_size_256bit  = {svt_axi_transaction::BURST_SIZE_256BIT}; \
    bins burst_size_512bit  = {svt_axi_transaction::BURST_SIZE_512BIT}; \
    bins burst_size_1024bit = {svt_axi_transaction::BURST_SIZE_1024BIT}; \
    bins burst_size_2048bit = {svt_axi_transaction::BURST_SIZE_2048BIT}; \
    `SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_TRANSFER_SIZE_BURST_SIZE_IGNORE_BINS \
  } 

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_RESPONSE_TYPE_AXI3 \
  axi_response_type : coverpoint  	m_response_type { \
    bins axi_okay_response   = {`SVT_AXI_OKAY_RESPONSE}; \
    bins axi_exokay_response = {`SVT_AXI_EXOKAY_RESPONSE}; \
    bins axi_slverr_response = {`SVT_AXI_SLVERR_RESPONSE}; \
    bins axi_decerr_response = {`SVT_AXI_DECERR_RESPONSE}; \
    bins axi_exokay_fail_response = {`SVT_AXI_OKAY_RESPONSE} iff(cfg.exclusive_access_enable == 1); \
   }                                                                                               

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_ALIGNED_ADDR_AXI3 \
  axi_address_aligned : coverpoint  	m_address_aligned { \
    wildcard bins axi_8bit_aligned_address    ={6'b?????1}; \
    wildcard bins axi_16bit_aligned_address   ={6'b????1?}; \
    wildcard bins axi_32bit_aligned_address   ={6'b???1??}; \
    wildcard bins axi_64bit_aligned_address   ={6'b??1???}; \
    wildcard bins axi_128bit_aligned_address  ={6'b?1????}; \
    wildcard bins axi_256bit_aligned_address  ={6'b1?????}; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_BURST_LEN_AXI3 \
  axi_burst_len : coverpoint cov_item.burst_length { \
    bins burst_length[] =  {[1:((1<<`SVT_AXI_MAX_BURST_LENGTH_WIDTH)-1)]}; \
    ignore_bins ignore_unsupported_burst_length_axi3 = {[`SVT_AXI3_IGNORE_MIN_VALUE:`SVT_AXI3_IGNORE_MAX_VALUE]};  \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_BURST_LEN_AXI4 \
  axi_burst_len : coverpoint cov_item.burst_length { \
    bins burst_length[] =  {[1:((1<<`SVT_AXI_MAX_BURST_LENGTH_WIDTH)-1)]}; \
    ignore_bins ignore_unsupported_burst_length_axi4 = {[`SVT_AXI4_IGNORE_MIN_VALUE:`SVT_AXI4_IGNORE_MAX_VALUE]};  \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_ATOMIC_TYPE_AXI3_AXI4 \
  atomic_type : coverpoint cov_item.atomic_type { \
    bins normal    = {svt_axi_transaction::NORMAL}; \
    bins locked    = {svt_axi_transaction::LOCKED}; \
    ignore_bins atomic_type_axi4 =  {svt_axi_transaction::LOCKED}iff((cfg.axi_interface_type == svt_axi_port_configuration::AXI4)||(cfg.locked_access_enable == 0));\
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_EXCLUSIVE_ATOMIC_TYPE_AXI3 \
  axi_ex_xact_type : coverpoint cov_item.atomic_type iff (cfg.exclusive_access_enable == 1){\
    bins exclusive_type  = {svt_axi_transaction::EXCLUSIVE} ;\
  } 

//macros used to cross AXI3 and AXI4 path coverage coverpoints with all_slaves and slaves_excluding register_space
 
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_CACHE_LEN_1_ALL_OKAY \
  cache_len_1_all_okay : cross all_slaves, write_xact_type,read_xact_type,cache_type,axi_burst_len,axi_burst_size,axi_response_type { \
    ignore_bins axi_ignore_len_greater_than_1                               = ! binsof (axi_burst_len) intersect {4'h1}; \
    ignore_bins axi_ignore_resp_except_all_okay                             = ! binsof (axi_response_type.axi_okay_response); \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_CACHE_LEN_REDUCED_ALL_OKAY \
  cache_len_reduced_all_okay: cross slaves_excluding_register_space,cache_type,write_xact_type,read_xact_type,burst_type,axi_burst_len,axi_response_type { \
    ignore_bins axi_ignored_len                                                = binsof (axi_burst_len) intersect {4'h3,[4'h5:4'h7],[4'h9:4'hf]}; \
    ignore_bins axi_ignore_resp_except_all_okay                                = ! binsof (axi_response_type.axi_okay_response); \
    ignore_bins axi_write_wrap_invalid_len                                     = (binsof (write_xact_type.write_xact) && binsof (burst_type.wrap_burst)  &&  !binsof (axi_burst_len) intersect {`SVT_AXI_WRAP_BURST_LENGTH_RANGE}); \
    ignore_bins axi_read_wrap_invalid_len_dw_64bit                             = binsof (read_xact_type.read_xact) && binsof (burst_type.wrap_burst)  &&  binsof (axi_burst_len) intersect {(cfg.data_width==64?4'h2:5'h11)} ; \
    ignore_bins axi_read_wrap_invalid_len_dw_128bit                            = binsof (read_xact_type.read_xact) && binsof (burst_type.wrap_burst)  &&  binsof (axi_burst_len) intersect {(cfg.data_width==128?5'h10:5'h11)} ; \
    ignore_bins axi_read_wrap_invalid_8len_dw_256bit                           = binsof (read_xact_type.read_xact) && binsof (burst_type.wrap_burst)  && (binsof (axi_burst_len) intersect {(cfg.data_width==256?4'h8:5'h11)}); \
    ignore_bins axi_read_wrap_invalid_16len_dw_256bit                          = binsof (read_xact_type.read_xact) && binsof (burst_type.wrap_burst)  && (binsof (axi_burst_len) intersect {(cfg.data_width==256?5'h10:5'h11)}); \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_CACHE_LEN_REDUCED_IGNORE_RESPONSE \
  cache_len_reduced_ignore_response: cross all_slaves, write_xact_type,read_xact_type, axi_burst_len, burst_type { \
    ignore_bins axi_ignored_len                                                = binsof (axi_burst_len) intersect {4'h2,[4'h4:4'h6],[4'h8:4'he]}; \
    ignore_bins axi_write_wrap_invalid_len                                     = (binsof (write_xact_type.write_xact) && binsof (burst_type.wrap_burst)  &&  !binsof (axi_burst_len) intersect {`SVT_AXI_WRAP_BURST_LENGTH_RANGE}); \
    ignore_bins axi_read_wrap_invalid_len_dw_64bit                             = binsof (read_xact_type.read_xact) && binsof (burst_type.wrap_burst)  &&  binsof (axi_burst_len) intersect {(cfg.data_width==64?4'h2:5'h10)}; \
    ignore_bins axi_read_wrap_invalid_len_dw_128bit                            = binsof (read_xact_type.read_xact) && binsof (burst_type.wrap_burst)  &&  binsof (axi_burst_len) intersect {(cfg.data_width==128?5'h10:5'h11)}; \
    ignore_bins axi_read_wrap_invalid_8len_dw_256bit                           = binsof (read_xact_type.read_xact) && binsof (burst_type.wrap_burst) && (binsof (axi_burst_len) intersect {(cfg.data_width==256?4'h8:5'h11)}); \
    ignore_bins axi_read_wrap_invalid_16len_dw_256bit                          = binsof (read_xact_type.read_xact) && binsof (burst_type.wrap_burst)  && (binsof (axi_burst_len) intersect {(cfg.data_width==256?5'h10:5'h11)}); \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_CACHE_ALL_OKAY_FIXED \
  cache_all_okay_fixed:cross slaves_excluding_register_space,cache_type,axi_burst_size,burst_type,axi_burst_len,axi_response_type { \
    ignore_bins axi_ignore_resp_except_all_okay                                = ! binsof (axi_response_type.axi_okay_response); \
    ignore_bins Ignore_invalid_fixed  =  binsof(burst_type.fixed_burst) && binsof(axi_burst_len) intersect {[`SVT_AXI_FIXED_IGNORE_MIN_VALUE:`SVT_AXI_FIXED_IGNORE_MAX_VALUE]}; \
  } 

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_CACHE_ALL_SLVERR_FIXED \
  cache_all_slverr_fixed:cross slaves_excluding_register_space, cache_type, axi_burst_size, axi_burst_len, burst_type, axi_response_type { \
    ignore_bins axi_ignore_resp_except_all_okay                                = ! binsof (axi_response_type.axi_slverr_response); \
    ignore_bins Ignore_invalid_fixed  =  binsof(burst_type.fixed_burst) && binsof(axi_burst_len) intersect {[`SVT_AXI_FIXED_IGNORE_MIN_VALUE:`SVT_AXI_FIXED_IGNORE_MAX_VALUE]}; \
  }
     
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_CACHE_IGNORE_RESP_FIXED \
  cache_ignore_resp_fixed:cross all_slaves, cache_type, axi_burst_len, axi_burst_size, burst_type { \
    ignore_bins Ignore_invalid_fixed  =  binsof(burst_type.fixed_burst) && binsof(axi_burst_len) intersect {[`SVT_AXI_FIXED_IGNORE_MIN_VALUE:`SVT_AXI_FIXED_IGNORE_MAX_VALUE]}; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_CACHE_ALL_OKAY_FIXED_UNALIGNED \
  cache_all_okay_fixed_unaligned:cross slaves_excluding_register_space, cache_type, axi_address_aligned, axi_burst_size, axi_burst_len, burst_type, axi_response_type { \
    ignore_bins axi_ignore_resp_except_all_okay                              = ! binsof (axi_response_type.axi_okay_response); \
    ignore_bins axi_ignore_len_greater_than_1                                = ! binsof (axi_burst_len) intersect {4'h1}; \
    ignore_bins Ignore_invalid_fixed  =  binsof(burst_type.fixed_burst) && binsof(axi_burst_len) intersect {[`SVT_AXI_FIXED_IGNORE_MIN_VALUE:`SVT_AXI_FIXED_IGNORE_MAX_VALUE]}; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_CACHE_IGNORE_RESP_FIXED_UNALIGNED \
  cache_ignore_resp_fixed_unaligned:cross all_slaves, cache_type, axi_address_aligned, axi_burst_size, axi_burst_len, burst_type { \
    ignore_bins axi_ignore_len_greater_than_1                                = ! binsof (axi_burst_len) intersect {4'h1}; \
    ignore_bins Ignore_invalid_fixed  =  binsof(burst_type.fixed_burst) && binsof(axi_burst_len) intersect {[`SVT_AXI_FIXED_IGNORE_MIN_VALUE:`SVT_AXI_FIXED_IGNORE_MAX_VALUE]}; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_MASTER_TO_SLAVE_ALL_OKAY \
  master_to_slave_all_okay: cross slaves_excluding_register_space, write_xact_type,read_xact_type, axi_burst_len, axi_burst_size, axi_response_type,burst_type { \
    ignore_bins axi_ignore_resp_except_all_okay             = ! binsof (axi_response_type.axi_okay_response); \
    ignore_bins axi_size_less_than_64bit_len_1_to_16        = (binsof (axi_burst_size) intersect {[3'h0:3'h2]}) && (binsof (axi_burst_len) intersect{[4'h1:5'h10]}); \
    ignore_bins axi_write_wrap_invalid_len                  = (binsof (write_xact_type.write_xact) && binsof (burst_type.wrap_burst)  &&  !binsof (axi_burst_len) intersect {`SVT_AXI_WRAP_BURST_LENGTH_RANGE}); \
    ignore_bins axi_read_wrap_invalid_len                   = (binsof (read_xact_type.read_xact) && binsof (burst_type.wrap_burst)  &&  binsof (axi_burst_len) intersect {4'h3,[4'h5:4'h7],[4'h9:4'hf]}); \
    ignore_bins axi_read_wrap_invalid_len_dw_64bit          =  binsof (read_xact_type.read_xact) && binsof (burst_type.wrap_burst)  &&  binsof (axi_burst_len) intersect {(cfg.data_width==64? 4'h2:5'h11)}; \
    ignore_bins axi_read_wrap_invalid_len_dw_128bit         =  binsof (read_xact_type.read_xact) && binsof (burst_type.wrap_burst)  &&  binsof (axi_burst_len) intersect {(cfg.data_width==128? 5'h10:5'h11)}; \
    ignore_bins axi_read_wrap_invalid_8len_dw_256bit        =  binsof (read_xact_type.read_xact) && binsof (burst_type.wrap_burst)  && (binsof (axi_burst_len) intersect {(cfg.data_width==256? 4'h8:5'h11)}); \
    ignore_bins axi_read_wrap_invalid_16len_dw_256bit       =  binsof (read_xact_type.read_xact) && binsof (burst_type.wrap_burst)  && (binsof (axi_burst_len) intersect {(cfg.data_width==256? 5'h10:5'h11)}); \
  } 
  
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_MASTER_TO_SLAVE_IGNORE_RESPONSE \
  master_to_slave_ignore_response: cross all_slaves, write_xact_type,read_xact_type, axi_burst_len, axi_burst_size, burst_type { \
    ignore_bins axi_size_less_than_64bit_len_1_to_16        = (binsof (axi_burst_size) intersect {[3'h0:3'h2]}) && (binsof (axi_burst_len) intersect{[4'h1:5'h10]}); \
    ignore_bins axi_write_wrap_invalid_len                  = (binsof (write_xact_type.write_xact) && binsof (burst_type.wrap_burst)  &&  !binsof (axi_burst_len) intersect {`SVT_AXI_WRAP_BURST_LENGTH_RANGE}); \
    ignore_bins axi_read_wrap_invalid_len                   = (binsof (read_xact_type.read_xact) && binsof (burst_type.wrap_burst)   &&  binsof (axi_burst_len) intersect {4'h3,[4'h5:4'h7],[4'h9:4'hf]}); \
    ignore_bins axi_read_wrap_invalid_len_dw_64bit          =  binsof (read_xact_type.read_xact) && binsof (burst_type.wrap_burst)  &&  binsof (axi_burst_len) intersect {(cfg.data_width==64? 4'h2:5'h11)}; \
    ignore_bins axi_read_wrap_invalid_len_dw_128bit         =  binsof (read_xact_type.read_xact) && binsof (burst_type.wrap_burst)   &&  binsof (axi_burst_len) intersect {(cfg.data_width==128? 5'h10:5'h11)}; \
    ignore_bins axi_read_wrap_invalid_8len_dw_256bit        =  binsof (read_xact_type.read_xact) && binsof (burst_type.wrap_burst)   && (binsof (axi_burst_len) intersect {(cfg.data_width==256? 4'h8:5'h11)}); \
    ignore_bins axi_read_wrap_invalid_16len_dw_256bit       =  binsof (read_xact_type.read_xact) && binsof (burst_type.wrap_burst)   && (binsof (axi_burst_len) intersect {(cfg.data_width==256? 5'h10:5'h11)}); \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_MASTER_TO_SLAVE_DECERR_LEN_1 \
  master_to_slave_decerr_len_1: cross slaves_excluding_register_space, write_xact_type,read_xact_type, cache_type, axi_burst_len, axi_burst_size, axi_response_type { \
    ignore_bins axi_ignore_len_greater_than_1                                  = ! binsof (axi_burst_len) intersect {4'h1}; \
    ignore_bins axi_ignore_resp_except_once_decerr                             = ! binsof (axi_response_type.axi_decerr_response); \
  }
  
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_MASTER_TO_SLAVE_SLVERR_LEN_1 \
  master_to_slave_slverr_len_1: cross slaves_excluding_register_space, cache_type, axi_burst_len, axi_burst_size, axi_response_type { \
    ignore_bins axi_ignore_len_greater_than_1                                  = ! binsof (axi_burst_len) intersect {4'h1}; \
    ignore_bins axi_ignore_resp_except_once_slverr                             = ! binsof (axi_response_type.axi_slverr_response); \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_MASTER_TO_SLAVE_DECERR \
  master_to_slave_decerr: cross slaves_excluding_register_space, write_xact_type,read_xact_type, axi_burst_len, axi_response_type, burst_type { \
    ignore_bins axi_ignore_resp_except_once_decerr          = ! binsof (axi_response_type.axi_decerr_response); \
    ignore_bins axi_write_wrap_invalid_len                  = (binsof (write_xact_type.write_xact) && binsof (burst_type.wrap_burst)  &&  !binsof (axi_burst_len) intersect {`SVT_AXI_WRAP_BURST_LENGTH_RANGE}); \
    ignore_bins axi_read_wrap_invalid_len                   = (binsof (read_xact_type.read_xact) && binsof (burst_type.wrap_burst)  &&  binsof (axi_burst_len) intersect {4'h3,[4'h5:4'h7],[4'h9:4'hf]}); \
    ignore_bins axi_read_wrap_invalid_len_dw_64bit          =  binsof (read_xact_type.read_xact) && binsof (burst_type.wrap_burst)  &&  binsof (axi_burst_len) intersect {(cfg.data_width==64? 4'h2:5'h11)}; \
    ignore_bins axi_read_wrap_invalid_len_dw_128bit         =  binsof (read_xact_type.read_xact) && binsof (burst_type.wrap_burst)  &&  binsof (axi_burst_len) intersect {(cfg.data_width==128? 5'h10:5'h11)}; \
    ignore_bins axi_read_wrap_invalid_8len_dw_256bit        =  binsof (read_xact_type.read_xact) && binsof (burst_type.wrap_burst)  && (binsof (axi_burst_len) intersect {(cfg.data_width==256?4'h8:5'h11)}); \
    ignore_bins axi_read_wrap_invalid_16len_dw_256bit       =  binsof (read_xact_type.read_xact) && binsof (burst_type.wrap_burst)  && (binsof (axi_burst_len) intersect {(cfg.data_width==256?5'h10:5'h11)}); \
  }
     
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_MASTER_TO_SLAVE_SLVERR \
  master_to_slave_slverr: cross slaves_excluding_register_space, write_xact_type,read_xact_type, axi_burst_len, axi_response_type, burst_type { \
    ignore_bins axi_ignore_resp_except_once_slverr          = ! binsof (axi_response_type.axi_slverr_response); \
    ignore_bins axi_write_wrap_invalid_len                  = (binsof (write_xact_type.write_xact) && binsof (burst_type.wrap_burst)  &&  !binsof (axi_burst_len) intersect {`SVT_AXI_WRAP_BURST_LENGTH_RANGE}); \
    ignore_bins axi_read_wrap_invalid_len                   = (binsof (read_xact_type.read_xact) && binsof (burst_type.wrap_burst)  &&  binsof (axi_burst_len) intersect {4'h3,[4'h5:4'h7],[4'h9:4'hf]}); \
    ignore_bins axi_read_wrap_invalid_len_dw_64bit          =  binsof (read_xact_type.read_xact) && binsof (burst_type.wrap_burst)  &&  binsof (axi_burst_len) intersect {(cfg.data_width==64?4'h2:5'h11)}; \
    ignore_bins axi_read_wrap_invalid_len_dw_128bit         =  binsof (read_xact_type.read_xact) && binsof (burst_type.wrap_burst)  &&  binsof (axi_burst_len) intersect {(cfg.data_width==128?5'h10:5'h11)}; \
    ignore_bins axi_read_wrap_invalid_8len_dw_256bit        =  binsof (read_xact_type.read_xact) && binsof (burst_type.wrap_burst)  && (binsof (axi_burst_len) intersect {(cfg.data_width==256?4'h8:5'h11)}); \
    ignore_bins axi_read_wrap_invalid_16len_dw_256bit       =  binsof (read_xact_type.read_xact) && binsof (burst_type.wrap_burst)  && (binsof (axi_burst_len) intersect {(cfg.data_width==256?5'h10:5'h11)}); \
   }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_MASTER_TO_ALL_SLAVE_IGNORE_RESPONSE \
  master_to_all_slave_ignore_response: cross all_slaves, write_xact_type,read_xact_type, axi_burst_len, burst_type { \
    ignore_bins axi_write_wrap_invalid_len                  = (binsof (write_xact_type.write_xact) && binsof (burst_type.wrap_burst)  &&  !binsof (axi_burst_len) intersect {`SVT_AXI_WRAP_BURST_LENGTH_RANGE}); \
    ignore_bins axi_read_wrap_invalid_len                   = (binsof (read_xact_type.read_xact) && binsof (burst_type.wrap_burst)  &&  binsof (axi_burst_len) intersect {4'h3,[4'h5:4'h7],[4'h9:4'hf]}); \
    ignore_bins axi_read_wrap_invalid_len_dw_64bit          =  binsof (read_xact_type.read_xact) && binsof (burst_type.wrap_burst)  &&  binsof (axi_burst_len) intersect {(cfg.data_width==64?4'h2:5'h11)}; \
    ignore_bins axi_read_wrap_invalid_len_dw_128bit         =  binsof (read_xact_type.read_xact) && binsof (burst_type.wrap_burst)  &&  binsof (axi_burst_len) intersect {(cfg.data_width==128?5'h10:5'h11)}; \
    ignore_bins axi_read_wrap_invalid_8len_dw_256bit        =  binsof (read_xact_type.read_xact) && binsof (burst_type.wrap_burst)  && (binsof (axi_burst_len) intersect {(cfg.data_width==256?4'h8:5'h11)}); \
    ignore_bins axi_read_wrap_invalid_16len_dw_256bit       =  binsof (read_xact_type.read_xact) && binsof (burst_type.wrap_burst)  && (binsof (axi_burst_len) intersect {(cfg.data_width==256?5'h10:5'h11)}); \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_CACHE_XACT_TYPE_LEN_1_WSTRB \
  cross_xact_type_len_1_wstrb: cross slaves_excluding_register_space, write_xact_type,read_xact_type, axi_burst_len, axi_response_type, burst_type, axi_wstrb_beat_0 iff (cov_item.xact_type == svt_axi_transaction::WRITE) { \
    ignore_bins axi_ignore_resp_except_all_okay             = ! binsof (axi_response_type.axi_okay_response); \
    ignore_bins axi_write_wrap_invalid_len                  =(binsof (write_xact_type.write_xact) && binsof (burst_type.wrap_burst)  &&  !binsof (axi_burst_len) intersect {`SVT_AXI_WRAP_BURST_LENGTH_RANGE}); \
    ignore_bins axi_read_incr_ignore                        = binsof (read_xact_type.read_xact) && binsof (burst_type.incr_burst); \
    ignore_bins axi_read_wrap_ignore                         = binsof (read_xact_type.read_xact) && binsof (burst_type.wrap_burst); \
  }
       
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_CACHE_XACT_TYPE_LEN_2_WSTRB \
  cross_xact_type_len_2_wstrb: cross slaves_excluding_register_space, write_xact_type,read_xact_type, axi_burst_len, axi_response_type, burst_type, axi_wstrb_beat_1 iff (cov_item.xact_type == svt_axi_transaction::WRITE) { \
    ignore_bins axi_ignore_resp_except_all_okay             = ! binsof (axi_response_type.axi_okay_response); \
    ignore_bins axi_write_wrap_invalid_len                  =(binsof (write_xact_type.write_xact) && binsof (burst_type.wrap_burst)  &&  !binsof (axi_burst_len) intersect {`SVT_AXI_WRAP_BURST_LENGTH_RANGE}); \
    ignore_bins axi_read_incr_ignore                        = binsof (read_xact_type.read_xact) && binsof (burst_type.incr_burst); \
    ignore_bins axi_read_wrap_ignore                         = binsof (read_xact_type.read_xact) && binsof (burst_type.wrap_burst); \
    ignore_bins axi_ignore_len1_for_beat2                   = binsof (axi_burst_len) intersect {4'h1}; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_CACHE_XACT_TYPE_LEN_3_WSTRB \
  cross_xact_type_len_3_wstrb: cross slaves_excluding_register_space, write_xact_type,read_xact_type, axi_burst_len, axi_response_type, burst_type, axi_wstrb_beat_2 iff (cov_item.xact_type == svt_axi_transaction::WRITE) { \
    ignore_bins axi_ignore_resp_except_all_okay             = ! binsof (axi_response_type.axi_okay_response); \
    ignore_bins axi_write_wrap_invalid_len                  =(binsof (write_xact_type.write_xact) && binsof (burst_type.wrap_burst)  &&  !binsof (axi_burst_len) intersect {`SVT_AXI_WRAP_BURST_LENGTH_RANGE}); \
    ignore_bins axi_read_incr_ignore                        = binsof (read_xact_type.read_xact) && binsof (burst_type.incr_burst); \
    ignore_bins axi_read_wrap_ignore                         = binsof (read_xact_type.read_xact) && binsof (burst_type.wrap_burst); \
    ignore_bins axi_ignore_len1_len2_for_beat3              = binsof (axi_burst_len) intersect {4'h1,4'h2}; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_CACHE_XACT_TYPE_LEN_4_WSTRB \
  cross_xact_type_len_4_wstrb: cross slaves_excluding_register_space, write_xact_type,read_xact_type, axi_burst_len, axi_response_type, burst_type, axi_wstrb_beat_3 iff (cov_item.xact_type == svt_axi_transaction::WRITE) { \
    ignore_bins axi_ignore_resp_except_all_okay             = ! binsof (axi_response_type.axi_okay_response); \
    ignore_bins axi_write_wrap_invalid_len                  =(binsof (write_xact_type.write_xact) && binsof (burst_type.wrap_burst)  &&  !binsof (axi_burst_len) intersect {`SVT_AXI_WRAP_BURST_LENGTH_RANGE}); \
    ignore_bins axi_read_incr_ignore                        = binsof (read_xact_type.read_xact) && binsof (burst_type.incr_burst); \
    ignore_bins axi_read_wrap_ignore                         = binsof (read_xact_type.read_xact) && binsof (burst_type.wrap_burst); \
    ignore_bins axi_ignore_len1_len2_len3_for_beat4         = binsof (axi_burst_len) intersect {4'h1,4'h2,4'h3}; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_CACHE_XACT_TYPE_LEN_16_WSTRB \
  cross_xact_type_len_16_wstrb: cross slaves_excluding_register_space, write_xact_type,read_xact_type, axi_burst_len, axi_response_type, burst_type, axi_wstrb_beat_15 iff (cov_item.xact_type == svt_axi_transaction::WRITE)  { \
    ignore_bins axi_ignore_resp_except_all_okay             = ! binsof (axi_response_type.axi_okay_response); \
    ignore_bins axi_write_wrap_invalid_len                  =(binsof (write_xact_type.write_xact) && binsof (burst_type.wrap_burst)  &&  !binsof (axi_burst_len) intersect {`SVT_AXI_WRAP_BURST_LENGTH_RANGE}); \
    ignore_bins axi_read_incr_ignore                        = binsof (read_xact_type.read_xact) && binsof (burst_type.incr_burst); \
    ignore_bins axi_read_wrap_ignore                         = binsof (read_xact_type.read_xact) && binsof (burst_type.wrap_burst); \
    ignore_bins axi_ignore_all_len_except_len16_for_beat16  = binsof (axi_burst_len) intersect {[4'h1:4'hf]}; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_CROSS_ALIGNED_UNALIGNED_ADDR_ASIZE \
  cross_aligned_unaligned_addr_asize: cross slaves_excluding_register_space, write_xact_type,read_xact_type, axi_burst_size, axi_address_aligned, axi_burst_len, burst_type, axi_response_type   { \
    ignore_bins axi_ignore_resp_except_all_okay             = ! binsof (axi_response_type.axi_okay_response); \
    ignore_bins axi_ignored_len                             =  binsof (axi_burst_len)  intersect {4'h3,[4'h5:4'h7],[4'h9:4'hf]}; \
    ignore_bins axi_size_less_than_64bit_len_1_to_16        = (binsof (axi_burst_size) intersect {[3'h0:3'h2]}) && (binsof (axi_burst_len) intersect{[4'h1:5'h10]}); \
    ignore_bins axi_write_wrap_invalid_len                  = (binsof (write_xact_type.write_xact) && binsof (burst_type.wrap_burst)  &&  !binsof (axi_burst_len) intersect {`SVT_AXI_WRAP_BURST_LENGTH_RANGE}); \
    ignore_bins axi_read_wrap_invalid_len_dw_64bit          =  binsof (read_xact_type.read_xact) && binsof (burst_type.wrap_burst)  &&  binsof (axi_burst_len) intersect {(cfg.data_width==64?4'h2:5'h11)} ; \
    ignore_bins axi_read_wrap_invalid_len_dw_128bit         =  binsof (read_xact_type.read_xact) && binsof (burst_type.wrap_burst)  &&  binsof (axi_burst_len) intersect {(cfg.data_width==128?5'h10:5'h11)} ; \
    ignore_bins axi_read_wrap_invalid_8len_dw_256bit        =  binsof (read_xact_type.read_xact) && binsof (burst_type.wrap_burst)  && (binsof (axi_burst_len) intersect {(cfg.data_width==256?4'h8:5'h11)}); \
    ignore_bins axi_read_wrap_invalid_16len_dw_256bit       =  binsof (read_xact_type.read_xact) && binsof (burst_type.wrap_burst)  && (binsof (axi_burst_len) intersect {(cfg.data_width==256?5'h10:5'h11)}); \
  }
     
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_CROSS_ALIGNED_UNALIGNED_ADDR_ASIZE_IGNORE_RESP \
  cross_aligned_unaligned_addr_asize_ignore_resp: cross slaves_excluding_register_space, write_xact_type,read_xact_type, axi_burst_size, axi_address_aligned, burst_type, axi_burst_len { \
    ignore_bins axi_ignored_len                             =  binsof (axi_burst_len)  intersect {4'h2,[4'h4:4'h6],[4'h8:4'he]}; \
    ignore_bins axi_size_less_than_64bit_len_1_to_16        = (binsof (axi_burst_size) intersect {[3'h0:3'h2]}) && (binsof (axi_burst_len) intersect{[4'h1:5'h10]}); \
    ignore_bins axi_write_wrap_invalid_len                  = (binsof (write_xact_type.write_xact) && binsof (burst_type.wrap_burst)  &&  !binsof (axi_burst_len) intersect {`SVT_AXI_WRAP_BURST_LENGTH_RANGE}); \
    ignore_bins axi_read_wrap_invalid_len_dw_64bit          = binsof (read_xact_type.read_xact) && binsof (burst_type.wrap_burst)  &&  binsof (axi_burst_len) intersect {(cfg.data_width==64?4'h2:5'h11)}; \
    ignore_bins axi_read_wrap_invalid_len_dw_128bit         =  binsof (read_xact_type.read_xact) && binsof (burst_type.wrap_burst)  &&  binsof (axi_burst_len) intersect {(cfg.data_width==128?5'h10:5'h11)}; \
    ignore_bins axi_read_wrap_invalid_8len_dw_256bit        =  binsof (read_xact_type.read_xact) && binsof (burst_type.wrap_burst)  && (binsof (axi_burst_len) intersect {(cfg.data_width==256?4'h8:5'h11)}); \
    ignore_bins axi_read_wrap_invalid_16len_dw_256bit       =  binsof (read_xact_type.read_xact) && binsof (burst_type.wrap_burst)  && (binsof (axi_burst_len) intersect {(cfg.data_width==256?5'h10:5'h11)}); \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_MASTER_TO_SLAVE_X_WR_OKAY_ADDR_ALIGN \
  master_to_slave_x_wr_okay_addr_align: cross slaves_excluding_register_space, axi_ex_xact_type, cache_type, write_xact_type,read_xact_type, burst_type, axi_burst_len, axi_burst_size, axi_address_aligned, axi_response_type iff (cov_item.xact_type == svt_axi_transaction::WRITE)   { \
    ignore_bins axi_ignore_resp_except_exokay                              = ! binsof (axi_response_type.axi_exokay_response); \
    ignore_bins axi_ignore_len_greater_than_1                                = ! binsof (axi_burst_len) intersect {4'h1}; \
    ignore_bins axi_ex_write_ignore                                          =  (binsof (axi_ex_xact_type.exclusive_type) && binsof (write_xact_type.write_xact) && (binsof (burst_type) intersect {svt_axi_transaction::WRAP,svt_axi_transaction::INCR})); \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_MASTER_TO_SLAVE_X_WR_FAIL_ADDR_ALIGN \
  master_to_slave_x_wr_fail_addr_align: cross slaves_excluding_register_space, axi_ex_xact_type, cache_type, write_xact_type,read_xact_type, burst_type, axi_burst_len, axi_burst_size, axi_address_aligned, axi_response_type iff (cov_item.xact_type == svt_axi_transaction::WRITE)  { \
    ignore_bins axi_ignore_resp_except_exokay_fail                              = ! binsof (axi_response_type.axi_exokay_fail_response); \
    ignore_bins axi_ignore_len_greater_than_1                                = ! binsof (axi_burst_len) intersect {4'h1}; \
    ignore_bins axi_ex_write_ignore                                          =   (binsof (axi_ex_xact_type.exclusive_type) && binsof (write_xact_type.write_xact) && (binsof (burst_type) intersect {svt_axi_transaction::WRAP,svt_axi_transaction::INCR})); \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_MASTER_TO_SLAVE_X_WR_DECERR \
  master_to_slave_x_wr_decerr: cross slaves_excluding_register_space, axi_ex_xact_type, cache_type, write_xact_type,read_xact_type, burst_type, axi_burst_len, axi_burst_size, axi_address_aligned, axi_response_type iff (cov_item.xact_type == svt_axi_transaction::WRITE)  { \
    ignore_bins axi_ignore_resp_except_decerr                              = ! binsof (axi_response_type.axi_decerr_response); \
    ignore_bins axi_ignore_len_greater_than_1                                = ! binsof (axi_burst_len) intersect {4'h1}; \
    ignore_bins axi_ex_write_ignore                                          =   (binsof (axi_ex_xact_type.exclusive_type) && binsof (write_xact_type.write_xact) && (binsof (burst_type) intersect {svt_axi_transaction::WRAP,svt_axi_transaction::INCR})); \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_MASTER_TO_SLAVE_X_WR_SLVERR \
  master_to_slave_x_wr_slverr: cross slaves_excluding_register_space, axi_ex_xact_type, cache_type, write_xact_type,read_xact_type, burst_type, axi_burst_len, axi_burst_size, axi_address_aligned, axi_response_type iff (cov_item.xact_type == svt_axi_transaction::WRITE) { \
           ignore_bins axi_ignore_resp_except_slverr                              = ! binsof (axi_response_type.axi_slverr_response); \
           ignore_bins axi_ignore_len_greater_than_1                                = ! binsof (axi_burst_len) intersect {4'h1}; \
           ignore_bins axi_ex_write_ignore                                          =   (binsof (axi_ex_xact_type.exclusive_type) && binsof (write_xact_type.write_xact) && (binsof (burst_type) intersect {svt_axi_transaction::WRAP,svt_axi_transaction::INCR})); \
  }
       
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_MASTER_TO_SLAVE_X_WR_OKAY_WSTRB \
  master_to_slave_x_wr_okay_wstrb: cross slaves_excluding_register_space, axi_ex_xact_type, cache_type, write_xact_type,read_xact_type, burst_type, axi_burst_len, axi_response_type, axi_wstrb_beat_0 iff (cov_item.xact_type == svt_axi_transaction::WRITE) { \
    ignore_bins axi_ignore_resp_except_exokay                              = ! binsof (axi_response_type.axi_exokay_response); \
    ignore_bins axi_ignore_len_greater_than_1                                = ! binsof (axi_burst_len) intersect {4'h1}; \
    ignore_bins axi_ex_read_ignore                                           =   (binsof (axi_ex_xact_type.exclusive_type) && binsof (write_xact_type.write_xact) && (binsof (burst_type) intersect {svt_axi_transaction::WRAP,svt_axi_transaction::INCR})); \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_MASTER_TO_SLAVE_X_WR_FAIL_WSTRB \
  master_to_slave_x_wr_fail_wstrb: cross slaves_excluding_register_space, axi_ex_xact_type, cache_type, write_xact_type,read_xact_type, burst_type, axi_burst_len, axi_response_type, axi_wstrb_beat_0 iff (cov_item.xact_type == svt_axi_transaction::WRITE) { \
    ignore_bins axi_ignore_resp_except_exokay_fail                              = ! binsof (axi_response_type.axi_exokay_fail_response); \
    ignore_bins axi_ignore_len_greater_than_1                                = ! binsof (axi_burst_len) intersect {4'h1}; \
    ignore_bins axi_ex_read_ignore                                           =   (binsof (axi_ex_xact_type.exclusive_type) && binsof (write_xact_type.write_xact) && (binsof (burst_type) intersect {svt_axi_transaction::WRAP,svt_axi_transaction::INCR})); \
  }

// macro used to define ignore bins of transfer size 
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_TRANSFER_SIZE_BURST_SIZE_IGNORE_BINS \
`ifdef SVT_AXI_MAX_DATA_WIDTH_32 \
  ignore_bins ignore_bins_xfer_size_bytes_8_128 ={svt_axi_transaction::BURST_SIZE_64BIT,svt_axi_transaction::BURST_SIZE_128BIT,svt_axi_transaction::BURST_SIZE_256BIT,svt_axi_transaction::BURST_SIZE_512BIT,svt_axi_transaction::BURST_SIZE_1024BIT,svt_axi_transaction::BURST_SIZE_2048BIT}; \
`elsif SVT_AXI_MAX_DATA_WIDTH_64 \
  ignore_bins ignore_bins_xfer_size_bytes_16_128 ={svt_axi_transaction::BURST_SIZE_128BIT,svt_axi_transaction::BURST_SIZE_256BIT,svt_axi_transaction::BURST_SIZE_512BIT,svt_axi_transaction::BURST_SIZE_1024BIT,svt_axi_transaction::BURST_SIZE_2048BIT}; \
`elsif SVT_AXI_MAX_DATA_WIDTH_128 \
  ignore_bins ignore_bins_xfer_size_bytes_32_128 ={svt_axi_transaction::BURST_SIZE_256BIT,svt_axi_transaction::BURST_SIZE_512BIT,svt_axi_transaction::BURST_SIZE_1024BIT,svt_axi_transaction::BURST_SIZE_2048BIT}; \
`elsif SVT_AXI_MAX_DATA_WIDTH_256 \
  ignore_bins ignore_bins_xfer_size_bytes_64_128 ={svt_axi_transaction::BURST_SIZE_512BIT,svt_axi_transaction::BURST_SIZE_1024BIT,svt_axi_transaction::BURST_SIZE_2048BIT}; \
`elsif SVT_AXI_MAX_DATA_WIDTH_512 \
  ignore_bins ignore_bins_xfer_size_bytes_128_256 = {svt_axi_transaction::BURST_SIZE_1024BIT,svt_axi_transaction::BURST_SIZE_2048BIT}; \
`elsif SVT_AXI_MAX_DATA_WIDTH_1024 \
  ignore_bins ignore_bins_xfer_size_bytes_256 = {svt_axi_transaction::BURST_SIZE_2048BIT}; \
`endif

// macro used to define ignore bins of transfer size 
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_RDATA_CHUNK_TRANSFER_SIZE_BURST_SIZE_IGNORE_BINS \
`ifdef SVT_AXI_MAX_DATA_WIDTH_128 \
  ignore_bins ignore_bins_xfer_size_bytes_32_128 ={svt_axi_transaction::BURST_SIZE_256BIT,svt_axi_transaction::BURST_SIZE_512BIT,svt_axi_transaction::BURST_SIZE_1024BIT,svt_axi_transaction::BURST_SIZE_2048BIT}; \
`elsif SVT_AXI_MAX_DATA_WIDTH_256 \
  ignore_bins ignore_bins_xfer_size_bytes_64_128 ={svt_axi_transaction::BURST_SIZE_512BIT,svt_axi_transaction::BURST_SIZE_1024BIT,svt_axi_transaction::BURST_SIZE_2048BIT}; \
`elsif SVT_AXI_MAX_DATA_WIDTH_512 \
  ignore_bins ignore_bins_xfer_size_bytes_128_256 = {svt_axi_transaction::BURST_SIZE_1024BIT,svt_axi_transaction::BURST_SIZE_2048BIT}; \
`elsif SVT_AXI_MAX_DATA_WIDTH_1024 \
  ignore_bins ignore_bins_xfer_size_bytes_256 = {svt_axi_transaction::BURST_SIZE_2048BIT}; \
`endif

`ifndef SVT_AXI_MON_CFG_BASED_COV_GRP_DEF 

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_ADDR_ACE \
  addr : coverpoint cov_item.addr iff(cov_addr_flag){ \
    option.weight = 1; \
     bins addr_range_min = {0} ; \
	 `ifdef SVT_MULTI_SIM_COVPOINT_GREATER_THAN_32_BITS \
     // Need to come up with an alternative \
`else \
     bins addr_range_mid = {[1:(64'd2**(cfg.addr_width)-2)]}; \
     bins addr_range_max = {((64'd2**(cfg.addr_width))-1)}; \
     ignore_bins Ignore_addr_range_max = {((64'd2**(cfg.addr_width))-1)} ; \
`endif \
     ignore_bins Ignore_addr_range_min = {0} iff(cfg.axi_interface_type == svt_axi_port_configuration::AXI_ACE  ||  cfg.axi_interface_type == svt_axi_port_configuration::ACE_LITE); \
  }

`endif

`ifdef SVT_AXI_MON_CFG_BASED_COV_GRP_DEF
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_ADDR_AXI3_AXI4 \
  addr : coverpoint cov_item.addr iff(cov_addr_flag){ \
    option.weight = 1; \
     bins addr_range_min = {0} ; \
     bins addr_range_mid = {[1:(64'd2**(cfg.addr_width)-2)]}; \
     bins addr_range_max = {((64'd2**(cfg.addr_width))-1)}; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_ADDR_ACE \
  addr : coverpoint cov_item.addr iff(cov_addr_flag){ \
    option.weight = 1; \
     bins addr_range_min = {0} ; \
     bins addr_range_mid = {[1:(64'd2**(cfg.addr_width)-2)]}; \
     bins addr_range_max = {((64'd2**(cfg.addr_width))-1)}; \
     ignore_bins Ignore_addr_range_max = {((64'd2**(cfg.addr_width))-1)} ; \
     ignore_bins Ignore_addr_range_min = {0} ; \
  }

`endif

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_BRESP \
  bresp : coverpoint cov_item.bresp iff(cov_bresp_flag){ \
    bins okay_resp    = {svt_axi_transaction::OKAY}; \
    bins exokay_resp  = {svt_axi_transaction::EXOKAY} iff ((cfg.axi_interface_type != svt_axi_port_configuration::AXI4_LITE) || (cfg.exclusive_access_enable == 1)) ; \
    bins slverr_resp  = {svt_axi_transaction::SLVERR}; \
    bins decerr_resp  = {svt_axi_transaction::DECERR}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_ATOMIC_BRESP_NO_EXCLUSIVE \
  bresp : coverpoint cov_item.bresp iff(cov_bresp_flag){ \
    bins okay_resp    = {svt_axi_transaction::OKAY}; \
    bins slverr_resp  = {svt_axi_transaction::SLVERR}; \
    bins decerr_resp  = {svt_axi_transaction::DECERR}; \
    option.weight = 1; \
  }

`ifdef SVT_AXI_MON_CFG_BASED_COV_GRP_DEF

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_BRESP_NO_EXCLUSIVE_AXI4_LITE \
  bresp : coverpoint cov_item.bresp iff(cov_bresp_flag){ \
    bins okay_resp    = {svt_axi_transaction::OKAY}; \
    bins slverr_resp  = {svt_axi_transaction::SLVERR}; \
    bins decerr_resp  = {svt_axi_transaction::DECERR}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_BRESP_ALL \
  bresp : coverpoint cov_item.bresp iff(cov_bresp_flag){ \
    bins okay_resp    = {svt_axi_transaction::OKAY}; \
    bins exokay_resp  = {svt_axi_transaction::EXOKAY}; \
    bins slverr_resp  = {svt_axi_transaction::SLVERR}; \
    bins decerr_resp  = {svt_axi_transaction::DECERR}; \
    option.weight = 1; \
  }
`endif 

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_ATOMIC_RRESP_NO_EXCLUSIVE \
  rresp : coverpoint cov_rresp iff(cov_rresp_flag){ \
    bins okay_resp    = {svt_axi_transaction::OKAY}; \
    bins slverr_resp  = {svt_axi_transaction::SLVERR}; \
    bins decerr_resp  = {svt_axi_transaction::DECERR}; \
    option.weight = 1; \
  }

`ifndef SVT_AXI_MON_CFG_BASED_COV_GRP_DEF
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_RRESP \
  rresp : coverpoint cov_rresp iff(cov_rresp_flag){ \
    bins okay_resp    = {svt_axi_transaction::OKAY}; \
    bins exokay_resp  = {svt_axi_transaction::EXOKAY} iff ((cfg.axi_interface_type != svt_axi_port_configuration::AXI4_LITE) || (cfg.exclusive_access_enable == 1)) ; \
    bins slverr_resp  = {svt_axi_transaction::SLVERR}; \
    bins decerr_resp  = {svt_axi_transaction::DECERR}; \
    option.weight = 1; \
  }

`else //SVT_AXI_MON_CFG_BASED_COV_GRP_DEF 
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_RRESP_NO_EXCLUSIVE_AXI4_LITE \
  rresp : coverpoint cov_rresp iff(cov_rresp_flag){ \
    bins okay_resp    = {svt_axi_transaction::OKAY}; \
    bins slverr_resp  = {svt_axi_transaction::SLVERR}; \
    bins decerr_resp  = {svt_axi_transaction::DECERR}; \
    option.weight = 1; \
  }
  
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_RRESP_ALL \
  rresp : coverpoint cov_rresp iff(cov_rresp_flag){ \
    bins okay_resp    = {svt_axi_transaction::OKAY}; \
    bins exokay_resp  = {svt_axi_transaction::EXOKAY}; \
    bins slverr_resp  = {svt_axi_transaction::SLVERR}; \
    bins decerr_resp  = {svt_axi_transaction::DECERR}; \
    option.weight = 1; \
  }
`endif //SVT_AXI_MON_CFG_BASED_COV_GRP_DEF

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_PATH_COV_WSTRB_BINS \
`ifdef SVT_AXI_PATH_COV_DATA_WIDTH_LESS_THAN_16_BIT \
   bins wstrb_all_ones_8    = {1'b1} ; \
   bins wstrb_all_zeroes_8  = {1'b0} ; \
`elsif SVT_AXI_PATH_COV_DATA_WIDTH_LESS_THAN_32_BIT \
   bins wstrb_all_ones_16   = {2'b11}; \
   bins wstrb_all_zeroes_16  = {2'b00}; \
   bins wstrb_all_one_zero_data_width_16  = {2'b10}; \
   bins wstrb_all_zero_one_data_width_16  = {2'b01}; \
`elsif SVT_AXI_PATH_COV_DATA_WIDTH_LESS_THAN_64_BIT \
   bins wstrb_all_ones_16   = {2'b11}; \
   bins wstrb_all_ones_32   = {4'b1111}; \
   bins wstrb_all_zeroes_16  = {2'b00}; \
   bins wstrb_all_zeroes_32   = {4'b0000}; \
   bins wstrb_all_one_zero_data_width_16  = {2'b10}; \
   bins wstrb_all_zero_one_data_width_16  = {2'b01}; \
   bins wstrb_all_one_zero_data_width_32  = {4'ha}; \
   bins wstrb_all_zero_one_data_width_32  = {4'h5}; \
`elsif SVT_AXI_PATH_COV_DATA_WIDTH_LESS_THAN_128_BIT \
  bins wstrb_all_ones_16   = {2'b11}; \
  bins wstrb_all_ones_32   = {4'b1111}; \
  bins wstrb_all_ones_64   = {8'hff}; \
  bins wstrb_all_zeroes_16  = {2'b00}; \
  bins wstrb_all_zeroes_32   = {4'b0000}; \
  bins wstrb_all_zeroes_64   = {8'h00}; \
  bins wstrb_all_one_zero_data_width_16  = {2'b10}; \
  bins wstrb_all_zero_one_data_width_16  = {2'b01}; \
  bins wstrb_all_one_zero_data_width_32  = {4'ha}; \
  bins wstrb_all_zero_one_data_width_32  = {4'h5}; \
  bins wstrb_all_one_zero_data_width_64  = {8'haa}; \
  bins wstrb_all_zero_one_data_width_64  = {8'h55}; \
`elsif SVT_AXI_PATH_COV_DATA_WIDTH_LESS_THAN_256_BIT \
  bins wstrb_all_ones_16   = {2'b11}; \
  bins wstrb_all_ones_32   = {4'b1111}; \
  bins wstrb_all_ones_64   = {8'hff}; \
  bins wstrb_all_ones_128  = {16'hffff}; \
  bins wstrb_all_zeroes_16  = {2'b00}; \
  bins wstrb_all_zeroes_32   = {4'b0000}; \
  bins wstrb_all_zeroes_64   = {8'h00}; \
  bins wstrb_all_zeroes_128  = {16'h0000}; \
  bins wstrb_all_one_zero_data_width_16  = {2'b10}; \
  bins wstrb_all_zero_one_data_width_16  = {2'b01}; \
  bins wstrb_all_one_zero_data_width_32  = {4'ha}; \
  bins wstrb_all_zero_one_data_width_32  = {4'h5}; \
  bins wstrb_all_one_zero_data_width_64  = {8'haa}; \
  bins wstrb_all_zero_one_data_width_64  = {8'h55}; \
  bins wstrb_all_one_zero_data_width_128  = {16'haaaa}; \
  bins wstrb_all_zero_one_data_width_128  = {16'h5555}; \
`elsif SVT_AXI_PATH_COV_DATA_WIDTH_LESS_THAN_512_BIT \
  bins wstrb_all_ones_16   = {2'b11}; \
  bins wstrb_all_ones_32   = {4'b1111}; \
  bins wstrb_all_ones_64   = {8'hff}; \
  bins wstrb_all_ones_128  = {16'hffff}; \
  bins wstrb_all_ones_256  = {32'hffff_ffff}; \
  bins wstrb_all_zeroes_16  = {2'b00}; \
  bins wstrb_all_zeroes_32   = {4'b0000}; \
  bins wstrb_all_zeroes_64   = {8'h00}; \
  bins wstrb_all_zeroes_128  = {16'h0000}; \
  bins wstrb_all_zeroes_256  = {32'h0000_0000}; \
  bins wstrb_all_one_zero_data_width_16  = {2'b10}; \
  bins wstrb_all_zero_one_data_width_16  = {2'b01}; \
  bins wstrb_all_one_zero_data_width_32  = {4'ha}; \
  bins wstrb_all_zero_one_data_width_32  = {4'h5}; \
  bins wstrb_all_one_zero_data_width_64  = {8'haa}; \
  bins wstrb_all_zero_one_data_width_64  = {8'h55}; \
  bins wstrb_all_one_zero_data_width_128  = {16'haaaa}; \
  bins wstrb_all_zero_one_data_width_128  = {16'h5555}; \
  bins wstrb_all_one_zero_data_width_256  = {32'haaaa_aaaa}; \
  bins wstrb_all_zero_one_data_width_256  = {32'h5555_5555}; \
`elsif SVT_AXI_PATH_COV_DATA_WIDTH_LESS_THAN_1024_BIT \
  bins wstrb_all_ones_16   = {2'b11}; \
  bins wstrb_all_ones_32   = {4'b1111}; \
  bins wstrb_all_ones_64   = {8'hff}; \
  bins wstrb_all_ones_128  = {16'hffff}; \
  bins wstrb_all_ones_256  = {32'hffff_ffff}; \
  bins wstrb_all_ones_512  = {64'hffff_ffff_ffff_ffff}; \
  bins wstrb_all_zeroes_16  = {2'b00}; \
  bins wstrb_all_zeroes_32   = {4'b0000}; \
  bins wstrb_all_zeroes_64   = {8'h00}; \
  bins wstrb_all_zeroes_128  = {16'h0000}; \
  bins wstrb_all_zeroes_256  = {32'h0000_0000}; \
  bins wstrb_all_zeroes_512  = {64'h0000_0000_0000_0000}; \
  bins wstrb_all_one_zero_data_width_16  = {2'b10}; \
  bins wstrb_all_zero_one_data_width_16  = {2'b01}; \
  bins wstrb_all_one_zero_data_width_32  = {4'ha}; \
  bins wstrb_all_zero_one_data_width_32  = {4'h5}; \
  bins wstrb_all_one_zero_data_width_64  = {8'haa}; \
  bins wstrb_all_zero_one_data_width_64  = {8'h55}; \
  bins wstrb_all_one_zero_data_width_128  = {16'haaaa}; \
  bins wstrb_all_zero_one_data_width_128  = {16'h5555}; \
  bins wstrb_all_one_zero_data_width_256  = {32'haaaa_aaaa}; \
  bins wstrb_all_zero_one_data_width_256  = {32'h5555_5555}; \
  bins wstrb_all_one_zero_data_width_512  = {64'haaaa_aaaa_aaaa_aaaa}; \
  bins wstrb_all_zero_one_data_width_512  = {64'h5555_5555_5555_5555}; \
`elsif SVT_AXI_PATH_COV_DATA_WIDTH_1024_BIT \
   bins wstrb_all_ones_8    = {1'b1} ; \
   bins wstrb_all_ones_16   = {2'b11} ; \
   bins wstrb_all_ones_32   = {4'b1111} ; \
   bins wstrb_all_ones_64   = {8'hff} ; \
   bins wstrb_all_ones_128  = {16'hffff} ; \
   bins wstrb_all_ones_256  = {32'hffff_ffff}; \
   bins wstrb_all_ones_512  = {64'hffff_ffff_ffff_ffff} ; \
   bins wstrb_all_ones_1024 = {128'hffff_ffff_ffff_ffff_ffff_ffff_ffff_ffff} ; \
   bins wstrb_all_zeroes_8  = {1'b0} ; \
   bins wstrb_all_zeroes_16  = {2'b00} ; \
   bins wstrb_all_zeroes_32   = {4'b0000} ; \
   bins wstrb_all_zeroes_64   = {8'h00} ; \
   bins wstrb_all_zeroes_128  = {16'h0000} ; \
   bins wstrb_all_zeroes_256  = {32'h0000_0000} ; \
   bins wstrb_all_zeroes_512  = {64'h0000_0000_0000_0000} ; \
   bins wstrb_all_zeroes_1024 = {128'h0000_0000_0000_0000_0000_0000_0000_0000} ; \
   bins wstrb_all_one_zero_data_width_16  = {2'b10} ; \
   bins wstrb_all_zero_one_data_width_16  = {2'b01} ; \
   bins wstrb_all_one_zero_data_width_32  = {4'ha} ; \
   bins wstrb_all_zero_one_data_width_32  = {4'h5}; \
   bins wstrb_all_one_zero_data_width_64  = {8'haa} ; \
   bins wstrb_all_zero_one_data_width_64  = {8'h55} ; \
   bins wstrb_all_one_zero_data_width_128  = {16'haaaa} ; \
   bins wstrb_all_zero_one_data_width_128  = {16'h5555} ; \
   bins wstrb_all_one_zero_data_width_256  = {32'haaaa_aaaa} ; \
   bins wstrb_all_zero_one_data_width_256  = {32'h5555_5555} ; \
   bins wstrb_all_one_zero_data_width_512  = {64'haaaa_aaaa_aaaa_aaaa} ; \
   bins wstrb_all_zero_one_data_width_512  = {64'h5555_5555_5555_5555} ; \
   bins wstrb_all_one_zero_data_width_1024  = {128'haaaa_aaaa_aaaa_aaaa_aaaa_aaaa_aaaa_aaaa} ; \
   bins wstrb_all_zero_one_data_width_1024  = {128'h5555_5555_5555_5555_5555_5555_5555_5555}  ; \
`endif \

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_BURST_SIZE_32BIT_AXI4_LITE \
  burst_size : coverpoint cov_item.burst_size iff(cov_burst_size_flag){ \
    bins burst_size_32bit   = {svt_axi_transaction::BURST_SIZE_32BIT}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_BURST_SIZE_64BIT_AXI4_LITE \
  burst_size : coverpoint cov_item.burst_size iff(cov_burst_size_flag){ \
    bins burst_size_64bit   = {svt_axi_transaction::BURST_SIZE_64BIT}; \
    option.weight = 1; \
  }

 
`ifdef SVT_AXI_GEN_COV_DATA_WIDTH_32_BIT 
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_BURST_SIZE \
  burst_size : coverpoint cov_item.burst_size iff(cov_burst_size_flag){ \
    bins burst_size_8bit    = {svt_axi_transaction::BURST_SIZE_8BIT}; \
    bins burst_size_16bit   = {svt_axi_transaction::BURST_SIZE_16BIT}; \
    bins burst_size_32bit   = {svt_axi_transaction::BURST_SIZE_32BIT}; \
 option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_WSTRB_DWLT_32 \
  wstrb :  coverpoint cov_wstrb iff(cov_wstrb_flag){ \
    bins wstrb_all_ones_16   = {2'b11}; \
    bins wstrb_all_zeroes_16  = {2'b00}; \
    bins wstrb_all_one_zero_data_width_16  = {2'b10}; \
    bins wstrb_all_zero_one_data_width_16  = {2'b01}; \
    option.weight = 1; \
  } 

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_WSTRB_DWLT_64 \
  wstrb :  coverpoint cov_wstrb iff(cov_wstrb_flag){ \
    bins wstrb_all_ones_16   = {2'b11}; \
    bins wstrb_all_ones_32   = {4'b1111}; \
    bins wstrb_all_zeroes_16  = {2'b00}; \
    bins wstrb_all_zeroes_32   = {4'b0000}; \
    bins wstrb_all_one_zero_data_width_16  = {2'b10}; \
    bins wstrb_all_zero_one_data_width_16  = {2'b01}; \
    bins wstrb_all_one_zero_data_width_32  = {4'ha}; \
    bins wstrb_all_zero_one_data_width_32  = {4'h5}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_WSTRB_DWLT_128 \
  wstrb :  coverpoint cov_wstrb iff(cov_wstrb_flag){ \
    bins wstrb_all_ones_16   = {2'b11}; \
    bins wstrb_all_ones_32   = {4'b1111}; \
    bins wstrb_all_ones_64   = {8'hff}; \
    bins wstrb_all_zeroes_16  = {2'b00}; \
    bins wstrb_all_zeroes_32   = {4'b0000}; \
    bins wstrb_all_zeroes_64   = {8'h00}; \
    bins wstrb_all_one_zero_data_width_16  = {2'b10}; \
    bins wstrb_all_zero_one_data_width_16  = {2'b01}; \
    bins wstrb_all_one_zero_data_width_32  = {4'ha}; \
    bins wstrb_all_zero_one_data_width_32  = {4'h5}; \
    bins wstrb_all_one_zero_data_width_64  = {8'haa}; \
    bins wstrb_all_zero_one_data_width_64  = {8'h55}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_WSTRB_DWLT_256 \
  wstrb :  coverpoint cov_wstrb iff(cov_wstrb_flag){ \
    bins wstrb_all_ones_16   = {2'b11}; \
    bins wstrb_all_ones_32   = {4'b1111}; \
    bins wstrb_all_ones_64   = {8'hff}; \
    bins wstrb_all_ones_128  = {16'hffff}; \
    bins wstrb_all_zeroes_16  = {2'b00}; \
    bins wstrb_all_zeroes_32   = {4'b0000}; \
    bins wstrb_all_zeroes_64   = {8'h00}; \
    bins wstrb_all_zeroes_128  = {16'h0000}; \
    bins wstrb_all_one_zero_data_width_16  = {2'b10}; \
    bins wstrb_all_zero_one_data_width_16  = {2'b01}; \
    bins wstrb_all_one_zero_data_width_32  = {4'ha}; \
    bins wstrb_all_zero_one_data_width_32  = {4'h5}; \
    bins wstrb_all_one_zero_data_width_64  = {8'haa}; \
    bins wstrb_all_zero_one_data_width_64  = {8'h55}; \
    bins wstrb_all_one_zero_data_width_128  = {16'haaaa}; \
    bins wstrb_all_zero_one_data_width_128  = {16'h5555}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_WSTRB_DWLT_512 \
  wstrb :  coverpoint cov_wstrb iff(cov_wstrb_flag){ \
    bins wstrb_all_ones_16   = {2'b11}; \
    bins wstrb_all_ones_32   = {4'b1111}; \
    bins wstrb_all_ones_64   = {8'hff}; \
    bins wstrb_all_ones_128  = {16'hffff}; \
    bins wstrb_all_ones_256  = {32'hffff_ffff}; \
    bins wstrb_all_zeroes_16  = {2'b00}; \
    bins wstrb_all_zeroes_32   = {4'b0000}; \
    bins wstrb_all_zeroes_64   = {8'h00}; \
    bins wstrb_all_zeroes_128  = {16'h0000}; \
    bins wstrb_all_zeroes_256  = {32'h0000_0000}; \
    bins wstrb_all_one_zero_data_width_16  = {2'b10}; \
    bins wstrb_all_zero_one_data_width_16  = {2'b01}; \
    bins wstrb_all_one_zero_data_width_32  = {4'ha}; \
    bins wstrb_all_zero_one_data_width_32  = {4'h5}; \
    bins wstrb_all_one_zero_data_width_64  = {8'haa}; \
    bins wstrb_all_zero_one_data_width_64  = {8'h55}; \
    bins wstrb_all_one_zero_data_width_128  = {16'haaaa}; \
    bins wstrb_all_zero_one_data_width_128  = {16'h5555}; \
    bins wstrb_all_one_zero_data_width_256  = {32'haaaa_aaaa}; \
    bins wstrb_all_zero_one_data_width_256  = {32'h5555_5555}; \
    option.weight = 1; \
  } 

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_WSTRB_DWLT_1024 \
  wstrb :  coverpoint cov_wstrb iff(cov_wstrb_flag){ \
    bins wstrb_all_ones_16   = {2'b11}; \
    bins wstrb_all_ones_32   = {4'b1111}; \
    bins wstrb_all_ones_64   = {8'hff}; \
    bins wstrb_all_ones_128  = {16'hffff}; \
    bins wstrb_all_ones_256  = {32'hffff_ffff}; \
    bins wstrb_all_ones_512  = {64'hffff_ffff_ffff_ffff}; \
    bins wstrb_all_zeroes_16  = {2'b00}; \
    bins wstrb_all_zeroes_32   = {4'b0000}; \
    bins wstrb_all_zeroes_64   = {8'h00}; \
    bins wstrb_all_zeroes_128  = {16'h0000}; \
    bins wstrb_all_zeroes_256  = {32'h0000_0000}; \
    bins wstrb_all_zeroes_512  = {64'h0000_0000_0000_0000}; \
    bins wstrb_all_one_zero_data_width_16  = {2'b10}; \
    bins wstrb_all_zero_one_data_width_16  = {2'b01}; \
    bins wstrb_all_one_zero_data_width_32  = {4'ha}; \
    bins wstrb_all_zero_one_data_width_32  = {4'h5}; \
    bins wstrb_all_one_zero_data_width_64  = {8'haa}; \
    bins wstrb_all_zero_one_data_width_64  = {8'h55}; \
    bins wstrb_all_one_zero_data_width_128  = {16'haaaa}; \
    bins wstrb_all_zero_one_data_width_128  = {16'h5555}; \
    bins wstrb_all_one_zero_data_width_256  = {32'haaaa_aaaa}; \
    bins wstrb_all_zero_one_data_width_256  = {32'h5555_5555}; \
    bins wstrb_all_one_zero_data_width_512  = {64'haaaa_aaaa_aaaa_aaaa}; \
    bins wstrb_all_zero_one_data_width_512  = {64'h5555_5555_5555_5555}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_WSTRB_DWEQ_1024 \
  wstrb :  coverpoint cov_wstrb iff(cov_wstrb_flag){ \
    bins wstrb_all_ones_16   = {2'b11}; \
    bins wstrb_all_ones_32   = {4'b1111}; \
    bins wstrb_all_ones_64   = {8'hff}; \
    bins wstrb_all_ones_128  = {16'hffff}; \
    bins wstrb_all_ones_256  = {32'hffff_ffff}; \
    bins wstrb_all_ones_512  = {64'hffff_ffff_ffff_ffff}; \
    bins wstrb_all_ones_1024 = {128'hffff_ffff_ffff_ffff_ffff_ffff_ffff_ffff}; \
    bins wstrb_all_zeroes_16  = {2'b00}; \
    bins wstrb_all_zeroes_32   = {4'b0000}; \
    bins wstrb_all_zeroes_64   = {8'h00}; \
    bins wstrb_all_zeroes_128  = {16'h0000}; \
    bins wstrb_all_zeroes_256  = {32'h0000_0000}; \
    bins wstrb_all_zeroes_512  = {64'h0000_0000_0000_0000}; \
    bins wstrb_all_zeroes_1024 = {128'h0000_0000_0000_0000_0000_0000_0000_0000}; \
    bins wstrb_all_one_zero_data_width_16  = {2'b10}; \
    bins wstrb_all_zero_one_data_width_16  = {2'b01}; \
    bins wstrb_all_one_zero_data_width_32  = {4'ha}; \
    bins wstrb_all_zero_one_data_width_32  = {4'h5}; \
    bins wstrb_all_one_zero_data_width_64  = {8'haa}; \
    bins wstrb_all_zero_one_data_width_64  = {8'h55}; \
    bins wstrb_all_one_zero_data_width_128  = {16'haaaa}; \
    bins wstrb_all_zero_one_data_width_128  = {16'h5555}; \
    bins wstrb_all_one_zero_data_width_256  = {32'haaaa_aaaa}; \
    bins wstrb_all_zero_one_data_width_256  = {32'h5555_5555}; \
    bins wstrb_all_one_zero_data_width_512  = {64'haaaa_aaaa_aaaa_aaaa}; \
    bins wstrb_all_zero_one_data_width_512  = {64'h5555_5555_5555_5555}; \
    bins wstrb_all_one_zero_data_width_1024  = {128'haaaa_aaaa_aaaa_aaaa_aaaa_aaaa_aaaa_aaaa}; \
    bins wstrb_all_zero_one_data_width_1024  = {128'h5555_5555_5555_5555_5555_5555_5555_5555}; \
    option.weight = 1; \
  }  
`else
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_BURST_SIZE \
  burst_size : coverpoint cov_item.burst_size iff(cov_burst_size_flag){ \
    bins burst_size_8bit    = {svt_axi_transaction::BURST_SIZE_8BIT}; \
    bins burst_size_16bit   = {svt_axi_transaction::BURST_SIZE_16BIT}; \
    bins burst_size_32bit   = {svt_axi_transaction::BURST_SIZE_32BIT}; \
    bins burst_size_64bit   = {svt_axi_transaction::BURST_SIZE_64BIT}; \
    bins burst_size_128bit  = {svt_axi_transaction::BURST_SIZE_128BIT}; \
    bins burst_size_256bit  = {svt_axi_transaction::BURST_SIZE_256BIT}; \
    bins burst_size_512bit  = {svt_axi_transaction::BURST_SIZE_512BIT}; \
    bins burst_size_1024bit = {svt_axi_transaction::BURST_SIZE_1024BIT};  \
    bins burst_size_2048bit = {svt_axi_transaction::BURST_SIZE_2048BIT};  \
    `SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_TRANSFER_SIZE_BURST_SIZE_IGNORE_BINS \
    option.weight = 1; \
  }
`endif
`ifdef SVT_AXI_MON_CFG_BASED_COV_GRP_DEF

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_BURST_SIZE_LT_16BIT \
  burst_size : coverpoint cov_item.burst_size iff(cov_burst_size_flag){ \
    bins burst_size_8bit    = {svt_axi_transaction::BURST_SIZE_8BIT}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_BURST_SIZE_LT_32BIT \
  burst_size : coverpoint cov_item.burst_size iff(cov_burst_size_flag){ \
    bins burst_size_8bit    = {svt_axi_transaction::BURST_SIZE_8BIT}; \
    bins burst_size_16bit   = {svt_axi_transaction::BURST_SIZE_16BIT}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_BURST_SIZE_LT_64BIT \
  burst_size : coverpoint cov_item.burst_size iff(cov_burst_size_flag){ \
    bins burst_size_8bit    = {svt_axi_transaction::BURST_SIZE_8BIT}; \
    bins burst_size_16bit   = {svt_axi_transaction::BURST_SIZE_16BIT}; \
    bins burst_size_32bit   = {svt_axi_transaction::BURST_SIZE_32BIT}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_BURST_SIZE_LT_128BIT \
  burst_size : coverpoint cov_item.burst_size iff(cov_burst_size_flag){ \
    bins burst_size_8bit    = {svt_axi_transaction::BURST_SIZE_8BIT}; \
    bins burst_size_16bit   = {svt_axi_transaction::BURST_SIZE_16BIT}; \
    bins burst_size_32bit   = {svt_axi_transaction::BURST_SIZE_32BIT}; \
    bins burst_size_64bit   = {svt_axi_transaction::BURST_SIZE_64BIT}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_BURST_SIZE_LT_256BIT \
  burst_size : coverpoint cov_item.burst_size iff(cov_burst_size_flag){ \
    bins burst_size_8bit    = {svt_axi_transaction::BURST_SIZE_8BIT}; \
    bins burst_size_16bit   = {svt_axi_transaction::BURST_SIZE_16BIT}; \
    bins burst_size_32bit   = {svt_axi_transaction::BURST_SIZE_32BIT}; \
    bins burst_size_64bit   = {svt_axi_transaction::BURST_SIZE_64BIT}; \
    bins burst_size_128bit  = {svt_axi_transaction::BURST_SIZE_128BIT}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_BURST_SIZE_LT_512BIT \
  burst_size : coverpoint cov_item.burst_size iff(cov_burst_size_flag){ \
    bins burst_size_8bit    = {svt_axi_transaction::BURST_SIZE_8BIT}; \
    bins burst_size_16bit   = {svt_axi_transaction::BURST_SIZE_16BIT}; \
    bins burst_size_32bit   = {svt_axi_transaction::BURST_SIZE_32BIT}; \
    bins burst_size_64bit   = {svt_axi_transaction::BURST_SIZE_64BIT}; \
    bins burst_size_128bit  = {svt_axi_transaction::BURST_SIZE_128BIT}; \
    bins burst_size_256bit  = {svt_axi_transaction::BURST_SIZE_256BIT}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_BURST_SIZE_LT_1024BIT \
  burst_size : coverpoint cov_item.burst_size iff(cov_burst_size_flag){ \
    bins burst_size_8bit    = {svt_axi_transaction::BURST_SIZE_8BIT}; \
    bins burst_size_16bit   = {svt_axi_transaction::BURST_SIZE_16BIT}; \
    bins burst_size_32bit   = {svt_axi_transaction::BURST_SIZE_32BIT}; \
    bins burst_size_64bit   = {svt_axi_transaction::BURST_SIZE_64BIT}; \
    bins burst_size_128bit  = {svt_axi_transaction::BURST_SIZE_128BIT}; \
    bins burst_size_256bit  = {svt_axi_transaction::BURST_SIZE_256BIT}; \
    bins burst_size_512bit  = {svt_axi_transaction::BURST_SIZE_512BIT}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_BURST_SIZE_EQ_1024BIT \
  burst_size : coverpoint cov_item.burst_size iff(cov_burst_size_flag){ \
    bins burst_size_8bit    = {svt_axi_transaction::BURST_SIZE_8BIT}; \
    bins burst_size_16bit   = {svt_axi_transaction::BURST_SIZE_16BIT}; \
    bins burst_size_32bit   = {svt_axi_transaction::BURST_SIZE_32BIT}; \
    bins burst_size_64bit   = {svt_axi_transaction::BURST_SIZE_64BIT}; \
    bins burst_size_128bit  = {svt_axi_transaction::BURST_SIZE_128BIT}; \
    bins burst_size_256bit  = {svt_axi_transaction::BURST_SIZE_256BIT}; \
    bins burst_size_512bit  = {svt_axi_transaction::BURST_SIZE_512BIT}; \
    bins burst_size_1024bit = {svt_axi_transaction::BURST_SIZE_1024BIT}; \
    option.weight = 1; \
  }
  
`endif
`ifdef SVT_AXI_GEN_COV_DATA_WIDTH_32_BIT
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_WSTRB \
  wstrb :  coverpoint cov_wstrb iff(cov_wstrb_flag){ \
    bins wstrb_all_ones_16   = {2'b11}; \
    bins wstrb_all_zeroes_16  = {2'b00}; \
    bins wstrb_all_one_zero_data_width_16  = {2'b10}; \
    bins wstrb_all_zero_one_data_width_16  = {2'b01}; \
    bins wstrb_all_ones_32   = {4'b1111}; \
    bins wstrb_all_zeroes_32   = {4'b0000}; \
    bins wstrb_all_one_zero_data_width_32  = {4'ha}; \
    bins wstrb_all_zero_one_data_width_32  = {4'h5}; \
    option.weight = 1; \
  }
`else
`ifndef SVT_AXI_MON_CFG_BASED_COV_GRP_DEF	
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_WSTRB \
  wstrb :  coverpoint cov_wstrb iff(cov_wstrb_flag){ \
    `ifdef SVT_AXI_MAX_DATA_WIDTH_32 \
      bins wstrb_all_ones_16   = {2'b11}; \
      bins wstrb_all_ones_32   = {4'b1111}; \
      bins wstrb_all_zeroes_16  = {2'b00}; \
      bins wstrb_all_zeroes_32   = {4'b0000}; \
      bins wstrb_all_one_zero_data_width_16  = {2'b10}; \
      bins wstrb_all_zero_one_data_width_16  = {2'b01}; \
      bins wstrb_all_one_zero_data_width_32  = {4'ha}; \
      bins wstrb_all_zero_one_data_width_32  = {4'h5}; \
    `elsif SVT_AXI_MAX_DATA_WIDTH_64 \
      bins wstrb_all_ones_16   = {2'b11}; \
      bins wstrb_all_ones_32   = {4'b1111}; \
      bins wstrb_all_ones_64   = {8'hff}; \
      bins wstrb_all_zeroes_16  = {2'b00}; \
      bins wstrb_all_zeroes_32   = {4'b0000}; \
      bins wstrb_all_zeroes_64   = {8'h00}; \
      bins wstrb_all_one_zero_data_width_16  = {2'b10}; \
      bins wstrb_all_zero_one_data_width_16  = {2'b01}; \
      bins wstrb_all_one_zero_data_width_32  = {4'ha}; \
      bins wstrb_all_zero_one_data_width_32  = {4'h5}; \
      bins wstrb_all_one_zero_data_width_64  = {8'haa}; \
      bins wstrb_all_zero_one_data_width_64  = {8'h55}; \
    `elsif SVT_AXI_MAX_DATA_WIDTH_128 \
      bins wstrb_all_ones_16   = {2'b11}; \
      bins wstrb_all_ones_32   = {4'b1111}; \
      bins wstrb_all_ones_64   = {8'hff}; \
      bins wstrb_all_ones_128  = {16'hffff}; \
      bins wstrb_all_zeroes_16  = {2'b00}; \
      bins wstrb_all_zeroes_32   = {4'b0000}; \
      bins wstrb_all_zeroes_64   = {8'h00}; \
      bins wstrb_all_zeroes_128  = {16'h0000}; \
      bins wstrb_all_one_zero_data_width_16  = {2'b10}; \
      bins wstrb_all_zero_one_data_width_16  = {2'b01}; \
      bins wstrb_all_one_zero_data_width_32  = {4'ha}; \
      bins wstrb_all_zero_one_data_width_32  = {4'h5}; \
      bins wstrb_all_one_zero_data_width_64  = {8'haa}; \
      bins wstrb_all_zero_one_data_width_64  = {8'h55}; \
      bins wstrb_all_one_zero_data_width_128  = {16'haaaa}; \
      bins wstrb_all_zero_one_data_width_128  = {16'h5555}; \
    `elsif SVT_AXI_MAX_DATA_WIDTH_256 \
      bins wstrb_all_ones_16   = {2'b11}; \
      bins wstrb_all_ones_32   = {4'b1111}; \
      bins wstrb_all_ones_64   = {8'hff}; \
      bins wstrb_all_ones_128  = {16'hffff}; \
      bins wstrb_all_ones_256  = {32'hffff_ffff}; \
      bins wstrb_all_zeroes_16  = {2'b00}; \
      bins wstrb_all_zeroes_32   = {4'b0000}; \
      bins wstrb_all_zeroes_64   = {8'h00}; \
      bins wstrb_all_zeroes_128  = {16'h0000}; \
      bins wstrb_all_zeroes_256  = {32'h0000_0000}; \
      bins wstrb_all_one_zero_data_width_16  = {2'b10}; \
      bins wstrb_all_zero_one_data_width_16  = {2'b01}; \
      bins wstrb_all_one_zero_data_width_32  = {4'ha}; \
      bins wstrb_all_zero_one_data_width_32  = {4'h5}; \
      bins wstrb_all_one_zero_data_width_64  = {8'haa}; \
      bins wstrb_all_zero_one_data_width_64  = {8'h55}; \
      bins wstrb_all_one_zero_data_width_128  = {16'haaaa}; \
      bins wstrb_all_zero_one_data_width_128  = {16'h5555}; \
      bins wstrb_all_one_zero_data_width_256  = {32'haaaa_aaaa}; \
      bins wstrb_all_zero_one_data_width_256  = {32'h5555_5555}; \
    `elsif SVT_AXI_MAX_DATA_WIDTH_512 \
      bins wstrb_all_ones_16   = {2'b11}; \
      bins wstrb_all_ones_32   = {4'b1111}; \
      bins wstrb_all_ones_64   = {8'hff}; \
      bins wstrb_all_ones_128  = {16'hffff}; \
      bins wstrb_all_ones_256  = {32'hffff_ffff}; \
      bins wstrb_all_ones_512  = {64'hffff_ffff_ffff_ffff}; \
      bins wstrb_all_zeroes_16  = {2'b00}; \
      bins wstrb_all_zeroes_32   = {4'b0000}; \
      bins wstrb_all_zeroes_64   = {8'h00}; \
      bins wstrb_all_zeroes_128  = {16'h0000}; \
      bins wstrb_all_zeroes_256  = {32'h0000_0000}; \
      bins wstrb_all_zeroes_512  = {64'h0000_0000_0000_0000}; \
      bins wstrb_all_one_zero_data_width_16  = {2'b10}; \
      bins wstrb_all_zero_one_data_width_16  = {2'b01}; \
      bins wstrb_all_one_zero_data_width_32  = {4'ha}; \
      bins wstrb_all_zero_one_data_width_32  = {4'h5}; \
      bins wstrb_all_one_zero_data_width_64  = {8'haa}; \
      bins wstrb_all_zero_one_data_width_64  = {8'h55}; \
      bins wstrb_all_one_zero_data_width_128  = {16'haaaa}; \
      bins wstrb_all_zero_one_data_width_128  = {16'h5555}; \
      bins wstrb_all_one_zero_data_width_256  = {32'haaaa_aaaa}; \
      bins wstrb_all_zero_one_data_width_256  = {32'h5555_5555}; \
      bins wstrb_all_one_zero_data_width_512  = {64'haaaa_aaaa_aaaa_aaaa}; \
      bins wstrb_all_zero_one_data_width_512  = {64'h5555_5555_5555_5555}; \
    `elsif SVT_AXI_MAX_DATA_WIDTH_1024 \
      bins wstrb_all_ones_16   = {2'b11}; \
      bins wstrb_all_ones_32   = {4'b1111}; \
      bins wstrb_all_ones_64   = {8'hff}; \
      bins wstrb_all_ones_128  = {16'hffff}; \
      bins wstrb_all_ones_256  = {32'hffff_ffff}; \
      bins wstrb_all_ones_512  = {64'hffff_ffff_ffff_ffff}; \
      bins wstrb_all_ones_1024 = {128'hffff_ffff_ffff_ffff_ffff_ffff_ffff_ffff}; \
      bins wstrb_all_zeroes_16  = {2'b00}; \
      bins wstrb_all_zeroes_32   = {4'b0000}; \
      bins wstrb_all_zeroes_64   = {8'h00}; \
      bins wstrb_all_zeroes_128  = {16'h0000}; \
      bins wstrb_all_zeroes_256  = {32'h0000_0000}; \
      bins wstrb_all_zeroes_512  = {64'h0000_0000_0000_0000}; \
      bins wstrb_all_zeroes_1024 = {128'h0000_0000_0000_0000_0000_0000_0000_0000}; \
      bins wstrb_all_one_zero_data_width_16  = {2'b10}; \
      bins wstrb_all_zero_one_data_width_16  = {2'b01}; \
      bins wstrb_all_one_zero_data_width_32  = {4'ha}; \
      bins wstrb_all_zero_one_data_width_32  = {4'h5}; \
      bins wstrb_all_one_zero_data_width_64  = {8'haa}; \
      bins wstrb_all_zero_one_data_width_64  = {8'h55}; \
      bins wstrb_all_one_zero_data_width_128  = {16'haaaa}; \
      bins wstrb_all_zero_one_data_width_128  = {16'h5555}; \
      bins wstrb_all_one_zero_data_width_256  = {32'haaaa_aaaa}; \
      bins wstrb_all_zero_one_data_width_256  = {32'h5555_5555}; \
      bins wstrb_all_one_zero_data_width_512  = {64'haaaa_aaaa_aaaa_aaaa}; \
      bins wstrb_all_zero_one_data_width_512  = {64'h5555_5555_5555_5555}; \
      bins wstrb_all_one_zero_data_width_1024  = {128'haaaa_aaaa_aaaa_aaaa_aaaa_aaaa_aaaa_aaaa}; \
      bins wstrb_all_zero_one_data_width_1024  = {128'h5555_5555_5555_5555_5555_5555_5555_5555}; \
    `else \
      bins wstrb_all_ones_16   = {2'b11}; \
      bins wstrb_all_ones_32   = {4'b1111}; \
      bins wstrb_all_ones_64   = {8'hff}; \
      bins wstrb_all_ones_128  = {16'hffff}; \
      bins wstrb_all_ones_256  = {32'hffff_ffff}; \
      bins wstrb_all_ones_512  = {64'hffff_ffff_ffff_ffff}; \
      bins wstrb_all_ones_1024 = {128'hffff_ffff_ffff_ffff_ffff_ffff_ffff_ffff}; \
      bins wstrb_all_ones_2048 = {256'hffff_ffff_ffff_ffff_ffff_ffff_ffff_ffff_ffff_ffff_ffff_ffff_ffff_ffff_ffff_ffff}; \
      bins wstrb_all_zeroes_16  = {2'b00}; \
      bins wstrb_all_zeroes_32   = {4'b0000}; \
      bins wstrb_all_zeroes_64   = {8'h00}; \
      bins wstrb_all_zeroes_128  = {16'h0000}; \
      bins wstrb_all_zeroes_256  = {32'h0000_0000}; \
      bins wstrb_all_zeroes_512  = {64'h0000_0000_0000_0000}; \
      bins wstrb_all_zeroes_1024 = {128'h0000_0000_0000_0000_0000_0000_0000_0000}; \
      bins wstrb_all_zeroes_2048 = {256'h0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000}; \
      bins wstrb_all_one_zero_data_width_16  = {2'b10}; \
      bins wstrb_all_zero_one_data_width_16  = {2'b01}; \
      bins wstrb_all_one_zero_data_width_32  = {4'ha}; \
      bins wstrb_all_zero_one_data_width_32  = {4'h5}; \
      bins wstrb_all_one_zero_data_width_64  = {8'haa}; \
      bins wstrb_all_zero_one_data_width_64  = {8'h55}; \
      bins wstrb_all_one_zero_data_width_128  = {16'haaaa}; \
      bins wstrb_all_zero_one_data_width_128  = {16'h5555}; \
      bins wstrb_all_one_zero_data_width_256  = {32'haaaa_aaaa}; \
      bins wstrb_all_zero_one_data_width_256  = {32'h5555_5555}; \
      bins wstrb_all_one_zero_data_width_512  = {64'haaaa_aaaa_aaaa_aaaa}; \
      bins wstrb_all_zero_one_data_width_512  = {64'h5555_5555_5555_5555}; \
      bins wstrb_all_one_zero_data_width_1024  = {128'haaaa_aaaa_aaaa_aaaa_aaaa_aaaa_aaaa_aaaa}; \
      bins wstrb_all_zero_one_data_width_1024  = {128'h5555_5555_5555_5555_5555_5555_5555_5555}; \
      bins wstrb_all_one_zero_data_width_2048  = {256'haaaa_aaaa_aaaa_aaaa_aaaa_aaaa_aaaa_aaaa_aaaa_aaaa_aaaa_aaaa_aaaa_aaaa_aaaa_aaaa}; \
      bins wstrb_all_zero_one_data_width_2048  = {256'h5555_5555_5555_5555_5555_5555_5555_5555_5555_5555_5555_5555_5555_5555_5555_5555}; \
    `endif \
      option.weight = 1; \
    }

`else //SVT_AXI_MON_CFG_BASED_COV_GRP_DEF

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_WSTRB_DWLT_32 \
  wstrb :  coverpoint cov_wstrb iff(cov_wstrb_flag){ \
    bins wstrb_all_ones_16   = {2'b11}; \
    bins wstrb_all_zeroes_16  = {2'b00}; \
    bins wstrb_all_one_zero_data_width_16  = {2'b10}; \
    bins wstrb_all_zero_one_data_width_16  = {2'b01}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_WSTRB_DWLT_64 \
  wstrb :  coverpoint cov_wstrb iff(cov_wstrb_flag){ \
    bins wstrb_all_ones_16   = {2'b11}; \
    bins wstrb_all_ones_32   = {4'b1111}; \
    bins wstrb_all_zeroes_16  = {2'b00}; \
    bins wstrb_all_zeroes_32   = {4'b0000}; \
    bins wstrb_all_one_zero_data_width_16  = {2'b10}; \
    bins wstrb_all_zero_one_data_width_16  = {2'b01}; \
    bins wstrb_all_one_zero_data_width_32  = {4'ha}; \
    bins wstrb_all_zero_one_data_width_32  = {4'h5}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_WSTRB_DWLT_128 \
  wstrb :  coverpoint cov_wstrb iff(cov_wstrb_flag){ \
    bins wstrb_all_ones_16   = {2'b11}; \
    bins wstrb_all_ones_32   = {4'b1111}; \
    bins wstrb_all_ones_64   = {8'hff}; \
    bins wstrb_all_zeroes_16  = {2'b00}; \
    bins wstrb_all_zeroes_32   = {4'b0000}; \
    bins wstrb_all_zeroes_64   = {8'h00}; \
    bins wstrb_all_one_zero_data_width_16  = {2'b10}; \
    bins wstrb_all_zero_one_data_width_16  = {2'b01}; \
    bins wstrb_all_one_zero_data_width_32  = {4'ha}; \
    bins wstrb_all_zero_one_data_width_32  = {4'h5}; \
    bins wstrb_all_one_zero_data_width_64  = {8'haa}; \
    bins wstrb_all_zero_one_data_width_64  = {8'h55}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_WSTRB_DWLT_256 \
  wstrb :  coverpoint cov_wstrb iff(cov_wstrb_flag){ \
    bins wstrb_all_ones_16   = {2'b11}; \
    bins wstrb_all_ones_32   = {4'b1111}; \
    bins wstrb_all_ones_64   = {8'hff}; \
    bins wstrb_all_ones_128  = {16'hffff}; \
    bins wstrb_all_zeroes_16  = {2'b00}; \
    bins wstrb_all_zeroes_32   = {4'b0000}; \
    bins wstrb_all_zeroes_64   = {8'h00}; \
    bins wstrb_all_zeroes_128  = {16'h0000}; \
    bins wstrb_all_one_zero_data_width_16  = {2'b10}; \
    bins wstrb_all_zero_one_data_width_16  = {2'b01}; \
    bins wstrb_all_one_zero_data_width_32  = {4'ha}; \
    bins wstrb_all_zero_one_data_width_32  = {4'h5}; \
    bins wstrb_all_one_zero_data_width_64  = {8'haa}; \
    bins wstrb_all_zero_one_data_width_64  = {8'h55}; \
    bins wstrb_all_one_zero_data_width_128  = {16'haaaa}; \
    bins wstrb_all_zero_one_data_width_128  = {16'h5555}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_WSTRB_DWLT_512 \
  wstrb :  coverpoint cov_wstrb iff(cov_wstrb_flag){ \
    bins wstrb_all_ones_16   = {2'b11}; \
    bins wstrb_all_ones_32   = {4'b1111}; \
    bins wstrb_all_ones_64   = {8'hff}; \
    bins wstrb_all_ones_128  = {16'hffff}; \
    bins wstrb_all_ones_256  = {32'hffff_ffff}; \
    bins wstrb_all_zeroes_16  = {2'b00}; \
    bins wstrb_all_zeroes_32   = {4'b0000}; \
    bins wstrb_all_zeroes_64   = {8'h00}; \
    bins wstrb_all_zeroes_128  = {16'h0000}; \
    bins wstrb_all_zeroes_256  = {32'h0000_0000}; \
    bins wstrb_all_one_zero_data_width_16  = {2'b10}; \
    bins wstrb_all_zero_one_data_width_16  = {2'b01}; \
    bins wstrb_all_one_zero_data_width_32  = {4'ha}; \
    bins wstrb_all_zero_one_data_width_32  = {4'h5}; \
    bins wstrb_all_one_zero_data_width_64  = {8'haa}; \
    bins wstrb_all_zero_one_data_width_64  = {8'h55}; \
    bins wstrb_all_one_zero_data_width_128  = {16'haaaa}; \
    bins wstrb_all_zero_one_data_width_128  = {16'h5555}; \
    bins wstrb_all_one_zero_data_width_256  = {32'haaaa_aaaa}; \
    bins wstrb_all_zero_one_data_width_256  = {32'h5555_5555}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_WSTRB_DWLT_1024 \
  wstrb :  coverpoint cov_wstrb iff(cov_wstrb_flag){ \
    bins wstrb_all_ones_16   = {2'b11}; \
    bins wstrb_all_ones_32   = {4'b1111}; \
    bins wstrb_all_ones_64   = {8'hff}; \
    bins wstrb_all_ones_128  = {16'hffff}; \
    bins wstrb_all_ones_256  = {32'hffff_ffff}; \
    bins wstrb_all_ones_512  = {64'hffff_ffff_ffff_ffff}; \
    bins wstrb_all_zeroes_16  = {2'b00}; \
    bins wstrb_all_zeroes_32   = {4'b0000}; \
    bins wstrb_all_zeroes_64   = {8'h00}; \
    bins wstrb_all_zeroes_128  = {16'h0000}; \
    bins wstrb_all_zeroes_256  = {32'h0000_0000}; \
    bins wstrb_all_zeroes_512  = {64'h0000_0000_0000_0000}; \
    bins wstrb_all_one_zero_data_width_16  = {2'b10}; \
    bins wstrb_all_zero_one_data_width_16  = {2'b01}; \
    bins wstrb_all_one_zero_data_width_32  = {4'ha}; \
    bins wstrb_all_zero_one_data_width_32  = {4'h5}; \
    bins wstrb_all_one_zero_data_width_64  = {8'haa}; \
    bins wstrb_all_zero_one_data_width_64  = {8'h55}; \
    bins wstrb_all_one_zero_data_width_128  = {16'haaaa}; \
    bins wstrb_all_zero_one_data_width_128  = {16'h5555}; \
    bins wstrb_all_one_zero_data_width_256  = {32'haaaa_aaaa}; \
    bins wstrb_all_zero_one_data_width_256  = {32'h5555_5555}; \
    bins wstrb_all_one_zero_data_width_512  = {64'haaaa_aaaa_aaaa_aaaa}; \
    bins wstrb_all_zero_one_data_width_512  = {64'h5555_5555_5555_5555}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_WSTRB_DWEQ_1024 \
  wstrb :  coverpoint cov_wstrb iff(cov_wstrb_flag){ \
    bins wstrb_all_ones_16   = {2'b11}; \
    bins wstrb_all_ones_32   = {4'b1111}; \
    bins wstrb_all_ones_64   = {8'hff}; \
    bins wstrb_all_ones_128  = {16'hffff}; \
    bins wstrb_all_ones_256  = {32'hffff_ffff}; \
    bins wstrb_all_ones_512  = {64'hffff_ffff_ffff_ffff}; \
    bins wstrb_all_ones_1024 = {128'hffff_ffff_ffff_ffff_ffff_ffff_ffff_ffff}; \
    bins wstrb_all_zeroes_16  = {2'b00}; \
    bins wstrb_all_zeroes_32   = {4'b0000}; \
    bins wstrb_all_zeroes_64   = {8'h00}; \
    bins wstrb_all_zeroes_128  = {16'h0000}; \
    bins wstrb_all_zeroes_256  = {32'h0000_0000}; \
    bins wstrb_all_zeroes_512  = {64'h0000_0000_0000_0000}; \
    bins wstrb_all_zeroes_1024 = {128'h0000_0000_0000_0000_0000_0000_0000_0000}; \
    bins wstrb_all_one_zero_data_width_16  = {2'b10}; \
    bins wstrb_all_zero_one_data_width_16  = {2'b01}; \
    bins wstrb_all_one_zero_data_width_32  = {4'ha}; \
    bins wstrb_all_zero_one_data_width_32  = {4'h5}; \
    bins wstrb_all_one_zero_data_width_64  = {8'haa}; \
    bins wstrb_all_zero_one_data_width_64  = {8'h55}; \
    bins wstrb_all_one_zero_data_width_128  = {16'haaaa}; \
    bins wstrb_all_zero_one_data_width_128  = {16'h5555}; \
    bins wstrb_all_one_zero_data_width_256  = {32'haaaa_aaaa}; \
    bins wstrb_all_zero_one_data_width_256  = {32'h5555_5555}; \
    bins wstrb_all_one_zero_data_width_512  = {64'haaaa_aaaa_aaaa_aaaa}; \
    bins wstrb_all_zero_one_data_width_512  = {64'h5555_5555_5555_5555}; \
    bins wstrb_all_one_zero_data_width_1024  = {128'haaaa_aaaa_aaaa_aaaa_aaaa_aaaa_aaaa_aaaa}; \
    bins wstrb_all_zero_one_data_width_1024  = {128'h5555_5555_5555_5555_5555_5555_5555_5555}; \
    option.weight = 1; \
  }

`endif //SVT_AXI_MON_CFG_BASED_COV_GRP_DEF
`endif
`ifdef SVT_AXI_GEN_COV_DATA_WIDTH_32_BIT
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_ADDR_OFFSET \
  addr_offset : coverpoint addr_offset_coverpoint iff(cov_addr_flag == 1'b1) { \
    bins offset_0     = {0}; \
    bins offset_1     = {1}; \
    bins offset_2     = {2}; \
    bins offset_3     = {3}; \
    option.weight = 1; \
  }
`else
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_ADDR_OFFSET \
    addr_offset : coverpoint addr_offset_coverpoint iff(cov_addr_flag == 1'b1) { \
    bins offset_0     = {0}; \
    bins offset_1     = {1}; \
    bins offset_2     = {2}; \
    bins offset_3     = {3}; \
    bins offset_4     = {4}; \
    bins offset_5     = {5}; \
    bins offset_6     = {6}; \
    bins offset_7     = {7}; \
    bins offset_8     = {8}; \
    bins offset_9     = {9}; \
    bins offset_a     = {10}; \
    bins offset_b     = {11}; \
    bins offset_c     = {12}; \
    bins offset_d     = {13}; \
    bins offset_e     = {14}; \
    bins offset_f     = {15}; \
    bins offset_10    = {16}; \
    bins offset_11    = {17}; \
    bins offset_12    = {18}; \
    bins offset_13    = {19}; \
    bins offset_14    = {20}; \
    bins offset_15    = {21}; \
    bins offset_16    = {22}; \
    bins offset_17    = {23}; \
    bins offset_18    = {24}; \
    bins offset_19    = {25}; \
    bins offset_1a    = {26}; \
    bins offset_1b    = {27}; \
    bins offset_1c    = {28}; \
    bins offset_1d    = {29}; \
    bins offset_1e    = {30}; \
    bins offset_1f    = {31}; \
    bins offset_20    = {32}; \
    bins offset_21    = {33}; \
    bins offset_22    = {34}; \
    bins offset_23    = {35}; \
    bins offset_24    = {36}; \
    bins offset_25    = {37}; \
    bins offset_26    = {38}; \
    bins offset_27    = {39}; \
    bins offset_28    = {40}; \
    bins offset_29    = {41}; \
    bins offset_2a    = {42}; \
    bins offset_2b    = {43}; \
    bins offset_2c    = {44}; \
    bins offset_2d    = {45}; \
    bins offset_2e    = {46}; \
    bins offset_2f    = {47}; \
    bins offset_30    = {48}; \
    bins offset_31    = {49}; \
    bins offset_32    = {50}; \
    bins offset_33    = {51}; \
    bins offset_34    = {52}; \
    bins offset_35    = {53}; \
    bins offset_36    = {54}; \
    bins offset_37    = {55}; \
    bins offset_38    = {56}; \
    bins offset_39    = {57}; \
    bins offset_3a    = {58}; \
    bins offset_3b    = {59}; \
    bins offset_3c    = {60}; \
    bins offset_3d    = {61}; \
    bins offset_3e    = {62}; \
    bins offset_3f    = {63}; \
    bins offset_40    = {64}; \
    bins offset_41    = {65}; \
    bins offset_42    = {66}; \
    bins offset_43    = {67}; \
    bins offset_44    = {68}; \
    bins offset_45    = {69}; \
    bins offset_46    = {70}; \
    bins offset_47    = {71}; \
    bins offset_48    = {72}; \
    bins offset_49    = {73}; \
    bins offset_4a    = {74}; \
    bins offset_4b    = {75}; \
    bins offset_4c    = {76}; \
    bins offset_4d    = {77}; \
    bins offset_4e    = {78}; \
    bins offset_4f    = {79}; \
    bins offset_50    = {80}; \
    bins offset_51    = {81}; \
    bins offset_52    = {82}; \
    bins offset_53    = {83}; \
    bins offset_54    = {84}; \
    bins offset_55    = {85}; \
    bins offset_56    = {86}; \
    bins offset_57    = {87}; \
    bins offset_58    = {88}; \
    bins offset_59    = {89}; \
    bins offset_5a    = {90}; \
    bins offset_5b    = {91}; \
    bins offset_5c    = {92}; \
    bins offset_5d    = {93}; \
    bins offset_5e    = {94}; \
    bins offset_5f    = {95}; \
    bins offset_60    = {96}; \
    bins offset_61    = {97}; \
    bins offset_62    = {98}; \
    bins offset_63    = {99}; \
    bins offset_64    = {100}; \
    bins offset_65    = {101}; \
    bins offset_66    = {102}; \
    bins offset_67    = {103}; \
    bins offset_68    = {104}; \
    bins offset_69    = {105}; \
    bins offset_6a    = {106}; \
    bins offset_6b    = {107}; \
    bins offset_6c    = {108}; \
    bins offset_6d    = {109}; \
    bins offset_6e    = {110}; \
    bins offset_6f    = {111}; \
    bins offset_70    = {112}; \
    bins offset_71    = {113}; \
    bins offset_72    = {114}; \
    bins offset_73    = {115}; \
    bins offset_74    = {116}; \
    bins offset_75    = {117}; \
    bins offset_76    = {118}; \
    bins offset_77    = {119}; \
    bins offset_78    = {120}; \
    bins offset_79    = {121}; \
    bins offset_7a    = {122}; \
    bins offset_7b    = {123}; \
    bins offset_7c    = {124}; \
    bins offset_7d    = {125}; \
    bins offset_7e    = {126}; \
    bins offset_7f    = {127}; \
    `SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_ADDR_OFFSET_IGNORE_BINS \
    option.weight = 1; \
  }

  `define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_ADDR_OFFSET_IGNORE_BINS \
    `ifdef SVT_AXI_MAX_DATA_WIDTH_32 \
      ignore_bins ignore_bins_4_127_dw32 = {[4:127]}; \
    `elsif SVT_AXI_MAX_DATA_WIDTH_64 \
      ignore_bins ignore_bins_8_127_dw64 = {[8:127]}; \
    `elsif SVT_AXI_MAX_DATA_WIDTH_128 \
      ignore_bins ignore_bins_16_127_dw128 = {[16:127]}; \
    `elsif SVT_AXI_MAX_DATA_WIDTH_256 \
      ignore_bins ignore_bins_32_127_dw256 = {[32:127]}; \
    `elsif SVT_AXI_MAX_DATA_WIDTH_512 \
      ignore_bins ignore_bins_64_127_dw512 = {[64:127]}; \
    `endif 
  `endif

`ifdef SVT_AXI_MON_CFG_BASED_COV_GRP_DEF

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_ADDR_OFFSET_DWEQ_32 \
    addr_offset : coverpoint addr_offset_coverpoint iff(cov_addr_flag == 1'b1) { \
    bins offset_0     = {0}; \
    bins offset_1     = {1}; \
    bins offset_2     = {2}; \
    bins offset_3     = {3}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_ADDR_OFFSET_DWEQ_64 \
    addr_offset : coverpoint addr_offset_coverpoint iff(cov_addr_flag == 1'b1) { \
    bins offset_0     = {0}; \
    bins offset_1     = {1}; \
    bins offset_2     = {2}; \
    bins offset_3     = {3}; \
    bins offset_4     = {4}; \
    bins offset_5     = {5}; \
    bins offset_6     = {6}; \
    bins offset_7     = {7}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_ADDR_OFFSET_DWEQ_128 \
    addr_offset : coverpoint addr_offset_coverpoint iff(cov_addr_flag == 1'b1) { \
    bins offset_0     = {0}; \
    bins offset_1     = {1}; \
    bins offset_2     = {2}; \
    bins offset_3     = {3}; \
    bins offset_4     = {4}; \
    bins offset_5     = {5}; \
    bins offset_6     = {6}; \
    bins offset_7     = {7}; \
    bins offset_8     = {8}; \
    bins offset_9     = {9}; \
    bins offset_a     = {10}; \
    bins offset_b     = {11}; \
    bins offset_c     = {12}; \
    bins offset_d     = {13}; \
    bins offset_e     = {14}; \
    bins offset_f     = {15}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_ADDR_OFFSET_DWEQ_256 \
    addr_offset : coverpoint addr_offset_coverpoint iff(cov_addr_flag == 1'b1) { \
    bins offset_0     = {0}; \
    bins offset_1     = {1}; \
    bins offset_2     = {2}; \
    bins offset_3     = {3}; \
    bins offset_4     = {4}; \
    bins offset_5     = {5}; \
    bins offset_6     = {6}; \
    bins offset_7     = {7}; \
    bins offset_8     = {8}; \
    bins offset_9     = {9}; \
    bins offset_a     = {10}; \
    bins offset_b     = {11}; \
    bins offset_c     = {12}; \
    bins offset_d     = {13}; \
    bins offset_e     = {14}; \
    bins offset_f     = {15}; \
    bins offset_10    = {16}; \
    bins offset_11    = {17}; \
    bins offset_12    = {18}; \
    bins offset_13    = {19}; \
    bins offset_14    = {20}; \
    bins offset_15    = {21}; \
    bins offset_16    = {22}; \
    bins offset_17    = {23}; \
    bins offset_18    = {24}; \
    bins offset_19    = {25}; \
    bins offset_1a    = {26}; \
    bins offset_1b    = {27}; \
    bins offset_1c    = {28}; \
    bins offset_1d    = {29}; \
    bins offset_1e    = {30}; \
    bins offset_1f    = {31}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_ADDR_OFFSET_DWEQ_512 \
    addr_offset : coverpoint addr_offset_coverpoint iff(cov_addr_flag == 1'b1) { \
    bins offset_0     = {0}; \
    bins offset_1     = {1}; \
    bins offset_2     = {2}; \
    bins offset_3     = {3}; \
    bins offset_4     = {4}; \
    bins offset_5     = {5}; \
    bins offset_6     = {6}; \
    bins offset_7     = {7}; \
    bins offset_8     = {8}; \
    bins offset_9     = {9}; \
    bins offset_a     = {10}; \
    bins offset_b     = {11}; \
    bins offset_c     = {12}; \
    bins offset_d     = {13}; \
    bins offset_e     = {14}; \
    bins offset_f     = {15}; \
    bins offset_10    = {16}; \
    bins offset_11    = {17}; \
    bins offset_12    = {18}; \
    bins offset_13    = {19}; \
    bins offset_14    = {20}; \
    bins offset_15    = {21}; \
    bins offset_16    = {22}; \
    bins offset_17    = {23}; \
    bins offset_18    = {24}; \
    bins offset_19    = {25}; \
    bins offset_1a    = {26}; \
    bins offset_1b    = {27}; \
    bins offset_1c    = {28}; \
    bins offset_1d    = {29}; \
    bins offset_1e    = {30}; \
    bins offset_1f    = {31}; \
    bins offset_20    = {32}; \
    bins offset_21    = {33}; \
    bins offset_22    = {34}; \
    bins offset_23    = {35}; \
    bins offset_24    = {36}; \
    bins offset_25    = {37}; \
    bins offset_26    = {38}; \
    bins offset_27    = {39}; \
    bins offset_28    = {40}; \
    bins offset_29    = {41}; \
    bins offset_2a    = {42}; \
    bins offset_2b    = {43}; \
    bins offset_2c    = {44}; \
    bins offset_2d    = {45}; \
    bins offset_2e    = {46}; \
    bins offset_2f    = {47}; \
    bins offset_30    = {48}; \
    bins offset_31    = {49}; \
    bins offset_32    = {50}; \
    bins offset_33    = {51}; \
    bins offset_34    = {52}; \
    bins offset_35    = {53}; \
    bins offset_36    = {54}; \
    bins offset_37    = {55}; \
    bins offset_38    = {56}; \
    bins offset_39    = {57}; \
    bins offset_3a    = {58}; \
    bins offset_3b    = {59}; \
    bins offset_3c    = {60}; \
    bins offset_3d    = {61}; \
    bins offset_3e    = {62}; \
    bins offset_3f    = {63}; \
    option.weight = 1; \
  }
`endif //SVT_AXI_MON_CFG_BASED_COV_GRP_DEF


`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_ACE_SNOOP_ASSOCIATION_IGNORE_BINS \
`ifdef SVT_ACE5_ENABLE \
   ignore_bins ignore_coherent_snoop_not_possible_combinations = ((binsof(coh_xact_from_ace) intersect { \
                                                                   svt_axi_transaction::MAKEINVALID} && \
                                                                 !binsof(snoop_xact_on_ace_master) intersect { \
                                                                    svt_axi_snoop_transaction::MAKEINVALID})  || \
                                                                (binsof(coh_xact_from_ace) intersect { \
                                                                   svt_axi_transaction::READONCE} && \
                                                                 !binsof(snoop_xact_on_ace_master) intersect { \
                                                                    svt_axi_snoop_transaction::READONCE})  || \
                                                                  (binsof(coh_xact_from_ace) intersect { \
                                                                   svt_axi_transaction::CLEANSHARED,svt_axi_transaction::CLEANSHAREDPERSIST} && \
                                                                 !binsof(snoop_xact_on_ace_master) intersect { \
                                                                    svt_axi_snoop_transaction::CLEANSHARED})  || \
                                                                   (binsof(coh_xact_from_ace) intersect { \
                                                                   svt_axi_transaction::CLEANINVALID} && \
                                                                 !binsof(snoop_xact_on_ace_master) intersect { \
                                                                    svt_axi_snoop_transaction::CLEANINVALID})  || \
                                                                   (binsof(coh_xact_from_ace) intersect { \
                                                                   svt_axi_transaction::WRITEUNIQUE} && \
                                                                 !binsof(snoop_xact_on_ace_master) intersect { \
                                                                    svt_axi_snoop_transaction::CLEANINVALID})  || \
                                                                   (binsof(coh_xact_from_ace) intersect { \
                                                                   svt_axi_transaction::WRITELINEUNIQUE} && \
                                                                 !binsof(snoop_xact_on_ace_master) intersect { \
                                                                    svt_axi_snoop_transaction::MAKEINVALID}) || \
                                                                (binsof(coh_xact_from_ace) intersect { \
                                                                   svt_axi_transaction::READSHARED} && \
                                                                 !binsof(snoop_xact_on_ace_master) intersect { \
                                                                    svt_axi_snoop_transaction::READSHARED})  || \
                                                                (binsof(coh_xact_from_ace) intersect { \
                                                                   svt_axi_transaction::READCLEAN} && \
                                                                 !binsof(snoop_xact_on_ace_master) intersect { \
                                                                    svt_axi_snoop_transaction::READCLEAN})  || \
                                                                  (binsof(coh_xact_from_ace) intersect { \
                                                                   svt_axi_transaction::READNOTSHAREDDIRTY} && \
                                                                 !binsof(snoop_xact_on_ace_master) intersect { \
                                                                    svt_axi_snoop_transaction::READNOTSHAREDDIRTY})  || \
                                                                   (binsof(coh_xact_from_ace) intersect { \
                                                                   svt_axi_transaction::READUNIQUE} && \
                                                                 !binsof(snoop_xact_on_ace_master) intersect { \
                                                                    svt_axi_snoop_transaction::READUNIQUE})  || \
                                                                   (binsof(coh_xact_from_ace) intersect { \
                                                                   svt_axi_transaction::MAKEUNIQUE} && \
                                                                 !binsof(snoop_xact_on_ace_master) intersect { \
                                                                    svt_axi_snoop_transaction::MAKEINVALID})  || \
                                                                   (binsof(coh_xact_from_ace) intersect { \
                                                                   svt_axi_transaction::CLEANUNIQUE} && \
                                                                 !binsof(snoop_xact_on_ace_master) intersect { \
                                                                    svt_axi_snoop_transaction::CLEANINVALID})); \
`else \
   ignore_bins ignore_coherent_snoop_not_possible_combinations = ((binsof(coh_xact_from_ace) intersect { \
                                                                   svt_axi_transaction::MAKEINVALID} && \
                                                                 !binsof(snoop_xact_on_ace_master) intersect { \
                                                                    svt_axi_snoop_transaction::MAKEINVALID})  || \
                                                                (binsof(coh_xact_from_ace) intersect { \
                                                                   svt_axi_transaction::READONCE} && \
                                                                 !binsof(snoop_xact_on_ace_master) intersect { \
                                                                    svt_axi_snoop_transaction::READONCE})  || \
                                                                  (binsof(coh_xact_from_ace) intersect { \
                                                                   svt_axi_transaction::CLEANSHARED} && \
                                                                 !binsof(snoop_xact_on_ace_master) intersect { \
                                                                    svt_axi_snoop_transaction::CLEANSHARED})  || \
                                                                   (binsof(coh_xact_from_ace) intersect { \
                                                                   svt_axi_transaction::CLEANINVALID} && \
                                                                 !binsof(snoop_xact_on_ace_master) intersect { \
                                                                    svt_axi_snoop_transaction::CLEANINVALID})  || \
                                                                   (binsof(coh_xact_from_ace) intersect { \
                                                                   svt_axi_transaction::WRITEUNIQUE} && \
                                                                 !binsof(snoop_xact_on_ace_master) intersect { \
                                                                    svt_axi_snoop_transaction::CLEANINVALID})  || \
                                                                   (binsof(coh_xact_from_ace) intersect { \
                                                                   svt_axi_transaction::WRITELINEUNIQUE} && \
                                                                 !binsof(snoop_xact_on_ace_master) intersect { \
                                                                    svt_axi_snoop_transaction::MAKEINVALID}) || \
                                                                (binsof(coh_xact_from_ace) intersect { \
                                                                   svt_axi_transaction::READSHARED} && \
                                                                 !binsof(snoop_xact_on_ace_master) intersect { \
                                                                    svt_axi_snoop_transaction::READSHARED})  || \
                                                                (binsof(coh_xact_from_ace) intersect { \
                                                                   svt_axi_transaction::READCLEAN} && \
                                                                 !binsof(snoop_xact_on_ace_master) intersect { \
                                                                    svt_axi_snoop_transaction::READCLEAN})  || \
                                                                  (binsof(coh_xact_from_ace) intersect { \
                                                                   svt_axi_transaction::READNOTSHAREDDIRTY} && \
                                                                 !binsof(snoop_xact_on_ace_master) intersect { \
                                                                    svt_axi_snoop_transaction::READNOTSHAREDDIRTY})  || \
                                                                   (binsof(coh_xact_from_ace) intersect { \
                                                                   svt_axi_transaction::READUNIQUE} && \
                                                                 !binsof(snoop_xact_on_ace_master) intersect { \
                                                                    svt_axi_snoop_transaction::READUNIQUE})  || \
                                                                   (binsof(coh_xact_from_ace) intersect { \
                                                                   svt_axi_transaction::MAKEUNIQUE} && \
                                                                 !binsof(snoop_xact_on_ace_master) intersect { \
                                                                    svt_axi_snoop_transaction::MAKEINVALID})  || \
                                                                   (binsof(coh_xact_from_ace) intersect { \
                                                                   svt_axi_transaction::CLEANUNIQUE} && \
                                                                 !binsof(snoop_xact_on_ace_master) intersect { \
                                                                    svt_axi_snoop_transaction::CLEANINVALID})); \
`endif \
  ignore_bins ignore_invalid_crresp_ud_sc_sd = binsof(coh_xact_from_ace) intersect { \
                                                   svt_axi_transaction::MAKEINVALID ,svt_axi_transaction::WRITELINEUNIQUE} && \
                                                 !binsof(snoop_crresp_from_ace) intersect { \
                                                   4'b0000 }; \
   ignore_bins ignore_invalid_makeinvalid_crresp_ud_sc_sd = binsof(snoop_xact_on_ace_master) intersect { \
                                                   svt_axi_snoop_transaction::MAKEINVALID} && \
                                                 !binsof(snoop_crresp_from_ace) intersect { \
                                                   4'b0000}; \
  ignore_bins Ignore_invalid_rresp_ud_sc_sd = binsof(coh_xact_from_ace) intersect { \
                                                   svt_axi_transaction::WRITEUNIQUE , svt_axi_transaction::CLEANINVALID} && \
                                                 !binsof(snoop_crresp_from_ace) intersect { \
                                                   4'b0000,4'b0101 }; \
  ignore_bins Ignore_invalid_cleaninvalid_rresp_ud_sc_sd = binsof(snoop_xact_on_ace_master) intersect { \
                                                   svt_axi_snoop_transaction::CLEANINVALID} && \
                                                 !binsof(snoop_crresp_from_ace) intersect { \
                                                   4'b0000,4'b0101 }; \
`ifdef SVT_ACE5_ENABLE \
  ignore_bins ignore_invalid_crresp_cleanshared   = binsof(coh_xact_from_ace) intersect { \
                                                       svt_axi_transaction::CLEANSHARED,svt_axi_transaction::CLEANSHAREDPERSIST} && \
                                                       binsof(snoop_crresp_from_ace) intersect { \
                                                       4'b1001,4'b0001}; \
`else \
  ignore_bins ignore_invalid_crresp_cleanshared   = binsof(coh_xact_from_ace) intersect { \
                                                       svt_axi_transaction::CLEANSHARED} && \
                                                       binsof(snoop_crresp_from_ace) intersect { \
                                                       4'b1001,4'b0001}; \
`endif \
  ignore_bins Ignore_invalid_crresp_readonce   = binsof(coh_xact_from_ace) intersect { \
                                                     svt_axi_transaction::READONCE} && \
                                                     binsof(snoop_crresp_from_ace) intersect { \
                                                      4'b1000}; \
  ignore_bins ignore_data_transfer_start_cache_state =  binsof(snoop_crresp_from_ace) intersect {4'b0001,4'b0101,4'b1101,4'b1001} && binsof(ace_init_cache_state) intersect {svt_axi_snoop_transaction::INVALID}; \
  ignore_bins ignore_is_shared_end_cache_state =  binsof(snoop_crresp_from_ace) intersect { \
                                                         4'b1000,4'b1101,4'b1001} && binsof(ace_final_cache_state) intersect {svt_axi_snoop_transaction::INVALID}; \
  ignore_bins ignore_pass_dirty_start_cache_state =  binsof(snoop_crresp_from_ace) intersect { \
                                                         4'b0101,4'b1101} && binsof(ace_init_cache_state) intersect {svt_axi_snoop_transaction::INVALID,svt_axi_snoop_transaction::SHAREDCLEAN,svt_axi_snoop_transaction::UNIQUECLEAN}; \
`ifdef SVT_ACE5_ENABLE \
  ignore_bins ignore_cleanshared_crresp = binsof(coh_xact_from_ace) intersect {svt_axi_transaction::CLEANSHARED,svt_axi_transaction::CLEANSHAREDPERSIST,svt_axi_transaction::READONCE} && binsof(snoop_crresp_from_ace) intersect {4'b1000,4'b1001,4'b1101} && binsof (ace_final_cache_state) intersect {svt_axi_snoop_transaction::INVALID}; \
`else \
  ignore_bins ignore_cleanshared_crresp = binsof(coh_xact_from_ace) intersect {svt_axi_transaction::CLEANSHARED,svt_axi_transaction::READONCE} && binsof(snoop_crresp_from_ace) intersect {4'b1000,4'b1001,4'b1101} && binsof (ace_final_cache_state) intersect {svt_axi_snoop_transaction::INVALID}; \
`endif \
  ignore_bins ignore_wasunique = !binsof(ace_init_cache_state)intersect {svt_axi_snoop_transaction::UNIQUECLEAN,svt_axi_snoop_transaction::UNIQUEDIRTY} && binsof (snoop_crresp_wu) intersect {1} ; \
  ignore_bins Ignore_readonce_states = (((binsof(coh_xact_from_ace) intersect \
                                                    {svt_axi_transaction::READONCE}) && \
                                               (binsof(ace_init_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::INVALID}) &&  \
                                               (!binsof(ace_final_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::INVALID})) ||  \
                                                ((binsof(coh_xact_from_ace) intersect \
                                                    {svt_axi_transaction::READONCE}) && \
                                               (binsof(ace_init_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::UNIQUECLEAN}) && \
                                                (!binsof(ace_final_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::INVALID,svt_axi_snoop_transaction::UNIQUECLEAN,svt_axi_snoop_transaction::SHAREDCLEAN})) || \
                                                ((binsof(coh_xact_from_ace) intersect \
                                                    {svt_axi_transaction::READONCE}) && \
                                               (binsof(ace_init_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::SHAREDCLEAN}) && \
                                               (!binsof(ace_final_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::INVALID,svt_axi_snoop_transaction::SHAREDCLEAN})) || \
                                               ((binsof(coh_xact_from_ace) intersect \
                                                    {svt_axi_transaction::READONCE}) && \
                                               (binsof(ace_init_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::SHAREDDIRTY}) && \
                                               (!binsof(ace_final_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::INVALID,svt_axi_snoop_transaction::SHAREDDIRTY,svt_axi_snoop_transaction::SHAREDCLEAN}))) ; \
`ifdef SVT_ACE5_ENABLE \
  ignore_bins Ignore_cleanshared_states = ((binsof(coh_xact_from_ace) intersect \
                                                    {svt_axi_transaction::CLEANSHARED,svt_axi_transaction::CLEANSHAREDPERSIST}) && \
                                               (binsof(ace_init_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::INVALID}) && \
                                               (!binsof(ace_final_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::INVALID})) || \
                                               ((binsof(coh_xact_from_ace) intersect \
                                                    {svt_axi_transaction::CLEANSHARED,svt_axi_transaction::CLEANSHAREDPERSIST}) && \
                                               (binsof(ace_init_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::UNIQUECLEAN}) && \
                                               (binsof(ace_final_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::UNIQUEDIRTY,svt_axi_snoop_transaction::SHAREDDIRTY})) || \
                                               ((binsof(coh_xact_from_ace) intersect \
                                                    {svt_axi_transaction::CLEANSHARED,svt_axi_transaction::CLEANSHAREDPERSIST}) && \
                                               (binsof(ace_init_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::SHAREDCLEAN,svt_axi_snoop_transaction::SHAREDDIRTY,svt_axi_snoop_transaction::UNIQUEDIRTY}) && \
                                               (!binsof(ace_final_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::INVALID,svt_axi_snoop_transaction::SHAREDCLEAN})); \
`else \
 ignore_bins Ignore_cleanshared_states = ((binsof(coh_xact_from_ace) intersect \
                                                    {svt_axi_transaction::CLEANSHARED}) && \
                                               (binsof(ace_init_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::INVALID}) && \
                                               (!binsof(ace_final_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::INVALID})) || \
                                               ((binsof(coh_xact_from_ace) intersect \
                                                    {svt_axi_transaction::CLEANSHARED}) && \
                                               (binsof(ace_init_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::UNIQUECLEAN}) && \
                                               (binsof(ace_final_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::UNIQUEDIRTY,svt_axi_snoop_transaction::SHAREDDIRTY})) || \
                                               ((binsof(coh_xact_from_ace) intersect \
                                                    {svt_axi_transaction::CLEANSHARED}) && \
                                               (binsof(ace_init_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::SHAREDCLEAN,svt_axi_snoop_transaction::SHAREDDIRTY,svt_axi_snoop_transaction::UNIQUEDIRTY}) && \
                                               (!binsof(ace_final_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::INVALID,svt_axi_snoop_transaction::SHAREDCLEAN})); \
`endif \
    ignore_bins Ignore_readshared_readclean_states = ((binsof(coh_xact_from_ace) intersect \
                                                    {svt_axi_transaction::READSHARED,svt_axi_transaction::READCLEAN,svt_axi_transaction::READNOTSHAREDDIRTY}) && \
                                               (binsof(ace_init_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::INVALID}) && \
                                               (!binsof(ace_final_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::INVALID})) || \
                                               ((binsof(coh_xact_from_ace) intersect \
                                                    {svt_axi_transaction::READSHARED,svt_axi_transaction::READCLEAN,svt_axi_transaction::READNOTSHAREDDIRTY}) && \
                                               (binsof(ace_init_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::UNIQUECLEAN,svt_axi_snoop_transaction::SHAREDCLEAN}) && \
                                               (!binsof(ace_final_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::INVALID,svt_axi_snoop_transaction::SHAREDCLEAN})) || \
                                               ((binsof(coh_xact_from_ace) intersect \
                                                    {svt_axi_transaction::READSHARED,svt_axi_transaction::READCLEAN,svt_axi_transaction::READNOTSHAREDDIRTY}) && \
                                               (binsof(ace_init_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::SHAREDDIRTY,svt_axi_snoop_transaction::UNIQUEDIRTY}) && \
                                               (!binsof(ace_final_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::INVALID,svt_axi_snoop_transaction::SHAREDCLEAN,svt_axi_snoop_transaction::SHAREDDIRTY})); \
  ignore_bins Ignore_cleaninvalid_states_ignore_readunique_states = ((binsof(coh_xact_from_ace) intersect \
                                                    {svt_axi_transaction::CLEANINVALID,svt_axi_transaction::READUNIQUE}) && \
                                               (!binsof(ace_final_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::INVALID})) || \
                                                   ((binsof(snoop_xact_on_ace_master) intersect \
                                                    {svt_axi_snoop_transaction::CLEANINVALID}) && \
                                               (!binsof(ace_final_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::INVALID})); \
  ignore_bins Ignore_makeinvalid_states = ((binsof(coh_xact_from_ace) intersect \
                                                    {svt_axi_transaction::MAKEINVALID}) && \
                                               (!binsof(ace_final_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::INVALID})) ||  \
                                           ((binsof(snoop_xact_on_ace_master) intersect \
                                                    {svt_axi_snoop_transaction::MAKEINVALID}) && \
                                               (!binsof(ace_final_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::INVALID})); \
  ignore_bins Ignore_writeuniqueorline_states = ((binsof(coh_xact_from_ace) intersect \
                                                    {svt_axi_transaction::WRITEUNIQUE, \
                                                    svt_axi_transaction::WRITELINEUNIQUE}) && \
                                                   (!binsof(ace_final_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::INVALID})); \
`ifdef SVT_ACE5_ENABLE \
  ignore_bins ignore_readonce_cleanshared_init_ud_state = binsof (coh_xact_from_ace)intersect {svt_axi_transaction::READONCE,svt_axi_transaction::CLEANSHARED,svt_axi_transaction::CLEANSHAREDPERSIST}&& binsof(ace_init_cache_state) intersect{svt_axi_snoop_transaction::UNIQUEDIRTY,svt_axi_snoop_transaction::SHAREDDIRTY}&&binsof(snoop_crresp_from_ace) intersect{4'b0000,4'b0001} ||  binsof(coh_xact_from_ace)intersect {svt_axi_transaction::READONCE,svt_axi_transaction::CLEANSHARED,svt_axi_transaction::CLEANSHAREDPERSIST}&& !binsof(ace_final_cache_state) intersect{svt_axi_snoop_transaction::INVALID}&&binsof(snoop_crresp_from_ace) intersect{4'b0000,4'b0001}; \
`else \
  ignore_bins ignore_readonce_cleanshared_init_ud_state = binsof (coh_xact_from_ace)intersect {svt_axi_transaction::READONCE,svt_axi_transaction::CLEANSHARED}&& binsof(ace_init_cache_state) intersect{svt_axi_snoop_transaction::UNIQUEDIRTY,svt_axi_snoop_transaction::SHAREDDIRTY}&&binsof(snoop_crresp_from_ace) intersect{4'b0000,4'b0001} ||  binsof(coh_xact_from_ace)intersect {svt_axi_transaction::READONCE,svt_axi_transaction::CLEANSHARED}&& !binsof(ace_final_cache_state) intersect{svt_axi_snoop_transaction::INVALID}&&binsof(snoop_crresp_from_ace) intersect{4'b0000,4'b0001}; \
`endif \
  ignore_bins ignore_readonce_final_sc_state = binsof (coh_xact_from_ace)intersect {svt_axi_transaction::READONCE}&& !binsof(ace_final_cache_state) intersect{svt_axi_snoop_transaction::SHAREDCLEAN}&&binsof(snoop_crresp_from_ace) intersect{4'b1101} ; \
`ifdef SVT_ACE5_ENABLE \
  ignore_bins ignore_readonce_01_state = binsof (coh_xact_from_ace)intersect {svt_axi_transaction::READONCE,svt_axi_transaction::CLEANSHARED,svt_axi_transaction::CLEANSHAREDPERSIST}&& !binsof(ace_final_cache_state) intersect{svt_axi_snoop_transaction::INVALID}&&binsof(snoop_crresp_from_ace) intersect{4'b0101} ; \
`else \
  ignore_bins ignore_readonce_01_state = binsof (coh_xact_from_ace)intersect {svt_axi_transaction::READONCE,svt_axi_transaction::CLEANSHARED}&& !binsof(ace_final_cache_state) intersect{svt_axi_snoop_transaction::INVALID}&&binsof(snoop_crresp_from_ace) intersect{4'b0101} ; \
`endif \
  ignore_bins ignore_readonce_final_10_state = binsof (coh_xact_from_ace)intersect {svt_axi_transaction::READONCE}&& !binsof(ace_final_cache_state) intersect{svt_axi_snoop_transaction::SHAREDDIRTY}&&binsof(snoop_crresp_from_ace) intersect{4'b1000,4'b1001} &&binsof (ace_init_cache_state) intersect {svt_axi_snoop_transaction::SHAREDDIRTY}; \
  ignore_bins ignore_readonce_final_sc_10_state = binsof (coh_xact_from_ace)intersect {svt_axi_transaction::READONCE}&& !binsof(ace_final_cache_state) intersect{svt_axi_snoop_transaction::SHAREDDIRTY,svt_axi_snoop_transaction::UNIQUEDIRTY}&&binsof(snoop_crresp_from_ace) intersect{4'b1000,4'b1001} &&binsof (ace_init_cache_state) intersect {svt_axi_snoop_transaction::UNIQUEDIRTY}; \
`ifdef SVT_ACE5_ENABLE \
  ignore_bins ignore_cleanshared_init_sd_ud_state = binsof (coh_xact_from_ace)intersect {svt_axi_transaction::CLEANSHARED,svt_axi_transaction::CLEANSHAREDPERSIST}&& binsof(snoop_crresp_from_ace) intersect{4'b1000,4'b1001} && !binsof (ace_init_cache_state) intersect {svt_axi_snoop_transaction::SHAREDCLEAN,svt_axi_snoop_transaction::UNIQUECLEAN}; \
`else \
 ignore_bins ignore_cleanshared_init_sd_ud_state = binsof (coh_xact_from_ace)intersect {svt_axi_transaction::CLEANSHARED}&& binsof(snoop_crresp_from_ace) intersect{4'b1000,4'b1001} && !binsof (ace_init_cache_state) intersect {svt_axi_snoop_transaction::SHAREDCLEAN,svt_axi_snoop_transaction::UNIQUECLEAN}; \
`endif \
  ignore_bins ignore_cleaninvalid_writeunique_init_state = binsof(snoop_xact_on_ace_master)intersect {svt_axi_snoop_transaction::CLEANINVALID}&&binsof(ace_init_cache_state) intersect {svt_axi_snoop_transaction::UNIQUEDIRTY, svt_axi_snoop_transaction::SHAREDDIRTY} && binsof(snoop_crresp_from_ace) intersect {4'b0000,4'b0001}; \
 ignore_bins ignore_readshared_illegal_combinations_invalid = binsof(snoop_xact_on_ace_master)intersect {svt_axi_snoop_transaction::READSHARED,svt_axi_snoop_transaction::READCLEAN,svt_axi_snoop_transaction::READNOTSHAREDDIRTY}&&binsof(ace_init_cache_state) intersect {svt_axi_snoop_transaction::INVALID} &&binsof(ace_final_cache_state)intersect{svt_axi_snoop_transaction::INVALID} && !binsof(snoop_crresp_from_ace) intersect {4'b0000,4'b0001}; \
  ignore_bins ignore_readshared_illegal_combinations_uniqueclean = binsof(snoop_xact_on_ace_master)intersect {svt_axi_snoop_transaction::READSHARED,svt_axi_snoop_transaction::READCLEAN,svt_axi_snoop_transaction::READNOTSHAREDDIRTY}&&binsof(ace_init_cache_state) intersect {svt_axi_snoop_transaction::UNIQUECLEAN,svt_axi_snoop_transaction::SHAREDCLEAN} &&binsof(ace_final_cache_state)intersect{svt_axi_snoop_transaction::INVALID,svt_axi_snoop_transaction::SHAREDCLEAN} && !binsof(snoop_crresp_from_ace) intersect {4'b0000,4'b0001,4'b0101}; \
 ignore_bins ignore_readshared_illegal_combinations_uniquedirty = binsof(snoop_xact_on_ace_master)intersect {svt_axi_snoop_transaction::READSHARED,svt_axi_snoop_transaction::READCLEAN,svt_axi_snoop_transaction::READNOTSHAREDDIRTY}&&binsof(ace_init_cache_state) intersect {svt_axi_snoop_transaction::UNIQUEDIRTY,svt_axi_snoop_transaction::SHAREDDIRTY} &&binsof(ace_final_cache_state)intersect{svt_axi_snoop_transaction::INVALID,svt_axi_snoop_transaction::SHAREDCLEAN,svt_axi_snoop_transaction::SHAREDDIRTY} && binsof(snoop_crresp_from_ace) intersect {4'b0000,4'b0001}; \
 option.weight = 1; \

 `define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_SNOOP_ASSOCIATION_IGNORE_BINS \
  ignore_bins ignore_invalid_crresp_ud_sc_sd = binsof(coh_xact_from_ace_lite) intersect { \
                                                   svt_axi_transaction::MAKEINVALID ,svt_axi_transaction::WRITELINEUNIQUE} && \
                                                 !binsof(snoop_crresp_from_ace) intersect { \
                                                   4'b0000 }; \
   ignore_bins Ignore_invalid_rresp_ud_sc_sd = binsof(coh_xact_from_ace_lite) intersect { \
                                                   svt_axi_transaction::WRITEUNIQUE , svt_axi_transaction::CLEANINVALID} && \
                                                 !binsof(snoop_crresp_from_ace) intersect { \
                                                   4'b0000,4'b0101 }; \
`ifdef SVT_ACE5_ENABLE \
  ignore_bins ignore_invalid_crresp_cleanshared   = binsof(coh_xact_from_ace_lite) intersect { \
                                                       svt_axi_transaction::CLEANSHARED,svt_axi_transaction::CLEANSHAREDPERSIST} && \
                                                       binsof(snoop_crresp_from_ace) intersect { \
                                                       4'b1001,4'b0001}; \
`else \
  ignore_bins ignore_invalid_crresp_cleanshared   = binsof(coh_xact_from_ace_lite) intersect { \
                                                       svt_axi_transaction::CLEANSHARED} && \
                                                       binsof(snoop_crresp_from_ace) intersect { \
                                                       4'b1001,4'b0001}; \
`endif \
  ignore_bins Ignore_invalid_crresp_readonce   = binsof(coh_xact_from_ace_lite) intersect { \
                                                     svt_axi_transaction::READONCE} && \
                                                     binsof(snoop_crresp_from_ace) intersect { \
                                                      4'b1000}; \
  ignore_bins ignore_data_transfer_start_cache_state =  binsof(snoop_crresp_from_ace) intersect {4'b0001,4'b0101,4'b1101,4'b1001} && binsof(ace_init_cache_state) intersect {svt_axi_snoop_transaction::INVALID}; \
  ignore_bins ignore_is_shared_end_cache_state =  binsof(snoop_crresp_from_ace) intersect { \
                                                         4'b1000,4'b1101,4'b1001} && binsof(ace_final_cache_state) intersect {svt_axi_snoop_transaction::INVALID}; \
  ignore_bins ignore_pass_dirty_start_cache_state =  binsof(snoop_crresp_from_ace) intersect { \
                                                         4'b0101,4'b1101} && binsof(ace_init_cache_state) intersect {svt_axi_snoop_transaction::INVALID,svt_axi_snoop_transaction::SHAREDCLEAN,svt_axi_snoop_transaction::UNIQUECLEAN}; \
`ifdef SVT_ACE5_ENABLE \
   ignore_bins ignore_cleanshared_crresp = binsof(coh_xact_from_ace_lite) intersect {svt_axi_transaction::CLEANSHARED,svt_axi_transaction::READONCE,svt_axi_transaction::CLEANSHAREDPERSIST} && binsof(snoop_crresp_from_ace) intersect {4'b1000,4'b1001,4'b1101} && binsof (ace_final_cache_state) intersect {svt_axi_snoop_transaction::INVALID}; \
`else \
 ignore_bins ignore_cleanshared_crresp = binsof(coh_xact_from_ace_lite) intersect {svt_axi_transaction::CLEANSHARED,svt_axi_transaction::READONCE} && binsof(snoop_crresp_from_ace) intersect {4'b1000,4'b1001,4'b1101} && binsof (ace_final_cache_state) intersect {svt_axi_snoop_transaction::INVALID}; \
`endif \
  ignore_bins ignore_wasunique = !binsof(ace_init_cache_state)intersect {svt_axi_snoop_transaction::UNIQUECLEAN,svt_axi_snoop_transaction::UNIQUEDIRTY} && binsof (snoop_crresp_wu) intersect {1} ; \
  ignore_bins Ignore_readonce_states = (((binsof(coh_xact_from_ace_lite) intersect \
                                                    {svt_axi_transaction::READONCE}) && \
                                               (binsof(ace_init_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::INVALID}) &&  \
                                               (!binsof(ace_final_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::INVALID})) ||  \
                                                ((binsof(coh_xact_from_ace_lite) intersect \
                                                    {svt_axi_transaction::READONCE}) && \
                                               (binsof(ace_init_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::UNIQUECLEAN}) && \
                                                (!binsof(ace_final_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::INVALID,svt_axi_snoop_transaction::UNIQUECLEAN,svt_axi_snoop_transaction::SHAREDCLEAN})) || \
                                                ((binsof(coh_xact_from_ace_lite) intersect \
                                                    {svt_axi_transaction::READONCE}) && \
                                               (binsof(ace_init_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::SHAREDCLEAN}) && \
                                               (!binsof(ace_final_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::INVALID,svt_axi_snoop_transaction::SHAREDCLEAN})) || \
                                               ((binsof(coh_xact_from_ace_lite) intersect \
                                                    {svt_axi_transaction::READONCE}) && \
                                               (binsof(ace_init_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::SHAREDDIRTY}) && \
                                               (!binsof(ace_final_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::INVALID,svt_axi_snoop_transaction::SHAREDDIRTY,svt_axi_snoop_transaction::SHAREDCLEAN}))) ; \
`ifdef ENABLE_ACE_COVBERAGE \
  ignore_bins Ignore_cleanshared_states = ((binsof(coh_xact_from_ace_lite) intersect \
                                                    {svt_axi_transaction::CLEANSHARED,svt_axi_transaction::CLEANSHAREDPERSIST}) && \
                                               (binsof(ace_init_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::INVALID}) && \
                                               (!binsof(ace_final_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::INVALID})) || \
                                               ((binsof(coh_xact_from_ace_lite) intersect \
                                                    {svt_axi_transaction::CLEANSHARED,svt_axi_transaction::CLEANSHAREDPERSIST}) && \
                                               (binsof(ace_init_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::UNIQUECLEAN}) && \
                                               (binsof(ace_final_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::UNIQUEDIRTY,svt_axi_snoop_transaction::SHAREDDIRTY})) || \
                                               ((binsof(coh_xact_from_ace_lite) intersect \
                                                    {svt_axi_transaction::CLEANSHARED,svt_axi_transaction::CLEANSHAREDPERSIST}) && \
                                               (binsof(ace_init_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::SHAREDCLEAN,svt_axi_snoop_transaction::SHAREDDIRTY,svt_axi_snoop_transaction::UNIQUEDIRTY}) && \
                                               (!binsof(ace_final_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::INVALID,svt_axi_snoop_transaction::SHAREDCLEAN})); \
`else \
  ignore_bins Ignore_cleanshared_states = ((binsof(coh_xact_from_ace_lite) intersect \
                                                    {svt_axi_transaction::CLEANSHARED}) && \
                                               (binsof(ace_init_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::INVALID}) && \
                                               (!binsof(ace_final_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::INVALID})) || \
                                               ((binsof(coh_xact_from_ace_lite) intersect \
                                                    {svt_axi_transaction::CLEANSHARED}) && \
                                               (binsof(ace_init_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::UNIQUECLEAN}) && \
                                               (binsof(ace_final_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::UNIQUEDIRTY,svt_axi_snoop_transaction::SHAREDDIRTY})) || \
                                               ((binsof(coh_xact_from_ace_lite) intersect \
                                                    {svt_axi_transaction::CLEANSHARED}) && \
                                               (binsof(ace_init_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::SHAREDCLEAN,svt_axi_snoop_transaction::SHAREDDIRTY,svt_axi_snoop_transaction::UNIQUEDIRTY}) && \
                                               (!binsof(ace_final_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::INVALID,svt_axi_snoop_transaction::SHAREDCLEAN})); \
`endif \
  ignore_bins Ignore_cleaninvalid_states = ((binsof(coh_xact_from_ace_lite) intersect \
                                                    {svt_axi_transaction::CLEANINVALID}) && \
                                               (!binsof(ace_final_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::INVALID})) ; \
  ignore_bins Ignore_makeinvalid_states = ((binsof(coh_xact_from_ace_lite) intersect \
                                                    {svt_axi_transaction::MAKEINVALID}) && \
                                               (!binsof(ace_final_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::INVALID})) ; \
  ignore_bins Ignore_writeuniqueorline_states = ((binsof(coh_xact_from_ace_lite) intersect \
                                                    {svt_axi_transaction::WRITEUNIQUE, \
                                                    svt_axi_transaction::WRITELINEUNIQUE}) && \
                                                   (!binsof(ace_final_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::INVALID})); \
`ifdef SVT_ACE5_ENABLE \
  ignore_bins ignore_readonce_cleanshared_init_ud_state = binsof (coh_xact_from_ace_lite)intersect {svt_axi_transaction::READONCE,svt_axi_transaction::CLEANSHARED,svt_axi_transaction::CLEANSHAREDPERSIST}&& binsof(ace_init_cache_state) intersect{svt_axi_snoop_transaction::UNIQUEDIRTY,svt_axi_snoop_transaction::SHAREDDIRTY}&&binsof(snoop_crresp_from_ace) intersect{4'b0000,4'b0001} ||  binsof(coh_xact_from_ace_lite)intersect {svt_axi_transaction::READONCE,svt_axi_transaction::CLEANSHARED,svt_axi_transaction::CLEANSHAREDPERSIST}&& !binsof(ace_final_cache_state) intersect{svt_axi_snoop_transaction::INVALID}&&binsof(snoop_crresp_from_ace) intersect{4'b0000,4'b0001}; \
`else \
  ignore_bins ignore_readonce_cleanshared_init_ud_state = binsof (coh_xact_from_ace_lite)intersect {svt_axi_transaction::READONCE,svt_axi_transaction::CLEANSHARED}&& binsof(ace_init_cache_state) intersect{svt_axi_snoop_transaction::UNIQUEDIRTY,svt_axi_snoop_transaction::SHAREDDIRTY}&&binsof(snoop_crresp_from_ace) intersect{4'b0000,4'b0001} ||  binsof(coh_xact_from_ace_lite)intersect {svt_axi_transaction::READONCE,svt_axi_transaction::CLEANSHARED}&& !binsof(ace_final_cache_state) intersect{svt_axi_snoop_transaction::INVALID}&&binsof(snoop_crresp_from_ace) intersect{4'b0000,4'b0001}; \
`endif \
  ignore_bins ignore_readonce_final_sc_state = binsof (coh_xact_from_ace_lite)intersect {svt_axi_transaction::READONCE}&& !binsof(ace_final_cache_state) intersect{svt_axi_snoop_transaction::SHAREDCLEAN}&&binsof(snoop_crresp_from_ace) intersect{4'b1101} ; \
`ifdef SVT_ACE5_ENABLE \
  ignore_bins ignore_readonce_01_state = binsof (coh_xact_from_ace_lite)intersect {svt_axi_transaction::READONCE,svt_axi_transaction::CLEANSHARED,svt_axi_transaction::CLEANSHAREDPERSIST}&& !binsof(ace_final_cache_state) intersect{svt_axi_snoop_transaction::INVALID}&&binsof(snoop_crresp_from_ace) intersect{4'b0101} ; \
`else \
  ignore_bins ignore_readonce_01_state = binsof (coh_xact_from_ace_lite)intersect {svt_axi_transaction::READONCE,svt_axi_transaction::CLEANSHARED}&& !binsof(ace_final_cache_state) intersect{svt_axi_snoop_transaction::INVALID}&&binsof(snoop_crresp_from_ace) intersect{4'b0101} ; \
`endif \
  ignore_bins ignore_readonce_final_10_state = binsof (coh_xact_from_ace_lite)intersect {svt_axi_transaction::READONCE}&& !binsof(ace_final_cache_state) intersect{svt_axi_snoop_transaction::SHAREDDIRTY}&&binsof(snoop_crresp_from_ace) intersect{4'b1000,4'b1001} &&binsof (ace_init_cache_state) intersect {svt_axi_snoop_transaction::SHAREDDIRTY}; \
  ignore_bins ignore_readonce_final_sc_10_state = binsof (coh_xact_from_ace_lite)intersect {svt_axi_transaction::READONCE}&& !binsof(ace_final_cache_state) intersect{svt_axi_snoop_transaction::SHAREDDIRTY,svt_axi_snoop_transaction::UNIQUEDIRTY}&&binsof(snoop_crresp_from_ace) intersect{4'b1000,4'b1001} &&binsof (ace_init_cache_state) intersect {svt_axi_snoop_transaction::UNIQUEDIRTY}; \
`ifdef SVT_ACE5_ENABLE \
  ignore_bins ignore_cleanshared_init_sd_ud_state = binsof (coh_xact_from_ace_lite)intersect {svt_axi_transaction::CLEANSHARED,svt_axi_transaction::CLEANSHAREDPERSIST}&& binsof(snoop_crresp_from_ace) intersect{4'b1000,4'b1001} && !binsof (ace_init_cache_state) intersect {svt_axi_snoop_transaction::SHAREDCLEAN,svt_axi_snoop_transaction::UNIQUECLEAN}; \
`else \
  ignore_bins ignore_cleanshared_init_sd_ud_state = binsof (coh_xact_from_ace_lite)intersect {svt_axi_transaction::CLEANSHARED}&& binsof(snoop_crresp_from_ace) intersect{4'b1000,4'b1001} && !binsof (ace_init_cache_state) intersect {svt_axi_snoop_transaction::SHAREDCLEAN,svt_axi_snoop_transaction::UNIQUECLEAN}; \
`endif \
  ignore_bins ignore_cleaninvalid_writeunique_init_state = binsof(coh_xact_from_ace_lite)intersect {svt_axi_transaction::CLEANINVALID,svt_axi_transaction::WRITEUNIQUE}&&binsof(ace_init_cache_state) intersect {svt_axi_snoop_transaction::UNIQUEDIRTY, svt_axi_snoop_transaction::SHAREDDIRTY} && binsof(snoop_crresp_from_ace) intersect {4'b0000,4'b0001}; \
  option.weight = 1; \

 `define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_ACELITE_SNOOP_ASSOCIATION_IGNORE_BINS \
  ignore_bins ignore_invalid_crresp_ud_sc_sd = binsof(coh_xact_from_ace_lite) intersect { \
                                                   svt_axi_transaction::MAKEINVALID ,svt_axi_transaction::WRITELINEUNIQUE} && \
                                                 !binsof(snoop_crresp_from_ace) intersect { \
                                                   4'b0000 }; \
`ifdef SVT_ACE5_ENABLE \
  ignore_bins ignore_coherent_snoop_not_possible_combinations = (binsof(coh_xact_from_ace_lite) intersect { \
                                                                   svt_axi_transaction::MAKEINVALID} && \
                                                                 !binsof(associate_snoop_xact_for_coh_xact_from_acelite_master) intersect { \
                                                                    svt_axi_snoop_transaction::MAKEINVALID}) || \
                                                                (binsof(coh_xact_from_ace_lite) intersect { \
                                                                   svt_axi_transaction::READONCE} && \
                                                                 !binsof(associate_snoop_xact_for_coh_xact_from_acelite_master) intersect { \
                                                                    svt_axi_snoop_transaction::READONCE})  || \
                                                                  (binsof(coh_xact_from_ace_lite) intersect { \
                                                                   svt_axi_transaction::CLEANSHARED,svt_axi_transaction::CLEANSHAREDPERSIST} && \
                                                                 !binsof(associate_snoop_xact_for_coh_xact_from_acelite_master) intersect { \
                                                                    svt_axi_snoop_transaction::CLEANSHARED})  || \
                                                                   (binsof(coh_xact_from_ace_lite) intersect { \
                                                                   svt_axi_transaction::CLEANINVALID} && \
                                                                 !binsof(associate_snoop_xact_for_coh_xact_from_acelite_master) intersect { \
                                                                    svt_axi_snoop_transaction::CLEANINVALID})  || \
                                                                   (binsof(coh_xact_from_ace_lite) intersect { \
                                                                   svt_axi_transaction::WRITEUNIQUE} && \
                                                                 !binsof(associate_snoop_xact_for_coh_xact_from_acelite_master) intersect { \
                                                                    svt_axi_snoop_transaction::CLEANINVALID})  || \
                                                                   (binsof(coh_xact_from_ace_lite) intersect { \
                                                                   svt_axi_transaction::WRITELINEUNIQUE} && \
                                                                 !binsof(associate_snoop_xact_for_coh_xact_from_acelite_master) intersect { \
                                                                    svt_axi_snoop_transaction::MAKEINVALID}); \
  ignore_bins ignore_invalid_crresp_cleanshared   = binsof(coh_xact_from_ace_lite) intersect { \
                                                       svt_axi_transaction::CLEANSHARED,svt_axi_transaction::CLEANSHAREDPERSIST} && \
                                                       binsof(snoop_crresp_from_ace) intersect { \
                                                       4'b1001,4'b0001}; \
  ignore_bins ignore_cleanshared_crresp = binsof(coh_xact_from_ace_lite) intersect {svt_axi_transaction::CLEANSHARED,svt_axi_transaction::READONCE,svt_axi_transaction::CLEANSHAREDPERSIST} && binsof(snoop_crresp_from_ace) intersect {4'b1000,4'b1001,4'b1101} && binsof (ace_final_cache_state) intersect {svt_axi_snoop_transaction::INVALID}; \
 ignore_bins Ignore_cleanshared_states = ((binsof(coh_xact_from_ace_lite) intersect \
                                                    {svt_axi_transaction::CLEANSHARED,svt_axi_transaction::CLEANSHAREDPERSIST}) && \
                                               (binsof(ace_init_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::INVALID}) && \
                                               (!binsof(ace_final_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::INVALID})) || \
                                               ((binsof(coh_xact_from_ace_lite) intersect \
                                                    {svt_axi_transaction::CLEANSHARED,svt_axi_transaction::CLEANSHAREDPERSIST}) && \
                                               (binsof(ace_init_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::UNIQUECLEAN}) && \
                                               (binsof(ace_final_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::UNIQUEDIRTY,svt_axi_snoop_transaction::SHAREDDIRTY})) || \
                                               ((binsof(coh_xact_from_ace_lite) intersect \
                                                    {svt_axi_transaction::CLEANSHARED,svt_axi_transaction::CLEANSHAREDPERSIST}) && \
                                               (binsof(ace_init_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::SHAREDCLEAN,svt_axi_snoop_transaction::SHAREDDIRTY,svt_axi_snoop_transaction::UNIQUEDIRTY}) && \
                                               (!binsof(ace_final_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::INVALID,svt_axi_snoop_transaction::SHAREDCLEAN})); \
 ignore_bins ignore_readonce_cleanshared_init_ud_state = binsof (coh_xact_from_ace_lite)intersect {svt_axi_transaction::READONCE,svt_axi_transaction::CLEANSHARED,svt_axi_transaction::CLEANSHAREDPERSIST}&& binsof(ace_init_cache_state) intersect{svt_axi_snoop_transaction::UNIQUEDIRTY,svt_axi_snoop_transaction::SHAREDDIRTY}&&binsof(snoop_crresp_from_ace) intersect{4'b0000,4'b0001} ||  binsof(coh_xact_from_ace_lite)intersect {svt_axi_transaction::READONCE,svt_axi_transaction::CLEANSHARED,svt_axi_transaction::CLEANSHAREDPERSIST}&& !binsof(ace_final_cache_state) intersect{svt_axi_snoop_transaction::INVALID}&&binsof(snoop_crresp_from_ace) intersect{4'b0000,4'b0001}; \
  ignore_bins ignore_readonce_01_state = binsof (coh_xact_from_ace_lite)intersect {svt_axi_transaction::READONCE,svt_axi_transaction::CLEANSHARED,svt_axi_transaction::CLEANSHAREDPERSIST}&& !binsof(ace_final_cache_state) intersect{svt_axi_snoop_transaction::INVALID}&&binsof(snoop_crresp_from_ace) intersect{4'b0101} ; \
  ignore_bins ignore_cleanshared_init_sd_ud_state = binsof (coh_xact_from_ace_lite)intersect {svt_axi_transaction::CLEANSHARED,svt_axi_transaction::CLEANSHAREDPERSIST}&& binsof(snoop_crresp_from_ace) intersect{4'b1000,4'b1001} && !binsof (ace_init_cache_state) intersect {svt_axi_snoop_transaction::SHAREDCLEAN,svt_axi_snoop_transaction::UNIQUECLEAN}; \
`else \
   ignore_bins ignore_coherent_snoop_not_possible_combinations = (binsof(coh_xact_from_ace_lite) intersect { \
                                                                   svt_axi_transaction::MAKEINVALID} && \
                                                                 !binsof(associate_snoop_xact_for_coh_xact_from_acelite_master) intersect { \
                                                                    svt_axi_snoop_transaction::MAKEINVALID}) || \
                                                                (binsof(coh_xact_from_ace_lite) intersect { \
                                                                   svt_axi_transaction::READONCE} && \
                                                                 !binsof(associate_snoop_xact_for_coh_xact_from_acelite_master) intersect { \
                                                                    svt_axi_snoop_transaction::READONCE})  || \
                                                                  (binsof(coh_xact_from_ace_lite) intersect { \
                                                                   svt_axi_transaction::CLEANSHARED} && \
                                                                 !binsof(associate_snoop_xact_for_coh_xact_from_acelite_master) intersect { \
                                                                    svt_axi_snoop_transaction::CLEANSHARED})  || \
                                                                   (binsof(coh_xact_from_ace_lite) intersect { \
                                                                   svt_axi_transaction::CLEANINVALID} && \
                                                                 !binsof(associate_snoop_xact_for_coh_xact_from_acelite_master) intersect { \
                                                                    svt_axi_snoop_transaction::CLEANINVALID})  || \
                                                                   (binsof(coh_xact_from_ace_lite) intersect { \
                                                                   svt_axi_transaction::WRITEUNIQUE} && \
                                                                 !binsof(associate_snoop_xact_for_coh_xact_from_acelite_master) intersect { \
                                                                    svt_axi_snoop_transaction::CLEANINVALID})  || \
                                                                   (binsof(coh_xact_from_ace_lite) intersect { \
                                                                   svt_axi_transaction::WRITELINEUNIQUE} && \
                                                                 !binsof(associate_snoop_xact_for_coh_xact_from_acelite_master) intersect { \
                                                                    svt_axi_snoop_transaction::MAKEINVALID}); \
  ignore_bins ignore_invalid_crresp_cleanshared   = binsof(coh_xact_from_ace_lite) intersect { \
                                                       svt_axi_transaction::CLEANSHARED} && \
                                                       binsof(snoop_crresp_from_ace) intersect { \
                                                       4'b1001,4'b0001}; \
  ignore_bins ignore_cleanshared_crresp = binsof(coh_xact_from_ace_lite) intersect {svt_axi_transaction::CLEANSHARED,svt_axi_transaction::READONCE} && binsof(snoop_crresp_from_ace) intersect {4'b1000,4'b1001,4'b1101} && binsof (ace_final_cache_state) intersect {svt_axi_snoop_transaction::INVALID}; \
 ignore_bins Ignore_cleanshared_states = ((binsof(coh_xact_from_ace_lite) intersect \
                                                    {svt_axi_transaction::CLEANSHARED}) && \
                                               (binsof(ace_init_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::INVALID}) && \
                                               (!binsof(ace_final_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::INVALID})) || \
                                               ((binsof(coh_xact_from_ace_lite) intersect \
                                                    {svt_axi_transaction::CLEANSHARED}) && \
                                               (binsof(ace_init_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::UNIQUECLEAN}) && \
                                               (binsof(ace_final_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::UNIQUEDIRTY,svt_axi_snoop_transaction::SHAREDDIRTY})) || \
                                               ((binsof(coh_xact_from_ace_lite) intersect \
                                                    {svt_axi_transaction::CLEANSHARED}) && \
                                               (binsof(ace_init_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::SHAREDCLEAN,svt_axi_snoop_transaction::SHAREDDIRTY,svt_axi_snoop_transaction::UNIQUEDIRTY}) && \
                                               (!binsof(ace_final_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::INVALID,svt_axi_snoop_transaction::SHAREDCLEAN})); \
 ignore_bins ignore_readonce_cleanshared_init_ud_state = binsof (coh_xact_from_ace_lite)intersect {svt_axi_transaction::READONCE,svt_axi_transaction::CLEANSHARED}&& binsof(ace_init_cache_state) intersect{svt_axi_snoop_transaction::UNIQUEDIRTY,svt_axi_snoop_transaction::SHAREDDIRTY}&&binsof(snoop_crresp_from_ace) intersect{4'b0000,4'b0001} ||  binsof(coh_xact_from_ace_lite)intersect {svt_axi_transaction::READONCE,svt_axi_transaction::CLEANSHARED}&& !binsof(ace_final_cache_state) intersect{svt_axi_snoop_transaction::INVALID}&&binsof(snoop_crresp_from_ace) intersect{4'b0000,4'b0001}; \
  ignore_bins ignore_readonce_01_state = binsof (coh_xact_from_ace_lite)intersect {svt_axi_transaction::READONCE,svt_axi_transaction::CLEANSHARED}&& !binsof(ace_final_cache_state) intersect{svt_axi_snoop_transaction::INVALID}&&binsof(snoop_crresp_from_ace) intersect{4'b0101} ; \
  ignore_bins ignore_cleanshared_init_sd_ud_state = binsof (coh_xact_from_ace_lite)intersect {svt_axi_transaction::CLEANSHARED}&& binsof(snoop_crresp_from_ace) intersect{4'b1000,4'b1001} && !binsof (ace_init_cache_state) intersect {svt_axi_snoop_transaction::SHAREDCLEAN,svt_axi_snoop_transaction::UNIQUECLEAN}; \
`endif \
   ignore_bins Ignore_invalid_rresp_ud_sc_sd = binsof(coh_xact_from_ace_lite) intersect { \
                                                   svt_axi_transaction::WRITEUNIQUE , svt_axi_transaction::CLEANINVALID} && \
                                                 !binsof(snoop_crresp_from_ace) intersect { \
                                                   4'b0000,4'b0101 }; \
  ignore_bins Ignore_invalid_crresp_readonce   = binsof(coh_xact_from_ace_lite) intersect { \
                                                     svt_axi_transaction::READONCE} && \
                                                     binsof(snoop_crresp_from_ace) intersect { \
                                                      4'b1000}; \
  ignore_bins ignore_data_transfer_start_cache_state =  binsof(snoop_crresp_from_ace) intersect {4'b0001,4'b0101,4'b1101,4'b1001} && binsof(ace_init_cache_state) intersect {svt_axi_snoop_transaction::INVALID}; \
  ignore_bins ignore_is_shared_end_cache_state =  binsof(snoop_crresp_from_ace) intersect { \
                                                         4'b1000,4'b1101,4'b1001} && binsof(ace_final_cache_state) intersect {svt_axi_snoop_transaction::INVALID}; \
  ignore_bins ignore_pass_dirty_start_cache_state =  binsof(snoop_crresp_from_ace) intersect { \
                                                         4'b0101,4'b1101} && binsof(ace_init_cache_state) intersect {svt_axi_snoop_transaction::INVALID,svt_axi_snoop_transaction::SHAREDCLEAN,svt_axi_snoop_transaction::UNIQUECLEAN}; \
  ignore_bins ignore_wasunique = !binsof(ace_init_cache_state)intersect {svt_axi_snoop_transaction::UNIQUECLEAN,svt_axi_snoop_transaction::UNIQUEDIRTY} && binsof (snoop_crresp_wu) intersect {1} ; \
  ignore_bins Ignore_readonce_states = (((binsof(coh_xact_from_ace_lite) intersect \
                                                    {svt_axi_transaction::READONCE}) && \
                                               (binsof(ace_init_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::INVALID}) &&  \
                                               (!binsof(ace_final_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::INVALID})) ||  \
                                                ((binsof(coh_xact_from_ace_lite) intersect \
                                                    {svt_axi_transaction::READONCE}) && \
                                               (binsof(ace_init_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::UNIQUECLEAN}) && \
                                                (!binsof(ace_final_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::INVALID,svt_axi_snoop_transaction::UNIQUECLEAN,svt_axi_snoop_transaction::SHAREDCLEAN})) || \
                                                ((binsof(coh_xact_from_ace_lite) intersect \
                                                    {svt_axi_transaction::READONCE}) && \
                                               (binsof(ace_init_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::SHAREDCLEAN}) && \
                                               (!binsof(ace_final_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::INVALID,svt_axi_snoop_transaction::SHAREDCLEAN})) || \
                                               ((binsof(coh_xact_from_ace_lite) intersect \
                                                    {svt_axi_transaction::READONCE}) && \
                                               (binsof(ace_init_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::SHAREDDIRTY}) && \
                                               (!binsof(ace_final_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::INVALID,svt_axi_snoop_transaction::SHAREDDIRTY,svt_axi_snoop_transaction::SHAREDCLEAN}))) ; \
   ignore_bins Ignore_cleaninvalid_states = ((binsof(coh_xact_from_ace_lite) intersect \
                                                    {svt_axi_transaction::CLEANINVALID}) && \
                                               (!binsof(ace_final_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::INVALID})) ; \
  ignore_bins Ignore_makeinvalid_states = ((binsof(coh_xact_from_ace_lite) intersect \
                                                    {svt_axi_transaction::MAKEINVALID}) && \
                                               (!binsof(ace_final_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::INVALID})) ; \
  ignore_bins Ignore_writeuniqueorline_states = ((binsof(coh_xact_from_ace_lite) intersect \
                                                    {svt_axi_transaction::WRITEUNIQUE, \
                                                    svt_axi_transaction::WRITELINEUNIQUE}) && \
                                                   (!binsof(ace_final_cache_state) intersect \
                                                    {svt_axi_snoop_transaction::INVALID})); \
   ignore_bins ignore_readonce_final_sc_state = binsof (coh_xact_from_ace_lite)intersect {svt_axi_transaction::READONCE}&& !binsof(ace_final_cache_state) intersect{svt_axi_snoop_transaction::SHAREDCLEAN}&&binsof(snoop_crresp_from_ace) intersect{4'b1101} ; \
  ignore_bins ignore_readonce_final_10_state = binsof (coh_xact_from_ace_lite)intersect {svt_axi_transaction::READONCE}&& !binsof(ace_final_cache_state) intersect{svt_axi_snoop_transaction::SHAREDDIRTY}&&binsof(snoop_crresp_from_ace) intersect{4'b1000,4'b1001} &&binsof (ace_init_cache_state) intersect {svt_axi_snoop_transaction::SHAREDDIRTY}; \
  ignore_bins ignore_readonce_final_sc_10_state = binsof (coh_xact_from_ace_lite)intersect {svt_axi_transaction::READONCE}&& !binsof(ace_final_cache_state) intersect{svt_axi_snoop_transaction::SHAREDDIRTY,svt_axi_snoop_transaction::UNIQUEDIRTY}&&binsof(snoop_crresp_from_ace) intersect{4'b1000,4'b1001} &&binsof (ace_init_cache_state) intersect {svt_axi_snoop_transaction::UNIQUEDIRTY}; \
  ignore_bins ignore_cleaninvalid_writeunique_init_state = binsof(coh_xact_from_ace_lite)intersect {svt_axi_transaction::CLEANINVALID,svt_axi_transaction::WRITEUNIQUE}&&binsof(ace_init_cache_state) intersect {svt_axi_snoop_transaction::UNIQUEDIRTY, svt_axi_snoop_transaction::SHAREDDIRTY} && binsof(snoop_crresp_from_ace) intersect {4'b0000,4'b0001}; \
  option.weight = 1; 

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_OFFSET_0_TO_F_IGNORE_BINS \
  `ifndef SVT_AXI_GEN_COV_DATA_WIDTH_32_BIT \
  ignore_bins Ig_sz1B_dw32_addr_3_0 = (((binsof(addr_offset) intersect {[2:3]})) && binsof(transfer_size.xfer_size_1byte)) iff(cfg.data_width < 32); \
  ignore_bins Ig_sz2B_dw32_addr_3_0   = (((binsof(addr_offset) intersect {[1:2]})) && binsof(transfer_size.xfer_size_2byte)) iff(cfg.data_width < 32); \
  ignore_bins Ig_sz1B_dw64_addr_3_0   = (((binsof(addr_offset) intersect {[4:7]})) && binsof(transfer_size.xfer_size_1byte)) iff(cfg.data_width < 64); \
  ignore_bins Ig_sz1B_dw128_addr_3_0   = (((binsof(addr_offset) intersect {[8:'hf]}))  && binsof(transfer_size.xfer_size_1byte)) iff(cfg.data_width < 128); \
 \
  ignore_bins Ig_sz2B_dw64_addr_3_0  = (((binsof(addr_offset) intersect {[3:6]})) && binsof(transfer_size.xfer_size_2byte)) iff(cfg.data_width < 64); \
  ignore_bins Ig_sz2B_dw128_addr_3_0   = (((binsof(addr_offset) intersect {[7:'he]})) && binsof(transfer_size.xfer_size_2byte)) iff(cfg.data_width < 128); \
  ignore_bins Ig_sz2B_dw256_addr_3_0  = (binsof(addr_offset.offset_f) && binsof(transfer_size.xfer_size_2byte)) iff(cfg.data_width < 256); \
 \
  ignore_bins Ig_sz4B_dw64_addr_3_0   = (((binsof(addr_offset) intersect {[1:4]})) && binsof(transfer_size.xfer_size_4byte)) iff(cfg.data_width < 64); \
  ignore_bins Ig_sz4B_dw128_addr_3_0   = (((binsof(addr_offset) intersect {[5:'hc]})) && binsof(transfer_size.xfer_size_4byte)) iff(cfg.data_width < 128); \
  ignore_bins Ig_sz4B_dw256_addr_3_0   = (((binsof(addr_offset) intersect {['hd:'hf]})) && binsof(transfer_size.xfer_size_4byte)) iff(cfg.data_width < 256); \
 \
  ignore_bins Ig_sz8B_dw128_addr_3_0   =  (((binsof(addr_offset) intersect {[1:8]})) && binsof(transfer_size.xfer_size_8byte)) iff(cfg.data_width < 128); \
  ignore_bins Ig_sz8B_dw256_addr_3_0   =  (((binsof(addr_offset) intersect {[9:'hf]})) && binsof(transfer_size.xfer_size_8byte)) iff(cfg.data_width < 256); \
 \
  ignore_bins Ig_sz16B_dw256_addr_3_0   =  (((binsof(addr_offset) intersect {[1:'hf]})) && binsof(transfer_size.xfer_size_16byte)) iff(cfg.data_width < 256); \
 \
  ignore_bins Ig_sz32B_dw512_addr_3_0   =  (((binsof(addr_offset) intersect {[1:'hf]})) && binsof(transfer_size.xfer_size_32byte)) iff(cfg.data_width < 512); \
 \
  ignore_bins Ig_sz64B_dw1024_addr_3_0   =  (((binsof(addr_offset) intersect {[1:'hf]})) && binsof(transfer_size.xfer_size_64byte)) iff(cfg.data_width < 1024); \
`endif
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_OFFSET_10_TO_1F_IGNORE_BINS \
  `ifndef SVT_AXI_GEN_COV_DATA_WIDTH_32_BIT \
  ignore_bins Ig_sz1B_dw256_addr_7_0   =  (((binsof(addr_offset) intersect {['h10:'h1f]})) && binsof(transfer_size.xfer_size_1byte)) iff(cfg.data_width < 256); \
 \
  ignore_bins Ig_sz2B_dw256_addr_7_0  =  (((binsof(addr_offset) intersect {['h10:'h1e]})) && binsof(transfer_size.xfer_size_2byte)) iff(cfg.data_width < 256); \
 \
  ignore_bins Ig_sz2B_dw512_addr_7_0  = (binsof(addr_offset.offset_1f) && binsof(transfer_size.xfer_size_2byte)) iff(cfg.data_width < 512); \
 \
  ignore_bins Ig_sz4B_dw256_addr_7_0  =  (((binsof(addr_offset) intersect {['h10:'h1c]})) && binsof(transfer_size.xfer_size_4byte)) iff(cfg.data_width < 256); \
  ignore_bins Ig_sz4B_dw512_addr_7_0  =  (((binsof(addr_offset) intersect {['h1d:'h1f]})) && binsof(transfer_size.xfer_size_4byte)) iff(cfg.data_width < 512); \
 \
  ignore_bins Ig_sz8B_dw256_addr_7_0  =  (((binsof(addr_offset) intersect {['h10:'h18]})) && binsof(transfer_size.xfer_size_8byte)) iff(cfg.data_width < 256); \
  ignore_bins Ig_sz8B_dw512_addr_7_0  =  (((binsof(addr_offset) intersect {['h19:'h1f]})) && binsof(transfer_size.xfer_size_8byte)) iff(cfg.data_width < 512); \
 \
  ignore_bins Ig_sz16B_dw256_addr_7_0  =  (binsof(addr_offset.offset_10) && binsof(transfer_size.xfer_size_16byte)) iff(cfg.data_width < 256); \
  ignore_bins Ig_sz16B_dw512_addr_7_0  =  (((binsof(addr_offset) intersect {['h11:'h1f]})) && binsof(transfer_size.xfer_size_16byte)) iff(cfg.data_width < 512); \
 \
  ignore_bins Ig_sz32B_dw512_addr_7_0  =  (((binsof(addr_offset) intersect {['h10:'h1f]})) && binsof(transfer_size.xfer_size_32byte)) iff(cfg.data_width < 512); \
 \
  ignore_bins Ig_sz64B_dw1024_addr_7_0  =  (((binsof(addr_offset) intersect {['h10:'h1f]})) && binsof(transfer_size.xfer_size_64byte)) iff(cfg.data_width < 1024); \
  `endif

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_OFFSET_20_TO_2F_IGNORE_BINS \
  `ifndef SVT_AXI_GEN_COV_DATA_WIDTH_32_BIT \
  ignore_bins Ig_size_dw512_addr_7_0  =  (((binsof(addr_offset) intersect {['h20:'h2f]})) && (binsof(transfer_size.xfer_size_1byte) || binsof(transfer_size.xfer_size_2byte) || binsof(transfer_size.xfer_size_4byte) || binsof(transfer_size.xfer_size_8byte) || binsof(transfer_size.xfer_size_16byte))) iff(cfg.data_width < 512); \
  ignore_bins Ig_sz32B_dw512_addr_7_0_ext  = (binsof(addr_offset.offset_20) && binsof(transfer_size.xfer_size_32byte)) iff(cfg.data_width < 512); \
 \
  ignore_bins Ig_size_dw1024_addr_7_0  =  (((binsof(addr_offset) intersect {['h21:'h2f]})) && (binsof(transfer_size.xfer_size_32byte))) iff(cfg.data_width < 1024); \
 \
  ignore_bins Ig_sz64B_dw1024_addr_7_0_ext1 =  (((binsof(addr_offset) intersect {['h20:'h2f]})) && binsof(transfer_size.xfer_size_64byte)) iff(cfg.data_width < 1024); \
  `endif
    
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_OFFSET_30_TO_3F_IGNORE_BINS \
  `ifndef SVT_AXI_GEN_COV_DATA_WIDTH_32_BIT \
  ignore_bins Ig_sz1B_dw512_addr_7_0  =  (((binsof(addr_offset) intersect {['h30:'h3f]})) && binsof(transfer_size.xfer_size_1byte)) iff(cfg.data_width < 512); \
 \
  ignore_bins Ig_sz2B_dw512_addr_7_0_ext1  =  (((binsof(addr_offset) intersect {['h30:'h3e]})) && binsof(transfer_size.xfer_size_2byte)) iff(cfg.data_width < 512); \
  ignore_bins Ig_sz2B_dw1024_addr_7_0  =  (binsof(addr_offset.offset_3f) && binsof(transfer_size.xfer_size_2byte)) iff(cfg.data_width < 1024); \
 \
  ignore_bins Ig_sz4B_dw512_addr_7_0_ext1 =  (((binsof(addr_offset) intersect {['h30:'h3c]})) && binsof(transfer_size.xfer_size_4byte)) iff(cfg.data_width < 512); \
  ignore_bins Ig_sz4B_dw1024_addr_7_0  = (((binsof(addr_offset) intersect {['h3d:'h3f]})) && binsof(transfer_size.xfer_size_4byte)) iff(cfg.data_width < 1024); \
 \
  ignore_bins Ig_sz8B_dw512_addr_7_0_ext1  =  (((binsof(addr_offset) intersect {['h30:'h38]})) && binsof(transfer_size.xfer_size_8byte)) iff(cfg.data_width < 512); \
  ignore_bins Ig_sz8B_dw1024_addr_7_0  =  (((binsof(addr_offset) intersect {['h39:'h3f]})) && binsof(transfer_size.xfer_size_8byte)) iff(cfg.data_width < 1024); \
 \
  ignore_bins Ig_sz16B_dw512_addr_7_0_ext1 = (binsof(addr_offset.offset_30) && binsof(transfer_size.xfer_size_16byte)) iff(cfg.data_width < 512); \
  ignore_bins Ig_sz16B_dw1024_addr_7_0  =  (((binsof(addr_offset) intersect {['h31:'h3f]})) && binsof(transfer_size.xfer_size_16byte)) iff(cfg.data_width < 1024); \
 \
  ignore_bins Ig_size_dw1024_addr_7_0_ext0  =  (((binsof(addr_offset) intersect {['h30:'h3f]})) && (binsof(transfer_size.xfer_size_32byte) || binsof(transfer_size.xfer_size_64byte))) iff(cfg.data_width < 1024);\
  `endif

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_OFFSET_40_TO_4F_IGNORE_BINS \
  `ifndef SVT_AXI_GEN_COV_DATA_WIDTH_32_BIT \
  ignore_bins Ig_szsize_with_dw1024_addr_7_0_ext1 =  (((binsof(addr_offset) intersect {['h40:'h4f]})) && (binsof(transfer_size.xfer_size_1byte) || binsof(transfer_size.xfer_size_2byte) || binsof(transfer_size.xfer_size_4byte) || binsof(transfer_size.xfer_size_8byte) || binsof(transfer_size.xfer_size_16byte) || binsof(transfer_size.xfer_size_32byte))) iff(cfg.data_width < 1024); \
 \
  ignore_bins Ig_sz64B_dw1024_addr_7_0_ext2 =  (binsof(addr_offset.offset_40) && binsof(transfer_size.xfer_size_64byte)) iff(cfg.data_width < 1024); \
`endif
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_OFFSET_50_TO_5F_IGNORE_BINS \
  `ifndef SVT_AXI_GEN_COV_DATA_WIDTH_32_BIT \
  ignore_bins Ig_szsize_with_dw1024_addr_7_0_ext2 =  (((binsof(addr_offset) intersect {['h50:'h5f]})) && (binsof(transfer_size.xfer_size_1byte) || binsof(transfer_size.xfer_size_2byte) || binsof(transfer_size.xfer_size_4byte) || binsof(transfer_size.xfer_size_8byte) || binsof(transfer_size.xfer_size_16byte) || binsof(transfer_size.xfer_size_32byte))) iff(cfg.data_width < 1024); \
`endif
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_OFFSET_60_TO_6F_IGNORE_BINS \
  `ifndef SVT_AXI_GEN_COV_DATA_WIDTH_32_BIT \
  ignore_bins Ig_szsize_with_dw1024_addr_7_0_ext3 =  (((binsof(addr_offset) intersect {['h60:'h6f]})) && (binsof(transfer_size.xfer_size_1byte) || binsof(transfer_size.xfer_size_2byte) || binsof(transfer_size.xfer_size_4byte) || binsof(transfer_size.xfer_size_8byte) || binsof(transfer_size.xfer_size_16byte))) iff(cfg.data_width < 1024); \
 \
  ignore_bins Ig_sz32B_dw1024_addr_7_0_ext2 =  (binsof(addr_offset.offset_60) && binsof(transfer_size.xfer_size_32byte)) iff(cfg.data_width < 1024); \
`endif

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_OFFSET_70_TO_7F_IGNORE_BINS \
  `ifndef SVT_AXI_GEN_COV_DATA_WIDTH_32_BIT \
  ignore_bins Ig_sz1B_dw1024_addr_7_0 =  (((binsof(addr_offset) intersect {['h70:'h7f]})) && binsof(transfer_size.xfer_size_1byte)) iff(cfg.data_width < 1024); \
 \
  ignore_bins Ig_sz2B_dw1024_addr_7_0_ext1 =  (((binsof(addr_offset) intersect {['h70:'h7e]})) && binsof(transfer_size.xfer_size_2byte)) iff(cfg.data_width < 1024); \
 \
  ignore_bins Ig_sz4B_dw1024_addr_7_0_ext1 =  (((binsof(addr_offset) intersect {['h70:'h7c]})) && binsof(transfer_size.xfer_size_4byte)) iff(cfg.data_width < 1024); \
 \
  ignore_bins Ig_sz8B_dw1024_addr_7_0_ext1 =  (((binsof(addr_offset) intersect {['h70:'h78]})) && binsof(transfer_size.xfer_size_8byte)) iff(cfg.data_width < 1024); \
 \
  ignore_bins Ig_sz16B_dw1024_addr_7_0_ext1 =  (binsof(addr_offset.offset_70) && binsof(transfer_size.xfer_size_16byte)) iff(cfg.data_width < 1024); \
  `endif

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_COMMON_IGNORE_BINS \
  `ifndef SVT_AXI_GEN_COV_DATA_WIDTH_32_BIT \
  ignore_bins Ignore_4byte_size =  (((!binsof(addr_offset) intersect {[0:'h7c]}))  && binsof(transfer_size.xfer_size_4byte)); \
 \
  ignore_bins Ignore_2byte_size =  (((!binsof(addr_offset) intersect {[0:'h7e]}))  && binsof(transfer_size.xfer_size_2byte)); \
  \
  ignore_bins Ignore_128byte_size =  (((!binsof(addr_offset.offset_0)))  && binsof(transfer_size.xfer_size_128byte)); \
 \
  ignore_bins Ignore_64byte_size =  (((!binsof(addr_offset) intersect {[0:'h40]}))  && binsof(transfer_size.xfer_size_64byte)); \
 \
  ignore_bins Ignore_32byte_size =  (((!binsof(addr_offset) intersect {[0:'h60]}))  && binsof(transfer_size.xfer_size_32byte)); \
 \
  ignore_bins Ignore_16byte_size =  (((!binsof(addr_offset) intersect {[0:'h70]}))  && binsof(transfer_size.xfer_size_16byte)); \
 \
  ignore_bins Ignore_8byte_size =  (((!binsof(addr_offset) intersect {[0:'h78]}))  && binsof(transfer_size.xfer_size_8byte)); \
 `endif

`ifndef SVT_AXI_GEN_COV_DATA_WIDTH_32_BIT
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_IGNORE_INVALID_UNALIGNED_TRANSFER_CROSS \
  ignore_bins ignore_unsupported_burst_type = binsof(burst_type) intersect {svt_axi_transaction::FIXED,svt_axi_transaction::WRAP}; \
 \
  ignore_bins ignore_aligned_addr_offset_0  = binsof(addr_offset) intersect {0}; \
 \
  ignore_bins ignore_addr_offset_2_3     = binsof(addr_offset) intersect {2,3} iff(cfg.data_width < 32); \
  ignore_bins ignore_addr_offset_4_7     = binsof(addr_offset) intersect {[4:7]} iff(cfg.data_width < 64); \
  ignore_bins ignore_addr_offset_8_f     = binsof(addr_offset) intersect {[8:'hf]} iff(cfg.data_width < 128); \
  ignore_bins ignore_addr_offset_10_1f   = binsof(addr_offset) intersect {['h10:'h1f]} iff(cfg.data_width < 256); \
  ignore_bins ignore_addr_offset_20_3f   = binsof(addr_offset) intersect {['h20:'h3f]} iff(cfg.data_width < 512); \
  ignore_bins ignore_addr_offset_40_7f   = binsof(addr_offset) intersect {['h40:'h7f]} iff(cfg.data_width < 1024); \
 \
  ignore_bins ignore_aligned_transfer_size = binsof(transfer_size) intersect {svt_axi_transaction::BURST_SIZE_8BIT}; \
  ignore_bins ignore_burst_length = binsof(burst_length) intersect {1}; \
 \
  ignore_bins ignore_invalid_32_data_tranfer = ((binsof(addr_offset)intersect {1,2}) && (binsof(transfer_size.xfer_size_2byte))) iff(cfg.data_width == 32); \
 \
  ignore_bins Ig_algn_2_4_Bxfer_64dw = ((binsof(addr_offset)intersect {[1:4]}) && (binsof(transfer_size.xfer_size_2byte) || binsof(transfer_size.xfer_size_4byte))) iff(cfg.data_width == 64); \
  ignore_bins Ig_algn_2byte_tranfer_on_64dw = ((binsof(addr_offset)intersect {[5:6]}) && binsof(transfer_size.xfer_size_2byte)) iff(cfg.data_width == 64); \
 \
  ignore_bins Ig_algn_2_4_8_Bxfer_128dw = ((binsof(addr_offset)intersect {[1:8]}) && (binsof(transfer_size.xfer_size_2byte) || binsof(transfer_size.xfer_size_4byte) || binsof(transfer_size.xfer_size_8byte))) iff(cfg.data_width == 128); \
  ignore_bins Ig_algn_2_4_Bxfer_128dw = ((binsof(addr_offset)intersect {[9:'hc]}) && (binsof(transfer_size.xfer_size_2byte) || binsof(transfer_size.xfer_size_4byte))) iff(cfg.data_width == 128); \
  ignore_bins Ig_algn_2_Bxfer_128dw = ((binsof(addr_offset)intersect {['hd:'he]}) && (binsof(transfer_size.xfer_size_2byte))) iff(cfg.data_width == 128); \
 \
  ignore_bins Ig_algn_2_4_8_16_Bxfer_256dw = ((binsof(addr_offset)intersect {[1:'h10]}) && (binsof(transfer_size.xfer_size_2byte) || binsof(transfer_size.xfer_size_4byte) || binsof(transfer_size.xfer_size_8byte) || binsof(transfer_size.xfer_size_16byte))) iff(cfg.data_width == 256); \
  ignore_bins Ig_algn_2_4_8_Bxfer_256dw = ((binsof(addr_offset)intersect {['h11:'h18]}) && (binsof(transfer_size.xfer_size_2byte) || binsof(transfer_size.xfer_size_4byte) || binsof(transfer_size.xfer_size_8byte))) iff(cfg.data_width == 256); \
  ignore_bins Ig_algn_2_4_Bxfer_256dw = ((binsof(addr_offset)intersect {['h19:'h1c]}) && (binsof(transfer_size.xfer_size_2byte) || binsof(transfer_size.xfer_size_4byte))) iff(cfg.data_width == 256); \
  ignore_bins Ig_algn_2_Bxfer_256dw = ((binsof(addr_offset)intersect {['h1d:'h1e]}) && (binsof(transfer_size.xfer_size_2byte))) iff(cfg.data_width == 256); \
 \
  ignore_bins Ig_algn_2_4_8_16_32_Bxfer_512dw = ((binsof(addr_offset)intersect {[1:'h20]}) && (binsof(transfer_size.xfer_size_2byte) || binsof(transfer_size.xfer_size_4byte) || binsof(transfer_size.xfer_size_8byte) || binsof(transfer_size.xfer_size_16byte) || binsof(transfer_size.xfer_size_32byte))) iff(cfg.data_width == 512); \
  ignore_bins Ig_algn_2_4_8_16_Bxfer_512dw = ((binsof(addr_offset)intersect {['h21:'h30]}) && (binsof(transfer_size.xfer_size_2byte) || binsof(transfer_size.xfer_size_4byte) || binsof(transfer_size.xfer_size_8byte) || binsof(transfer_size.xfer_size_16byte))) iff(cfg.data_width == 512); \
  ignore_bins Ig_algn_2_4_8_Bxfer_512dw = ((binsof(addr_offset)intersect {['h31:'h38]}) && (binsof(transfer_size.xfer_size_2byte) || binsof(transfer_size.xfer_size_4byte) || binsof(transfer_size.xfer_size_8byte))) iff(cfg.data_width == 512); \
  ignore_bins Ig_algn_2_4_Bxfer_512dw = ((binsof(addr_offset)intersect {['h39:'h3c]}) && (binsof(transfer_size.xfer_size_2byte) || binsof(transfer_size.xfer_size_4byte))) iff(cfg.data_width == 512); \
  ignore_bins Ig_algn_2_Bxfer_512dw = ((binsof(addr_offset)intersect {['h3d:'h3e]}) && (binsof(transfer_size.xfer_size_2byte))) iff(cfg.data_width == 512); \
 \
  ignore_bins Ig_algn_2_4_8_16_32_64_Bxfer_1024dw = ((binsof(addr_offset)intersect {[1:'h40]}) && (binsof(transfer_size.xfer_size_2byte) || binsof(transfer_size.xfer_size_4byte) || binsof(transfer_size.xfer_size_8byte) || binsof(transfer_size.xfer_size_16byte) || binsof(transfer_size.xfer_size_32byte) || binsof(transfer_size.xfer_size_64byte))) iff(cfg.data_width == 1024); \
  ignore_bins Ig_algn_2_4_8_16_32_Bxfer_1024dw = ((binsof(addr_offset)intersect {['h41:'h60]}) && (binsof(transfer_size.xfer_size_2byte) || binsof(transfer_size.xfer_size_4byte) || binsof(transfer_size.xfer_size_8byte) || binsof(transfer_size.xfer_size_16byte) || binsof(transfer_size.xfer_size_32byte))) iff(cfg.data_width == 1024); \
  ignore_bins Ig_algn_2_4_8_16_Bxfer_1024dw = ((binsof(addr_offset)intersect {['h61:'h70]}) && (binsof(transfer_size.xfer_size_2byte) || binsof(transfer_size.xfer_size_4byte) || binsof(transfer_size.xfer_size_8byte) || binsof(transfer_size.xfer_size_16byte))) iff(cfg.data_width == 1024); \
  ignore_bins Ig_algn_2_4_8_Bxfer_1024dw = ((binsof(addr_offset)intersect {['h71:'h78]}) && (binsof(transfer_size.xfer_size_2byte) || binsof(transfer_size.xfer_size_4byte) || binsof(transfer_size.xfer_size_8byte))) iff(cfg.data_width == 1024); \
  ignore_bins Ig_algn_2_4_Bxfer_1024dw = ((binsof(addr_offset)intersect {['h79:'h7c]}) && (binsof(transfer_size.xfer_size_2byte) || binsof(transfer_size.xfer_size_4byte))) iff(cfg.data_width == 1024); \
  ignore_bins Ig_algn_2_Bxfer_1024dw = ((binsof(addr_offset)intersect {['h7d:'h7e]}) && (binsof(transfer_size.xfer_size_2byte))) iff(cfg.data_width == 1024);
`else  
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_IGNORE_INVALID_UNALIGNED_TRANSFER_CROSS \
  ignore_bins ignore_unsupported_burst_type = binsof(burst_type) intersect {svt_axi_transaction::FIXED,svt_axi_transaction::WRAP}; \
 \
  ignore_bins ignore_aligned_addr_offset_0  = binsof(addr_offset) intersect {0}; \
 \
 ignore_bins ignore_aligned_transfer_size = binsof(transfer_size) intersect {svt_axi_transaction::BURST_SIZE_8BIT}; \
 ignore_bins ignore_burst_length = binsof(burst_length) intersect {1}; \
 \
 ignore_bins ignore_invalid_32_data_tranfer = ((binsof(addr_offset)intersect {1,2}) && (binsof(transfer_size.xfer_size_2byte)));
`endif

`ifdef SVT_AXI_MON_CFG_BASED_COV_GRP_DEF

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_IGNORE_INVALID_UNALIGNED_TRANSFER_CROSS_DW_32BIT \
 ignore_bins ignore_unsupported_burst_type = binsof(burst_type) intersect {svt_axi_transaction::FIXED,svt_axi_transaction::WRAP}; \
  ignore_bins ignore_aligned_addr_offset_0  = binsof(addr_offset) intersect {0}; \
 ignore_bins ignore_aligned_transfer_size = binsof(transfer_size) intersect {svt_axi_transaction::BURST_SIZE_8BIT}; \
 ignore_bins ignore_burst_length = binsof(burst_length) intersect {1}; \
 ignore_bins ignore_invalid_32_data_tranfer = ((binsof(addr_offset)intersect {1,2}) && (binsof(transfer_size.xfer_size_2byte)));

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_IGNORE_INVALID_UNALIGNED_TRANSFER_CROSS_DW_64BIT \
 ignore_bins ignore_unsupported_burst_type = binsof(burst_type) intersect {svt_axi_transaction::FIXED,svt_axi_transaction::WRAP}; \
  ignore_bins ignore_aligned_addr_offset_0  = binsof(addr_offset) intersect {0}; \
 ignore_bins ignore_aligned_transfer_size = binsof(transfer_size) intersect {svt_axi_transaction::BURST_SIZE_8BIT}; \
 ignore_bins ignore_burst_length = binsof(burst_length) intersect {1}; \
 ignore_bins Ig_algn_2_4_Bxfer_64dw = ((binsof(addr_offset)intersect {[1:4]}) && (binsof(transfer_size.xfer_size_2byte) || binsof(transfer_size.xfer_size_4byte))); \
 ignore_bins Ig_algn_2byte_tranfer_on_64dw = ((binsof(addr_offset)intersect {[5:6]}) && binsof(transfer_size.xfer_size_2byte)); \

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_IGNORE_INVALID_UNALIGNED_TRANSFER_CROSS_DW_128BIT \
 ignore_bins ignore_unsupported_burst_type = binsof(burst_type) intersect {svt_axi_transaction::FIXED,svt_axi_transaction::WRAP}; \
  ignore_bins ignore_aligned_addr_offset_0  = binsof(addr_offset) intersect {0}; \
  ignore_bins ignore_aligned_transfer_size = binsof(transfer_size) intersect {svt_axi_transaction::BURST_SIZE_8BIT}; \
  ignore_bins ignore_burst_length = binsof(burst_length) intersect {1}; \
  ignore_bins Ig_algn_2_4_8_Bxfer_128dw = ((binsof(addr_offset)intersect {['h8:'hf]}) && (binsof(transfer_size.xfer_size_2byte) || binsof(transfer_size.xfer_size_4byte) || binsof(transfer_size.xfer_size_8byte))); \
  ignore_bins Ig_algn_2_4_Bxfer_128dw   = ((binsof(addr_offset)intersect {['h4:'hf]}) && (binsof(transfer_size.xfer_size_2byte) || binsof(transfer_size.xfer_size_4byte))); \
  ignore_bins Ig_algn_2_Bxfer_128dw     = ((binsof(addr_offset)intersect {['h2:'hf]}) && (binsof(transfer_size.xfer_size_2byte))); \

`endif

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_IGNORE_4KB_BOUNDARY_CROSS \
 ignore_bins ignore_4k_boundary_cross = (binsof(addr_offset) && binsof(transfer_size) && binsof(burst_type) && binsof(burst_length)) iff(is_addr_4kb_boundary_cross_flag == 1);


`ifdef SVT_AXI_GEN_COV_DATA_WIDTH_32_BIT
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_TRANSFER_SIZE \
  transfer_size : coverpoint cov_item.burst_size iff(cov_burst_size_flag){ \
    bins xfer_size_1byte    = {svt_axi_transaction::BURST_SIZE_8BIT}; \
    bins xfer_size_2byte   = {svt_axi_transaction::BURST_SIZE_16BIT}; \
    bins xfer_size_4byte   = {svt_axi_transaction::BURST_SIZE_32BIT}; \
    option.weight = 1; \
  }
`else
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_TRANSFER_SIZE \
  transfer_size : coverpoint cov_item.burst_size iff(cov_burst_size_flag){ \
    bins xfer_size_1byte    = {svt_axi_transaction::BURST_SIZE_8BIT}; \
    bins xfer_size_2byte   = {svt_axi_transaction::BURST_SIZE_16BIT};  \
    bins xfer_size_4byte   = {svt_axi_transaction::BURST_SIZE_32BIT}; \
    bins xfer_size_8byte   = {svt_axi_transaction::BURST_SIZE_64BIT}; \
    bins xfer_size_16byte  = {svt_axi_transaction::BURST_SIZE_128BIT}; \
    bins xfer_size_32byte  = {svt_axi_transaction::BURST_SIZE_256BIT}; \
    bins xfer_size_64byte  = {svt_axi_transaction::BURST_SIZE_512BIT}; \
    bins xfer_size_128byte = {svt_axi_transaction::BURST_SIZE_1024BIT}; \
    bins xfer_size_256byte = {svt_axi_transaction::BURST_SIZE_2048BIT}; \
    `SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_TRANSFER_SIZE_BURST_SIZE_IGNORE_BINS \
    option.weight = 1; \
  }
`endif

`ifdef SVT_AXI_MON_CFG_BASED_COV_GRP_DEF

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_TRANSFER_SIZE_DWLT_1024 \
  transfer_size : coverpoint cov_item.burst_size iff(cov_burst_size_flag){ \
    bins xfer_size_1byte    = {svt_axi_transaction::BURST_SIZE_8BIT}; \
    bins xfer_size_2byte   = {svt_axi_transaction::BURST_SIZE_16BIT}; \
    bins xfer_size_4byte   = {svt_axi_transaction::BURST_SIZE_32BIT}; \
    bins xfer_size_8byte   = {svt_axi_transaction::BURST_SIZE_64BIT}; \
    bins xfer_size_16byte  = {svt_axi_transaction::BURST_SIZE_128BIT}; \
    bins xfer_size_32byte  = {svt_axi_transaction::BURST_SIZE_256BIT}; \
    bins xfer_size_64byte  = {svt_axi_transaction::BURST_SIZE_512BIT}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_TRANSFER_SIZE_DWLT_512 \
  transfer_size : coverpoint cov_item.burst_size iff(cov_burst_size_flag){ \
    bins xfer_size_1byte    = {svt_axi_transaction::BURST_SIZE_8BIT}; \
    bins xfer_size_2byte   = {svt_axi_transaction::BURST_SIZE_16BIT}; \
    bins xfer_size_4byte   = {svt_axi_transaction::BURST_SIZE_32BIT}; \
    bins xfer_size_8byte   = {svt_axi_transaction::BURST_SIZE_64BIT}; \
    bins xfer_size_16byte  = {svt_axi_transaction::BURST_SIZE_128BIT}; \
    bins xfer_size_32byte  = {svt_axi_transaction::BURST_SIZE_256BIT}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_TRANSFER_SIZE_DWLT_256 \
  transfer_size : coverpoint cov_item.burst_size iff(cov_burst_size_flag){ \
    bins xfer_size_1byte    = {svt_axi_transaction::BURST_SIZE_8BIT}; \
    bins xfer_size_2byte   = {svt_axi_transaction::BURST_SIZE_16BIT}; \
    bins xfer_size_4byte   = {svt_axi_transaction::BURST_SIZE_32BIT}; \
    bins xfer_size_8byte   = {svt_axi_transaction::BURST_SIZE_64BIT}; \
    bins xfer_size_16byte  = {svt_axi_transaction::BURST_SIZE_128BIT}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_TRANSFER_SIZE_DWLT_128 \
  transfer_size : coverpoint cov_item.burst_size iff(cov_burst_size_flag){ \
    bins xfer_size_1byte    = {svt_axi_transaction::BURST_SIZE_8BIT}; \
    bins xfer_size_2byte   = {svt_axi_transaction::BURST_SIZE_16BIT}; \
    bins xfer_size_4byte   = {svt_axi_transaction::BURST_SIZE_32BIT}; \
    bins xfer_size_8byte   = {svt_axi_transaction::BURST_SIZE_64BIT}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_TRANSFER_SIZE_DWLT_64 \
  transfer_size : coverpoint cov_item.burst_size iff(cov_burst_size_flag){ \
    bins xfer_size_1byte    = {svt_axi_transaction::BURST_SIZE_8BIT}; \
    bins xfer_size_2byte   = {svt_axi_transaction::BURST_SIZE_16BIT}; \
    bins xfer_size_4byte   = {svt_axi_transaction::BURST_SIZE_32BIT}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_TRANSFER_SIZE_DWLT_32 \
  transfer_size : coverpoint cov_item.burst_size iff(cov_burst_size_flag){ \
    bins xfer_size_1byte    = {svt_axi_transaction::BURST_SIZE_8BIT}; \
    bins xfer_size_2byte   = {svt_axi_transaction::BURST_SIZE_16BIT}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_TRANSFER_SIZE_DWLT_16 \
  transfer_size : coverpoint cov_item.burst_size iff(cov_burst_size_flag){ \
    bins xfer_size_1byte    = {svt_axi_transaction::BURST_SIZE_8BIT}; \
    option.weight = 1; \
  }

`endif //SVT_AXI_MON_CFG_BASED_COV_GRP_DEF

`ifndef SVT_AXI_MON_CFG_BASED_COV_GRP_DEF

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_ATOMIC_TYPE \
  atomic_type : coverpoint cov_item.atomic_type iff(cov_atomic_type_flag){ \
    bins normal    = {svt_axi_transaction::NORMAL}; \
    bins exclusive = {svt_axi_transaction::EXCLUSIVE} iff(cfg.exclusive_access_enable == 1); \
    bins locked    = {svt_axi_transaction::LOCKED} iff((cfg.axi_interface_type == svt_axi_port_configuration::AXI3) || (cfg.locked_access_enable == 1)) ; \
    option.weight = 1; \
  }

`else //SVT_AXI_MON_CFG_BASED_COV_GRP_DEF

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_ATOMIC_TYPE_LOCKED_AXI3 \
  atomic_type : coverpoint cov_item.atomic_type iff(cov_atomic_type_flag){ \
    bins normal    = {svt_axi_transaction::NORMAL}; \
    bins locked    = {svt_axi_transaction::LOCKED}; \
    option.weight = 1; \
  }
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_ATOMIC_TYPE_NO_LOCKED_AXI3 \
  atomic_type : coverpoint cov_item.atomic_type iff(cov_atomic_type_flag){ \
    bins normal    = {svt_axi_transaction::NORMAL}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_ATOMIC_TYPE_EXCLUSIVE_AXI3 \
  atomic_type : coverpoint cov_item.atomic_type iff(cov_atomic_type_flag){ \
    bins normal    = {svt_axi_transaction::NORMAL}; \
    bins exclusive = {svt_axi_transaction::EXCLUSIVE}; \
    bins locked    = {svt_axi_transaction::LOCKED}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_ATOMIC_TYPE_EXCLUSIVE_NOT_AXI3 \
  atomic_type : coverpoint cov_item.atomic_type iff(cov_atomic_type_flag){ \
    bins normal    = {svt_axi_transaction::NORMAL}; \
    bins exclusive = {svt_axi_transaction::EXCLUSIVE}; \
    option.weight = 1; \
  }
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_ATOMIC_TYPE_NO_EXCLUSIVE_AXI3 \
  atomic_type : coverpoint cov_item.atomic_type iff(cov_atomic_type_flag){ \
    bins normal    = {svt_axi_transaction::NORMAL}; \
    bins locked    = {svt_axi_transaction::LOCKED}; \
    option.weight = 1; \
  }
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_ATOMIC_TYPE_NO_EXCLUSIVE_NOT_AXI3 \
  atomic_type : coverpoint cov_item.atomic_type iff(cov_atomic_type_flag){ \
    bins normal    = {svt_axi_transaction::NORMAL}; \
    option.weight = 1; \
  }

`endif //SVT_AXI_MON_CFG_BASED_COV_GRP_DEF

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_CACHE_TYPE \
  cache_type : coverpoint cov_item.cache_type iff(cov_cache_type_flag){ \
    bins non_cacheable_non_bufferable = {`SVT_AXI_3_NON_CACHEABLE_NON_BUFFERABLE};\
    bins bufferable_or_modifiable_only = {`SVT_AXI_3_BUFFERABLE_OR_MODIFIABLE_ONLY};\
    bins cacheable_but_no_alloc =  {`SVT_AXI_3_CACHEABLE_BUT_NO_ALLOC};\
    bins cacheable_bufferable_but_no_alloc =  {`SVT_AXI_3_CACHEABLE_BUFFERABLE_BUT_NO_ALLOC};\
    bins cacheable_write_through_allocate_on_read_only =  {`SVT_AXI_3_CACHEABLE_WR_THRU_ALLOC_ON_RD_ONLY};\
    bins cacheable_write_back_allocate_on_read_only =  {`SVT_AXI_3_CACHEABLE_WR_BACK_ALLOC_ON_RD_ONLY};\
    bins cacheable_write_through_allocate_on_write_only =  {`SVT_AXI_3_CACHEABLE_WR_THRU_ALLOC_ON_WR_ONLY};\
    bins cacheable_write_back_allocate_on_write_only =  {`SVT_AXI_3_CACHEABLE_WR_BACK_ALLOC_ON_WR_ONLY};\
    bins cacheable_write_through_allocate_on_both_read_write =  {`SVT_AXI_3_CACHEABLE_WR_THRU_ALLOC_ON_BOTH_RD_WR};\
    bins cacheable_write_back_allocate_on_both_read_write =  {`SVT_AXI_3_CACHEABLE_WR_BACK_ALLOC_ON_BOTH_RD_WR};\
    ignore_bins ignore_rsvd = {4,5,8,9,12,13}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_ARCACHE_TYPE_AXI4 \
  cache_type : coverpoint cov_item.cache_type iff(cov_cache_type_flag){ \
    bins device_non_bufferable = {`SVT_AXI_4_ARCACHE_DEVICE_NON_BUFFERABLE};\
    bins device_bufferable = {`SVT_AXI_4_ARCACHE_DEVICE_BUFFERABLE};\
    bins normal_non_cacheable_non_bufferable = {`SVT_AXI_4_ARCACHE_NORMAL_NON_CACHABLE_NON_BUFFERABLE};\
    bins normal_non_cacheable_bufferable = {`SVT_AXI_4_ARCACHE_NORMAL_NON_CACHABLE_BUFFERABLE};\
    bins write_through_no_allocate = {`SVT_AXI_4_ARCACHE_WRITE_THROUGH_NO_ALLOCATE};\
    bins write_through_read_allocate = {`SVT_AXI_4_ARCACHE_WRITE_THROUGH_READ_ALLOCATE};\
    bins write_through_write_allocate = {`SVT_AXI_4_ARCACHE_WRITE_THROUGH_WRITE_ALLOCATE};\
    bins write_through_read_and_write_allocate = {`SVT_AXI_4_ARCACHE_WRITE_THROUGH_READ_AND_WRITE_ALLOCATE};\
    bins write_back_no_allocate = {`SVT_AXI_4_ARCACHE_WRITE_BACK_NO_ALLOCATE};\
    bins write_back_read_allocate = {`SVT_AXI_4_ARCACHE_WRITE_BACK_READ_ALLOCATE};\
    bins write_back_write_allocate = {`SVT_AXI_4_ARCACHE_WRITE_BACK_WRITE_ALLOCATE};\
    bins write_back_read_and_write_allocate = {`SVT_AXI_4_ARCACHE_WRITE_BACK_READ_AND_WRITE_ALLOCATE};\
    ignore_bins ignore_rsvd = {4,5,8,9,12,13}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_AWCACHE_TYPE_AXI4 \
  cache_type : coverpoint cov_item.cache_type iff(cov_cache_type_flag){ \
    bins device_non_bufferable = {`SVT_AXI_4_AWCACHE_DEVICE_NON_BUFFERABLE};\
    bins device_bufferable = {`SVT_AXI_4_AWCACHE_DEVICE_BUFFERABLE};\
    bins normal_non_cacheable_non_bufferable = {`SVT_AXI_4_AWCACHE_NORMAL_NON_CACHABLE_NON_BUFFERABLE};\
    bins normal_non_cacheable_bufferable = {`SVT_AXI_4_AWCACHE_NORMAL_NON_CACHABLE_BUFFERABLE};\
    bins write_through_no_allocate = {`SVT_AXI_4_AWCACHE_WRITE_THROUGH_NO_ALLOCATE};\
    bins write_through_read_allocate = {`SVT_AXI_4_AWCACHE_WRITE_THROUGH_READ_ALLOCATE};\
    bins write_through_write_allocate = {`SVT_AXI_4_AWCACHE_WRITE_THROUGH_WRITE_ALLOCATE};\
    bins write_through_read_and_write_allocate = {`SVT_AXI_4_AWCACHE_WRITE_THROUGH_READ_AND_WRITE_ALLOCATE};\
    bins write_back_no_allocate = {`SVT_AXI_4_AWCACHE_WRITE_BACK_NO_ALLOCATE};\
    bins write_back_read_allocate = {`SVT_AXI_4_AWCACHE_WRITE_BACK_READ_ALLOCATE};\
    bins write_back_write_allocate = {`SVT_AXI_4_AWCACHE_WRITE_BACK_WRITE_ALLOCATE};\
    bins write_back_read_and_write_allocate = {`SVT_AXI_4_AWCACHE_WRITE_BACK_READ_AND_WRITE_ALLOCATE};\
    ignore_bins ignore_rsvd = {4,5,8,9,12,13}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_CACHE_TYPE_MODIFIABLE_BIT \
  cache_type_modifiable_bit : coverpoint cov_item.cache_type[1] iff(cov_cache_type_flag){ \
    option.weight = 1; \
  }

 `define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_CACHE_TYPE_EXCLUSIVE_ACCESS \
  cache_type : coverpoint cov_item.cache_type iff(cov_cache_type_flag){ \
    bins device_non_bufferable = {`SVT_AXI_4_ARCACHE_DEVICE_NON_BUFFERABLE};\
    bins device_bufferable = {`SVT_AXI_4_ARCACHE_DEVICE_BUFFERABLE};\
    bins normal_non_cacheable_non_bufferable = {`SVT_AXI_4_ARCACHE_NORMAL_NON_CACHABLE_NON_BUFFERABLE};\
    bins normal_non_cacheable_bufferable = {`SVT_AXI_4_ARCACHE_NORMAL_NON_CACHABLE_BUFFERABLE};\
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_CACHE_TYPE_EXCLUSIVE_ACCESS_AXI3 \
  cache_type : coverpoint cov_item.cache_type iff(cov_cache_type_flag){ \
    bins device_noncacheable_nonbufferable = {`SVT_AXI_3_NON_CACHEABLE_NON_BUFFERABLE};\
    bins device_bufferable_or_modifiable_only = {`SVT_AXI_3_BUFFERABLE_OR_MODIFIABLE_ONLY};\
    bins cacheable_but_do_not_alloc = {`SVT_AXI_3_CACHEABLE_BUT_NO_ALLOC};\
    bins cacheable_and_bufferable_but_do_not_alloc = {`SVT_AXI_3_CACHEABLE_BUFFERABLE_BUT_NO_ALLOC};\
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_PROT_TYPE \
  prot_type : coverpoint cov_item.prot_type iff(cov_prot_type_flag){ \
    bins data_secure_normal                = {svt_axi_transaction::DATA_SECURE_NORMAL}; \
    bins data_secure_privileged            = {svt_axi_transaction::DATA_SECURE_PRIVILEGED}; \
    bins data_non_secure_normal            = {svt_axi_transaction::DATA_NON_SECURE_NORMAL}; \
    bins data_non_secure_privileged        = {svt_axi_transaction::DATA_NON_SECURE_PRIVILEGED}; \
    bins instruction_secure_normal         = {svt_axi_transaction::INSTRUCTION_SECURE_NORMAL}; \
    bins instruction_secure_privileged      = {svt_axi_transaction::INSTRUCTION_SECURE_PRIVILEGED}; \
    bins instruction_non_secure_normal     = {svt_axi_transaction::INSTRUCTION_NON_SECURE_NORMAL}; \
    bins instruction_non_secure_privileged = {svt_axi_transaction::INSTRUCTION_NON_SECURE_PRIVILEGED}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_BARRIER_OUTSTANDING_TRANSACTION \
  barrier_outstanding_xact : coverpoint num_outstanding_xact iff(barrier_outstanding_xact_flag){ \
    bins barrier_outstanding_xact_range_low = {[1:32]}; \
    bins barrier_outstanding_xact_range_med = {[33:128]}; \
    bins barrier_outstanding_xact_range_max = {[129:256]}; \
    ignore_bins barrier_outstanding_xact_range_above_256 = {257} iff(cfg.axi_interface_type == svt_axi_port_configuration::AXI_ACE && (`SVT_AXI_MAX_NUM_OUTSTANDING_XACT > 256)); \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_BARRIER_OUTSTANDING_TRANSACTION_ACE \
  barrier_outstanding_xact : coverpoint num_outstanding_xact iff(barrier_outstanding_xact_flag){ \
    bins barrier_outstanding_xact_range_low = {[1:32]}; \
    bins barrier_outstanding_xact_range_med = {[33:128]}; \
    bins barrier_outstanding_xact_range_max = {[129:256]}; \
    ignore_bins barrier_outstanding_xact_range_above_256 = {257}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_BARRIER_OUTSTANDING_TRANSACTION_ACELITE \
  barrier_outstanding_xact : coverpoint num_outstanding_xact iff(barrier_outstanding_xact_flag){ \
    bins barrier_outstanding_xact_range_low = {[1:32]}; \
    bins barrier_outstanding_xact_range_med = {[33:128]}; \
    bins barrier_outstanding_xact_range_max = {[129:256]}; \
    bins barrier_outstanding_xact_range_above_256 = {257}; \
    option.weight = 1; \
  }


`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_TOTAL_OUTSTANDING_TRANSACTION \
  total_outstanding_xact : coverpoint num_outstanding_xact iff(total_outstanding_xact_flag){ \
    bins total_outstanding_xact[] = {[1:num_outstanding_xacts]}; \
    option.weight = 1; \
  }
 
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_OUTSTANDING_WRITE_TRANSACTION \
  outstanding_write_xact : coverpoint num_write_outstanding_xact iff(outstanding_write_xact_flag){ \
    bins write_outstanding_xact[]    = {[1:num_write_outstanding_xacts]}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_OUTSTANDING_READ_TRANSACTION \
  outstanding_read_xact : coverpoint num_read_outstanding_xact iff(outstanding_read_xact_flag){ \
    bins read_outstanding_xact[]    = {[1:num_read_outstanding_xacts]}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_AXI4_STREAM_DATA_INTERLEAVE_DEPTH \
  axi4_stream_data_interleave : coverpoint axi4_stream_data_interleaving_depth iff(stream_data_interleave_flag){ \
    bins axi4_stream_data_interleave_size[] = {[1:`SVT_AXI_MAX_READ_DATA_INTERLEAVE_SIZE]}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_READ_DATA_INTERLEAVE_DEPTH \
  read_data_interleave : coverpoint read_data_interleaving_depth iff(read_data_interleave_flag){ \
    bins read_data_interleave_size[] = {[1:`SVT_AXI_MAX_READ_DATA_INTERLEAVE_SIZE]}; \
    option.weight = 1; \
  }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_WRITE_DATA_INTERLEAVE_DEPTH \
  write_data_interleave : coverpoint write_data_interleaving_depth iff(write_data_interleave_flag){ \
    bins write_data_interleave_depth[] = {[1:`SVT_AXI_MAX_WR_INTERLEAVE_DEPTH]}; \
    option.weight = 1; \
   }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_INITIAL_CACHE_LINE_STATE \
    initial_cache_line_state : coverpoint cov_item.initial_cache_line_state iff (cov_initial_cache_line_state_flag) { \
      bins initial_state_invalid          = {svt_axi_transaction::INVALID}; \
      bins initial_state_uniqueclean      = {svt_axi_transaction::UNIQUECLEAN}; \
      bins initial_state_uniquedirty      = {svt_axi_transaction::UNIQUEDIRTY}; \
      bins initial_state_sharedclean      = {svt_axi_transaction::SHAREDCLEAN}; \
      bins initial_state_shareddirty      = {svt_axi_transaction::SHAREDDIRTY}; \
      option.weight = 1 ; \
    }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_FINAL_CACHE_LINE_STATE \
    final_cache_line_state : coverpoint cov_item.final_cache_line_state iff (cov_final_cache_line_state_flag) { \
      bins final_state_invalid          = {svt_axi_transaction::INVALID}; \
      bins final_state_uniqueclean      = {svt_axi_transaction::UNIQUECLEAN}; \
      bins final_state_uniquedirty      = {svt_axi_transaction::UNIQUEDIRTY}; \
      bins final_state_sharedclean      = {svt_axi_transaction::SHAREDCLEAN}; \
      bins final_state_shareddirty      = {svt_axi_transaction::SHAREDDIRTY}; \
      option.weight = 1 ; \
    }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_SNOOP_INITIAL_CACHE_LINE_STATE \
    initial_cache_line_state : coverpoint cov_snoop_item.snoop_initial_cache_line_state iff (cov_snoop_initial_cache_line_state_flag) { \
      bins initial_state_invalid          = {svt_axi_snoop_transaction::INVALID}; \
      bins initial_state_uniqueclean      = {svt_axi_snoop_transaction::UNIQUECLEAN}; \
      bins initial_state_uniquedirty      = {svt_axi_snoop_transaction::UNIQUEDIRTY}; \
      bins initial_state_sharedclean      = {svt_axi_snoop_transaction::SHAREDCLEAN}; \
      bins initial_state_shareddirty      = {svt_axi_snoop_transaction::SHAREDDIRTY}; \
      option.weight = 1 ; \
    }

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_SNOOP_FINAL_CACHE_LINE_STATE \
    final_cache_line_state : coverpoint cov_snoop_item.snoop_final_cache_line_state iff (cov_snoop_final_cache_line_state_flag) { \
      bins final_state_invalid          = {svt_axi_snoop_transaction::INVALID}; \
      bins final_state_uniqueclean      = {svt_axi_snoop_transaction::UNIQUECLEAN}; \
      bins final_state_uniquedirty      = {svt_axi_snoop_transaction::UNIQUEDIRTY}; \
      bins final_state_sharedclean      = {svt_axi_snoop_transaction::SHAREDCLEAN}; \
      bins final_state_shareddirty      = {svt_axi_snoop_transaction::SHAREDDIRTY}; \
      option.weight = 1 ; \
    }


`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_EXCEPTIONS \
  axi_exceptions : coverpoint cov_item.exceptions iff(cov_exceptions_flag){ \
    options.weight = 0; \
  }

//======================================================================
// Signal level coverage macros 
//====================================================================== 

/**
 *  Macro consists covergroup having single bit as coverpoint and declaration of
 *  transition bins of single bit signal
 */
  //covergroup toggle_cov @(sample_event); \
  /** Removed the sampling enevt as it will call the sample*/
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_CREATE_CG \
  covergroup toggle_cov ;\
    option.per_instance = 1; \
    option.goal = 100; \
    coverpoint signal_index { \
      bins toggle_bit_0to1 = (0 => 1); \
      bins toggle_bit_1to0 = (1 => 0); \
    } \
  endgroup
/**
 * Macro to give group name by appending signal name and bit index (e.g.
 * signal_toggle_awid_0) for ease of reading coverage report  
 */
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_TOGGLE_COV_SIGNAME_TO_GRP_NAME(signal_name, bitindex) \
   $sformatf("%0s_signal_toggle_%0s_bit%0d", cfg.inst, `SVT_DATA_UTIL_ARG_TO_STRING(signal_name), bitindex)
/**
 *  Macro used by variable width AXI3,4,Lite signal instaces to trigger the
 *  local event and triggering coverage group.
 */    
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_COVER_SAMPLE_SIGNAL(signal_name) \
  foreach (signal_name``_toggle_cov[i]) begin \
    signal_name``_toggle_cov[i].bit_cov(axi_monitor_mp.axi_monitor_cb.signal_name[i]); \
  end 
/**
 *  Macro used by variable width AXI4 Stream signal instaces to trigger the
 *  local event and triggering coverage group.
 */    
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_COVER_SAMPLE_SIGNAL_AXI4_STREAM(signal_name) \
  foreach (signal_name``_toggle_cov[i]) begin \
    signal_name``_toggle_cov[i].bit_cov(axi_stream_monitor_mp.axi_stream_monitor_cb.signal_name[i]); \
  end 
/**
 *  Macro used by variable width AXI3,4,Lite single bit signals to trigger the
 *  local event and triggering coverage group.
 */    
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_COVER_SAMPLE_SIGNAL_BIT(signal_name) \
  foreach (signal_name``_toggle_cov[i]) begin \
    signal_name``_toggle_cov[i].bit_cov(axi_monitor_mp.axi_monitor_cb.signal_name); \
  end 
/**
 *  Macro used by variable width AXI4 Stream single bit signals to trigger the
 *  local event and triggering coverage group.
 */    
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_COVER_SAMPLE_SIGNAL_AXI4_STREAM_BIT(signal_name) \
  foreach (signal_name``_toggle_cov[i]) begin \
    signal_name``_toggle_cov[i].bit_cov(axi_stream_monitor_mp.axi_stream_monitor_cb.signal_name); \
  end 
/**
 * Macro used to create number of instances as per the respective width of the
 * signal 
 */
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_CREATE_REQ_INSTANCES(signal_name, signal_width, signal_enable) \
 if(signal_enable) begin \
  signal_name``_toggle_cov = new[signal_width]; \
  for (int i=0; i < signal_width; i++) begin \
    string s_inst_name = `SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_TOGGLE_COV_SIGNAME_TO_GRP_NAME(signal_name, i); \
    svt_axi_toggle_bit_cov toggle_bit_inst = new(); \
    toggle_bit_inst.toggle_cov.set_inst_name(s_inst_name); \
    signal_name``_toggle_cov[i] = toggle_bit_inst; \
  end \
 end \
 else begin \
 end
/**
 * Macro to declare covergroup template
 */
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_CG(signal_name, sample_event) \
  covergroup signal_state_``signal_name @(sample_event); \
   option.per_instance = 1; \
    option.goal = 100; 
/**
 * Macro to create state covergroup instances 
 */
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_SET_STATE_CG_INST_NAME(signal_name) \
   signal_state_``signal_name = new(); \
   s_inst_name = `SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_STATE_COV_SIGNAME_TO_GRP_NAME(signal_name); \
   signal_state_``signal_name.set_inst_name(s_inst_name); 
/** 
 * Macro to give cover group name by appending class name for ease of reading of
 * coverage report in case of state coverage
 */
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_STATE_COV_SIGNAME_TO_GRP_NAME(signal_name) \
   $sformatf("%0s_signal_state_%0s", cfg.inst, `SVT_DATA_UTIL_ARG_TO_STRING(signal_name))

                   //bins signal_name``_range_mid = {[1:(( (`SVT_AXI_MAX_SIZED_1<<(signal_max_val-1)) + (`SVT_AXI_MAX_SIZED_1<<(signal_max_val-1)) - 1)-2)]}; \
                   //bins signal_name``_range_max = {( (`SVT_AXI_MAX_SIZED_1<<(signal_max_val-1)) + (`SVT_AXI_MAX_SIZED_1<<(signal_max_val-1)) -1)}; \
/**
 *  Following macros takes protocol signal, it's respective maximum value
 *  defined in *defines.svi and sample event as arguements and defines signal's
 *  min,mid,max bin value ranges in covergroup.
 */
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_RANGE_CG(signal_name, signal_max_val, sample_event) \
 \
 `SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_CG(signal_name, sample_event) \
   signal_name``_min_mid_max : coverpoint axi_monitor_mp.axi_monitor_cb.signal_name & ((`SVT_AXI_MAX_SIZED_1<<(signal_max_val)) -1 ) \
                { \
                   bins signal_name``_range_min = {0};\
`ifdef SVT_MULTI_SIM_COVPOINT_GREATER_THAN_32_BITS \
  // Need to come up with an alternative \
`else \
                   bins signal_name``_range_mid = {[1:(( (`SVT_AXI_MAX_SIZED_1<<((signal_max_val)-1)) + (`SVT_AXI_MAX_SIZED_1<<((signal_max_val)-1)) - 1)-1)]}; \
                   bins signal_name``_range_max = {( (`SVT_AXI_MAX_SIZED_1<<((signal_max_val)-1)) + (`SVT_AXI_MAX_SIZED_1<<((signal_max_val)-1)) -1)}; \
`endif \
                } \
  endgroup

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_RANGE_CG_AXI4_STREAM(signal_name, signal_max_val, sample_event) \
 \
 `SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_CG(signal_name, sample_event) \
   signal_name``_min_mid_max : coverpoint axi_stream_monitor_mp.axi_stream_monitor_cb.signal_name & ((`SVT_AXI_MAX_SIZED_1<<(signal_max_val)) -1 ) \
                { \
                   bins signal_name``_range_min = {0};\
`ifdef SVT_MULTI_SIM_COVPOINT_GREATER_THAN_32_BITS \
  // Need to come up with an alternative \
`else \
                   bins signal_name``_range_mid = {[1:(( (`SVT_AXI_MAX_SIZED_1<<(signal_max_val-1)) + (`SVT_AXI_MAX_SIZED_1<<(signal_max_val-1)) - 1)-1)]}; \
                   bins signal_name``_range_max = {( (`SVT_AXI_MAX_SIZED_1<<(signal_max_val-1)) + (`SVT_AXI_MAX_SIZED_1<<(signal_max_val-1)) -1)}; \
`endif \
                } \
  endgroup
/**
 *  Following macro takes protocol signal related to size as arguement and defines
 *  specific bins of interest in covergroup
 */
 `ifndef SVT_AXI_MON_CFG_BASED_COV_GRP_DEF
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_SIZE_CG(signal_name, sample_event) \
 \
 `SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_CG(signal_name, sample_event) \
   signal_name : coverpoint axi_monitor_mp.axi_monitor_cb.signal_name \
   { \
       bins svt_axi_transaction_burst_size_8 =    {`SVT_AXI_TRANSACTION_BURST_SIZE_8}; \
       bins svt_axi_transaction_burst_size_16 =   {`SVT_AXI_TRANSACTION_BURST_SIZE_16}; \
       bins svt_axi_transaction_burst_size_32 =   {`SVT_AXI_TRANSACTION_BURST_SIZE_32}; \
       bins svt_axi_transaction_burst_size_64 =   {`SVT_AXI_TRANSACTION_BURST_SIZE_64}; \
       bins svt_axi_transaction_burst_size_128 =  {`SVT_AXI_TRANSACTION_BURST_SIZE_128}; \
       bins svt_axi_transaction_burst_size_256 =  {`SVT_AXI_TRANSACTION_BURST_SIZE_256}; \
       bins svt_axi_transaction_burst_size_512 =  {`SVT_AXI_TRANSACTION_BURST_SIZE_512}; \
       bins svt_axi_transaction_burst_size_1024 = {`SVT_AXI_TRANSACTION_BURST_SIZE_1024}; \
       ignore_bins ignore_burst_size_16 =   {`SVT_AXI_TRANSACTION_BURST_SIZE_16} iff (cfg.data_width < 16); \
       ignore_bins ignore_burst_size_32 =   {`SVT_AXI_TRANSACTION_BURST_SIZE_32} iff (cfg.data_width < 32); \
       ignore_bins ignore_burst_size_64 =   {`SVT_AXI_TRANSACTION_BURST_SIZE_64} iff (cfg.data_width < 64); \
       ignore_bins ignore_burst_size_128 =  {`SVT_AXI_TRANSACTION_BURST_SIZE_128} iff (cfg.data_width < 128); \
       ignore_bins ignore_burst_size_256 =  {`SVT_AXI_TRANSACTION_BURST_SIZE_256} iff (cfg.data_width < 256); \
       ignore_bins ignore_burst_size_512 =  {`SVT_AXI_TRANSACTION_BURST_SIZE_512} iff (cfg.data_width < 512); \
       ignore_bins ignore_burst_size_1024 = {`SVT_AXI_TRANSACTION_BURST_SIZE_1024} iff (cfg.data_width < 1024); \
   } \
  endgroup
  `else
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_SIZE_LT_16_CG(cp_name, signal_name, sample_event) \
 \
 `SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_CG(cp_name, sample_event) \
   cp_name : coverpoint axi_monitor_mp.axi_monitor_cb.signal_name \
   { \
       bins svt_axi_transaction_burst_size_8 =    {`SVT_AXI_TRANSACTION_BURST_SIZE_8}; \
   } \
  endgroup

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_SIZE_LT_32_CG(cp_name, signal_name, sample_event) \
 \
 `SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_CG(cp_name, sample_event) \
   cp_name : coverpoint axi_monitor_mp.axi_monitor_cb.signal_name \
   { \
       bins svt_axi_transaction_burst_size_8 =    {`SVT_AXI_TRANSACTION_BURST_SIZE_8}; \
       bins svt_axi_transaction_burst_size_16 =   {`SVT_AXI_TRANSACTION_BURST_SIZE_16}; \
   } \
  endgroup

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_SIZE_LT_64_CG(cp_name, signal_name, sample_event) \
 \
 `SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_CG(cp_name, sample_event) \
   cp_name : coverpoint axi_monitor_mp.axi_monitor_cb.signal_name \
   { \
       bins svt_axi_transaction_burst_size_8 =    {`SVT_AXI_TRANSACTION_BURST_SIZE_8}; \
       bins svt_axi_transaction_burst_size_16 =   {`SVT_AXI_TRANSACTION_BURST_SIZE_16}; \
       bins svt_axi_transaction_burst_size_32 =   {`SVT_AXI_TRANSACTION_BURST_SIZE_32}; \
   } \
  endgroup

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_SIZE_LT_128_CG(cp_name, signal_name, sample_event) \
 \
 `SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_CG(cp_name, sample_event) \
   cp_name : coverpoint axi_monitor_mp.axi_monitor_cb.signal_name \
   { \
       bins svt_axi_transaction_burst_size_8 =    {`SVT_AXI_TRANSACTION_BURST_SIZE_8}; \
       bins svt_axi_transaction_burst_size_16 =   {`SVT_AXI_TRANSACTION_BURST_SIZE_16}; \
       bins svt_axi_transaction_burst_size_32 =   {`SVT_AXI_TRANSACTION_BURST_SIZE_32}; \
       bins svt_axi_transaction_burst_size_64 =   {`SVT_AXI_TRANSACTION_BURST_SIZE_64}; \
   } \
  endgroup

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_SIZE_LT_256_CG(cp_name, signal_name, sample_event) \
 \
 `SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_CG(cp_name, sample_event) \
   cp_name : coverpoint axi_monitor_mp.axi_monitor_cb.signal_name \
   { \
       bins svt_axi_transaction_burst_size_8 =    {`SVT_AXI_TRANSACTION_BURST_SIZE_8}; \
       bins svt_axi_transaction_burst_size_16 =   {`SVT_AXI_TRANSACTION_BURST_SIZE_16}; \
       bins svt_axi_transaction_burst_size_32 =   {`SVT_AXI_TRANSACTION_BURST_SIZE_32}; \
       bins svt_axi_transaction_burst_size_64 =   {`SVT_AXI_TRANSACTION_BURST_SIZE_64}; \
       bins svt_axi_transaction_burst_size_128 =  {`SVT_AXI_TRANSACTION_BURST_SIZE_128}; \
   } \
  endgroup

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_SIZE_LT_512_CG(cp_name, signal_name, sample_event) \
 \
 `SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_CG(cp_name, sample_event) \
   cp_name : coverpoint axi_monitor_mp.axi_monitor_cb.signal_name \
   { \
       bins svt_axi_transaction_burst_size_8 =    {`SVT_AXI_TRANSACTION_BURST_SIZE_8}; \
       bins svt_axi_transaction_burst_size_16 =   {`SVT_AXI_TRANSACTION_BURST_SIZE_16}; \
       bins svt_axi_transaction_burst_size_32 =   {`SVT_AXI_TRANSACTION_BURST_SIZE_32}; \
       bins svt_axi_transaction_burst_size_64 =   {`SVT_AXI_TRANSACTION_BURST_SIZE_64}; \
       bins svt_axi_transaction_burst_size_128 =  {`SVT_AXI_TRANSACTION_BURST_SIZE_128}; \
       bins svt_axi_transaction_burst_size_256 =  {`SVT_AXI_TRANSACTION_BURST_SIZE_256}; \
   } \
  endgroup

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_SIZE_LT_1024_CG(cp_name, signal_name, sample_event) \
 \
 `SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_CG(cp_name, sample_event) \
   cp_name : coverpoint axi_monitor_mp.axi_monitor_cb.signal_name \
   { \
       bins svt_axi_transaction_burst_size_8 =    {`SVT_AXI_TRANSACTION_BURST_SIZE_8}; \
       bins svt_axi_transaction_burst_size_16 =   {`SVT_AXI_TRANSACTION_BURST_SIZE_16}; \
       bins svt_axi_transaction_burst_size_32 =   {`SVT_AXI_TRANSACTION_BURST_SIZE_32}; \
       bins svt_axi_transaction_burst_size_64 =   {`SVT_AXI_TRANSACTION_BURST_SIZE_64}; \
       bins svt_axi_transaction_burst_size_128 =  {`SVT_AXI_TRANSACTION_BURST_SIZE_128}; \
       bins svt_axi_transaction_burst_size_256 =  {`SVT_AXI_TRANSACTION_BURST_SIZE_256}; \
       bins svt_axi_transaction_burst_size_512 =  {`SVT_AXI_TRANSACTION_BURST_SIZE_512}; \
   } \
  endgroup

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_SIZE_GE_1024_CG(cp_name, signal_name, sample_event) \
 \
 `SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_CG(cp_name, sample_event) \
   cp_name : coverpoint axi_monitor_mp.axi_monitor_cb.signal_name \
   { \
       bins svt_axi_transaction_burst_size_8 =    {`SVT_AXI_TRANSACTION_BURST_SIZE_8}; \
       bins svt_axi_transaction_burst_size_16 =   {`SVT_AXI_TRANSACTION_BURST_SIZE_16}; \
       bins svt_axi_transaction_burst_size_32 =   {`SVT_AXI_TRANSACTION_BURST_SIZE_32}; \
       bins svt_axi_transaction_burst_size_64 =   {`SVT_AXI_TRANSACTION_BURST_SIZE_64}; \
       bins svt_axi_transaction_burst_size_128 =  {`SVT_AXI_TRANSACTION_BURST_SIZE_128}; \
       bins svt_axi_transaction_burst_size_256 =  {`SVT_AXI_TRANSACTION_BURST_SIZE_256}; \
       bins svt_axi_transaction_burst_size_512 =  {`SVT_AXI_TRANSACTION_BURST_SIZE_512}; \
       bins svt_axi_transaction_burst_size_1024 = {`SVT_AXI_TRANSACTION_BURST_SIZE_1024}; \
   } \
  endgroup


  `endif
/**
 *  Following macro takes protocol signal related to burst as arguement and defines
 *  specific bins of interest in covergroup
 */
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_BURST_CG(signal_name, sample_event) \
 \
 `SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_CG(signal_name, sample_event) \
   signal_name : coverpoint axi_monitor_mp.axi_monitor_cb.signal_name \
   { \
       bins svt_axi_transaction_burst_fixed = {`SVT_AXI_TRANSACTION_BURST_FIXED}; \
       bins svt_axi_transaction_burst_incr  = {`SVT_AXI_TRANSACTION_BURST_INCR}; \
       bins svt_axi_transaction_burst_wrap  = {`SVT_AXI_TRANSACTION_BURST_WRAP}; \
 \
       ignore_bins resvd = {3}; \
   } \
  endgroup
/**
 *  Following macro takes protocol signal related to protection as arguement and defines
 *  specific bins of interest in covergroup
 */
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_PROT_CG(signal_name, sample_event) \
 \
 `SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_CG(signal_name, sample_event) \
   signal_name : coverpoint axi_monitor_mp.axi_monitor_cb.signal_name \
   { \
       bins svt_axi_data_secure_normal                =   {`SVT_AXI_DATA_SECURE_NORMAL}; \
       bins svt_axi_data_secure_privileged            =   {`SVT_AXI_DATA_SECURE_PRIVILEGED}; \
       bins svt_axi_data_non_secure_normal            =   {`SVT_AXI_DATA_NON_SECURE_NORMAL}; \
       bins svt_axi_data_non_secure_privileged        =   {`SVT_AXI_DATA_NON_SECURE_PRIVILEGED}; \
       bins svt_axi_instruction_secure_normal         =   {`SVT_AXI_INSTRUCTION_SECURE_NORMAL}; \
       bins svt_axi_instruction_secure_privileged     =   {`SVT_AXI_INSTRUCTION_SECURE_PRIVILEGED}; \
       bins svt_axi_instruction_non_secure_normal     =   {`SVT_AXI_INSTRUCTION_NON_SECURE_NORMAL}; \
       bins svt_axi_instruction_non_secure_privileged =   {`SVT_AXI_INSTRUCTION_NON_SECURE_PRIVILEGED}; \
   } \
  endgroup

`ifndef SVT_AXI_MON_CFG_BASED_COV_GRP_DEF
/**
 *  Following macro takes protocol signal related to lock in AXI3 as arguement and defines
 *  specific bins of interest in covergroup
 */
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_LOCK_CG_AXI3(signal_name, sample_event) \
 \
 `SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_CG(signal_name, sample_event) \
   signal_name : coverpoint axi_monitor_mp.axi_monitor_cb.signal_name \
   { \
       bins svt_axi_transaction_normal   =    {`SVT_AXI_LOCK_WIDTH'd`SVT_AXI_TRANSACTION_NORMAL}; \
       bins svt_axi_transaction_exclusive   = {`SVT_AXI_LOCK_WIDTH'd`SVT_AXI_TRANSACTION_EXCLUSIVE}; \
       bins svt_axi_transaction_locked   =    {`SVT_AXI_LOCK_WIDTH'd`SVT_AXI_TRANSACTION_LOCKED}; \
       ignore_bins ignore_exclusive = {`SVT_AXI_LOCK_WIDTH'd`SVT_AXI_TRANSACTION_EXCLUSIVE} \
                             iff(cfg.exclusive_access_enable == 0); \
       ignore_bins resvd = {`SVT_AXI_LOCK_WIDTH'd3}; \
   } \
  endgroup
`else //SVT_AXI_MON_CFG_BASED_COV_GRP_DEF
/**
 *  Following macro takes protocol signal related to lock in AXI3 as arguement and defines
 *  specific bins of interest in covergroup
 */
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_LOCK_EXCLUSIVE_CG_AXI3(signal_name, sample_event) \
 \
   covergroup signal_state_``signal_name``_exclusive @(sample_event); \
   option.per_instance = 1; \
    option.goal = 100; \
   signal_name : coverpoint axi_monitor_mp.axi_monitor_cb.signal_name \
   { \
       bins svt_axi_transaction_normal   =    {`SVT_AXI_LOCK_WIDTH'd`SVT_AXI_TRANSACTION_NORMAL}; \
       bins svt_axi_transaction_exclusive   = {`SVT_AXI_LOCK_WIDTH'd`SVT_AXI_TRANSACTION_EXCLUSIVE}; \
       bins svt_axi_transaction_locked   =    {`SVT_AXI_LOCK_WIDTH'd`SVT_AXI_TRANSACTION_LOCKED}; \
   } \
  endgroup

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_LOCK_NO_EXCLUSIVE_CG_AXI3(signal_name, sample_event) \
 \
   covergroup signal_state_``signal_name``_no_exclusive @(sample_event); \
   option.per_instance = 1; \
    option.goal = 100; \
   signal_name : coverpoint axi_monitor_mp.axi_monitor_cb.signal_name \
   { \
       bins svt_axi_transaction_normal   =    {`SVT_AXI_LOCK_WIDTH'd`SVT_AXI_TRANSACTION_NORMAL}; \
       bins svt_axi_transaction_locked   =    {`SVT_AXI_LOCK_WIDTH'd`SVT_AXI_TRANSACTION_LOCKED}; \
   } \
  endgroup

`endif //SVT_AXI_MON_CFG_BASED_COV_GRP_DEF 

/**
 *  Following macro takes protocol signal related to cache in AXI3 as arguement and defines
 *  specific bins of interest in covergroup
 */
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_CACHE_CG_AXI3(signal_name, sample_event) \
 \
 `SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_CG(signal_name, sample_event) \
   signal_name : coverpoint axi_monitor_mp.axi_monitor_cb.signal_name \
   { \
       bins svt_axi_3_non_cacheable_non_bufferable =          {`SVT_AXI_3_NON_CACHEABLE_NON_BUFFERABLE}; \
       bins svt_axi_3_bufferable_or_modifiable_only =         {`SVT_AXI_3_BUFFERABLE_OR_MODIFIABLE_ONLY}; \
       bins svt_axi_3_cacheable_but_no_alloc =                {`SVT_AXI_3_CACHEABLE_BUT_NO_ALLOC}; \
       bins svt_axi_3_cacheable_bufferable_but_no_alloc =     {`SVT_AXI_3_CACHEABLE_BUFFERABLE_BUT_NO_ALLOC}; \
       bins svt_axi_3_cacheable_wr_thru_alloc_on_rd_only =    {`SVT_AXI_3_CACHEABLE_WR_THRU_ALLOC_ON_RD_ONLY}; \
       bins svt_axi_3_cacheable_wr_back_alloc_on_rd_only =    {`SVT_AXI_3_CACHEABLE_WR_BACK_ALLOC_ON_RD_ONLY}; \
       bins svt_axi_3_cacheable_wr_thru_alloc_on_wr_only =    {`SVT_AXI_3_CACHEABLE_WR_THRU_ALLOC_ON_WR_ONLY}; \
       bins svt_axi_3_cacheable_wr_back_alloc_on_wr_only =    {`SVT_AXI_3_CACHEABLE_WR_BACK_ALLOC_ON_WR_ONLY}; \
       bins svt_axi_3_cacheable_wr_thru_alloc_on_both_rd_wr = {`SVT_AXI_3_CACHEABLE_WR_THRU_ALLOC_ON_BOTH_RD_WR}; \
       bins svt_axi_3_cacheable_wr_back_alloc_on_both_rd_wr = {`SVT_AXI_3_CACHEABLE_WR_BACK_ALLOC_ON_BOTH_RD_WR}; \
 \
    ignore_bins resvd = {4,5,8,9,12,13}; \
   } \
  endgroup
/**
 *  Following macro takes protocol signal related to response as arguement and defines
 *  specific bins of interest in covergroup
 */
`ifndef SVT_AXI_MON_CFG_BASED_COV_GRP_DEF

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_RESP_CG(signal_name, sample_event) \
 \
 `SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_CG(signal_name, sample_event) \
   signal_name : coverpoint axi_monitor_mp.axi_monitor_cb.signal_name[1:0] \
   { \
       bins svt_axi_okay_response   = {`SVT_AXI_OKAY_RESPONSE}; \
       bins svt_axi_exokay_response = {`SVT_AXI_EXOKAY_RESPONSE}; \
       bins svt_axi_slverr_response = {`SVT_AXI_SLVERR_RESPONSE}; \
       bins svt_axi_decerr_response = {`SVT_AXI_DECERR_RESPONSE}; \
       ignore_bins ignore_exokay = {`SVT_AXI_EXOKAY_RESPONSE} iff \
       ((cfg.axi_interface_type == svt_axi_port_configuration::AXI4_LITE) || \
        (cfg.exclusive_access_enable == 0)) ; \
   } \
  endgroup

`else //SVT_AXI_MON_CFG_BASED_COV_GRP_DEF

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_RESP_CG_EX_ACCESS(covgrp_name, signal_name, sample_event) \
 \
 `SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_CG(covgrp_name, sample_event) \
   signal_name : coverpoint axi_monitor_mp.axi_monitor_cb.signal_name[1:0] \
   { \
       bins svt_axi_okay_response   = {`SVT_AXI_OKAY_RESPONSE}; \
       bins svt_axi_exokay_response = {`SVT_AXI_EXOKAY_RESPONSE}; \
       bins svt_axi_slverr_response = {`SVT_AXI_SLVERR_RESPONSE}; \
       bins svt_axi_decerr_response = {`SVT_AXI_DECERR_RESPONSE}; \
   } \
  endgroup

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_RESP_CG(signal_name, sample_event) \
 \
 `SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_CG(signal_name, sample_event) \
   signal_name : coverpoint axi_monitor_mp.axi_monitor_cb.signal_name[1:0] \
   { \
       bins svt_axi_okay_response   = {`SVT_AXI_OKAY_RESPONSE}; \
       bins svt_axi_slverr_response = {`SVT_AXI_SLVERR_RESPONSE}; \
       bins svt_axi_decerr_response = {`SVT_AXI_DECERR_RESPONSE}; \
      } \
  endgroup

`endif //SVT_AXI_MON_CFG_BASED_COV_GRP_DEF

`ifndef SVT_AXI_MON_CFG_BASED_COV_GRP_DEF
/**
 *  Following macro takes protocol signal related to lock in AXI4 as arguement and defines
 *  specific bins of interest in covergroup
 */
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_LOCK_CG_AXI4(signal_name, sample_event) \
 \
  covergroup signal_state_``signal_name``_axi4 @(sample_event); \
    option.per_instance = 1; \
    option.goal = 100; \
   signal_name : coverpoint axi_monitor_mp.axi_monitor_cb.signal_name \
   { \
       bins svt_axi_transaction_normal = {`SVT_AXI_LOCK_WIDTH'd`SVT_AXI_TRANSACTION_NORMAL}; \
       bins svt_axi_transaction_exclusive = {`SVT_AXI_LOCK_WIDTH'd`SVT_AXI_TRANSACTION_EXCLUSIVE}; \
       ignore_bins ignore_locked = {`SVT_AXI_LOCK_WIDTH'd`SVT_AXI_TRANSACTION_LOCKED}; \
       ignore_bins ignore_exclusive = {`SVT_AXI_LOCK_WIDTH'd`SVT_AXI_TRANSACTION_EXCLUSIVE} \
                iff(cfg.exclusive_access_enable == 0); \
       ignore_bins resvd = {`SVT_AXI_LOCK_WIDTH'd3}; \
   } \
  endgroup
`else
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_LOCK_CG_AXI4_NO_EXCLUSIVE(signal_name, sample_event) \
 \
  covergroup signal_state_``signal_name``_axi4_no_exclusive @(sample_event); \
    option.per_instance = 1; \
    option.goal = 100; \
   signal_name : coverpoint axi_monitor_mp.axi_monitor_cb.signal_name \
   { \
       bins svt_axi_transaction_normal = {`SVT_AXI_LOCK_WIDTH'd`SVT_AXI_TRANSACTION_NORMAL}; \
       ignore_bins ignore_locked = {`SVT_AXI_LOCK_WIDTH'd`SVT_AXI_TRANSACTION_LOCKED}; \
       ignore_bins resvd = {`SVT_AXI_LOCK_WIDTH'd3}; \
   } \
  endgroup
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_LOCK_CG_AXI4_EXCLUSIVE(signal_name, sample_event) \
 \
  covergroup signal_state_``signal_name``_axi4_exclusive @(sample_event); \
    option.per_instance = 1; \
    option.goal = 100; \
   signal_name : coverpoint axi_monitor_mp.axi_monitor_cb.signal_name \
   { \
       bins svt_axi_transaction_normal = {`SVT_AXI_LOCK_WIDTH'd`SVT_AXI_TRANSACTION_NORMAL}; \
       bins svt_axi_transaction_exclusive = {`SVT_AXI_LOCK_WIDTH'd`SVT_AXI_TRANSACTION_EXCLUSIVE}; \
       ignore_bins ignore_locked = {`SVT_AXI_LOCK_WIDTH'd`SVT_AXI_TRANSACTION_LOCKED}; \
       ignore_bins resvd = {`SVT_AXI_LOCK_WIDTH'd3}; \
   } \
  endgroup
`endif
/**
 *  Following macro takes protocol signal related to write cache in AXI4 as arguement and defines
 *  specific bins of interest in covergroup
 */
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_AWCACHE_CG_AXI4(signal_name, sample_event) \
 \
  covergroup signal_state_``signal_name``_axi4 @(sample_event); \
    option.per_instance = 1; \
    option.goal = 100; \
   signal_name : coverpoint axi_monitor_mp.axi_monitor_cb.signal_name \
   { \
       bins svt_axi_4_awcache_device_non_bufferable =                 {`SVT_AXI_4_AWCACHE_DEVICE_NON_BUFFERABLE}; \
       bins svt_axi_4_awcache_device_bufferable =                     {`SVT_AXI_4_AWCACHE_DEVICE_BUFFERABLE}; \
       bins svt_axi_4_awcache_normal_non_cachable_non_bufferable =    {`SVT_AXI_4_AWCACHE_NORMAL_NON_CACHABLE_NON_BUFFERABLE}; \
       bins svt_axi_4_awcache_normal_non_cachable_bufferable =        {`SVT_AXI_4_AWCACHE_NORMAL_NON_CACHABLE_BUFFERABLE}; \
       bins svt_axi_4_awcache_write_through_no_allocate =             {`SVT_AXI_4_AWCACHE_WRITE_THROUGH_NO_ALLOCATE}; \
       bins svt_axi_4_awcache_write_through_read_allocate =           {`SVT_AXI_4_AWCACHE_WRITE_THROUGH_READ_ALLOCATE}; \
       bins svt_axi_4_awcache_write_through_write_allocate =          {`SVT_AXI_4_AWCACHE_WRITE_THROUGH_WRITE_ALLOCATE,10}; \
       bins svt_axi_4_awcache_write_through_read_and_write_allocate = {`SVT_AXI_4_AWCACHE_WRITE_THROUGH_READ_AND_WRITE_ALLOCATE}; \
       bins svt_axi_4_awcache_write_back_no_allocate =                {`SVT_AXI_4_AWCACHE_WRITE_BACK_NO_ALLOCATE}; \
       bins svt_axi_4_awcache_write_back_read_allocate =              {`SVT_AXI_4_AWCACHE_WRITE_BACK_READ_ALLOCATE}; \
       bins svt_axi_4_awcache_write_back_write_allocate =             {`SVT_AXI_4_AWCACHE_WRITE_BACK_WRITE_ALLOCATE,11}; \
       bins svt_axi_4_awcache_write_back_read_and_write_allocate =    {`SVT_AXI_4_AWCACHE_WRITE_BACK_READ_AND_WRITE_ALLOCATE}; \
 \
       ignore_bins resvd = {4,5,8,9,12,13}; \
   } \
  endgroup
/**
 *  Following macro takes protocol signal related to read cache in AXI4 as arguement and defines
 *  specific bins of interest in covergroup
 */
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_ARCACHE_CG_AXI4(signal_name, sample_event) \
 \
  covergroup signal_state_``signal_name``_axi4 @(sample_event); \
    option.per_instance = 1; \
    option.goal = 100; \
   signal_name : coverpoint axi_monitor_mp.axi_monitor_cb.signal_name \
   { \
       bins svt_axi_4_arcache_device_non_bufferable =                 {`SVT_AXI_4_ARCACHE_DEVICE_NON_BUFFERABLE}; \
       bins svt_axi_4_arcache_device_bufferable =                     {`SVT_AXI_4_ARCACHE_DEVICE_BUFFERABLE}; \
       bins svt_axi_4_arcache_normal_non_cachable_non_bufferable =    {`SVT_AXI_4_ARCACHE_NORMAL_NON_CACHABLE_NON_BUFFERABLE}; \
       bins svt_axi_4_arcache_normal_non_cachable_bufferable =        {`SVT_AXI_4_ARCACHE_NORMAL_NON_CACHABLE_BUFFERABLE}; \
       bins svt_axi_4_arcache_write_through_no_allocate =             {`SVT_AXI_4_ARCACHE_WRITE_THROUGH_NO_ALLOCATE}; \
       bins svt_axi_4_arcache_write_through_read_allocate =           {`SVT_AXI_4_ARCACHE_WRITE_THROUGH_READ_ALLOCATE,5}; \
       bins svt_axi_4_arcache_write_through_write_allocate =          {`SVT_AXI_4_ARCACHE_WRITE_THROUGH_WRITE_ALLOCATE}; \
       bins svt_axi_4_arcache_write_through_read_and_write_allocate = {`SVT_AXI_4_ARCACHE_WRITE_THROUGH_READ_AND_WRITE_ALLOCATE}; \
       bins svt_axi_4_arcache_write_back_no_allocate =                {`SVT_AXI_4_ARCACHE_WRITE_BACK_NO_ALLOCATE}; \
       bins svt_axi_4_arcache_write_back_read_allocate =              {`SVT_AXI_4_ARCACHE_WRITE_BACK_READ_ALLOCATE,7}; \
       bins svt_axi_4_arcache_write_back_write_allocate =             {`SVT_AXI_4_ARCACHE_WRITE_BACK_WRITE_ALLOCATE}; \
       bins svt_axi_4_arcache_write_back_read_and_write_allocate =    {`SVT_AXI_4_ARCACHE_WRITE_BACK_READ_AND_WRITE_ALLOCATE}; \
 \
    ignore_bins resvd = {4,5,8,9,12,13}; \
   } \
  endgroup

/**
 *  Following macro takes protocol signal related to domain in ACE as arguement and defines
 *  specific bins of interest in covergroup
 */
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_DOMAIN_CG_ACE(signal_name, sample_event) \
 \
  covergroup signal_state_``signal_name @(sample_event); \
    option.per_instance = 1; \
    option.goal = 100; \
   signal_name : coverpoint axi_monitor_mp.axi_monitor_cb.signal_name \
   { \
       bins svt_axi_domain_type_nonshareable =    {`SVT_AXI_DOMAIN_TYPE_NONSHAREABLE}; \
       bins svt_axi_domain_type_innershareable =  {`SVT_AXI_DOMAIN_TYPE_INNERSHAREABLE}; \
       bins svt_axi_domain_type_outershareable =  {`SVT_AXI_DOMAIN_TYPE_OUTERSHAREABLE}; \
       bins svt_axi_domain_type_systemshareable = {`SVT_AXI_DOMAIN_TYPE_SYSTEMSHAREABLE}; \
   } \
  endgroup

/**
 *  Following macro takes protocol signal related to barrier in ACE as arguement and defines
 *  specific bins of interest in covergroup
 */
`ifndef SVT_AXI_MON_CFG_BASED_COV_GRP_DEF

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_BARRIER_CG_ACE(signal_name, sample_event) \
 \
  covergroup signal_state_``signal_name @(sample_event); \
    option.per_instance = 1; \
    option.goal = 100; \
   signal_name : coverpoint axi_monitor_mp.axi_monitor_cb.signal_name \
   { \
       bins svt_axi_barrier_type_na_respbar = {`SVT_AXI_NORMAL_ACCESS_RESPECT_BARRIER}; \
       bins svt_axi_barrier_type_membar =     {`SVT_AXI_MEMORY_BARRIER}; \
       bins svt_axi_barrier_type_na_ignbar =  {`SVT_AXI_NORMAL_ACCESS_IGNORE_BARRIER}; \
       bins svt_axi_barrier_type_syncbar =    {`SVT_AXI_SYNC_BARRIER}; \
       ignore_bins ignore_barrier = {`SVT_AXI_MEMORY_BARRIER,`SVT_AXI_SYNC_BARRIER} iff(cfg.barrier_enable == 1'b0);\
   } \
  endgroup

`else //SVT_AXI_MON_CFG_BASED_COV_GRP_DEF

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_BARRIER_CG_ACE_BE_EQ_1(covgrp_name, signal_name, sample_event) \
 \
  covergroup signal_state_``covgrp_name @(sample_event); \
    option.per_instance = 1; \
    option.goal = 100; \
   signal_name : coverpoint axi_monitor_mp.axi_monitor_cb.signal_name \
   { \
       bins svt_axi_barrier_type_na_respbar = {`SVT_AXI_NORMAL_ACCESS_RESPECT_BARRIER}; \
       bins svt_axi_barrier_type_membar =     {`SVT_AXI_MEMORY_BARRIER}; \
       bins svt_axi_barrier_type_na_ignbar =  {`SVT_AXI_NORMAL_ACCESS_IGNORE_BARRIER}; \
       bins svt_axi_barrier_type_syncbar =    {`SVT_AXI_SYNC_BARRIER}; \
   } \
  endgroup

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_BARRIER_CG_ACE(signal_name, sample_event) \
 \
  covergroup signal_state_``signal_name @(sample_event); \
    option.per_instance = 1; \
    option.goal = 100; \
   signal_name : coverpoint axi_monitor_mp.axi_monitor_cb.signal_name \
   { \
       bins svt_axi_barrier_type_na_respbar = {`SVT_AXI_NORMAL_ACCESS_RESPECT_BARRIER}; \
       bins svt_axi_barrier_type_na_ignbar =  {`SVT_AXI_NORMAL_ACCESS_IGNORE_BARRIER}; \
   } \
  endgroup

`endif //SVT_AXI_MON_CFG_BASED_COV_GRP_DEF

/**
 *  Following macro takes protocol signal related to snoop transaction type in ACE as
 *  argument and defines specific bins of interest in covergroup
 */
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_SNOOP_CG_ACE(signal_name, sample_event) \
 \
  covergroup signal_state_``signal_name @(sample_event); \
    option.per_instance = 1; \
    option.goal = 100; \
   signal_name : coverpoint axi_monitor_mp.axi_monitor_cb.signal_name \
   { \
       bins svt_axi_snoop_transaction_type_readonce =           {`SVT_AXI_SNOOP_TRANSACTION_TYPE_READONCE}; \
       bins svt_axi_snoop_transaction_type_readshared =         {`SVT_AXI_SNOOP_TRANSACTION_TYPE_READSHARED}; \
       bins svt_axi_snoop_transaction_type_readclean =          {`SVT_AXI_SNOOP_TRANSACTION_TYPE_READCLEAN}; \
       bins svt_axi_snoop_transaction_type_readnotshareddirty = {`SVT_AXI_SNOOP_TRANSACTION_TYPE_READNOTSHAREDDIRTY}; \
       bins svt_axi_snoop_transaction_type_readunique =         {`SVT_AXI_SNOOP_TRANSACTION_TYPE_READUNIQUE}; \
       bins svt_axi_snoop_transaction_type_cleanshared =        {`SVT_AXI_SNOOP_TRANSACTION_TYPE_CLEANSHARED}; \
       bins svt_axi_snoop_transaction_type_cleaninvalid =       {`SVT_AXI_SNOOP_TRANSACTION_TYPE_CLEANINVALID}; \
       bins svt_axi_snoop_transaction_type_makeinvalid =        {`SVT_AXI_SNOOP_TRANSACTION_TYPE_MAKEINVALID}; \
       bins svt_axi_snoop_transaction_type_dvmcomplete =        {`SVT_AXI_SNOOP_TRANSACTION_TYPE_DVMCOMPLETE}; \
       bins svt_axi_snoop_transaction_type_dvmmessage =         {`SVT_AXI_SNOOP_TRANSACTION_TYPE_DVMMESSAGE}; \
     \
   } \
  endgroup
// ignore_bins ace_lite_resvd = {1,2,3,7,14,15} iff(cfg.axi_interface_type == svt_axi_port_configuration::ACE_LITE);\  //This is a bug, It should be removed for ACE as it is acsnoop is not applicable for ACE LITE

/**
 *  Following macro takes protocol signal related to transaction type for
 *  shareable write transactions in ACE as arguement and defines specific bins of
 *  interest in covergroup
 */
`ifndef SVT_AXI_MON_CFG_BASED_COV_GRP_DEF

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_AWSNOOP_CG_ACE(signal_name, sample_event) \
 \
  covergroup signal_state_``signal_name @(sample_event); \
    option.per_instance = 1; \
    option.goal = 100; \
   signal_name : coverpoint axi_monitor_mp.axi_monitor_cb.signal_name \
   { \
       bins awsnoop_zero =  {0}; \
       bins awsnoop_one =   {1}; \
       bins awsnoop_two =   {2}; \
       bins awsnoop_three = {3}; \
       bins awsnoop_four =  {4}; \
       bins awsnoop_five =  {5}; \
     \
       ignore_bins ace_lite_resvd = {2,3,4} iff(cfg.axi_interface_type == svt_axi_port_configuration::ACE_LITE); \
       ignore_bins writeevict_disabled = {5} iff(cfg.writeevict_enable == 0); \
    } \
  endgroup

`else
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_AWSNOOP_CG_ACE(signal_name, sample_event) \
 \
  covergroup signal_state_``signal_name @(sample_event); \
    option.per_instance = 1; \
    option.goal = 100; \
   signal_name : coverpoint axi_monitor_mp.axi_monitor_cb.signal_name \
   { \
       bins awsnoop_zero =  {0}; \
       bins awsnoop_one =   {1}; \
       bins awsnoop_two =   {2}; \
       bins awsnoop_three = {3}; \
       bins awsnoop_four =  {4}; \
       bins awsnoop_five =  {5}; \
    } \
  endgroup

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_AWSNOOP_CG_ACE_WEE_EQ_0(covgrp_name, signal_name, sample_event) \
 \
  covergroup signal_state_``covgrp_name @(sample_event); \
    option.per_instance = 1; \
    option.goal = 100; \
   signal_name : coverpoint axi_monitor_mp.axi_monitor_cb.signal_name \
   { \
       bins awsnoop_zero =  {0}; \
       bins awsnoop_one =   {1}; \
       bins awsnoop_two =   {2}; \
       bins awsnoop_three = {3}; \
       bins awsnoop_four =  {4}; \
    } \
  endgroup

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_AWSNOOP_CG_ACE_LITE(covgrp_name, signal_name, sample_event) \
 \
  covergroup signal_state_``covgrp_name @(sample_event); \
    option.per_instance = 1; \
    option.goal = 100; \
   signal_name : coverpoint axi_monitor_mp.axi_monitor_cb.signal_name \
   { \
       bins awsnoop_zero =  {0}; \
       bins awsnoop_one =   {1}; \
       bins awsnoop_five =  {5}; \
    } \
  endgroup

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_AWSNOOP_CG_ACE_LITE_WEE_EQ_0(covgrp_name, signal_name, sample_event) \
 \
  covergroup signal_state_``covgrp_name @(sample_event); \
    option.per_instance = 1; \
    option.goal = 100; \
   signal_name : coverpoint axi_monitor_mp.axi_monitor_cb.signal_name \
   { \
       bins awsnoop_zero =  {0}; \
       bins awsnoop_one =   {1}; \
    } \
  endgroup

`endif

/**
 *  Following macro takes protocol signal related to transaction type for
 *  shareable read transactions in ACE as arguement and defines specific bins of
 *  interest in covergroup
 */
`ifndef SVT_AXI_MON_CFG_BASED_COV_GRP_DEF

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_ARSNOOP_CG_ACE(signal_name, sample_event) \
 \
  covergroup signal_state_``signal_name @(sample_event); \
    option.per_instance = 1; \
    option.goal = 100; \
   signal_name : coverpoint axi_monitor_mp.axi_monitor_cb.signal_name \
   { \
       bins arsnoop_zero =     {0}; \
       bins arsnoop_one =      {1}; \
       bins arsnoop_two =      {2}; \
       bins arsnoop_three =    {3}; \
       bins arsnoop_seven =    {7}; \
       bins arsnoop_eight =    {8}; \
       bins arsnoop_nine =     {9}; \
       bins arsnoop_eleven =   {11}; \
       bins arsnoop_twelve =   {12}; \
       bins arsnoop_thirteen = {13}; \
       bins arsnoop_fourteen = {14}; \
       bins arsnoop_fifteen =  {15}; \
     \
       ignore_bins ace_lite_resvd = {1,2,3,7,14,15} iff(cfg.axi_interface_type == svt_axi_port_configuration::ACE_LITE);\
    } \
  endgroup

`else

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_ARSNOOP_CG_ACE(signal_name, sample_event) \
 \
  covergroup signal_state_``signal_name @(sample_event); \
    option.per_instance = 1; \
    option.goal = 100; \
   signal_name : coverpoint axi_monitor_mp.axi_monitor_cb.signal_name \
   { \
       bins arsnoop_zero =     {0}; \
       bins arsnoop_one =      {1}; \
       bins arsnoop_two =      {2}; \
       bins arsnoop_three =    {3}; \
       bins arsnoop_seven =    {7}; \
       bins arsnoop_eight =    {8}; \
       bins arsnoop_nine =     {9}; \
       bins arsnoop_eleven =   {11}; \
       bins arsnoop_twelve =   {12}; \
       bins arsnoop_thirteen = {13}; \
       bins arsnoop_fourteen = {14}; \
       bins arsnoop_fifteen =  {15}; \
     \
    } \
  endgroup

`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_ARSNOOP_CG_ACE_LITE(covgrp_name, signal_name, sample_event) \
 \
  covergroup signal_state_``covgrp_name @(sample_event); \
    option.per_instance = 1; \
    option.goal = 100; \
   signal_name : coverpoint axi_monitor_mp.axi_monitor_cb.signal_name \
   { \
       bins arsnoop_zero =     {0}; \
       bins arsnoop_eight =    {8}; \
       bins arsnoop_nine =     {9}; \
       bins arsnoop_eleven =   {11}; \
       bins arsnoop_twelve =   {12}; \
       bins arsnoop_thirteen = {13}; \
     \
    } \
  endgroup

`endif

/**
 *  Following macro takes protocol signal related to additional read response
 *  bits(for shareable read transactions) in ACE as arguement and defines specific 
 *  bins of interest in covergroup
 */
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_RRESP_CG_ACE(signal_name, sample_event) \
 \
  covergroup signal_state_``signal_name``_ace @(sample_event); \
    option.per_instance = 1; \
    option.goal = 100; \
   signal_name : coverpoint axi_monitor_mp.axi_monitor_cb.signal_name[`SVT_AXI_RESP_WIDTH-1:`SVT_AXI_RESP_WIDTH-2] \
   { \
       bins svt_axi_coherent_resp_type_unique_clean = {`SVT_AXI_COHERENT_RESP_TYPE_UNIQUE_CLEAN}; \
       bins svt_axi_coherent_resp_type_unique_dirty = {`SVT_AXI_COHERENT_RESP_TYPE_UNIQUE_DIRTY}; \
       bins svt_axi_coherent_resp_type_shared_clean = {`SVT_AXI_COHERENT_RESP_TYPE_SHARED_CLEAN}; \
       bins svt_axi_coherent_resp_type_shared_dirty = {`SVT_AXI_COHERENT_RESP_TYPE_SHARED_DIRTY}; \
    } \
  endgroup

/**
 *  Following macro takes protocol signal related to snoop response in ACE as
 *  arguement and defines specific bins of interest in covergroup
 */
`define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_CRRESP_CG_ACE(signal_name, sample_event) \
 \
  covergroup signal_state_``signal_name @(sample_event); \
    option.per_instance = 1; \
    option.goal = 100; \
   signal_name : coverpoint axi_monitor_mp.axi_monitor_cb.signal_name \
   { \
       bins crresp_zero =        {0}; \
       bins crresp_one =         {1}; \
       bins crresp_two =         {2}; \
       bins crresp_three =       {3}; \
       bins crresp_five =        {5}; \
       bins crresp_seven =       {7}; \
       bins crresp_eight =       {8}; \
       bins crresp_nine =        {9}; \
       bins crrsep_ten =         {10}; \
       bins crresp_eleven =      {11}; \
       bins crresp_thirteen =    {13}; \
       bins crresp_fifteen =     {15}; \
       bins crresp_sixteen =     {16}; \
       bins crresp_seventeen =   {17}; \
       bins crresp_eighteen =    {18}; \
       bins crresp_nineteen =    {19}; \
       bins crresp_twentyone =   {21}; \
       bins crresp_twentythree = {23}; \
       bins crresp_twentyfour =  {24}; \
       bins crresp_twentyfive =  {25}; \
       bins crresp_twentysix =   {26}; \
       bins crresp_twentyseven = {27}; \
       bins crresp_twentynine =  {29}; \
       bins crresp_thirtyone =   {31}; \
     \
       ignore_bins resvd = {4,6,12,14,20,22,28,30}; \
    } \
  endgroup

  `define SVT_AXI_PORT_MONITOR_DEV_COV_UTIL_MEMORY_UPDATE_EXCLUDING_WRITEEVICT_CP \
    memory_update_excluding_writeevict: coverpoint write_xact_type_to_same_addr_as_snoop { \
      bins coherent_writenosnoop_xact   = {0};  \
      bins coherent_writeunique_xact = {1};  \
      bins coherent_writelineunique_xact = {2};  \
      bins coherent_writeback_xact = {3};  \
      bins coherent_writeclean_xact = {4};  \
      bins coherent_evict_xact = {5};  \
    }
  
  `define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_SNOOP_ADDR_PHASE_XACT_TYPE_DVM_UNSET \
    snoop_xact_type : coverpoint cov_snoop_addr_item.snoop_xact_type { \
      bins snoop_readonce_xact   = {svt_axi_snoop_transaction::READONCE}; \
      bins snoop_readshared_xact   = {svt_axi_snoop_transaction::READSHARED}; \
      bins snoop_readclean_xact   = {svt_axi_snoop_transaction::READCLEAN}; \
      bins snoop_readnotshareddirty_xact   = {svt_axi_snoop_transaction::READNOTSHAREDDIRTY}; \
      bins snoop_readunique_xact   = {svt_axi_snoop_transaction::READUNIQUE}; \
      bins snoop_cleanshared_xact   = {svt_axi_snoop_transaction::CLEANSHARED}; \
      bins snoop_cleaninvalid_xact   = {svt_axi_snoop_transaction::CLEANINVALID}; \
      bins snoop_makeinvalid_xact   = {svt_axi_snoop_transaction::MAKEINVALID}; \
      ignore_bins ignore_dvm_snoops = {svt_axi_snoop_transaction::DVMMESSAGE,svt_axi_snoop_transaction::DVMCOMPLETE}; \
      option.weight = 1; \
    }
  
  `define SVT_AXI_PORT_MONITOR_DEF_COV_UTIL_SNOOP_ADDR_PHASE_XACT_TYPE_DVM_UNSET_ONE_ACE_ACELITE \
    snoop_xact_type : coverpoint cov_snoop_addr_item.snoop_xact_type { \
      bins snoop_readonce_xact   = {svt_axi_snoop_transaction::READONCE}; \
      bins snoop_cleanshared_xact   = {svt_axi_snoop_transaction::CLEANSHARED}; \
      bins snoop_cleaninvalid_xact   = {svt_axi_snoop_transaction::CLEANINVALID}; \
      bins snoop_makeinvalid_xact   = {svt_axi_snoop_transaction::MAKEINVALID}; \
      ignore_bins ignore_dvm_snoops = {svt_axi_snoop_transaction::DVMMESSAGE,svt_axi_snoop_transaction::DVMCOMPLETE}; \
      option.weight = 1; \
    }

/** @endcond */

`endif
